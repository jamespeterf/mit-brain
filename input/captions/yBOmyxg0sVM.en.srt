1
00:00:13,280 --> 00:00:20,600
Let's uh let's start a so first the

2
00:00:17,400 --> 00:00:24,199
homework assignment is out as I

3
00:00:20,600 --> 00:00:26,199
said uh it's due right before

4
00:00:24,199 --> 00:00:27,960
Thanksgiving if anybody needs an

5
00:00:26,199 --> 00:00:30,480
extension just let me

6
00:00:27,960 --> 00:00:32,599
know a and

7
00:00:30,480 --> 00:00:35,520
uh the instructions are on the on the

8
00:00:32,599 --> 00:00:37,680
site essentially uh each one should

9
00:00:35,520 --> 00:00:39,000
write like their own solution to make

10
00:00:37,680 --> 00:00:40,879
sure you understand it's okay if you

11
00:00:39,000 --> 00:00:43,239
talk among one among one another as long

12
00:00:40,879 --> 00:00:44,800
as it's fruitful and please type it up

13
00:00:43,239 --> 00:00:47,879
in latch and submit it through great

14
00:00:44,800 --> 00:00:47,879
scope questions

15
00:00:51,020 --> 00:00:55,879
[Music]

16
00:00:52,879 --> 00:00:55,879
yeah

17
00:00:56,280 --> 00:01:02,399
oh you what why can't you do don't you

18
00:01:00,320 --> 00:01:05,519
use grade scope for other classes yeah

19
00:01:02,399 --> 00:01:08,320
but I have not seen this class oh no it

20
00:01:05,519 --> 00:01:12,159
is it is now when did you check

21
00:01:08,320 --> 00:01:14,600
oh yeah it's recently uh yeah if there's

22
00:01:12,159 --> 00:01:16,400
issues let me know yeah this class is

23
00:01:14,600 --> 00:01:17,200
assigned to there is a great scope site

24
00:01:16,400 --> 00:01:21,280
for

25
00:01:17,200 --> 00:01:23,439
this uh any any other questions before

26
00:01:21,280 --> 00:01:23,439
we

27
00:01:23,479 --> 00:01:30,439
start okay so uh just a quick a quick

28
00:01:27,840 --> 00:01:33,320
recap uh so last time we talked Al about

29
00:01:30,439 --> 00:01:35,600
the kilan mikali protocol it's an

30
00:01:33,320 --> 00:01:38,000
interactive argument it's a succinct

31
00:01:35,600 --> 00:01:41,759
interactive argument that which you can

32
00:01:38,000 --> 00:01:44,840
use to prove uh membership in any NP

33
00:01:41,759 --> 00:01:46,840
language okay if you recall the idea was

34
00:01:44,840 --> 00:01:49,560
we started before that was kind of our

35
00:01:46,840 --> 00:01:52,240
entrance to to cryptography so we said

36
00:01:49,560 --> 00:01:54,680
the idea of the K mic protocol is that

37
00:01:52,240 --> 00:01:57,320
you take any PCP which is very very

38
00:01:54,680 --> 00:01:59,200
large but very efficiently if you just

39
00:01:57,320 --> 00:02:00,680
have Ram access to it you can verify it

40
00:01:59,200 --> 00:02:02,280
very efficiently

41
00:02:00,680 --> 00:02:05,600
and the idea is you take this very very

42
00:02:02,280 --> 00:02:09,039
large PCP and you kind of shrink it to

43
00:02:05,600 --> 00:02:11,720
kind of a you uh you know uh digest it

44
00:02:09,039 --> 00:02:14,400
down uh using cryptography to this kind

45
00:02:11,720 --> 00:02:16,080
of suing digest this is done using

46
00:02:14,400 --> 00:02:18,640
what's called using hash function but in

47
00:02:16,080 --> 00:02:21,239
particular mirle hash or hash function

48
00:02:18,640 --> 00:02:23,840
that are sixing but can be opened

49
00:02:21,239 --> 00:02:26,879
locally so I'll recall what this is in a

50
00:02:23,840 --> 00:02:30,560
second and once the prover sends over

51
00:02:26,879 --> 00:02:32,480
kind of a uh squished form of the PC

52
00:02:30,560 --> 00:02:35,000
then the verifier now behav like he's a

53
00:02:32,480 --> 00:02:37,680
PCP verifier he tells the Prov open this

54
00:02:35,000 --> 00:02:41,080
PCP and the location that the PCP

55
00:02:37,680 --> 00:02:45,280
verifier would want to open and he gets

56
00:02:41,080 --> 00:02:48,800
back the openings so uh so that's kind

57
00:02:45,280 --> 00:02:52,720
of what the Kil mikali protocol is but

58
00:02:48,800 --> 00:02:53,959
in order to to uh when I said you know

59
00:02:52,720 --> 00:02:57,080
it squishes down and then there's

60
00:02:53,959 --> 00:02:59,319
opening really what we need is a we want

61
00:02:57,080 --> 00:03:01,640
to take a hash function so if you

62
00:02:59,319 --> 00:03:04,280
remember a hash hash function is kind of

63
00:03:01,640 --> 00:03:06,760
consists of a key generation algorithm

64
00:03:04,280 --> 00:03:08,680
that generates a hash key and an eval

65
00:03:06,760 --> 00:03:11,560
algorithm that take a hash and an input

66
00:03:08,680 --> 00:03:16,200
and generates kind of a digest or a hash

67
00:03:11,560 --> 00:03:19,440
value a last time we uh we talk we

68
00:03:16,200 --> 00:03:21,680
showed how to get a a hash value uh how

69
00:03:19,440 --> 00:03:24,879
to construct from uh the discrete log we

70
00:03:21,680 --> 00:03:28,640
showed how to construct a hash function

71
00:03:24,879 --> 00:03:32,560
uh uh from two Lambda to Lambda it takes

72
00:03:28,640 --> 00:03:36,720
2 Lambda bit Lambda B actually was z p

73
00:03:32,560 --> 00:03:39,879
to the 2 Lambda to zp to Lambda but

74
00:03:36,720 --> 00:03:41,879
anyway one can encoded to have to be 01

75
00:03:39,879 --> 00:03:44,799
to the 2 Lambda to 0 1 to the

76
00:03:41,879 --> 00:03:47,640
Lambda but this is actually not enough

77
00:03:44,799 --> 00:03:50,560
for the Kil M protocol what we actually

78
00:03:47,640 --> 00:03:51,920
need is a collision hash function first

79
00:03:50,560 --> 00:03:54,239
it needs to be much bigger because we're

80
00:03:51,920 --> 00:03:58,000
taking a gigantic PCP we want to squish

81
00:03:54,239 --> 00:04:00,959
it way more than like half this takes

82
00:03:58,000 --> 00:04:03,000
you know make squishes the size reduces

83
00:04:00,959 --> 00:04:04,920
the size from two Lambda to Lambda so it

84
00:04:03,000 --> 00:04:07,360
squishes it by factor of two we actually

85
00:04:04,920 --> 00:04:10,480
want to squish it to much bigger Factor

86
00:04:07,360 --> 00:04:12,239
okay so we want to take kind of eval

87
00:04:10,480 --> 00:04:14,680
what we what we use actually is an eval

88
00:04:12,239 --> 00:04:17,320
algorithm that takes strings of size two

89
00:04:14,680 --> 00:04:19,320
to the Lambda to Lambda so note here the

90
00:04:17,320 --> 00:04:21,840
Lambda is upstairs it's very different

91
00:04:19,320 --> 00:04:25,680
than two Lambda it's exponential

92
00:04:21,840 --> 00:04:28,199
difference a so we take a a hash

93
00:04:25,680 --> 00:04:30,479
function that goes takes gigantic

94
00:04:28,199 --> 00:04:32,639
strings to lamb

95
00:04:30,479 --> 00:04:34,960
and moreover another property that we

96
00:04:32,639 --> 00:04:38,039
want is we can open locally remember we

97
00:04:34,960 --> 00:04:40,400
said the way the mikali protocol works

98
00:04:38,039 --> 00:04:43,320
is that the verifier asks okay you

99
00:04:40,400 --> 00:04:47,280
committed to the gigantic PCP open it in

100
00:04:43,320 --> 00:04:51,520
location you know 37 and 15 now how do

101
00:04:47,280 --> 00:04:53,199
you open it so we also want kind of a a

102
00:04:51,520 --> 00:04:55,240
opening algorithm so really what we

103
00:04:53,199 --> 00:04:58,919
needed when we talked about Miracle hash

104
00:04:55,240 --> 00:05:00,960
or hash hashes with local opening in

105
00:04:58,919 --> 00:05:03,400
addition to having a key generation and

106
00:05:00,960 --> 00:05:05,560
eval algorithm we also have a open

107
00:05:03,400 --> 00:05:06,680
algorithm that generates kind of a

108
00:05:05,560 --> 00:05:09,520
succinct

109
00:05:06,680 --> 00:05:11,120
opening and you which can be verified in

110
00:05:09,520 --> 00:05:13,080
a verification algorithm that verifies

111
00:05:11,120 --> 00:05:14,800
it so last time we we kind of

112
00:05:13,080 --> 00:05:17,720
constructed this morle hatch I'll recall

113
00:05:14,800 --> 00:05:19,479
it today quickly and we ended without

114
00:05:17,720 --> 00:05:21,280
kind of proving that it's collagen

115
00:05:19,479 --> 00:05:23,680
resistant so that's where we're going to

116
00:05:21,280 --> 00:05:25,400
start today we're going to just wrap up

117
00:05:23,680 --> 00:05:28,479
the K mikali

118
00:05:25,400 --> 00:05:30,400
protocol by explaining the thing that

119
00:05:28,479 --> 00:05:31,919
was left is kind of to argue that this

120
00:05:30,400 --> 00:05:33,759
Merkel hash

121
00:05:31,919 --> 00:05:35,880
construction is indeed Collision

122
00:05:33,759 --> 00:05:39,280
resistance so that's where we're going

123
00:05:35,880 --> 00:05:41,479
to start today but then uh so once we do

124
00:05:39,280 --> 00:05:43,120
that once we argue that the we have this

125
00:05:41,479 --> 00:05:45,680
Merkel hash we put that it's Collision

126
00:05:43,120 --> 00:05:47,520
resistant then we're done with the kill

127
00:05:45,680 --> 00:05:48,639
M you actually proved that it sound

128
00:05:47,520 --> 00:05:51,720
under this

129
00:05:48,639 --> 00:05:53,960
assumption so so okay so where are we

130
00:05:51,720 --> 00:05:58,080
heading today after we finished the

131
00:05:53,960 --> 00:06:01,759
Merkel hash now we we actually showed a

132
00:05:58,080 --> 00:06:03,080
succinct argument for all of NP this is

133
00:06:01,759 --> 00:06:05,960
great however it's

134
00:06:03,080 --> 00:06:09,720
interactive and interactive proofs or

135
00:06:05,960 --> 00:06:11,560
arguments are really they're not very

136
00:06:09,720 --> 00:06:14,599
useful and the reason they're not very

137
00:06:11,560 --> 00:06:17,199
useful is for many reasons a there's

138
00:06:14,599 --> 00:06:20,280
latency to talk back forth back forth

139
00:06:17,199 --> 00:06:23,720
but another reason perhaps much more

140
00:06:20,280 --> 00:06:26,080
important is that it's per per verifier

141
00:06:23,720 --> 00:06:28,919
so if I want to just prove to the world

142
00:06:26,080 --> 00:06:30,840
some statement I can't prove it using I

143
00:06:28,919 --> 00:06:32,360
I'm not gonna go to each person in the

144
00:06:30,840 --> 00:06:34,880
world and give him an an interactive

145
00:06:32,360 --> 00:06:37,039
proof so it's really verifier specific

146
00:06:34,880 --> 00:06:39,319
interactive proofs are verifier specific

147
00:06:37,039 --> 00:06:40,120
it convinces the specific verifier you

148
00:06:39,319 --> 00:06:42,120
talk

149
00:06:40,120 --> 00:06:44,319
with okay and we want to prove that

150
00:06:42,120 --> 00:06:47,800
convinces

151
00:06:44,319 --> 00:06:49,919
everyone so that's kind of where the

152
00:06:47,800 --> 00:06:52,080
segue we're taking today how do we

153
00:06:49,919 --> 00:06:55,560
construct actually

154
00:06:52,080 --> 00:06:57,840
non-interactive R now to reduce

155
00:06:55,560 --> 00:07:01,720
interraction okay so what we're going to

156
00:06:57,840 --> 00:07:03,080
show is how to eliminate interaction and

157
00:07:01,720 --> 00:07:05,199
this is going to be done using a really

158
00:07:03,080 --> 00:07:07,080
beautiful Paradigm called the F Paradigm

159
00:07:05,199 --> 00:07:09,479
so I'm going to explain what it is it's

160
00:07:07,080 --> 00:07:11,720
very very simple and then we're going to

161
00:07:09,479 --> 00:07:14,800
introduce the random Oracle model which

162
00:07:11,720 --> 00:07:17,240
is a model that was invented in order to

163
00:07:14,800 --> 00:07:21,280
an attempt to analyze or to understand

164
00:07:17,240 --> 00:07:24,680
the security of this F Paradigm uh it's

165
00:07:21,280 --> 00:07:26,840
an ideal model okay we're gonna prove

166
00:07:24,680 --> 00:07:28,919
the soundness of the Kil mikali protocol

167
00:07:26,840 --> 00:07:32,039
that we we saw last time we're going to

168
00:07:28,919 --> 00:07:34,440
actually show that it sound uh even if

169
00:07:32,039 --> 00:07:36,240
you apply the F Paradigm to it as long

170
00:07:34,440 --> 00:07:37,840
as you rign this random Oracle model and

171
00:07:36,240 --> 00:07:40,120
this ideal

172
00:07:37,840 --> 00:07:41,720
model and then we're going to probably

173
00:07:40,120 --> 00:07:43,560
this we're going to only get till next

174
00:07:41,720 --> 00:07:46,319
time but we're going to try to we're

175
00:07:43,560 --> 00:07:49,039
talk about the soundness uh of the F and

176
00:07:46,319 --> 00:07:50,240
the standard model okay so again we're

177
00:07:49,039 --> 00:07:52,440
going to talk about eliminating

178
00:07:50,240 --> 00:07:54,440
interaction using F talk about the

179
00:07:52,440 --> 00:07:56,039
random orical model show that actually

180
00:07:54,440 --> 00:07:59,080
the random oral model of this Paradigm

181
00:07:56,039 --> 00:08:00,960
works well often uh we'll see exactly

182
00:07:59,080 --> 00:08:02,960
when it works well when it doesn't and

183
00:08:00,960 --> 00:08:05,639
then we're going to talk about if we

184
00:08:02,960 --> 00:08:07,240
have time maybe start talking about uh

185
00:08:05,639 --> 00:08:08,639
about Security in that standard model

186
00:08:07,240 --> 00:08:10,560
because the random work model is not

187
00:08:08,639 --> 00:08:13,800
it's a it's an ideal model so is it

188
00:08:10,560 --> 00:08:14,800
secure is it sound like in when used in

189
00:08:13,800 --> 00:08:17,560
actual

190
00:08:14,800 --> 00:08:20,879
reality that's the plan questions yes

191
00:08:17,560 --> 00:08:20,879
you shouldn't be able to do two of the

192
00:08:21,280 --> 00:08:29,560
land you're something that long you find

193
00:08:24,479 --> 00:08:31,520
a oh okay so um uh okay uh of course of

194
00:08:29,560 --> 00:08:34,560
course you can find the Collision the qu

195
00:08:31,520 --> 00:08:36,200
okay so I we Define it okay so the

196
00:08:34,560 --> 00:08:39,159
question was about this two two to the

197
00:08:36,200 --> 00:08:40,760
Lambda let me get let me now we'll see

198
00:08:39,159 --> 00:08:45,000
the definition the construction I'll

199
00:08:40,760 --> 00:08:47,120
explain but the the we get we get

200
00:08:45,000 --> 00:08:48,839
completeness for two to the Lambda now

201
00:08:47,120 --> 00:08:52,800
you're talking about soundness okay

202
00:08:48,839 --> 00:08:56,040
soundness says that any poly adversary

203
00:08:52,800 --> 00:08:59,079
or t time adversary yeah poly Lambda

204
00:08:56,040 --> 00:09:00,000
adversary or po or t poly in t Lambda

205
00:08:59,079 --> 00:09:03,279
adversary

206
00:09:00,000 --> 00:09:04,680
cannot find a collision now if this T is

207
00:09:03,279 --> 00:09:06,320
two to the Lambda then you're not going

208
00:09:04,680 --> 00:09:08,519
to be secure so that I mean the

209
00:09:06,320 --> 00:09:10,560
Assumption R so there's this is for

210
00:09:08,519 --> 00:09:12,480
completeness for soundness the

211
00:09:10,560 --> 00:09:15,600
assumption is for Collision resistance

212
00:09:12,480 --> 00:09:17,920
the the definition is that no poly

213
00:09:15,600 --> 00:09:19,720
Lambda time or poly T Lambda depending

214
00:09:17,920 --> 00:09:22,480
on if you want standard Collision

215
00:09:19,720 --> 00:09:24,680
resistant or T Collision resistant which

216
00:09:22,480 --> 00:09:25,720
is slightly stronger assumption cannot

217
00:09:24,680 --> 00:09:27,720
find

218
00:09:25,720 --> 00:09:31,079
collisions great thank thanks for the

219
00:09:27,720 --> 00:09:33,160
question any any other

220
00:09:31,079 --> 00:09:34,560
questions I like questions just

221
00:09:33,160 --> 00:09:37,079
reminding you

222
00:09:34,560 --> 00:09:38,760
guys okay yeah so during this whole

223
00:09:37,079 --> 00:09:41,720
thing I'm trying to imagine like how big

224
00:09:38,760 --> 00:09:44,600
are the parameters so n like inside of

225
00:09:41,720 --> 00:09:47,200
the input is something that's like like

226
00:09:44,600 --> 00:09:48,880
normal people can read right yeah yeah

227
00:09:47,200 --> 00:09:50,680
yeah yeah yeah yeah exactly okay so let

228
00:09:48,880 --> 00:09:52,040
me yeah let me talk a little bit about

229
00:09:50,680 --> 00:09:54,240
the parameters that's a great question

230
00:09:52,040 --> 00:09:56,360
that's a good good thing to start with

231
00:09:54,240 --> 00:09:59,120
so we want succinctness okay now when we

232
00:09:56,360 --> 00:10:00,240
say succinct really what we want is so

233
00:09:59,120 --> 00:10:02,839
we that's the things by using

234
00:10:00,240 --> 00:10:05,040
cryptography once we use cryptography

235
00:10:02,839 --> 00:10:06,600
things grow with the security of the

236
00:10:05,040 --> 00:10:08,720
that we want so things will grow with

237
00:10:06,600 --> 00:10:10,279
Lambda which is the security parameter

238
00:10:08,720 --> 00:10:12,079
what the security parameter is depends

239
00:10:10,279 --> 00:10:14,959
kind of how paranoid we are in the world

240
00:10:12,079 --> 00:10:16,920
okay you can think about it is 256 bits

241
00:10:14,959 --> 00:10:18,360
sometimes it's more depending on also

242
00:10:16,920 --> 00:10:20,240
which crypto systems you use but that's

243
00:10:18,360 --> 00:10:22,240
a good it's kind of independent of the

244
00:10:20,240 --> 00:10:23,920
input okay just you want as succinct as

245
00:10:22,240 --> 00:10:26,279
you can get and you know if you want to

246
00:10:23,920 --> 00:10:28,959
use cryptography it's it's like security

247
00:10:26,279 --> 00:10:30,399
parameter now the input it should in

248
00:10:28,959 --> 00:10:32,240
some sense it should not depend on the

249
00:10:30,399 --> 00:10:33,880
input but of course the input is not

250
00:10:32,240 --> 00:10:36,680
going to be like more than two to the

251
00:10:33,880 --> 00:10:40,279
Lambda because you think of Lambda is

252
00:10:36,680 --> 00:10:42,079
such that two to the Lambda is like more

253
00:10:40,279 --> 00:10:44,360
than the number of of molecules in the

254
00:10:42,079 --> 00:10:47,959
universe so nothing is that big in our

255
00:10:44,360 --> 00:10:49,600
world okay so you think of the X can be

256
00:10:47,959 --> 00:10:51,160
bigger actually the input can also be

257
00:10:49,600 --> 00:10:53,079
small you know but then sometimes you

258
00:10:51,160 --> 00:10:55,240
don't need cryptography so so tiny it's

259
00:10:53,079 --> 00:10:59,079
like phography is useless uh you can

260
00:10:55,240 --> 00:11:01,079
just give the witness um so usually we

261
00:10:59,079 --> 00:11:02,760
think think in our head of the input as

262
00:11:01,079 --> 00:11:05,120
being can be much bigger than Lambda can

263
00:11:02,760 --> 00:11:08,240
be poly Lambda and maybe even be like

264
00:11:05,120 --> 00:11:09,760
Lambda to the log Lambda it can be you

265
00:11:08,240 --> 00:11:12,200
know but it's not as big as two to the

266
00:11:09,760 --> 00:11:14,040
Lambda that's doesn't exist okay but it

267
00:11:12,200 --> 00:11:18,639
can be kind of anything that's kind of

268
00:11:14,040 --> 00:11:21,240
real world number in in the sense um and

269
00:11:18,639 --> 00:11:24,040
so that's kind of what what we should

270
00:11:21,240 --> 00:11:28,720
think of okay does

271
00:11:24,040 --> 00:11:31,800
that okay so when we do we're trying to

272
00:11:28,720 --> 00:11:35,360
reduce the amount of the side of the pro

273
00:11:31,800 --> 00:11:39,399
from like still a reasonable polze thing

274
00:11:35,360 --> 00:11:41,320
but just like a 26 exactly exactly or or

275
00:11:39,399 --> 00:11:43,519
right so you can think of it you're

276
00:11:41,320 --> 00:11:45,760
trying to when when you do and let me

277
00:11:43,519 --> 00:11:48,000
just repeat it also for the mic uh when

278
00:11:45,760 --> 00:11:50,320
you're trying uh when you do this

279
00:11:48,000 --> 00:11:53,160
interactive argument you think of you

280
00:11:50,320 --> 00:11:55,120
take an X that's still real world you

281
00:11:53,160 --> 00:11:56,959
can think of it polom l but it can be

282
00:11:55,120 --> 00:11:58,720
more but as long as a kind of real world

283
00:11:56,959 --> 00:12:02,880
thing and you reduce it to kind of 256

284
00:11:58,720 --> 00:12:04,600
bits okay that's kind of the um the

285
00:12:02,880 --> 00:12:06,600
Practical idea you should think of and

286
00:12:04,600 --> 00:12:08,279
the more theoretical idea is to say you

287
00:12:06,600 --> 00:12:10,079
can take any input X but not more than

288
00:12:08,279 --> 00:12:12,240
two to the Lambda because that's like

289
00:12:10,079 --> 00:12:14,880
you know but something anything less and

290
00:12:12,240 --> 00:12:18,839
we make it as small as as po

291
00:12:14,880 --> 00:12:21,600
Lambda okay great any any other

292
00:12:18,839 --> 00:12:23,519
questions yeah and verify that row is

293
00:12:21,600 --> 00:12:26,560
like the opening is that what it

294
00:12:23,519 --> 00:12:28,639
is yes yes yes yeah yeah sorry yes this

295
00:12:26,560 --> 00:12:30,680
is yeah I'll I'll go to it now yeah yeah

296
00:12:28,639 --> 00:12:33,760
yeah yeah yeah yeah let me let me okay

297
00:12:30,680 --> 00:12:36,120
so good so let me uh just finish wrap up

298
00:12:33,760 --> 00:12:38,440
what we where we left last time which is

299
00:12:36,120 --> 00:12:40,480
the Merle hash so we use ml hash in the

300
00:12:38,440 --> 00:12:42,519
kilan mikali protocol actually we don't

301
00:12:40,480 --> 00:12:43,839
need to really remember the kilan mikali

302
00:12:42,519 --> 00:12:46,760
protocol for today we're not going to

303
00:12:43,839 --> 00:12:48,240
actually really use it but let me still

304
00:12:46,760 --> 00:12:49,760
finish the Merle hash because it's a

305
00:12:48,240 --> 00:12:51,360
very important primitive it's kind of

306
00:12:49,760 --> 00:12:54,040
used everywhere in cryptography so it's

307
00:12:51,360 --> 00:12:56,880
very important to know so uh so what is

308
00:12:54,040 --> 00:12:58,760
the miracle hash it takes any hash

309
00:12:56,880 --> 00:13:00,440
function not local opening just a

310
00:12:58,760 --> 00:13:03,040
regular hash function that generates a

311
00:13:00,440 --> 00:13:05,959
hash key and has an eval algorithm

312
00:13:03,040 --> 00:13:08,240
evaluates just generates hash value such

313
00:13:05,959 --> 00:13:10,120
that it takes two Lambda bits to Lambda

314
00:13:08,240 --> 00:13:12,399
bits okay you can actually you can make

315
00:13:10,120 --> 00:13:14,240
it more you can be even one plus Epsilon

316
00:13:12,399 --> 00:13:17,199
Lambda bits to lamb you can play with it

317
00:13:14,240 --> 00:13:21,120
but let's say two Lambda to Lambda

318
00:13:17,199 --> 00:13:23,519
bits and we construct from it a hash

319
00:13:21,120 --> 00:13:25,040
function with local opening so let me

320
00:13:23,519 --> 00:13:28,240
tell you exactly what this hash function

321
00:13:25,040 --> 00:13:30,480
with local opening what it looks like so

322
00:13:28,240 --> 00:13:32,800
that then the hash key is exactly the

323
00:13:30,480 --> 00:13:35,120
same as before we take the same hash key

324
00:13:32,800 --> 00:13:38,360
as our underlying so first we started

325
00:13:35,120 --> 00:13:40,680
with a hash we started with this hash

326
00:13:38,360 --> 00:13:42,160
family what is it last time we saw we

327
00:13:40,680 --> 00:13:44,199
can take for example I gave an example

328
00:13:42,160 --> 00:13:45,560
with this discrete log but you can even

329
00:13:44,199 --> 00:13:48,040
if you don't remember it doesn't matter

330
00:13:45,560 --> 00:13:52,000
take think of it someone gave you a hash

331
00:13:48,040 --> 00:13:54,440
family with this domain and range okay

332
00:13:52,000 --> 00:13:56,720
now I'm gonna do a domain extension I'm

333
00:13:54,440 --> 00:13:59,519
going to make the domain much bigger and

334
00:13:56,720 --> 00:14:01,800
get local opening how do I do it so this

335
00:13:59,519 --> 00:14:05,120
is the miracle hash

336
00:14:01,800 --> 00:14:06,680
construction the idea is so the Gen is

337
00:14:05,120 --> 00:14:09,360
as I said just generate the same hash

338
00:14:06,680 --> 00:14:11,759
key as the original gen no change to the

339
00:14:09,360 --> 00:14:13,600
Gen algorithm the eval algorithm on the

340
00:14:11,759 --> 00:14:16,079
other end of course changes because the

341
00:14:13,600 --> 00:14:17,959
domain is much bigger okay it takes

342
00:14:16,079 --> 00:14:20,920
strings of size at most two to the L

343
00:14:17,959 --> 00:14:23,759
bits and what does it do so what it does

344
00:14:20,920 --> 00:14:26,440
is the following it takes his input X

345
00:14:23,759 --> 00:14:29,800
let's suppose for Simplicity that X is

346
00:14:26,440 --> 00:14:31,360
exactly kind of 2 the L time Lambda

347
00:14:29,800 --> 00:14:35,240
bits

348
00:14:31,360 --> 00:14:37,120
okay a so it's uh you don't have to

349
00:14:35,240 --> 00:14:38,680
assume this this is just easy to assume

350
00:14:37,120 --> 00:14:40,160
and you can always get it with padding

351
00:14:38,680 --> 00:14:42,639
kind of take any input and Pad it so

352
00:14:40,160 --> 00:14:44,320
it'll be of this form and I'll hash it

353
00:14:42,639 --> 00:14:47,360
okay I I'll say a word if it's not of

354
00:14:44,320 --> 00:14:51,040
this form uh but if it is of this form

355
00:14:47,360 --> 00:14:52,800
what do you do you take your input X

356
00:14:51,040 --> 00:14:55,320
just partition it to blocks each of

357
00:14:52,800 --> 00:14:58,240
length Lambda so you have two to the L

358
00:14:55,320 --> 00:15:01,120
blocks okay you have an input X of

359
00:14:58,240 --> 00:15:03,800
length two to the L * Lambda you

360
00:15:01,120 --> 00:15:06,079
partition it to chunks each of length

361
00:15:03,800 --> 00:15:08,959
Lambda so you have two to the L chunks

362
00:15:06,079 --> 00:15:12,560
let's call the chunks X1 X2 X3 X4 and so

363
00:15:08,959 --> 00:15:14,360
on up to X2 to the Lambda each of them

364
00:15:12,560 --> 00:15:18,040
up to X2 to the L

365
00:15:14,360 --> 00:15:20,440
sorry each of them of length Lambda and

366
00:15:18,040 --> 00:15:25,160
now what you do you take two blocks this

367
00:15:20,440 --> 00:15:27,240
is two Lambda bits and hash it using our

368
00:15:25,160 --> 00:15:30,240
building block hash that takes 2 Lambda

369
00:15:27,240 --> 00:15:34,399
to Lambda you take the to Lambda you

370
00:15:30,240 --> 00:15:37,000
hash you take these two you hash so in

371
00:15:34,399 --> 00:15:40,759
other words you take the two to the L

372
00:15:37,000 --> 00:15:42,920
blocks to two to the L minus one blocks

373
00:15:40,759 --> 00:15:44,319
you hash every every pair you hash every

374
00:15:42,920 --> 00:15:47,600
pair you hash every pair you hash every

375
00:15:44,319 --> 00:15:50,160
pair you hash you got two to the L minus

376
00:15:47,600 --> 00:15:52,240
one blocks then you take these blocks

377
00:15:50,160 --> 00:15:54,800
and again every pair you hash every pair

378
00:15:52,240 --> 00:15:56,839
you hash every pair two to the L minus

379
00:15:54,800 --> 00:15:59,680
two blocks and so on for so forth until

380
00:15:56,839 --> 00:16:01,920
you arrive to one block at the end

381
00:15:59,680 --> 00:16:03,240
what do you output you output the top

382
00:16:01,920 --> 00:16:04,199
the final I guess it's going to be

383
00:16:03,240 --> 00:16:08,240
somewhere

384
00:16:04,199 --> 00:16:11,040
here uh block which is often called a

385
00:16:08,240 --> 00:16:12,319
root you output the root and you output

386
00:16:11,040 --> 00:16:14,440
the depth of the

387
00:16:12,319 --> 00:16:16,880
tree okay that's the output of the hash

388
00:16:14,440 --> 00:16:18,680
so the output is the root the hash value

389
00:16:16,880 --> 00:16:21,199
here it's Lambda

390
00:16:18,680 --> 00:16:22,959
bits and D which you also think of it as

391
00:16:21,199 --> 00:16:26,040
being Lambda bits even if it's less just

392
00:16:22,959 --> 00:16:27,440
encoded using Lambda bits so if you're

393
00:16:26,040 --> 00:16:29,600
mad now at me because I promise you

394
00:16:27,440 --> 00:16:31,880
Lambda bits and you see here two Lambda

395
00:16:29,600 --> 00:16:33,759
bits apply this hash one more time and

396
00:16:31,880 --> 00:16:36,480
you'll get your Lambda

397
00:16:33,759 --> 00:16:40,639
bits okay but how two Lambda bits is

398
00:16:36,480 --> 00:16:42,680
also fine yeah um why are we Bing the

399
00:16:40,639 --> 00:16:44,560
input L to two to the Lambda instead of

400
00:16:42,680 --> 00:16:46,160
just arbitrary good good good good good

401
00:16:44,560 --> 00:16:47,880
great because last time great question

402
00:16:46,160 --> 00:16:51,279
so last time when I mention I said oh

403
00:16:47,880 --> 00:16:54,199
just take STAR here anything so why am I

404
00:16:51,279 --> 00:16:56,720
why am I bounding out to to the Lambda

405
00:16:54,199 --> 00:16:59,480
so this construction bounds two to the

406
00:16:56,720 --> 00:17:01,639
Lambda because as you I take every

407
00:16:59,480 --> 00:17:03,920
Lambda I can't take that's all it gives

408
00:17:01,639 --> 00:17:05,600
me so that's all I get now you can say

409
00:17:03,920 --> 00:17:07,400
wait what if I want more maybe I more

410
00:17:05,600 --> 00:17:09,319
than two Lambda you can actually get

411
00:17:07,400 --> 00:17:12,000
more than two to the Lambda for example

412
00:17:09,319 --> 00:17:14,600
you can bootstrap this so now you can

413
00:17:12,000 --> 00:17:15,919
take two to the Lambda to Lambda you can

414
00:17:14,600 --> 00:17:18,439
kind of create a Merkel hash of this

415
00:17:15,919 --> 00:17:21,799
Merkel hash you know you can kind of uh

416
00:17:18,439 --> 00:17:23,679
uh but actually you never it doesn't

417
00:17:21,799 --> 00:17:26,319
come up because you never need to two to

418
00:17:23,679 --> 00:17:28,360
Lambda is like nothing is more than two

419
00:17:26,319 --> 00:17:29,880
to we choose Lambda to in our world

420
00:17:28,360 --> 00:17:33,240
nothing is more than size two to the

421
00:17:29,880 --> 00:17:35,160
Lambda but you can think of like um you

422
00:17:33,240 --> 00:17:38,720
you can get if you just as a kind of

423
00:17:35,160 --> 00:17:40,960
mathematical curiosity you can uh apply

424
00:17:38,720 --> 00:17:43,120
it you know so once you have from two to

425
00:17:40,960 --> 00:17:45,360
the Lambda to Lambda you

426
00:17:43,120 --> 00:17:48,320
can chop your things to two to the

427
00:17:45,360 --> 00:17:50,080
Lambda and and do this kind of use this

428
00:17:48,320 --> 00:17:52,360
as a building block to a bigger morle

429
00:17:50,080 --> 00:17:55,600
high so you can kind of amplify it you

430
00:17:52,360 --> 00:17:58,000
know uh but we're not for us 2 to the

431
00:17:55,600 --> 00:18:00,840
Lambda to Lambda is good enough great

432
00:17:58,000 --> 00:18:00,840
great question

433
00:18:01,480 --> 00:18:07,240
any any other question yes why does the

434
00:18:05,600 --> 00:18:08,679
need to be included in the like should

435
00:18:07,240 --> 00:18:12,080
it not just be a function of the left of

436
00:18:08,679 --> 00:18:14,880
X ah good great great question why do

437
00:18:12,080 --> 00:18:16,600
why do I insist on including D is it not

438
00:18:14,880 --> 00:18:18,200
a function of X it is a function of X

439
00:18:16,600 --> 00:18:21,200
it's a deterministic function of the L

440
00:18:18,200 --> 00:18:24,440
not even X of the length of X yes

441
00:18:21,200 --> 00:18:25,520
however nobody knows what x is so you

442
00:18:24,440 --> 00:18:28,080
know at the end of the day I want

443
00:18:25,520 --> 00:18:29,880
Collision resistance and so the property

444
00:18:28,080 --> 00:18:31,720
we want from this hash is that it's

445
00:18:29,880 --> 00:18:34,320
Collision resistance what does Collision

446
00:18:31,720 --> 00:18:37,919
resistant means it means that you cannot

447
00:18:34,320 --> 00:18:40,480
output a hash value with two different

448
00:18:37,919 --> 00:18:42,520
openings now when you outut a has value

449
00:18:40,480 --> 00:18:45,679
nobody knows what the x is actually you

450
00:18:42,520 --> 00:18:48,799
may not even know well if

451
00:18:45,679 --> 00:18:50,200
you um okay when you open you know but

452
00:18:48,799 --> 00:18:52,200
uh you know when you give someone a hash

453
00:18:50,200 --> 00:18:55,240
value there's no X

454
00:18:52,200 --> 00:18:57,760
inherently a part of it if you don't

455
00:18:55,240 --> 00:18:59,600
include the dep actually there's an

456
00:18:57,760 --> 00:19:01,440
attack it's not collig resistance it's

457
00:18:59,600 --> 00:19:03,559
really not it's not just a why is it not

458
00:19:01,440 --> 00:19:06,640
Collision resistance for example just as

459
00:19:03,559 --> 00:19:09,320
an attack let's say I publish this route

460
00:19:06,640 --> 00:19:12,480
even this is my root okay this is my

461
00:19:09,320 --> 00:19:15,120
input my input is X1 X2 X3 X4 and the

462
00:19:12,480 --> 00:19:17,159
output is root now let me break the

463
00:19:15,120 --> 00:19:20,840
Collision resistance I'll give you two

464
00:19:17,159 --> 00:19:22,240
different openings one is X1 X2 X3 X4

465
00:19:20,840 --> 00:19:24,600
you do the hash you see yeah you're

466
00:19:22,240 --> 00:19:27,039
happy it's a good opening now let me

467
00:19:24,600 --> 00:19:29,880
give you another opening just this and

468
00:19:27,039 --> 00:19:31,480
this that's also a good open opening so

469
00:19:29,880 --> 00:19:35,080
I open it in two different

470
00:19:31,480 --> 00:19:39,240
ways that's not okay that's a collision

471
00:19:35,080 --> 00:19:40,919
if you include D however then so that's

472
00:19:39,240 --> 00:19:43,799
exactly what will allow me to argue

473
00:19:40,919 --> 00:19:48,600
Collision resistance it's this D great

474
00:19:43,799 --> 00:19:50,600
question thank you any so so this is the

475
00:19:48,600 --> 00:19:52,799
construction

476
00:19:50,600 --> 00:19:55,640
questions okay let's see how do we open

477
00:19:52,799 --> 00:19:57,200
so now this is this is just so far great

478
00:19:55,640 --> 00:19:59,679
we managed to go from two to the Lambda

479
00:19:57,200 --> 00:20:02,600
to Lambda I didn't argue Collision resen

480
00:19:59,679 --> 00:20:05,360
but at least we did domain extension so

481
00:20:02,600 --> 00:20:07,159
we extended the domain but I also want

482
00:20:05,360 --> 00:20:09,039
especially I need it for the killan M

483
00:20:07,159 --> 00:20:11,720
protocol and for many many other uses in

484
00:20:09,039 --> 00:20:13,960
cryptography I want to be able to do

485
00:20:11,720 --> 00:20:17,159
local opening so remember what does

486
00:20:13,960 --> 00:20:19,600
local opening mean I may not want to

487
00:20:17,159 --> 00:20:21,159
open when with I may not want to give

488
00:20:19,600 --> 00:20:23,880
you my entire

489
00:20:21,159 --> 00:20:27,120
input I may just want to give you to

490
00:20:23,880 --> 00:20:31,159
convince you that this hash value in

491
00:20:27,120 --> 00:20:34,240
some location I of the of the of the

492
00:20:31,159 --> 00:20:35,600
input the value is some bit B but I

493
00:20:34,240 --> 00:20:36,840
don't want to give you the entire

494
00:20:35,600 --> 00:20:39,679
because the entire input is gigantic you

495
00:20:36,840 --> 00:20:41,520
can't even hold it so I want kind of a

496
00:20:39,679 --> 00:20:44,240
succinct opener I want to convince you

497
00:20:41,520 --> 00:20:46,760
in a kind of a very succinct way that

498
00:20:44,240 --> 00:20:52,679
what's sitting here in this bit is zero

499
00:20:46,760 --> 00:20:55,440
or it's one so how do I do it so this um

500
00:20:52,679 --> 00:20:57,360
a uh construction is actually really

501
00:20:55,440 --> 00:20:59,000
nice it gives you a local opening in a

502
00:20:57,360 --> 00:21:01,679
very nice way so what's the local

503
00:20:59,000 --> 00:21:04,240
opening suppose I want to open this kind

504
00:21:01,679 --> 00:21:06,240
of the bit here sitting here what I'm

505
00:21:04,240 --> 00:21:08,400
going to do I'm going to actually give

506
00:21:06,240 --> 00:21:10,880
you this entire Block it's only L the

507
00:21:08,400 --> 00:21:13,039
bit so it's not that big okay I give you

508
00:21:10,880 --> 00:21:15,760
this block what do you do with it so let

509
00:21:13,039 --> 00:21:18,000
me help you convince you that this block

510
00:21:15,760 --> 00:21:20,880
is indeed the block related to the root

511
00:21:18,000 --> 00:21:23,679
namely it's the it's the block that

512
00:21:20,880 --> 00:21:24,640
indeed sits here next to how do I

513
00:21:23,679 --> 00:21:28,200
convince

514
00:21:24,640 --> 00:21:31,039
you I give you the sibling so this block

515
00:21:28,200 --> 00:21:32,080
has a parent I give you the sibling and

516
00:21:31,039 --> 00:21:35,279
the

517
00:21:32,080 --> 00:21:38,360
parent this parent has a parent I give

518
00:21:35,279 --> 00:21:40,760
you the sibling and the parent and so on

519
00:21:38,360 --> 00:21:44,159
so forth until you get to the root I

520
00:21:40,760 --> 00:21:47,679
give you all these blocks so in each

521
00:21:44,159 --> 00:21:50,240
layer I open two blocks which are the

522
00:21:47,679 --> 00:21:51,880
two siblings so I open two siblings you

523
00:21:50,240 --> 00:21:55,520
get this I open the two siblings you get

524
00:21:51,880 --> 00:21:57,960
this I open the twoing and so on

525
00:21:55,520 --> 00:21:59,799
yes so I don't know if it matters but

526
00:21:57,960 --> 00:22:01,760
you strictly you to return the ancestors

527
00:21:59,799 --> 00:22:03,000
you can only return the sit ons right

528
00:22:01,760 --> 00:22:04,320
good good good right right right you're

529
00:22:03,000 --> 00:22:06,440
totally right you're saying well if you

530
00:22:04,320 --> 00:22:08,000
really want to be what you're saying

531
00:22:06,440 --> 00:22:10,279
which is completely right thing this is

532
00:22:08,000 --> 00:22:12,960
wasteful because actually all I need to

533
00:22:10,279 --> 00:22:15,640
give you is the sibling so why waste

534
00:22:12,960 --> 00:22:18,080
communication I if I want to open this

535
00:22:15,640 --> 00:22:19,159
I'll give you this and this sibling I

536
00:22:18,080 --> 00:22:21,159
don't need to give you this you can

537
00:22:19,159 --> 00:22:23,120
compute this on your own so compute this

538
00:22:21,159 --> 00:22:24,880
on your own I'll give you this I don't

539
00:22:23,120 --> 00:22:27,039
need to give you this you have these two

540
00:22:24,880 --> 00:22:29,360
so complet it on this on your own and

541
00:22:27,039 --> 00:22:31,640
then I'll only give you this and then

542
00:22:29,360 --> 00:22:32,880
and so on you're 100% correct I actually

543
00:22:31,640 --> 00:22:35,960
just need to give you

544
00:22:32,880 --> 00:22:38,640
one okay I wrote two because it's just

545
00:22:35,960 --> 00:22:41,640
easier to say something but yes exactly

546
00:22:38,640 --> 00:22:43,159
one is enough and you can compute the

547
00:22:41,640 --> 00:22:46,880
yeah

548
00:22:43,159 --> 00:22:49,799
fantastic uh so that's the so I I I

549
00:22:46,880 --> 00:22:52,520
denoted by so what does the open do it

550
00:22:49,799 --> 00:22:55,120
gives you for each layer it gives you

551
00:22:52,520 --> 00:22:57,799
two blocks for layer J denoted by ZJ so

552
00:22:55,120 --> 00:23:00,480
ZJ is two blocks okay there's on the

553
00:22:57,799 --> 00:23:02,159
leaves it's two blocks J equal zero it's

554
00:23:00,480 --> 00:23:03,960
on the leaf layer one layer two up to

555
00:23:02,159 --> 00:23:06,080
layer D it's actually just the root so

556
00:23:03,960 --> 00:23:09,799
you don't you can actually go to D minus

557
00:23:06,080 --> 00:23:11,799
one if you want okay but I I'll just in

558
00:23:09,799 --> 00:23:13,880
in my mind I want to include the root

559
00:23:11,799 --> 00:23:16,159
it's just you'll the reason I include

560
00:23:13,880 --> 00:23:17,880
both and the root is now when I analyze

561
00:23:16,159 --> 00:23:20,120
it it's notation wise it's just very

562
00:23:17,880 --> 00:23:22,000
very easy but really it's enough like

563
00:23:20,120 --> 00:23:24,000
you said to have the sibling and the

564
00:23:22,000 --> 00:23:26,400
roots of course you don't need to

565
00:23:24,000 --> 00:23:29,000
give okay but let's just think this is

566
00:23:26,400 --> 00:23:32,360
how I open and now how do I

567
00:23:29,000 --> 00:23:33,960
verify I just take each two sibling

568
00:23:32,360 --> 00:23:36,720
compute the hash and make sure it

569
00:23:33,960 --> 00:23:39,640
corresponds to the relevant the relevant

570
00:23:36,720 --> 00:23:42,000
Z is indeed uh the parent so again you

571
00:23:39,640 --> 00:23:44,320
gave me all these things I compute these

572
00:23:42,000 --> 00:23:45,559
two I check that it's consistent with

573
00:23:44,320 --> 00:23:48,120
the what you gave you if you didn't give

574
00:23:45,559 --> 00:23:51,760
me fine I'll compute on my own I get

575
00:23:48,120 --> 00:23:53,159
this I'll compute this and give and then

576
00:23:51,760 --> 00:23:56,200
they'll check that all I need to check

577
00:23:53,159 --> 00:24:00,799
it then is consistency with the

578
00:23:56,200 --> 00:24:00,799
root okay that the

579
00:24:01,080 --> 00:24:06,559
verification question about the design

580
00:24:03,640 --> 00:24:06,559
the the

581
00:24:07,480 --> 00:24:11,200
algorithms okay so this is kind of where

582
00:24:09,520 --> 00:24:13,960
we left off actually last time and what

583
00:24:11,200 --> 00:24:16,080
I want to do now is do the Collision

584
00:24:13,960 --> 00:24:17,679
resistance I'm happy that actually we

585
00:24:16,080 --> 00:24:20,480
got a chance to do it again because it's

586
00:24:17,679 --> 00:24:23,840
a very important primitive so it's worth

587
00:24:20,480 --> 00:24:26,960
kind of having it ingrained in your mind

588
00:24:23,840 --> 00:24:29,960
a okay so why why is it collagen

589
00:24:26,960 --> 00:24:29,960
resistant

590
00:24:30,760 --> 00:24:35,360
so to prove Collision resistance what do

591
00:24:32,640 --> 00:24:38,960
we want to argue that an adversary

592
00:24:35,360 --> 00:24:42,080
that's given a hash key cannot produce a

593
00:24:38,960 --> 00:24:43,000
hash value namely root and D with two

594
00:24:42,080 --> 00:24:47,520
different

595
00:24:43,000 --> 00:24:47,520
openings okay so

596
00:24:48,120 --> 00:24:55,279
Suppose there

597
00:24:51,039 --> 00:24:55,279
exists a poly

598
00:24:56,120 --> 00:25:03,320
size adversary that does find the

599
00:24:59,279 --> 00:25:06,799
Collision okay such that the probability

600
00:25:03,320 --> 00:25:09,799
that a he gets a hash key hash key is

601
00:25:06,799 --> 00:25:09,799
from

602
00:25:09,960 --> 00:25:17,320
gen and somehow he manages to Output a

603
00:25:13,760 --> 00:25:18,799
hash value which is root and D that's

604
00:25:17,320 --> 00:25:22,320
just a hash

605
00:25:18,799 --> 00:25:26,520
value and he gives me some

606
00:25:22,320 --> 00:25:28,320
index uh I and he managed to open it in

607
00:25:26,520 --> 00:25:32,399
two different way he gives me an open

608
00:25:28,320 --> 00:25:35,919
opening that says oh I is zero and it

609
00:25:32,399 --> 00:25:39,080
gives me another opening that says the I

610
00:25:35,919 --> 00:25:42,919
bit is one and such that for both of

611
00:25:39,080 --> 00:25:44,159
them such that for every B for both zero

612
00:25:42,919 --> 00:25:48,840
and

613
00:25:44,159 --> 00:25:55,320
one there will accept there and hash

614
00:25:48,840 --> 00:25:59,320
key uh root and d i and row b outputs

615
00:25:55,320 --> 00:26:02,760
one so suppose I have an algorithm

616
00:25:59,320 --> 00:26:06,039
that gives me a hash value an index and

617
00:26:02,760 --> 00:26:08,640
a valid opening both to zero and to one

618
00:26:06,039 --> 00:26:10,960
valid I mean that the ver will accept

619
00:26:08,640 --> 00:26:15,520
both of them oh sorry

620
00:26:10,960 --> 00:26:19,120
B so ver takes hash key a value an index

621
00:26:15,520 --> 00:26:21,960
I and a b bit B saying whether index I

622
00:26:19,120 --> 00:26:25,200
is zero or one and a proof an

623
00:26:21,960 --> 00:26:27,679
opening and suppose he accepts

624
00:26:25,200 --> 00:26:30,080
both suppose he accepts both with

625
00:26:27,679 --> 00:26:32,799
probability at least I know

626
00:26:30,080 --> 00:26:35,799
Epsilon okay so Suppose there exist an

627
00:26:32,799 --> 00:26:35,799
exists

628
00:26:40,840 --> 00:26:45,840
Epsilon so Suppose there exist epon so

629
00:26:43,679 --> 00:26:48,559
that for any L that the probability that

630
00:26:45,840 --> 00:26:51,000
a managed to find the Collision like

631
00:26:48,559 --> 00:26:53,480
this is at least Epsilon I'm going to

632
00:26:51,000 --> 00:26:56,159
argue then then you can find a collision

633
00:26:53,480 --> 00:26:58,640
in the underlying H in the small H with

634
00:26:56,159 --> 00:27:00,960
probability Epsilon

635
00:26:58,640 --> 00:27:03,120
okay so if you you if you have an

636
00:27:00,960 --> 00:27:08,000
algorithm like this

637
00:27:03,120 --> 00:27:10,520
then there exists an algorithm uh uh

638
00:27:08,000 --> 00:27:10,520
poly

639
00:27:14,600 --> 00:27:20,440
size such that

640
00:27:18,039 --> 00:27:24,679
b such that the

641
00:27:20,440 --> 00:27:28,559
probability that b he gets hash key the

642
00:27:24,679 --> 00:27:28,559
probability that he outputs

643
00:27:29,279 --> 00:27:40,919
a I don't know x0 x and x Prime such

644
00:27:33,799 --> 00:27:46,960
that the original eval HK x equals

645
00:27:40,919 --> 00:27:50,080
eval hkx Prime and X is different than x

646
00:27:46,960 --> 00:27:52,159
Prime is at least

647
00:27:50,080 --> 00:27:54,640
Epsilon but we assume that this is

648
00:27:52,159 --> 00:27:56,880
Collision resistance we started with an

649
00:27:54,640 --> 00:27:59,559
underlying hash function that's

650
00:27:56,880 --> 00:28:01,799
Collision resistance so the Epsilon has

651
00:27:59,559 --> 00:28:01,799
to be

652
00:28:01,840 --> 00:28:06,399
negligible okay that's what we're going

653
00:28:03,480 --> 00:28:09,880
to show so we're going to use if an

654
00:28:06,399 --> 00:28:13,240
adversary can find a coll a local

655
00:28:09,880 --> 00:28:16,080
opening that collides for the Merkel

656
00:28:13,240 --> 00:28:18,799
hash we can use them to actually

657
00:28:16,080 --> 00:28:21,240
break the to find collisions in the

658
00:28:18,799 --> 00:28:23,640
underlying kind of two Lambda to L to

659
00:28:21,240 --> 00:28:25,320
Lambda uh hash function in the little

660
00:28:23,640 --> 00:28:28,360
hash

661
00:28:25,320 --> 00:28:32,640
function so how does B work what does B

662
00:28:28,360 --> 00:28:35,080
do B takes it a hash key he just run a

663
00:28:32,640 --> 00:28:37,320
so let me so we claim that there exists

664
00:28:35,080 --> 00:28:42,320
a b so let's see

665
00:28:37,320 --> 00:28:51,159
B an input hash key what does it do just

666
00:28:42,320 --> 00:28:56,159
run a so get root d i row0 Row

667
00:28:51,159 --> 00:28:58,640
one which is just a and hash

668
00:28:56,159 --> 00:29:00,840
key now

669
00:28:58,640 --> 00:29:04,440
he got row zero and Row one what are row

670
00:29:00,840 --> 00:29:07,840
zero Row one each row is this kind of

671
00:29:04,440 --> 00:29:09,519
two uh pairs of siblings I'm going to

672
00:29:07,840 --> 00:29:11,039
assume that both exist because it's just

673
00:29:09,519 --> 00:29:13,600
easier for me that's why I wrote both of

674
00:29:11,039 --> 00:29:18,519
them so each

675
00:29:13,600 --> 00:29:20,000
opening so row zero is for each level

676
00:29:18,519 --> 00:29:23,000
you have

677
00:29:20,000 --> 00:29:23,000
z0

678
00:29:25,720 --> 00:29:30,799
J from zero to D and Row

679
00:29:30,919 --> 00:29:38,240
one is let's call it z uh one

680
00:29:39,360 --> 00:29:45,519
J now what do we know in the leaves so

681
00:29:43,640 --> 00:29:51,320
we know that

682
00:29:45,519 --> 00:29:53,360
z0 Z is different than Z One Z the two

683
00:29:51,320 --> 00:29:56,559
leaves are different because in one

684
00:29:53,360 --> 00:29:59,480
leaf okay suppose suppose verify access

685
00:29:56,559 --> 00:30:01,600
to both of them in the case that these

686
00:29:59,480 --> 00:30:02,559
are both accepted I'm going to argue

687
00:30:01,600 --> 00:30:05,679
that I found

688
00:30:02,559 --> 00:30:08,559
collisions okay so now suppose row Z and

689
00:30:05,679 --> 00:30:12,200
Row one are accepted so

690
00:30:08,559 --> 00:30:16,399
ver ver accepts both of

691
00:30:12,200 --> 00:30:18,799
them now if there accepts both of them

692
00:30:16,399 --> 00:30:21,840
so we know that the leaves are different

693
00:30:18,799 --> 00:30:24,840
because in the leaves in one case I have

694
00:30:21,840 --> 00:30:27,440
here one and the other case I have zero

695
00:30:24,840 --> 00:30:31,080
so they have to be different so I know

696
00:30:27,440 --> 00:30:34,000
the leaves are different I also know

697
00:30:31,080 --> 00:30:38,360
that z0

698
00:30:34,000 --> 00:30:40,360
D equals z1d these are both a

699
00:30:38,360 --> 00:30:41,760
root now of course I said we don't need

700
00:30:40,360 --> 00:30:44,080
to include it because but I'm just

701
00:30:41,760 --> 00:30:45,799
putting here because I want what the

702
00:30:44,080 --> 00:30:48,559
reason I want to include it is just for

703
00:30:45,799 --> 00:30:50,640
clarity to say look we have kind of D

704
00:30:48,559 --> 00:30:53,000
layers of information on each

705
00:30:50,640 --> 00:30:54,320
opening the leaves they must be

706
00:30:53,000 --> 00:30:57,039
different because one opens to zero one

707
00:30:54,320 --> 00:30:59,200
opens to one the root the last one must

708
00:30:57,039 --> 00:31:01,440
be the same it's the root

709
00:30:59,200 --> 00:31:05,120
it means that there must be some kind of

710
00:31:01,440 --> 00:31:08,080
two adjacent layers on which one of

711
00:31:05,120 --> 00:31:09,360
below they disagree and above they agree

712
00:31:08,080 --> 00:31:11,720
okay we know here they disagree here

713
00:31:09,360 --> 00:31:13,000
they agree okay they disagree do they

714
00:31:11,720 --> 00:31:14,919
disagree here disagree here at some

715
00:31:13,000 --> 00:31:16,720
point they're going to agree so we say

716
00:31:14,919 --> 00:31:24,159
there must

717
00:31:16,720 --> 00:31:30,039
be a layer J such that zj0 is different

718
00:31:24,159 --> 00:31:34,279
than zj1 but ZJ + one 0 is equal to

719
00:31:30,039 --> 00:31:38,200
ZJ + 1

720
00:31:34,279 --> 00:31:39,960
1 yeah okay they disagree here how about

721
00:31:38,200 --> 00:31:41,440
one layer above do they agree if they

722
00:31:39,960 --> 00:31:44,519
agree great then that's going to be our

723
00:31:41,440 --> 00:31:45,720
J plus one they disagree let's go up

724
00:31:44,519 --> 00:31:49,480
until at some point they'll agree

725
00:31:45,720 --> 00:31:49,480
because they agree

726
00:31:52,840 --> 00:31:58,799
yeah oh thank you very much thank you uh

727
00:31:57,399 --> 00:32:00,519
great thank you yeah it's not just for

728
00:31:58,799 --> 00:32:05,480
the video it's also for you guys so I

729
00:32:00,519 --> 00:32:11,760
won't uh confuse you more than it thank

730
00:32:05,480 --> 00:32:16,840
you a one J One J + one thank

731
00:32:11,760 --> 00:32:16,840
you okay yes I I is

732
00:32:21,440 --> 00:32:28,720
it I did I miss

733
00:32:24,919 --> 00:32:34,039
I yes

734
00:32:28,720 --> 00:32:40,399
my God okay no there zero one

735
00:32:34,039 --> 00:32:42,799
ah okay did I get it right yes okay so

736
00:32:40,399 --> 00:32:44,840
there's a layer J said that in layer J

737
00:32:42,799 --> 00:32:49,039
they disagree in layer j+ one they

738
00:32:44,840 --> 00:32:52,720
agree that's it this is a collision why

739
00:32:49,039 --> 00:32:54,960
what is layer J + one one of them is the

740
00:32:52,720 --> 00:33:00,080
father is the

741
00:32:54,960 --> 00:33:03,080
parent so we have two that they

742
00:33:00,080 --> 00:33:06,399
disagree but both of these they agree

743
00:33:03,080 --> 00:33:09,159
on in particular they agree on this so

744
00:33:06,399 --> 00:33:12,159
done so we found a collision this must

745
00:33:09,159 --> 00:33:12,159
mean

746
00:33:13,799 --> 00:33:20,840
that the hash

747
00:33:16,080 --> 00:33:24,159
eval hash key of

748
00:33:20,840 --> 00:33:29,159
z0j is equal to

749
00:33:24,159 --> 00:33:33,519
eval H key of z1j because this value is

750
00:33:29,159 --> 00:33:34,919
one of the it's you know one of this and

751
00:33:33,519 --> 00:33:36,639
one one of this and one of this

752
00:33:34,919 --> 00:33:38,799
depending if it's the left or the right

753
00:33:36,639 --> 00:33:42,600
depending on the tree but and they're

754
00:33:38,799 --> 00:33:42,600
both equal so done I found a

755
00:33:45,919 --> 00:33:51,240
collision okay with the same exact

756
00:33:48,360 --> 00:33:54,679
probability so it's

757
00:33:51,240 --> 00:33:57,440
uh now as I said this I wrote here

758
00:33:54,679 --> 00:33:59,919
supposed to exist P Lambda I could have

759
00:33:57,440 --> 00:34:03,120
if we assumed that the underlying hash

760
00:33:59,919 --> 00:34:04,919
function is t- secure namely you can't

761
00:34:03,120 --> 00:34:07,519
find collisions even if you run time

762
00:34:04,919 --> 00:34:11,919
poly T of Lambda then we get that the

763
00:34:07,519 --> 00:34:14,879
Merle hash is POL secure because B all

764
00:34:11,919 --> 00:34:16,599
it does really is just run a it doesn't

765
00:34:14,879 --> 00:34:19,240
run much more than a it just runs a and

766
00:34:16,599 --> 00:34:20,879
then it does something very trivial so

767
00:34:19,240 --> 00:34:22,040
the complexity of breaking the miracle

768
00:34:20,879 --> 00:34:24,119
hash is really the same as the

769
00:34:22,040 --> 00:34:26,879
complexity of breaking the underlying

770
00:34:24,119 --> 00:34:29,720
hash so if the underlying hash is tsec

771
00:34:26,879 --> 00:34:29,720
Miracle hash is TC

772
00:34:32,040 --> 00:34:35,040
secure

773
00:34:39,159 --> 00:34:45,399
questions okay so where are we so we

774
00:34:43,679 --> 00:34:47,159
prove the Merkel hash as we saw the

775
00:34:45,399 --> 00:34:49,520
Merkel hash was used to give an

776
00:34:47,159 --> 00:34:51,000
interactive a succinct interactive

777
00:34:49,520 --> 00:34:56,000
argument for all of

778
00:34:51,000 --> 00:34:59,520
NP so now if you're willing to you know

779
00:34:56,000 --> 00:35:01,680
to you're happy with intrac

780
00:34:59,520 --> 00:35:04,160
protocols thank you very much I hope you

781
00:35:01,680 --> 00:35:06,880
enjoyed the semester and we're

782
00:35:04,160 --> 00:35:08,480
done if you're not though but as I said

783
00:35:06,880 --> 00:35:10,720
we're actually we're not happy with

784
00:35:08,480 --> 00:35:11,960
interactive protocols it's really

785
00:35:10,720 --> 00:35:15,000
interesting actually to think of the

786
00:35:11,960 --> 00:35:18,160
evolution of of this because you know it

787
00:35:15,000 --> 00:35:20,680
before all this interactive proofs and

788
00:35:18,160 --> 00:35:22,560
arguments and so on we had just

789
00:35:20,680 --> 00:35:25,400
mathematical proofs which were not

790
00:35:22,560 --> 00:35:27,880
interactive but they were very very

791
00:35:25,400 --> 00:35:29,440
long and people were not happy like kid

792
00:35:27,880 --> 00:35:31,800
like oh they're so long and then

793
00:35:29,440 --> 00:35:33,400
interactive proofs were defined I think

794
00:35:31,800 --> 00:35:36,040
they were defined only for the sake of

795
00:35:33,400 --> 00:35:37,359
zero knowledge they were defined just to

796
00:35:36,040 --> 00:35:38,839
get zero knowledge proofs I'm GNA

797
00:35:37,359 --> 00:35:40,839
actually mention we're going to talk

798
00:35:38,839 --> 00:35:44,599
about zero knowledge later

799
00:35:40,839 --> 00:35:45,720
today and this motivated kind of the int

800
00:35:44,599 --> 00:35:48,040
to introduce

801
00:35:45,720 --> 00:35:49,839
interraction and then people like wow

802
00:35:48,040 --> 00:35:51,119
you oh what a great forget about zero

803
00:35:49,839 --> 00:35:53,480
knowledge forget about cryptography this

804
00:35:51,119 --> 00:35:56,520
is such a great model using intraction

805
00:35:53,480 --> 00:35:59,200
we can prove a lot more right and we saw

806
00:35:56,520 --> 00:36:02,599
the Gare protocol you can can do like uh

807
00:35:59,200 --> 00:36:04,200
you can prove actually any any circuits

808
00:36:02,599 --> 00:36:07,000
that are really really huge as long as

809
00:36:04,200 --> 00:36:09,960
they're kind of have dep you can do PE

810
00:36:07,000 --> 00:36:12,359
space or any computation that has poly

811
00:36:09,960 --> 00:36:15,720
depth you verify can be any depth V you

812
00:36:12,359 --> 00:36:17,520
can the verify runs in time deep great

813
00:36:15,720 --> 00:36:19,680
not it doesn't run in the sign so it's

814
00:36:17,520 --> 00:36:21,240
much much more powerful wow wow wow and

815
00:36:19,680 --> 00:36:24,359
then people like actually with

816
00:36:21,240 --> 00:36:26,520
cryptographer can do much more great but

817
00:36:24,359 --> 00:36:29,040
now like but wait there was a big price

818
00:36:26,520 --> 00:36:31,200
we actually don't want ction so where

819
00:36:29,040 --> 00:36:34,079
are we are we back at

820
00:36:31,200 --> 00:36:36,119
NP NP is very we're back in the

821
00:36:34,079 --> 00:36:38,640
mathematical proof that are way way too

822
00:36:36,119 --> 00:36:41,040
long so I said

823
00:36:38,640 --> 00:36:43,720
no we're actually going to circle back

824
00:36:41,040 --> 00:36:46,440
in a very interesting way and get suin

825
00:36:43,720 --> 00:36:46,440
non-interactive

826
00:36:46,599 --> 00:36:53,000
proofs so how do we Circle back okay

827
00:37:08,160 --> 00:37:15,319
so so this idea of how to Circle back

828
00:37:12,240 --> 00:37:19,760
actually was

829
00:37:15,319 --> 00:37:21,880
um put forth by fat Cham this is in the

830
00:37:19,760 --> 00:37:25,040
mid 80s and

831
00:37:21,880 --> 00:37:27,839
86 they proposed a really really nice

832
00:37:25,040 --> 00:37:30,359
Paradigm actually they didn't think

833
00:37:27,839 --> 00:37:32,560
about this is this is 86 this is kind of

834
00:37:30,359 --> 00:37:36,400
before intractive proofs it was just

835
00:37:32,560 --> 00:37:39,079
when zonal was introduced um interactive

836
00:37:36,400 --> 00:37:41,400
proofs just came about but no you know

837
00:37:39,079 --> 00:37:46,240
there was no PCP no interactive argument

838
00:37:41,400 --> 00:37:46,240
none of that okay this is an 86

839
00:37:55,400 --> 00:38:00,880
F they proposed the method

840
00:37:58,560 --> 00:38:05,480
of actually reducing interaction of

841
00:38:00,880 --> 00:38:07,240
constructing signature schemes now I I

842
00:38:05,480 --> 00:38:09,720
stand behind what I said that this class

843
00:38:07,240 --> 00:38:11,160
will not require a lot of cryptog crypto

844
00:38:09,720 --> 00:38:14,319
background you don't need to know what

845
00:38:11,160 --> 00:38:17,560
signature schemes are but the what they

846
00:38:14,319 --> 00:38:19,880
did their idea is there was there's a

847
00:38:17,560 --> 00:38:22,599
primitive called identification scheme I

848
00:38:19,880 --> 00:38:24,160
want to prove to you that I'm y okay how

849
00:38:22,599 --> 00:38:25,760
do I prove that I'm y I have a public

850
00:38:24,160 --> 00:38:27,040
key corresponding to my name and I'm

851
00:38:25,760 --> 00:38:27,960
going to prove to that I know the secret

852
00:38:27,040 --> 00:38:30,000
key

853
00:38:27,960 --> 00:38:31,560
me knowing whoever knows the secret key

854
00:38:30,000 --> 00:38:33,640
has my identity essentially that's how

855
00:38:31,560 --> 00:38:35,040
things work in the digital world so I'm

856
00:38:33,640 --> 00:38:38,560
going to prove to you that I know the

857
00:38:35,040 --> 00:38:40,520
secret key this proves that I'm me okay

858
00:38:38,560 --> 00:38:42,359
this proof was interactive okay

859
00:38:40,520 --> 00:38:44,599
identification Protocols are like three

860
00:38:42,359 --> 00:38:46,960
round protocols I give you a message

861
00:38:44,599 --> 00:38:49,040
Alpha you send me a question beta I give

862
00:38:46,960 --> 00:38:50,200
you an answer gamma you verify that's

863
00:38:49,040 --> 00:38:53,480
how it

864
00:38:50,200 --> 00:38:55,839
works now they said let's convert this

865
00:38:53,480 --> 00:38:58,319
identification scheme into a signature

866
00:38:55,839 --> 00:39:00,920
scheme instead of kind of interacting to

867
00:38:58,319 --> 00:39:04,240
make sure it's you every time you sign a

868
00:39:00,920 --> 00:39:07,040
you want to send a message kind of use

869
00:39:04,240 --> 00:39:08,760
this use this message take this

870
00:39:07,040 --> 00:39:10,440
identification protocol together with

871
00:39:08,760 --> 00:39:12,440
some message and kind of eliminate the

872
00:39:10,440 --> 00:39:14,200
interaction I'll explain exactly how

873
00:39:12,440 --> 00:39:16,000
they do it but but they do it in a way

874
00:39:14,200 --> 00:39:17,079
to construct signature scheme that was

875
00:39:16,000 --> 00:39:20,480
their

876
00:39:17,079 --> 00:39:22,640
goal but now after several years after

877
00:39:20,480 --> 00:39:24,280
we use it all the time to actually

878
00:39:22,640 --> 00:39:26,079
forget about just the specific

879
00:39:24,280 --> 00:39:27,920
application of identification skin to

880
00:39:26,079 --> 00:39:30,240
signature that's one application

881
00:39:27,920 --> 00:39:33,000
but actually we can show we can use it

882
00:39:30,240 --> 00:39:35,640
to reduce to eliminate intraction not

883
00:39:33,000 --> 00:39:38,440
only from identification scheme but from

884
00:39:35,640 --> 00:39:42,880
any interactive protocol that is public

885
00:39:38,440 --> 00:39:49,400
coin so let me explain so now take any

886
00:39:42,880 --> 00:39:49,400
protocol uh so so this is a this is a

887
00:39:51,400 --> 00:39:55,880
paradigm for eliminating

888
00:40:01,470 --> 00:40:06,000
[Music]

889
00:40:03,960 --> 00:40:08,359
interaction

890
00:40:06,000 --> 00:40:11,359
from

891
00:40:08,359 --> 00:40:11,359
interactive

892
00:40:11,560 --> 00:40:18,200
protocols that are public

893
00:40:14,480 --> 00:40:21,640
coin so not all protocol but ones that

894
00:40:18,200 --> 00:40:24,200
are public coin so what is a public coin

895
00:40:21,640 --> 00:40:28,079
protocol take any protocol let say a

896
00:40:24,200 --> 00:40:30,599
proof so I have aover and a VAR

897
00:40:28,079 --> 00:40:33,240
verifier and suppose for a second it's

898
00:40:30,599 --> 00:40:35,599
so the suppose for Simplicity that it's

899
00:40:33,240 --> 00:40:37,880
three messages okay so the verify the

900
00:40:35,599 --> 00:40:41,079
prover sends a message Alpha the

901
00:40:37,880 --> 00:40:43,520
verifier sends beta which is random okay

902
00:40:41,079 --> 00:40:46,079
that's public CO mean the message of the

903
00:40:43,520 --> 00:40:49,280
ver far is completely random okay let's

904
00:40:46,079 --> 00:40:51,839
say it's kind of Lambda bits if it's

905
00:40:49,280 --> 00:40:53,400
less then just P it to be Lambda okay

906
00:40:51,839 --> 00:40:55,119
and if it's more just call that Lambda

907
00:40:53,400 --> 00:40:57,880
make that the security parameter just

908
00:40:55,119 --> 00:41:00,440
increase the security parameter

909
00:40:57,880 --> 00:41:03,040
okay now you send

910
00:41:00,440 --> 00:41:04,760
gamma and maybe it's more round so maybe

911
00:41:03,040 --> 00:41:08,920
then he sends

912
00:41:04,760 --> 00:41:12,040
Delta let's say random bits and then you

913
00:41:08,920 --> 00:41:14,359
say epsilon and you can continue okay

914
00:41:12,040 --> 00:41:17,480
let me stop here for the sake

915
00:41:14,359 --> 00:41:19,560
of okay now I'm going to eliminate

916
00:41:17,480 --> 00:41:21,520
intraction how do we eliminate

917
00:41:19,560 --> 00:41:24,640
intraction it seem like intraction is

918
00:41:21,520 --> 00:41:28,359
very important I mean the entire kind of

919
00:41:24,640 --> 00:41:30,960
if you remember the surack and G

920
00:41:28,359 --> 00:41:34,440
I mean it's tempting maybe to say oh

921
00:41:30,960 --> 00:41:35,880
tell the prover compute Alpha Beta GMA

922
00:41:34,440 --> 00:41:38,200
just compute the transcript on your own

923
00:41:35,880 --> 00:41:40,079
you simulate the verifi messages then

924
00:41:38,200 --> 00:41:43,599
he'll

925
00:41:40,079 --> 00:41:46,920
cheat so how do you get rid of the

926
00:41:43,599 --> 00:41:50,920
interaction seems

927
00:41:46,920 --> 00:41:53,400
really really hard actually it's so easy

928
00:41:50,920 --> 00:41:54,960
I mean there idea is Trivial so what is

929
00:41:53,400 --> 00:41:57,920
their idea they said they say the

930
00:41:54,960 --> 00:41:59,680
following

931
00:41:57,920 --> 00:42:00,880
how does the verifier how does the Prov

932
00:41:59,680 --> 00:42:04,880
get this

933
00:42:00,880 --> 00:42:08,480
beta the verifier chose it so you know

934
00:42:04,880 --> 00:42:09,599
what let's comp let not have the ver now

935
00:42:08,480 --> 00:42:11,599
we don't have a verifier it's not

936
00:42:09,599 --> 00:42:14,560
interactive there's no verifier so how

937
00:42:11,599 --> 00:42:16,960
to compute this beta let's compute it as

938
00:42:14,560 --> 00:42:18,839
kind of a hash function applied to the

939
00:42:16,960 --> 00:42:22,599
transcript so

940
00:42:18,839 --> 00:42:25,200
far so let me explain so

941
00:42:22,599 --> 00:42:29,160
how here's how you convert it

942
00:42:25,200 --> 00:42:33,440
to p f CH

943
00:42:29,160 --> 00:42:35,720
V this is associated with some hash

944
00:42:33,440 --> 00:42:38,400
family okay there's some It's associated

945
00:42:35,720 --> 00:42:40,559
with a hash family so the F Paradigm you

946
00:42:38,400 --> 00:42:42,920
can take any hash family and use that to

947
00:42:40,559 --> 00:42:48,079
reduce interraction how do you use it to

948
00:42:42,920 --> 00:42:50,440
reduce intraction now there's some hash

949
00:42:48,079 --> 00:42:52,680
key that's chosen once and for all

950
00:42:50,440 --> 00:42:54,520
everybody knows it either the verifier

951
00:42:52,680 --> 00:42:56,160
sends it once or if you think about

952
00:42:54,520 --> 00:42:58,240
public like everybody can verify I don't

953
00:42:56,160 --> 00:43:00,680
know the

954
00:42:58,240 --> 00:43:02,359
the US government publishes this hash

955
00:43:00,680 --> 00:43:03,680
key everybody uses this hash key okay

956
00:43:02,359 --> 00:43:08,119
there's some fixed hash key everybody

957
00:43:03,680 --> 00:43:10,040
uses it now once we agree on a hash key

958
00:43:08,119 --> 00:43:12,960
what does the prover

959
00:43:10,040 --> 00:43:16,960
do he computes Alpha that's let's say he

960
00:43:12,960 --> 00:43:16,960
wants to prove that X is in some

961
00:43:17,000 --> 00:43:20,400
language so he let's say he want he's

962
00:43:19,160 --> 00:43:22,839
telling okay I'm going to prove to you

963
00:43:20,400 --> 00:43:25,800
that X is in the language let me prove

964
00:43:22,839 --> 00:43:28,920
it to you okay I compute the

965
00:43:25,800 --> 00:43:31,920
alpha now I'm waiting for a beta but

966
00:43:28,920 --> 00:43:34,079
there's no verifier fine the I'll tell

967
00:43:31,920 --> 00:43:39,440
you what the beta is beta is just has is

968
00:43:34,079 --> 00:43:43,119
going to be EV Val of hash key on the

969
00:43:39,440 --> 00:43:45,319
transcript so far X in Alpha that's

970
00:43:43,119 --> 00:43:47,760
currently what's in the transcript the

971
00:43:45,319 --> 00:43:50,040
the statement and the first message

972
00:43:47,760 --> 00:43:52,119
Alpha now the proof is like okay this is

973
00:43:50,040 --> 00:43:53,640
the beta I got from the verifier he's

974
00:43:52,119 --> 00:43:56,000
interpreting this as the beta he got

975
00:43:53,640 --> 00:43:58,079
from the verifier and now he computes

976
00:43:56,000 --> 00:44:00,880
gamma my answer

977
00:43:58,079 --> 00:44:04,119
the Pro's answer now he's waiting for a

978
00:44:00,880 --> 00:44:06,520
message a query from the verifier some

979
00:44:04,119 --> 00:44:09,160
Delta but there is no verifier so he's

980
00:44:06,520 --> 00:44:13,079
going to compute

981
00:44:09,160 --> 00:44:18,800
Delta as eval of the hash key using the

982
00:44:13,079 --> 00:44:22,280
transcript so far so X Alpha Beta

983
00:44:18,800 --> 00:44:25,160
gamma once he has Delta he's going to go

984
00:44:22,280 --> 00:44:28,000
back to being aover and

985
00:44:25,160 --> 00:44:30,040
compute Epsilon

986
00:44:28,000 --> 00:44:33,880
and then you can continue next message

987
00:44:30,040 --> 00:44:35,880
he goes computes a hash value of all the

988
00:44:33,880 --> 00:44:37,079
transends of so far compute the next

989
00:44:35,880 --> 00:44:40,240
Pro's

990
00:44:37,079 --> 00:44:42,319
message another ver and we go that's how

991
00:44:40,240 --> 00:44:44,720
we

992
00:44:42,319 --> 00:44:47,000
continue any questions about so what

993
00:44:44,720 --> 00:44:48,680
what did we go we got we started from an

994
00:44:47,000 --> 00:44:52,119
interactive

995
00:44:48,680 --> 00:44:53,920
protocol can have many rounds and now

996
00:44:52,119 --> 00:44:57,079
all we need is to agree on a

997
00:44:53,920 --> 00:44:58,880
haski and once we agree on Hashi the pro

998
00:44:57,079 --> 00:45:00,400
just gives you this is one message

999
00:44:58,880 --> 00:45:03,400
that's

1000
00:45:00,400 --> 00:45:03,400
it

1001
00:45:03,559 --> 00:45:07,040
yeah good great question is it important

1002
00:45:05,960 --> 00:45:08,319
to include beta actually you don't need

1003
00:45:07,040 --> 00:45:12,599
to include beta at all because the

1004
00:45:08,319 --> 00:45:14,200
verifier can compute beta so we you only

1005
00:45:12,599 --> 00:45:16,040
need to know beta so you can compute

1006
00:45:14,200 --> 00:45:20,280
gamma you actually don't need to include

1007
00:45:16,040 --> 00:45:20,280
it great question great great

1008
00:45:21,400 --> 00:45:26,680
question so note for example if you

1009
00:45:24,240 --> 00:45:28,800
think about kilan mikali protocol you

1010
00:45:26,680 --> 00:45:30,920
may not remembered but let me just write

1011
00:45:28,800 --> 00:45:32,400
it here just to refresh your memory why

1012
00:45:30,920 --> 00:45:34,640
not you don't need to actually to

1013
00:45:32,400 --> 00:45:36,880
understand this but uh since it's such a

1014
00:45:34,640 --> 00:45:38,839
nice protocol and so how does it go

1015
00:45:36,880 --> 00:45:41,599
there's a prover and a verifier the

1016
00:45:38,839 --> 00:45:42,880
verifier sends a hash key so he wants to

1017
00:45:41,599 --> 00:45:45,440
prove that X is an

1018
00:45:42,880 --> 00:45:48,800
L he does a Merkle

1019
00:45:45,440 --> 00:45:49,960
hash of the PCP so he computes a PCP Pi

1020
00:45:48,800 --> 00:45:52,440
is a

1021
00:45:49,960 --> 00:45:56,280
PCP for x and

1022
00:45:52,440 --> 00:45:58,920
L and he sends you the Merkel hash so he

1023
00:45:56,280 --> 00:45:58,920
sends you root

1024
00:45:59,680 --> 00:46:06,400
and the and the depth

1025
00:46:03,119 --> 00:46:08,920
that's that's just the so he takes the

1026
00:46:06,400 --> 00:46:10,880
PCP and he does a hatch with local

1027
00:46:08,920 --> 00:46:13,119
opening for example mer hatch actually

1028
00:46:10,880 --> 00:46:16,440
can do any hatch with local opening that

1029
00:46:13,119 --> 00:46:19,720
you want this is the most common one and

1030
00:46:16,440 --> 00:46:23,640
then he gets kind of the randomness from

1031
00:46:19,720 --> 00:46:25,680
the PCP verifier so this is R from our

1032
00:46:23,640 --> 00:46:28,319
correspond to the PCP

1033
00:46:25,680 --> 00:46:31,119
verifier this determines a few locations

1034
00:46:28,319 --> 00:46:34,079
to open so now he opens so he gives so

1035
00:46:31,119 --> 00:46:36,760
this may this you know this Randomness

1036
00:46:34,079 --> 00:46:40,119
corresponds to like some locations i1 up

1037
00:46:36,760 --> 00:46:44,280
to I L and then you just Open PI i1 with

1038
00:46:40,119 --> 00:46:48,319
open one up to Pi i l with open

1039
00:46:44,280 --> 00:46:49,760
L that's the protocol note this is

1040
00:46:48,319 --> 00:46:52,800
completely

1041
00:46:49,760 --> 00:46:55,680
random it's the randomness of the PCP

1042
00:46:52,800 --> 00:46:58,000
verifier so we can uh eliminate

1043
00:46:55,680 --> 00:46:59,880
intraction this you if you think of it

1044
00:46:58,000 --> 00:47:02,839
this is just kind of a protocol where

1045
00:46:59,880 --> 00:47:06,160
you send a hash key and then you have

1046
00:47:02,839 --> 00:47:06,160
kind of Alpha Beta

1047
00:47:07,640 --> 00:47:11,319
gamma okay so let's eliminate

1048
00:47:09,520 --> 00:47:14,280
interaction so how do we eliminate

1049
00:47:11,319 --> 00:47:16,880
interaction well there's this hash key

1050
00:47:14,280 --> 00:47:20,359
let's we can use this hash key to do but

1051
00:47:16,880 --> 00:47:22,119
we can also use another hash key hash

1052
00:47:20,359 --> 00:47:26,160
key and

1053
00:47:22,119 --> 00:47:28,839
now the well this can be now you give

1054
00:47:26,160 --> 00:47:30,200
Alpha beta is going to be simply you

1055
00:47:28,839 --> 00:47:31,720
don't have to include it but it's going

1056
00:47:30,200 --> 00:47:37,160
to be in your in our head it's going to

1057
00:47:31,720 --> 00:47:37,160
be eval of hash

1058
00:47:37,480 --> 00:47:44,240
hash of X in

1059
00:47:41,359 --> 00:47:45,920
Alpha and then maybe hash key is also

1060
00:47:44,240 --> 00:47:48,720
part of the

1061
00:47:45,920 --> 00:47:52,359
transcript and and uh this gives bit and

1062
00:47:48,720 --> 00:47:52,359
now you compute the GMA which is the

1063
00:47:53,559 --> 00:48:00,200
opening okay so you can

1064
00:47:57,040 --> 00:48:03,800
you can take any so now if what does the

1065
00:48:00,200 --> 00:48:07,000
F give you it gives us a away remember K

1066
00:48:03,800 --> 00:48:09,680
mikali was very succinct right you can

1067
00:48:07,000 --> 00:48:12,079
take X any let's say NP

1068
00:48:09,680 --> 00:48:14,000
language n can be very large it can be

1069
00:48:12,079 --> 00:48:16,520
Lambda to that thousand I know it can be

1070
00:48:14,000 --> 00:48:18,520
what it can be even super poom Lambda it

1071
00:48:16,520 --> 00:48:20,040
can be almost as l two to the

1072
00:48:18,520 --> 00:48:23,079
Lambda

1073
00:48:20,040 --> 00:48:25,400
okay and look how sucing the protocol is

1074
00:48:23,079 --> 00:48:27,839
you just send a hash key the root which

1075
00:48:25,400 --> 00:48:30,079
is Lambda bits and the opening and this

1076
00:48:27,839 --> 00:48:33,440
the PCP is all L the bits poly L the

1077
00:48:30,079 --> 00:48:35,400
bits so very very succinct and now you

1078
00:48:33,440 --> 00:48:38,359
can even just make it

1079
00:48:35,400 --> 00:48:41,160
so what is this you can all send it all

1080
00:48:38,359 --> 00:48:42,760
in one round so what what does it give

1081
00:48:41,160 --> 00:48:44,440
you what does it tell us that you we can

1082
00:48:42,760 --> 00:48:46,839
take any NP

1083
00:48:44,440 --> 00:48:50,359
statement and give a proof of size poly

1084
00:48:46,839 --> 00:48:50,359
Lambda doesn't matter what size X

1085
00:48:50,960 --> 00:48:55,799
is that's

1086
00:48:53,079 --> 00:49:00,000
amazing without cryptography we need po

1087
00:48:55,799 --> 00:49:00,000
you know these G Witnesses

1088
00:49:00,200 --> 00:49:05,760
yeah

1089
00:49:02,240 --> 00:49:07,760
prob imagine ofd hash family where there

1090
00:49:05,760 --> 00:49:09,319
exist hash keys that are really bad okay

1091
00:49:07,760 --> 00:49:11,520
and so I guess here it's fine because

1092
00:49:09,319 --> 00:49:14,000
the verifier chooses the hash key but

1093
00:49:11,520 --> 00:49:15,760
you might imagine if the US publishes a

1094
00:49:14,000 --> 00:49:18,680
anything else what if it happens to be a

1095
00:49:15,760 --> 00:49:20,640
bad one or to be a bad one okay you two

1096
00:49:18,680 --> 00:49:22,760
things first you're saying who chooses

1097
00:49:20,640 --> 00:49:25,200
this hash key of the F how do we know

1098
00:49:22,760 --> 00:49:28,160
that we trusted but you know it's much

1099
00:49:25,200 --> 00:49:29,480
worse than that is it secure let's say

1100
00:49:28,160 --> 00:49:30,280
let's say it's chosen randomly from the

1101
00:49:29,480 --> 00:49:32,760
hash

1102
00:49:30,280 --> 00:49:36,760
family is this

1103
00:49:32,760 --> 00:49:39,559
sound it's so again what did we do here

1104
00:49:36,760 --> 00:49:41,720
we started with an interactive protocol

1105
00:49:39,559 --> 00:49:43,559
we proved it sound let's say k m sound

1106
00:49:41,720 --> 00:49:45,640
we proved it ass we have Collision in

1107
00:49:43,559 --> 00:49:49,480
hash we prove that it

1108
00:49:45,640 --> 00:49:51,280
sound it sound assuming the prover gets

1109
00:49:49,480 --> 00:49:54,200
the ver the messages of the verify

1110
00:49:51,280 --> 00:49:56,920
randomly that's one 20 it sounds that's

1111
00:49:54,200 --> 00:49:58,559
we used it to Pro Sound is

1112
00:49:56,920 --> 00:50:01,240
now what am I saying what are we doing

1113
00:49:58,559 --> 00:50:03,520
now I'm saying oh forget about it it's

1114
00:50:01,240 --> 00:50:04,240
not random actually you comput it on

1115
00:50:03,520 --> 00:50:08,559
your

1116
00:50:04,240 --> 00:50:11,079
own from some hash key that someone

1117
00:50:08,559 --> 00:50:13,319
chooses even honestly from let's say we

1118
00:50:11,079 --> 00:50:15,160
agree we all agreed on some hash family

1119
00:50:13,319 --> 00:50:17,240
and someone honestly chose a hash key

1120
00:50:15,160 --> 00:50:19,720
but now you know this hash key now you

1121
00:50:17,240 --> 00:50:22,799
compute who says it sound I mean is it

1122
00:50:19,720 --> 00:50:22,799
still sound maybe it's not

1123
00:50:24,559 --> 00:50:30,400
sound okay so

1124
00:50:27,319 --> 00:50:32,440
first of all okay so first of all of

1125
00:50:30,400 --> 00:50:35,240
course there's one can think

1126
00:50:32,440 --> 00:50:37,559
of this hash this hash functions need to

1127
00:50:35,240 --> 00:50:39,920
have some property okay Collision

1128
00:50:37,559 --> 00:50:41,440
resistance like at the minimum if if you

1129
00:50:39,920 --> 00:50:44,599
can find collisions for example here

1130
00:50:41,440 --> 00:50:46,079
you're screwed it can be it can be ID it

1131
00:50:44,599 --> 00:50:48,359
can be trivial okay so you need some

1132
00:50:46,079 --> 00:50:51,280
property now the question is what

1133
00:50:48,359 --> 00:50:54,640
property do you need what property do

1134
00:50:51,280 --> 00:50:58,359
you need from this hash family to argue

1135
00:50:54,640 --> 00:50:58,359
soundness yeah

1136
00:51:01,760 --> 00:51:04,480
very very okay good so it seems like

1137
00:51:03,480 --> 00:51:07,079
well what do you need it need to be

1138
00:51:04,480 --> 00:51:09,319
random like in the protocol like okay we

1139
00:51:07,079 --> 00:51:11,480
we want to say take any what is our goal

1140
00:51:09,319 --> 00:51:15,079
our goal is to say take any

1141
00:51:11,480 --> 00:51:18,280
protocol that is sound public coin and

1142
00:51:15,079 --> 00:51:20,160
we want to convert it to non-interactive

1143
00:51:18,280 --> 00:51:22,440
that's what we're trying to do now I'm

1144
00:51:20,160 --> 00:51:25,040
saying what property do you need well

1145
00:51:22,440 --> 00:51:27,520
look here the our guarantee was that it

1146
00:51:25,040 --> 00:51:29,440
sound if this was random so need this

1147
00:51:27,520 --> 00:51:34,319
has to be somehow

1148
00:51:29,440 --> 00:51:36,200
random stand for reason so this is okay

1149
00:51:34,319 --> 00:51:38,240
but look hash functions are not random

1150
00:51:36,200 --> 00:51:41,359
it's a hash function by the way let me

1151
00:51:38,240 --> 00:51:43,920
say this Paradigm is used all over the

1152
00:51:41,359 --> 00:51:46,680
place it's a very popular Paradigm it's

1153
00:51:43,920 --> 00:51:50,880
used a lot in in signature schemes and

1154
00:51:46,680 --> 00:51:53,359
also in in uh um proof systems it's used

1155
00:51:50,880 --> 00:51:55,640
all over the place and which hash

1156
00:51:53,359 --> 00:51:58,799
function is used some of the Shelf hash

1157
00:51:55,640 --> 00:52:01,240
function sh 250 six like

1158
00:51:58,799 --> 00:52:02,599
these engineered type you know hash

1159
00:52:01,240 --> 00:52:06,480
function that are

1160
00:52:02,599 --> 00:52:10,359
optimized so is it secure with shot

1161
00:52:06,480 --> 00:52:14,319
256 it's definitely not random

1162
00:52:10,359 --> 00:52:17,200
it's so we actually don't know that so

1163
00:52:14,319 --> 00:52:19,440
let me be honest that is it

1164
00:52:17,200 --> 00:52:22,440
secure I don't

1165
00:52:19,440 --> 00:52:22,440
know

1166
00:52:23,720 --> 00:52:27,720
yeah extension

1167
00:52:29,839 --> 00:52:35,280
yeah right yeah you right right right

1168
00:52:33,119 --> 00:52:38,200
right right so actually let me good so

1169
00:52:35,280 --> 00:52:38,200
let me just say a few

1170
00:52:38,880 --> 00:52:42,799
things okay maybe I'll cut to just to

1171
00:52:41,440 --> 00:52:45,720
the

1172
00:52:42,799 --> 00:52:47,400
chase I do know let me tell you it's not

1173
00:52:45,720 --> 00:52:50,200
necessarily secure actually

1174
00:52:47,400 --> 00:52:51,960
unfortunately we have counter examples

1175
00:52:50,200 --> 00:52:54,760
so I said this is used in practice all

1176
00:52:51,960 --> 00:52:57,160
the time you know it's uh one of the

1177
00:52:54,760 --> 00:52:58,839
great inventions of cryptography is it

1178
00:52:57,160 --> 00:53:02,359
secure

1179
00:52:58,839 --> 00:53:06,799
no okay so what do I mean by no okay let

1180
00:53:02,359 --> 00:53:09,119
me is it always secure no so yeah let me

1181
00:53:06,799 --> 00:53:11,240
say let me take back my know thing is it

1182
00:53:09,119 --> 00:53:12,520
always secure is it always the case that

1183
00:53:11,240 --> 00:53:15,400
when you start with an

1184
00:53:12,520 --> 00:53:17,880
interactive protocol and convert public

1185
00:53:15,400 --> 00:53:21,680
coin and you apply is it always secure

1186
00:53:17,880 --> 00:53:24,440
no moreover let me tell you we have

1187
00:53:21,680 --> 00:53:28,680
protocols so that no matter which has

1188
00:53:24,440 --> 00:53:30,760
family you use for for all half families

1189
00:53:28,680 --> 00:53:32,839
the protocol becomes

1190
00:53:30,760 --> 00:53:34,799
insecure hey let me tell you even more

1191
00:53:32,839 --> 00:53:36,040
than that that will kind of really

1192
00:53:34,799 --> 00:53:39,520
you'll be

1193
00:53:36,040 --> 00:53:42,839
mad you know the K mikali

1194
00:53:39,520 --> 00:53:46,599
protocol that we kind of built

1195
00:53:42,839 --> 00:53:50,040
up even that's not secure the the F

1196
00:53:46,599 --> 00:53:51,920
won't be secure on it but this let me

1197
00:53:50,040 --> 00:53:54,720
actually put an Asters

1198
00:53:51,920 --> 00:53:55,880
there it's what okay so let me let me

1199
00:53:54,720 --> 00:53:57,000
tell you what's known about the

1200
00:53:55,880 --> 00:53:59,720
insecurity

1201
00:53:57,000 --> 00:54:03,040
of the F Paradigm for this protocol what

1202
00:53:59,720 --> 00:54:06,640
is known is there are some contrived so

1203
00:54:03,040 --> 00:54:10,240
the F the KE mikali protocol says take

1204
00:54:06,640 --> 00:54:14,680
any hash function that's Collision

1205
00:54:10,240 --> 00:54:17,400
resistance and uh and take any

1206
00:54:14,680 --> 00:54:21,440
PCP we get

1207
00:54:17,400 --> 00:54:25,480
tness there are examples of specific

1208
00:54:21,440 --> 00:54:27,119
hash functions or specific pcps that are

1209
00:54:25,480 --> 00:54:28,760
sound of course because it's so I mean

1210
00:54:27,119 --> 00:54:31,960
there are example of collision resistant

1211
00:54:28,760 --> 00:54:33,319
hash functions and pcps such that this

1212
00:54:31,960 --> 00:54:36,079
of course it sound it sounds for any

1213
00:54:33,319 --> 00:54:38,799
Collision hash function PCP but such

1214
00:54:36,079 --> 00:54:42,760
that no matter which hash function you

1215
00:54:38,799 --> 00:54:43,760
use for the phia this will be insecure

1216
00:54:42,760 --> 00:54:47,400
not

1217
00:54:43,760 --> 00:54:47,400
sound no matter what you

1218
00:54:49,880 --> 00:54:55,640
use

1219
00:54:52,799 --> 00:54:57,280
yeah what break yeah I I'll say a little

1220
00:54:55,640 --> 00:55:00,720
bit what break

1221
00:54:57,280 --> 00:55:04,040
in a second yeah example or okay good

1222
00:55:00,720 --> 00:55:07,520
good good same question so the example

1223
00:55:04,040 --> 00:55:09,280
for why it so why it breaks the example

1224
00:55:07,520 --> 00:55:12,880
for why it break is very contrived

1225
00:55:09,280 --> 00:55:16,400
actually so that's why am is the message

1226
00:55:12,880 --> 00:55:18,240
here don't use f CH we have a break no

1227
00:55:16,400 --> 00:55:19,680
that's not the message you should use f

1228
00:55:18,240 --> 00:55:22,039
because in practice it works very well I

1229
00:55:19,680 --> 00:55:25,319
don't have a single instance that people

1230
00:55:22,039 --> 00:55:27,240
used F practice and it broke so it's a

1231
00:55:25,319 --> 00:55:29,960
great paradigm use

1232
00:55:27,240 --> 00:55:32,960
it can we come up with a general proof

1233
00:55:29,960 --> 00:55:37,160
of security no because we have counter

1234
00:55:32,960 --> 00:55:39,720
examples so what did we learn okay so

1235
00:55:37,160 --> 00:55:43,319
maybe I'll start by saying I'll say very

1236
00:55:39,720 --> 00:55:45,640
very high level not in detail but about

1237
00:55:43,319 --> 00:55:47,920
the counter examples okay how can we

1238
00:55:45,640 --> 00:55:49,559
build counter examples and as opposed to

1239
00:55:47,920 --> 00:55:50,920
going to the K mikali protocol because

1240
00:55:49,559 --> 00:55:53,200
there you need to work a little harder

1241
00:55:50,920 --> 00:55:55,559
to fit it in uh I'll say a word how you

1242
00:55:53,200 --> 00:55:59,559
fit it in there too but the idea is the

1243
00:55:55,559 --> 00:56:01,920
foll let me try to give you a a proof

1244
00:55:59,559 --> 00:56:06,440
that is or an interactive protocol that

1245
00:56:01,920 --> 00:56:08,760
is sound but when you convert it to uh

1246
00:56:06,440 --> 00:56:13,039
when you apply F soundness

1247
00:56:08,760 --> 00:56:15,160
breaks so the idea is the following it's

1248
00:56:13,039 --> 00:56:18,160
going to be a very contrived protocol

1249
00:56:15,160 --> 00:56:21,839
okay so my what I want to do is

1250
00:56:18,160 --> 00:56:21,839
construct a contrived

1251
00:56:23,720 --> 00:56:28,720
protocol that is sound

1252
00:56:26,599 --> 00:56:31,240
but when you apply F no matter which

1253
00:56:28,720 --> 00:56:34,319
hash function you use it will

1254
00:56:31,240 --> 00:56:36,559
break and intuitively the contri

1255
00:56:34,319 --> 00:56:39,680
protocol is the following take any sound

1256
00:56:36,559 --> 00:56:42,280
protocol for example f for example kilan

1257
00:56:39,680 --> 00:56:44,400
mikali whatever or gkr whatever sound

1258
00:56:42,280 --> 00:56:45,839
protocol you like and I'm going to

1259
00:56:44,400 --> 00:56:48,559
change it I'm going to tweak a little

1260
00:56:45,839 --> 00:56:51,400
bit that the sound will still remain I'm

1261
00:56:48,559 --> 00:56:53,160
I'm going to tweak it so that I the

1262
00:56:51,400 --> 00:56:55,680
soundness will still

1263
00:56:53,160 --> 00:56:57,680
hold but on the twick protocol when you

1264
00:56:55,680 --> 00:57:00,760
apply for will

1265
00:56:57,680 --> 00:57:04,280
fail okay so start with PV for example

1266
00:57:00,760 --> 00:57:06,680
gkr for example k m whatever you like

1267
00:57:04,280 --> 00:57:09,319
and I'm gonna kind of tweak it a little

1268
00:57:06,680 --> 00:57:11,920
bit how am I going to tweak it I'm gonna

1269
00:57:09,319 --> 00:57:15,640
say tell the tell the verifier you know

1270
00:57:11,920 --> 00:57:17,200
what accept if you accept it before but

1271
00:57:15,640 --> 00:57:19,920
accept also if something very weird

1272
00:57:17,200 --> 00:57:22,079
happens but don't worry it will never

1273
00:57:19,920 --> 00:57:24,240
happen Okay when else are we going to

1274
00:57:22,079 --> 00:57:28,160
accept so remember the verifier let's

1275
00:57:24,240 --> 00:57:28,160
say he sends kind of a random beta

1276
00:57:28,240 --> 00:57:34,400
if the prover let's say ahead of time

1277
00:57:32,440 --> 00:57:36,720
guessed your beta he told you I know how

1278
00:57:34,400 --> 00:57:40,880
you're going Compu your beta so if the

1279
00:57:36,720 --> 00:57:43,480
pro ahead of time sent you kind of um

1280
00:57:40,880 --> 00:57:48,119
sent you a message that will kind of

1281
00:57:43,480 --> 00:57:50,640
tell say kind of I can

1282
00:57:48,119 --> 00:57:53,720
predict beta and kind of will predict

1283
00:57:50,640 --> 00:57:55,440
bet ahead of time then you accept him

1284
00:57:53,720 --> 00:57:56,880
this is random what's the property that

1285
00:57:55,440 --> 00:57:59,079
you can prct my bet

1286
00:57:56,880 --> 00:58:01,880
if beta is like random and 0 one to the

1287
00:57:59,079 --> 00:58:03,559
Lambda there's no way you can predict it

1288
00:58:01,880 --> 00:58:05,119
so if by any chance you predict I'm

1289
00:58:03,559 --> 00:58:07,240
going to you know you can won the

1290
00:58:05,119 --> 00:58:08,440
lottery I'll accept you no matter I

1291
00:58:07,240 --> 00:58:10,799
don't care if that's in the language or

1292
00:58:08,440 --> 00:58:13,480
not it only adds like a negligable

1293
00:58:10,799 --> 00:58:15,400
probability of you know because the

1294
00:58:13,480 --> 00:58:18,160
probability that you can predict beta is

1295
00:58:15,400 --> 00:58:18,160
one over two to the

1296
00:58:19,799 --> 00:58:25,880
beta now what happens in the F meal

1297
00:58:23,160 --> 00:58:27,280
Paradigm oh I can tell you oh I know bet

1298
00:58:25,880 --> 00:58:29,200
I'm I can predict it I'm going to tell

1299
00:58:27,280 --> 00:58:34,839
you exactly how I predict it beta is

1300
00:58:29,200 --> 00:58:34,839
going to be eval hash key and this

1301
00:58:36,599 --> 00:58:43,599
message that's the idea now to implement

1302
00:58:40,400 --> 00:58:45,480
this idea it's harder it requires some

1303
00:58:43,599 --> 00:58:46,799
work I'll tell you why this idea is not

1304
00:58:45,480 --> 00:58:48,680
trivially

1305
00:58:46,799 --> 00:58:52,920
implemented

1306
00:58:48,680 --> 00:58:55,839
because when we do F we say we

1307
00:58:52,920 --> 00:58:58,720
start with a protocol and now the

1308
00:58:55,839 --> 00:59:01,720
question question is does there exist a

1309
00:58:58,720 --> 00:59:05,240
hash a f has family for which it's

1310
00:59:01,720 --> 00:59:08,400
secure now we start with a protocol this

1311
00:59:05,240 --> 00:59:09,960
protocol can say can say Okay Alpha is

1312
00:59:08,400 --> 00:59:13,640
Hash key for

1313
00:59:09,960 --> 00:59:19,000
example and then you accept if you

1314
00:59:13,640 --> 00:59:22,720
originally accepted or if eval of hash

1315
00:59:19,000 --> 00:59:24,680
key of alpha which is also hash key is

1316
00:59:22,720 --> 00:59:26,920
equal to Beta now this will not happen

1317
00:59:24,680 --> 00:59:28,520
but in the future me it will happen

1318
00:59:26,920 --> 00:59:29,559
I'm going to just send the F in haski

1319
00:59:28,520 --> 00:59:33,200
that's what I

1320
00:59:29,559 --> 00:59:35,119
do okay but then someone will say okay

1321
00:59:33,200 --> 00:59:38,400
so you give me a protocol what is the

1322
00:59:35,119 --> 00:59:40,880
length of your Alpha it's Lambda bits

1323
00:59:38,400 --> 00:59:42,760
I'm going to use a hash function that

1324
00:59:40,880 --> 00:59:44,960
the hash key is longer and now you can't

1325
00:59:42,760 --> 00:59:46,760
send it because here I'm like I'll send

1326
00:59:44,960 --> 00:59:49,400
the hash

1327
00:59:46,760 --> 00:59:51,680
key so then you need to use a hash to

1328
00:59:49,400 --> 00:59:52,480
kind of Squish this hash key it it's

1329
00:59:51,680 --> 00:59:57,400
more

1330
00:59:52,480 --> 01:00:01,400
complicated but the the basic idea

1331
00:59:57,400 --> 01:00:03,799
is this does not work if somehow the

1332
01:00:01,400 --> 01:00:06,119
verifier accepts you if you kind of

1333
01:00:03,799 --> 01:00:09,599
convinced him that you can kind of

1334
01:00:06,119 --> 01:00:12,760
predict his his beta that's really

1335
01:00:09,599 --> 01:00:17,280
and so we can construct kind of

1336
01:00:12,760 --> 01:00:20,000
contrived um protocols that achieve this

1337
01:00:17,280 --> 01:00:22,440
or we can cont construct very contrived

1338
01:00:20,000 --> 01:00:24,200
hash function that do this weird game

1339
01:00:22,440 --> 01:00:25,720
inside the hash function like the hash

1340
01:00:24,200 --> 01:00:29,280
function becomes trivial if you feed it

1341
01:00:25,720 --> 01:00:31,640
something that kind of so so it requires

1342
01:00:29,280 --> 01:00:34,000
more work but it's all very

1343
01:00:31,640 --> 01:00:35,960
contrived okay so I hope I convinced you

1344
01:00:34,000 --> 01:00:38,839
by with these examples the counter

1345
01:00:35,960 --> 01:00:41,039
examples are so contrived so when you

1346
01:00:38,839 --> 01:00:43,000
when you say oh we found the p is not

1347
01:00:41,039 --> 01:00:46,079
secure and you show these example the

1348
01:00:43,000 --> 01:00:47,640
reaction should be come on okay nobody

1349
01:00:46,079 --> 01:00:50,440
uses these

1350
01:00:47,640 --> 01:00:52,960
protocols but what it does tell us you

1351
01:00:50,440 --> 01:00:55,640
can't apply F blind you can't okay what

1352
01:00:52,960 --> 01:00:58,559
it does tell us is for all of us who are

1353
01:00:55,640 --> 01:01:01,079
upset with trying to prove the Paradigm

1354
01:00:58,559 --> 01:01:03,880
there's no General proof because we have

1355
01:01:01,079 --> 01:01:07,799
counter examples at least

1356
01:01:03,880 --> 01:01:07,799
that question you need to

1357
01:01:08,760 --> 01:01:15,319
start great great question okay I that's

1358
01:01:12,039 --> 01:01:17,960
my next so I I'll I'll uh

1359
01:01:15,319 --> 01:01:20,640
yeah I'll the answer is yes but I'll

1360
01:01:17,960 --> 01:01:22,280
I'll I'll talk about that next the

1361
01:01:20,640 --> 01:01:25,960
question was about negligible soundness

1362
01:01:22,280 --> 01:01:28,319
but we'll get to that next so any

1363
01:01:25,960 --> 01:01:32,039
question though

1364
01:01:28,319 --> 01:01:34,520
before okay so but you know still people

1365
01:01:32,039 --> 01:01:35,799
use the F Paradigm and there's a

1366
01:01:34,520 --> 01:01:39,119
question

1367
01:01:35,799 --> 01:01:40,240
of is it sound for natural protocols is

1368
01:01:39,119 --> 01:01:43,160
it

1369
01:01:40,240 --> 01:01:44,799
sound and the answer is actually it

1370
01:01:43,160 --> 01:01:47,359
would have been nice if we can come up

1371
01:01:44,799 --> 01:01:49,720
with Pro nice protocols and say at least

1372
01:01:47,359 --> 01:01:51,359
a large class of protocols and say yeah

1373
01:01:49,720 --> 01:01:53,240
if you use this hash function this

1374
01:01:51,359 --> 01:01:55,039
specific hash function which we know is

1375
01:01:53,240 --> 01:01:56,440
Collision resistant under discret log or

1376
01:01:55,039 --> 01:01:58,039
under some other

1377
01:01:56,440 --> 01:02:00,240
then your scheme is sound that would be

1378
01:01:58,039 --> 01:02:00,240
very

1379
01:02:00,559 --> 01:02:05,279
nice we're still not there yet but we

1380
01:02:03,680 --> 01:02:06,359
made a lot of progress in recent years

1381
01:02:05,279 --> 01:02:09,760
and I want to tell you about the

1382
01:02:06,359 --> 01:02:13,400
progress but before that the first way

1383
01:02:09,760 --> 01:02:13,400
the first a

1384
01:02:13,480 --> 01:02:20,440
a uh kind of way we try to analyze so

1385
01:02:17,279 --> 01:02:23,000
the F gained popularity very quickly

1386
01:02:20,440 --> 01:02:25,400
okay uh and because it's so simple and

1387
01:02:23,000 --> 01:02:26,680
so efficient uh it became very very

1388
01:02:25,400 --> 01:02:28,880
popular

1389
01:02:26,680 --> 01:02:31,920
and people really wanted to understand

1390
01:02:28,880 --> 01:02:34,119
its uh security is it sound is it not

1391
01:02:31,920 --> 01:02:38,319
sound and then in

1392
01:02:34,119 --> 01:02:42,359
93 Bela and rway introduced kind of an

1393
01:02:38,319 --> 01:02:42,359
ideal model called the random Oracle

1394
01:02:54,359 --> 01:03:00,400
model and this model said you know

1395
01:02:57,960 --> 01:03:03,240
what by the way this was before we had

1396
01:03:00,400 --> 01:03:07,920
any counter examples okay this model was

1397
01:03:03,240 --> 01:03:10,720
introduced by Bel and rway in I believe

1398
01:03:07,920 --> 01:03:13,119
80 uh

1399
01:03:10,720 --> 01:03:17,240
93 this was before we knew any counter

1400
01:03:13,119 --> 01:03:19,920
examples for the Paradigm and they I

1401
01:03:17,240 --> 01:03:21,920
mean except for some which goes through

1402
01:03:19,920 --> 01:03:24,480
your question Leo but I'm going to get

1403
01:03:21,920 --> 01:03:28,799
to it and they wanted to ask can we

1404
01:03:24,480 --> 01:03:31,400
prove security of of

1405
01:03:28,799 --> 01:03:32,960
the uh what do we need about the hash

1406
01:03:31,400 --> 01:03:34,240
function what properties do we need

1407
01:03:32,960 --> 01:03:36,160
about the hash function to prove

1408
01:03:34,240 --> 01:03:38,039
security and the first property they

1409
01:03:36,160 --> 01:03:40,480
said you know what what if the hash

1410
01:03:38,039 --> 01:03:43,480
function was completely

1411
01:03:40,480 --> 01:03:44,720
random so when you use we use a specific

1412
01:03:43,480 --> 01:03:47,039
there's a circuit that computes the hash

1413
01:03:44,720 --> 01:03:48,480
function it's like a touring machine a

1414
01:03:47,039 --> 01:03:50,319
polinomial Time touring machine or a

1415
01:03:48,480 --> 01:03:52,319
polinomial size circuit takes a hash key

1416
01:03:50,319 --> 01:03:54,440
and okay they say you know what what if

1417
01:03:52,319 --> 01:03:59,520
the hash function is completely

1418
01:03:54,440 --> 01:03:59,520
random Okay so the r welome model says

1419
01:04:00,319 --> 01:04:06,599
suppose we

1420
01:04:02,799 --> 01:04:06,599
apply Fe to

1421
01:04:08,720 --> 01:04:13,240
Paradigm with

1422
01:04:11,039 --> 01:04:15,559
truly

1423
01:04:13,240 --> 01:04:18,119
random function

1424
01:04:15,559 --> 01:04:19,799
H so this is completely completely

1425
01:04:18,119 --> 01:04:23,880
random so what do I mean by completely

1426
01:04:19,799 --> 01:04:23,880
random so now I

1427
01:04:24,319 --> 01:04:27,680
guess let me

1428
01:04:26,359 --> 01:04:33,279
instead of

1429
01:04:27,680 --> 01:04:36,480
choosing a function from a

1430
01:04:33,279 --> 01:04:38,520
family we don't choose a function and we

1431
01:04:36,480 --> 01:04:41,440
just say suppose they have a truly

1432
01:04:38,520 --> 01:04:44,920
random they have access to both of them

1433
01:04:41,440 --> 01:04:48,799
to a truly truly random function and

1434
01:04:44,920 --> 01:04:51,240
they can ask so when the prover computes

1435
01:04:48,799 --> 01:04:53,520
Alpha he asks he has Oracle this

1436
01:04:51,240 --> 01:04:57,559
function and he tells the function give

1437
01:04:53,520 --> 01:05:00,119
me the function apply 2 x and Alpha and

1438
01:04:57,559 --> 01:05:03,319
he gets back a beta and every time this

1439
01:05:00,119 --> 01:05:05,480
hash this Oracle he gets a query he

1440
01:05:03,319 --> 01:05:08,880
chooses a completely random so think of

1441
01:05:05,480 --> 01:05:10,720
this as like a database of all like size

1442
01:05:08,880 --> 01:05:13,160
two to the Lambda of all like just

1443
01:05:10,720 --> 01:05:15,359
random random random elements a really

1444
01:05:13,160 --> 01:05:18,559
really truly random

1445
01:05:15,359 --> 01:05:20,640
function so now the question was okay if

1446
01:05:18,559 --> 01:05:23,200
this is truly random now can we get

1447
01:05:20,640 --> 01:05:26,160
security at least like that's the

1448
01:05:23,200 --> 01:05:27,920
minimum and moreover it seem like the

1449
01:05:26,160 --> 01:05:30,640
answer should be yes because in some

1450
01:05:27,920 --> 01:05:33,039
sense what was their what was their

1451
01:05:30,640 --> 01:05:35,720
intuition the intuition is what does it

1452
01:05:33,039 --> 01:05:38,760
matter if you're talking to a verifier

1453
01:05:35,720 --> 01:05:41,359
that gives you random queries or you're

1454
01:05:38,760 --> 01:05:43,359
talking to in terms of the prover so the

1455
01:05:41,359 --> 01:05:44,839
prover is trying to cheat what does it

1456
01:05:43,359 --> 01:05:47,680
matter if he's talking to a verifier

1457
01:05:44,839 --> 01:05:50,000
that give him kind of random vas or he's

1458
01:05:47,680 --> 01:05:52,279
talking to a random function that gives

1459
01:05:50,000 --> 01:05:53,480
them random betas both of them do random

1460
01:05:52,279 --> 01:05:56,240
betas what's the

1461
01:05:53,480 --> 01:05:58,599
difference so it should at least be

1462
01:05:56,240 --> 01:06:01,000
secure in the random Oracle model let's

1463
01:05:58,599 --> 01:06:03,240
first establish

1464
01:06:01,000 --> 01:06:06,240
that so is it secure in the random

1465
01:06:03,240 --> 01:06:09,039
Oracle model

1466
01:06:06,240 --> 01:06:11,000
no and this goes to Leo's

1467
01:06:09,039 --> 01:06:13,119
question and I'm going to tell you why

1468
01:06:11,000 --> 01:06:16,599
it's not secured the random oracal model

1469
01:06:13,119 --> 01:06:21,440
and actually let me take a little

1470
01:06:16,599 --> 01:06:23,000
detour and uh tell you I'll I'll show

1471
01:06:21,440 --> 01:06:26,279
why it's not secure in the random oracal

1472
01:06:23,000 --> 01:06:27,880
model via a little protocol

1473
01:06:26,279 --> 01:06:30,559
this protocol actually is going to be

1474
01:06:27,880 --> 01:06:32,920
useful because actually later we will

1475
01:06:30,559 --> 01:06:36,000
show that the f is sound for this

1476
01:06:32,920 --> 01:06:37,520
protocol it's kind of weird but let's

1477
01:06:36,000 --> 01:06:38,720
this protocol by the way is very

1478
01:06:37,520 --> 01:06:42,960
important

1479
01:06:38,720 --> 01:06:45,400
protocol so so let me quickly do let me

1480
01:06:42,960 --> 01:06:47,279
do a little detour I think it's a really

1481
01:06:45,400 --> 01:06:50,359
interesting detour so I hope you enjoy

1482
01:06:47,279 --> 01:06:51,359
it um it takes us a little bit into the

1483
01:06:50,359 --> 01:06:56,039
land of

1484
01:06:51,359 --> 01:06:56,039
cryptography but not too bad

1485
01:06:56,440 --> 01:07:01,920
a little further than we went so far so

1486
01:06:58,599 --> 01:07:05,799
far we just talked about hash

1487
01:07:01,920 --> 01:07:05,799
functions okay

1488
01:07:06,079 --> 01:07:12,400
so what I'm going to say now is going to

1489
01:07:08,200 --> 01:07:16,640
be a little bit of a high level

1490
01:07:12,400 --> 01:07:19,760
a so a protocol that I want

1491
01:07:16,640 --> 01:07:23,119
to talk about is actually a zero

1492
01:07:19,760 --> 01:07:24,359
knowledge protocol so you know so far we

1493
01:07:23,119 --> 01:07:27,119
just talked about verification

1494
01:07:24,359 --> 01:07:30,039
verification you know synness and

1495
01:07:27,119 --> 01:07:31,440
efficiency but uh as I mentioned

1496
01:07:30,039 --> 01:07:33,319
interactive protocols were actually

1497
01:07:31,440 --> 01:07:36,520
invented for the sake of zero

1498
01:07:33,319 --> 01:07:39,559
knowledge so what was the goal the goal

1499
01:07:36,520 --> 01:07:43,119
was forget about sness now it was not at

1500
01:07:39,559 --> 01:07:45,760
all about sness all we wanted is a

1501
01:07:43,119 --> 01:07:48,359
prover that has let's say a witness for

1502
01:07:45,760 --> 01:07:50,160
some there's some there's some language

1503
01:07:48,359 --> 01:07:52,319
and let's say the language we're going

1504
01:07:50,160 --> 01:07:55,039
to be interested for today just as an

1505
01:07:52,319 --> 01:07:57,440
example is the language of hamiltonian

1506
01:07:55,039 --> 01:07:57,440
cycle

1507
01:07:58,720 --> 01:08:02,839
that's just an example so this language

1508
01:08:01,400 --> 01:08:05,319
consists of

1509
01:08:02,839 --> 01:08:07,559
graphs so this is the language that

1510
01:08:05,319 --> 01:08:10,000
consists of all graphs graph is just

1511
01:08:07,559 --> 01:08:13,119
consists of nodes and

1512
01:08:10,000 --> 01:08:16,480
edges such that this graph has a

1513
01:08:13,119 --> 01:08:18,759
hamiltonian cycle so that g

1514
01:08:16,480 --> 01:08:21,600
has

1515
01:08:18,759 --> 01:08:24,640
a

1516
01:08:21,600 --> 01:08:27,440
hamiltonian cycle what this means is

1517
01:08:24,640 --> 01:08:27,440
just

1518
01:08:28,799 --> 01:08:35,279
you can just there's a kind of a a cycle

1519
01:08:32,880 --> 01:08:36,640
of all the nodes so it means that

1520
01:08:35,279 --> 01:08:39,359
there's a cycle of all the nodes so

1521
01:08:36,640 --> 01:08:44,719
let's say you start with node i1

1522
01:08:39,359 --> 01:08:47,239
I2 up to i n and then go up to I in said

1523
01:08:44,719 --> 01:08:49,839
that there's an edge here Edge Edge Edge

1524
01:08:47,239 --> 01:08:52,120
Edge Edge an edge all the way back

1525
01:08:49,839 --> 01:08:57,080
that's that means it if if you can if

1526
01:08:52,120 --> 01:08:59,640
there's some such um uh uh a setting of

1527
01:08:57,080 --> 01:09:01,400
The nodes for which you can kind of set

1528
01:08:59,640 --> 01:09:03,239
them in a way that there's edges that

1529
01:09:01,400 --> 01:09:06,319
kind of complete a cycle then we say the

1530
01:09:03,239 --> 01:09:10,359
graph has the hamiltonian cycle okay

1531
01:09:06,319 --> 01:09:12,279
this language is NP complete okay now so

1532
01:09:10,359 --> 01:09:14,640
now going back what is a zero knowledge

1533
01:09:12,279 --> 01:09:17,920
proof a zero knowledge proof is a way I

1534
01:09:14,640 --> 01:09:20,960
want to convince you that a graph G has

1535
01:09:17,920 --> 01:09:23,040
aonian cycle now I can give you the

1536
01:09:20,960 --> 01:09:25,520
cycle I can give you see here's the node

1537
01:09:23,040 --> 01:09:27,480
you can look there's a cycle there but I

1538
01:09:25,520 --> 01:09:29,839
don't want to give you any information I

1539
01:09:27,480 --> 01:09:31,880
don't want you to learn anything I don't

1540
01:09:29,839 --> 01:09:33,640
want you to to find the cycle I don't

1541
01:09:31,880 --> 01:09:34,960
want to reveal any information but I

1542
01:09:33,640 --> 01:09:37,560
want to convince you that it has a

1543
01:09:34,960 --> 01:09:37,560
hamiltonian

1544
01:09:38,319 --> 01:09:44,960
cycle how do I do that so this kind of

1545
01:09:42,199 --> 01:09:48,920
so there's a a celebrated result it

1546
01:09:44,960 --> 01:09:51,279
started with gasali and ROV in mid 80s

1547
01:09:48,920 --> 01:09:53,359
and uh where they defined this notion of

1548
01:09:51,279 --> 01:09:56,480
zero knowledge uh and constructed some

1549
01:09:53,359 --> 01:10:02,040
protocols but later very shortly later

1550
01:09:56,480 --> 01:10:05,040
uh uh by gold gold mikali and vigone

1551
01:10:02,040 --> 01:10:06,400
showed that actually any NP language has

1552
01:10:05,040 --> 01:10:09,520
a zero knowledge

1553
01:10:06,400 --> 01:10:12,199
proof okay let me give you one specific

1554
01:10:09,520 --> 01:10:16,199
zero knowledge proof for the aonian uh

1555
01:10:12,199 --> 01:10:18,239
cycle language uh and this is Du to blam

1556
01:10:16,199 --> 01:10:20,600
okay so I'll show you the the proof it's

1557
01:10:18,239 --> 01:10:23,199
very very nice okay and it's going to be

1558
01:10:20,600 --> 01:10:24,960
useful for us uh to show NE to show why

1559
01:10:23,199 --> 01:10:27,560
the random oral model fails and then

1560
01:10:24,960 --> 01:10:29,719
also to show the security of the F so

1561
01:10:27,560 --> 01:10:33,440
this is actually we'll get back to this

1562
01:10:29,719 --> 01:10:34,920
protocol okay so what is this protocol

1563
01:10:33,440 --> 01:10:39,000
there's a prover in a

1564
01:10:34,920 --> 01:10:42,120
verifier the idea is the following the

1565
01:10:39,000 --> 01:10:43,840
prover will he knows he will first he

1566
01:10:42,120 --> 01:10:47,520
has a

1567
01:10:43,840 --> 01:10:49,760
g the first thing he's going to permute

1568
01:10:47,520 --> 01:10:50,840
completely permute that the nodes okay

1569
01:10:49,760 --> 01:10:54,640
so he's going to choose a random

1570
01:10:50,840 --> 01:10:55,920
permutation Pi let's say n is the number

1571
01:10:54,640 --> 01:10:59,480
denoted by

1572
01:10:55,920 --> 01:11:03,280
n the number of vertices in G he's going

1573
01:10:59,480 --> 01:11:03,280
to to choose a a random

1574
01:11:03,480 --> 01:11:07,800
permutation of the

1575
01:11:05,360 --> 01:11:10,000
nodes now he has kind of the permuted

1576
01:11:07,800 --> 01:11:11,960
graph in his head so he has pi of G in

1577
01:11:10,000 --> 01:11:15,040
his

1578
01:11:11,960 --> 01:11:17,280
head now this it has this P of G has a

1579
01:11:15,040 --> 01:11:20,920
hamiltonian cycle because G has and I

1580
01:11:17,280 --> 01:11:23,320
just renamed the nodes now I'm going to

1581
01:11:20,920 --> 01:11:25,040
I want to give you I want to give you

1582
01:11:23,320 --> 01:11:26,880
just this hamiltonian cycle so I want to

1583
01:11:25,040 --> 01:11:29,840
give you the nodes here that form

1584
01:11:26,880 --> 01:11:31,920
Hamilton so I want to give you H I would

1585
01:11:29,840 --> 01:11:35,159
like to give you the nodes that form the

1586
01:11:31,920 --> 01:11:36,920
ham just the hamiltonian cycle but I

1587
01:11:35,159 --> 01:11:39,000
can't give you that will reveal

1588
01:11:36,920 --> 01:11:42,920
information okay so I don't want to do

1589
01:11:39,000 --> 01:11:46,040
that instead I'm going to give it to you

1590
01:11:42,920 --> 01:11:47,440
kind of in a safe okay hidden this is

1591
01:11:46,040 --> 01:11:49,520
what called in cryptography call this

1592
01:11:47,440 --> 01:11:50,960
commitment scheme so I'm going to give

1593
01:11:49,520 --> 01:11:56,239
you a

1594
01:11:50,960 --> 01:11:58,800
commitment of the cycle C

1595
01:11:56,239 --> 01:12:02,199
so think of this I'm for all the

1596
01:11:58,800 --> 01:12:04,000
possible edges I'm put 0 0 0 0 only in

1597
01:12:02,199 --> 01:12:06,280
the cycle I'm going to put one that's

1598
01:12:04,000 --> 01:12:09,239
what I mean here because this so this is

1599
01:12:06,280 --> 01:12:09,239
like think of it's a

1600
01:12:09,719 --> 01:12:15,800
matrix uh of n byn uh

1601
01:12:13,639 --> 01:12:18,320
sorry yeah n

1602
01:12:15,800 --> 01:12:21,520
byn for any possible Edge for any

1603
01:12:18,320 --> 01:12:23,840
possible node I and J I'm going to put

1604
01:12:21,520 --> 01:12:25,400
zero like there's no Edge only if it's

1605
01:12:23,840 --> 01:12:29,880
in the cycle I'm going to put an edge

1606
01:12:25,400 --> 01:12:32,520
there yeah is on the label of the like

1607
01:12:29,880 --> 01:12:35,040
permuted gra exactly on the permuted

1608
01:12:32,520 --> 01:12:37,719
graph okay this the reason I permute the

1609
01:12:35,040 --> 01:12:39,880
graph is to ensure zero knowledg this

1610
01:12:37,719 --> 01:12:41,560
even though when I send the commitment

1611
01:12:39,880 --> 01:12:43,520
really think of it I'm we're going to

1612
01:12:41,560 --> 01:12:45,880
later talk about how to do this

1613
01:12:43,520 --> 01:12:48,679
commitment but for now think of it

1614
01:12:45,880 --> 01:12:51,199
there's a safe I'm putting my commitment

1615
01:12:48,679 --> 01:12:52,760
inside the safe I leave the key to

1616
01:12:51,199 --> 01:12:53,920
myself and I give you this box so you

1617
01:12:52,760 --> 01:12:56,840
learn

1618
01:12:53,920 --> 01:12:59,400
nothing okay so here really you learn

1619
01:12:56,840 --> 01:13:00,880
nothing but now but you but you're not

1620
01:12:59,400 --> 01:13:02,840
convinced either because you just got a

1621
01:13:00,880 --> 01:13:04,840
safe what are you going to do with it so

1622
01:13:02,840 --> 01:13:07,560
now here's how I'm going to convince you

1623
01:13:04,840 --> 01:13:11,040
that actually this graph is is has a

1624
01:13:07,560 --> 01:13:13,960
hamiltonian cycle without leaking any

1625
01:13:11,040 --> 01:13:16,840
information so you the verifier you're

1626
01:13:13,960 --> 01:13:20,480
going to give me a random bid

1627
01:13:16,840 --> 01:13:20,480
B this is going to be

1628
01:13:21,040 --> 01:13:28,480
random random bit now

1629
01:13:26,199 --> 01:13:32,600
if B is

1630
01:13:28,480 --> 01:13:37,600
zero I'm just going to open this so if B

1631
01:13:32,600 --> 01:13:40,040
zero if B is zero open I'm going to open

1632
01:13:37,600 --> 01:13:43,239
the safe and now you can see that what's

1633
01:13:40,040 --> 01:13:43,239
sitting there is a hamiltonian

1634
01:13:43,280 --> 01:13:49,199
cycle okay now what did you

1635
01:13:45,880 --> 01:13:50,800
learn well because I permuted it's just

1636
01:13:49,199 --> 01:13:54,520
a random cycle actually it has nothing

1637
01:13:50,800 --> 01:13:58,199
to do with the graph I can even first

1638
01:13:54,520 --> 01:14:01,159
just choose a random cycle commit to it

1639
01:13:58,199 --> 01:14:04,320
and then kind of post kind of choose

1640
01:14:01,159 --> 01:14:07,159
this permutation to align with this uh

1641
01:14:04,320 --> 01:14:09,400
with this cycle so really because I G I

1642
01:14:07,159 --> 01:14:11,960
chose you a random permutation it's just

1643
01:14:09,400 --> 01:14:14,120
a random cycle so you didn't learn

1644
01:14:11,960 --> 01:14:15,800
anything it's just a random cycle you

1645
01:14:14,120 --> 01:14:19,360
and yourself can put a random cycle in a

1646
01:14:15,800 --> 01:14:19,360
safe so really no

1647
01:14:19,760 --> 01:14:26,760
information what if B equals

1648
01:14:23,120 --> 01:14:29,199
1 if B equals 1

1649
01:14:26,760 --> 01:14:30,760
I want to first I want to give you Pi

1650
01:14:29,199 --> 01:14:33,880
okay so I give you Pi but now I can't

1651
01:14:30,760 --> 01:14:35,159
open this because now if you know pi and

1652
01:14:33,880 --> 01:14:36,679
you see the cycle you know where my

1653
01:14:35,159 --> 01:14:39,000
hamiltonian cycle

1654
01:14:36,679 --> 01:14:40,800
is so what I'm going to do I just want

1655
01:14:39,000 --> 01:14:43,120
to convince

1656
01:14:40,800 --> 01:14:46,360
you

1657
01:14:43,120 --> 01:14:49,800
that this cycle only

1658
01:14:46,360 --> 01:14:54,360
has edges that were in this

1659
01:14:49,800 --> 01:14:57,840
graph so I'm G to open only the non

1660
01:14:54,360 --> 01:14:59,960
edges so instead of opening everything

1661
01:14:57,840 --> 01:15:03,639
I'm going to

1662
01:14:59,960 --> 01:15:03,639
open non

1663
01:15:04,000 --> 01:15:08,840
edges

1664
01:15:06,159 --> 01:15:12,840
in the the permuted

1665
01:15:08,840 --> 01:15:15,159
graph so note here we have so I have

1666
01:15:12,840 --> 01:15:17,760
here like okay so there's a question how

1667
01:15:15,159 --> 01:15:22,560
do I how do I open so think of

1668
01:15:17,760 --> 01:15:24,760
it I I commit to N squared bits okay for

1669
01:15:22,560 --> 01:15:27,120
any possible IG I have a bit saying is

1670
01:15:24,760 --> 01:15:29,199
it zero or is it one is there an edge or

1671
01:15:27,120 --> 01:15:33,199
is it not an edge think of it as I'm

1672
01:15:29,199 --> 01:15:35,480
giving you N squared safes okay like now

1673
01:15:33,199 --> 01:15:37,520
if B is zero I open all the safes I open

1674
01:15:35,480 --> 01:15:39,560
all the safes and you see oh there's

1675
01:15:37,520 --> 01:15:42,480
only there's just a cycle you know

1676
01:15:39,560 --> 01:15:45,440
there's everything is zero except for

1677
01:15:42,480 --> 01:15:49,120
you know i1 and I2 are there's one and

1678
01:15:45,440 --> 01:15:52,560
then I2 I3 that's it everything else is

1679
01:15:49,120 --> 01:15:54,600
zero if you send me a one then I open

1680
01:15:52,560 --> 01:15:59,080
something else I don't open everything

1681
01:15:54,600 --> 01:16:04,880
now opposite what I do is I give you

1682
01:15:59,080 --> 01:16:07,560
pi and for every nonedge in pi I open

1683
01:16:04,880 --> 01:16:09,199
the nonedge safe and I show you see

1684
01:16:07,560 --> 01:16:12,719
there

1685
01:16:09,199 --> 01:16:14,120
zero so all the all the safes I opened

1686
01:16:12,719 --> 01:16:16,280
are just going to be

1687
01:16:14,120 --> 01:16:18,400
zero so you really didn't learn anything

1688
01:16:16,280 --> 01:16:21,320
I just opened zeros you can simulate

1689
01:16:18,400 --> 01:16:23,960
that in your head what do you learn in

1690
01:16:21,320 --> 01:16:25,880
some sense you know if if you you know

1691
01:16:23,960 --> 01:16:28,000
that if you accept me oh I'm going to

1692
01:16:25,880 --> 01:16:30,520
open to do zeros

1693
01:16:28,000 --> 01:16:33,080
there and the pi doesn't reveal anything

1694
01:16:30,520 --> 01:16:33,080
it's just random

1695
01:16:33,440 --> 01:16:40,159
permutation so note you the verifier

1696
01:16:37,080 --> 01:16:43,199
didn't learn anything if you open to

1697
01:16:40,159 --> 01:16:45,159
zero if you send me zero I just open

1698
01:16:43,199 --> 01:16:47,760
random cycle has nothing to do with the

1699
01:16:45,159 --> 01:16:49,320
graph nothing just random cycle okay

1700
01:16:47,760 --> 01:16:53,320
that doesn't get that that's not helpful

1701
01:16:49,320 --> 01:16:56,719
for you if you open one I gave you

1702
01:16:53,320 --> 01:16:59,800
completely random permutation

1703
01:16:56,719 --> 01:17:03,000
you know p on your own and I open to

1704
01:16:59,800 --> 01:17:04,880
zeros all the n edes i open to zero you

1705
01:17:03,000 --> 01:17:06,800
learn

1706
01:17:04,880 --> 01:17:10,320
nothing

1707
01:17:06,800 --> 01:17:13,040
still you are somewhat

1708
01:17:10,320 --> 01:17:14,760
convinced that this protocol that that

1709
01:17:13,040 --> 01:17:17,000
the graph is hamiltonian why are you

1710
01:17:14,760 --> 01:17:19,159
somewhat convinced that the that there's

1711
01:17:17,000 --> 01:17:21,679
a hamiltonian cycle why are you someone

1712
01:17:19,159 --> 01:17:25,800
convinced because if there is no

1713
01:17:21,679 --> 01:17:27,360
hamiltonian cycle in G I cannot open to

1714
01:17:25,800 --> 01:17:29,840
both zero and

1715
01:17:27,360 --> 01:17:31,320
one why why is it the case that I cannot

1716
01:17:29,840 --> 01:17:35,120
open let's

1717
01:17:31,320 --> 01:17:39,040
see I'm a cheating let's say the graph

1718
01:17:35,120 --> 01:17:43,520
is there's no hamiltonian

1719
01:17:39,040 --> 01:17:46,880
cycle now I sent you these N squared

1720
01:17:43,520 --> 01:17:49,320
safes case one there's indeed only a

1721
01:17:46,880 --> 01:17:51,760
hamiltonian cycle there like indeed when

1722
01:17:49,320 --> 01:17:53,320
you open all these end saves what you

1723
01:17:51,760 --> 01:17:56,080
see is everything is zero except for

1724
01:17:53,320 --> 01:17:58,679
hamiltonian cycle

1725
01:17:56,080 --> 01:18:02,960
if that's not the case I cannot open to

1726
01:17:58,679 --> 01:18:05,679
zero if I open to zero you catch

1727
01:18:02,960 --> 01:18:09,000
me now suppose I did succeed in opening

1728
01:18:05,679 --> 01:18:10,560
to zero namely there's just aonian cycle

1729
01:18:09,000 --> 01:18:13,199
there that's

1730
01:18:10,560 --> 01:18:16,920
it then I claim there's no way I can

1731
01:18:13,199 --> 01:18:19,520
open to one why if there is a

1732
01:18:16,920 --> 01:18:22,199
hamiltonian cycle there I know the

1733
01:18:19,520 --> 01:18:25,639
hamiltonian cycle is not on the

1734
01:18:22,199 --> 01:18:28,199
non-edges because the non-edges are zero

1735
01:18:25,639 --> 01:18:30,280
if I open on one the non-edges are zero

1736
01:18:28,199 --> 01:18:34,000
so Theon CLE is on the edges but there

1737
01:18:30,280 --> 01:18:37,800
is noonian cycle it can be on the

1738
01:18:34,000 --> 01:18:40,800
edges so either I'm a chover either I

1739
01:18:37,800 --> 01:18:42,199
can I I may be able to open to zero I

1740
01:18:40,800 --> 01:18:43,239
may be able to open to one but I can't

1741
01:18:42,199 --> 01:18:45,600
open to

1742
01:18:43,239 --> 01:18:47,760
both so with probability half you'll

1743
01:18:45,600 --> 01:18:51,280
reject

1744
01:18:47,760 --> 01:18:53,199
me half is not that great but it's

1745
01:18:51,280 --> 01:18:54,440
something okay so at least now we know

1746
01:18:53,199 --> 01:18:56,719
with probability half I'm going to be

1747
01:18:54,440 --> 01:18:56,719
rejected

1748
01:18:58,719 --> 01:19:03,120
okay you like The

1749
01:19:00,920 --> 01:19:06,159
Detour okay let's go back to the random

1750
01:19:03,120 --> 01:19:06,159
or but

1751
01:19:07,600 --> 01:19:15,280
yeah I so what no what I commit to is

1752
01:19:11,360 --> 01:19:18,639
actually I have N squared commitments

1753
01:19:15,280 --> 01:19:21,480
everything is zero except for a random

1754
01:19:18,639 --> 01:19:23,199
cycle I don't I only commit to zeros why

1755
01:19:21,480 --> 01:19:26,600
is it important that I only commit to

1756
01:19:23,199 --> 01:19:29,440
zeros because

1757
01:19:26,600 --> 01:19:31,360
when I open okay I want to make sure

1758
01:19:29,440 --> 01:19:34,040
that there's a cycle

1759
01:19:31,360 --> 01:19:35,880
here but when I open to one I don't want

1760
01:19:34,040 --> 01:19:38,360
to reveal anything and the way I don't

1761
01:19:35,880 --> 01:19:42,400
reveal anything is I show that all the

1762
01:19:38,360 --> 01:19:45,280
non edges in pi in pi of G if you open

1763
01:19:42,400 --> 01:19:45,280
them here you'll get a

1764
01:19:48,639 --> 01:19:55,239
zero just with the cyle like outline

1765
01:19:52,800 --> 01:19:57,719
exactly exactly what I commit is a

1766
01:19:55,239 --> 01:19:59,520
matrix what I commit to is like a matrix

1767
01:19:57,719 --> 01:20:02,880
that only has like a hamiltonian cycle

1768
01:19:59,520 --> 01:20:02,880
and that's it everything else is

1769
01:20:02,920 --> 01:20:10,159
zero yeah so in the second case the

1770
01:20:06,920 --> 01:20:13,719
verifi cannot use the permutation to

1771
01:20:10,159 --> 01:20:16,440
figure out what edges are not in the hon

1772
01:20:13,719 --> 01:20:18,120
ccle for the original right so in the in

1773
01:20:16,440 --> 01:20:20,560
in the b equals one case you're talking

1774
01:20:18,120 --> 01:20:22,960
about yeah in the b equals one case the

1775
01:20:20,560 --> 01:20:24,280
verifier what does he learn he learns Pi

1776
01:20:22,960 --> 01:20:26,400
the permutation that's just a random

1777
01:20:24,280 --> 01:20:27,960
permutation

1778
01:20:26,400 --> 01:20:29,960
and then I'm just telling you I'm

1779
01:20:27,960 --> 01:20:32,800
reassuring you that I didn't lie what do

1780
01:20:29,960 --> 01:20:34,199
I mean by reassure you I open everybody

1781
01:20:32,800 --> 01:20:36,000
you can compute Pi G on your own that's

1782
01:20:34,199 --> 01:20:38,040
not a secret G's given Pi is given you

1783
01:20:36,000 --> 01:20:40,920
can Pi G you see all the non edges

1784
01:20:38,040 --> 01:20:43,040
that's not a that's not and all the N

1785
01:20:40,920 --> 01:20:45,560
edges I'm going to open only the N edges

1786
01:20:43,040 --> 01:20:45,560
and show you

1787
01:20:45,800 --> 01:20:52,440
zeros okay because the point is if I was

1788
01:20:49,639 --> 01:20:54,760
honest what I should do is put on only

1789
01:20:52,440 --> 01:20:56,639
on edges and not only on edges only on

1790
01:20:54,760 --> 01:20:59,199
hamiltonian and the edes that former

1791
01:20:56,639 --> 01:21:02,600
hamiltonian cycle that's what I should

1792
01:20:59,199 --> 01:21:03,679
do if I'm honest and what I show you I

1793
01:21:02,600 --> 01:21:05,120
don't show you that because that will

1794
01:21:03,679 --> 01:21:07,719
give information but at least what I

1795
01:21:05,120 --> 01:21:08,920
show you then all the non-edges here I

1796
01:21:07,719 --> 01:21:12,120
committed to

1797
01:21:08,920 --> 01:21:15,880
zero and that gives you no

1798
01:21:12,120 --> 01:21:18,800
information but if indeed I the

1799
01:21:15,880 --> 01:21:21,239
non-edges are zero and there's

1800
01:21:18,800 --> 01:21:24,000
hamiltonian cycle then it means Honan

1801
01:21:21,239 --> 01:21:27,400
must must be edges and then it means

1802
01:21:24,000 --> 01:21:29,639
that P G has a hon cycle and that can't

1803
01:21:27,400 --> 01:21:31,840
be if G doesn't have a hilon cycle 5G

1804
01:21:29,639 --> 01:21:34,800
doesn't have a honi cycle and that's why

1805
01:21:31,840 --> 01:21:38,719
I can't succeed in convincing

1806
01:21:34,800 --> 01:21:38,719
you in answering both

1807
01:21:40,320 --> 01:21:47,679
questions yeah is there a formal way to

1808
01:21:43,679 --> 01:21:47,679
say what it means to be zero knowledge

1809
01:21:47,719 --> 01:21:51,639
like good good good good good so the

1810
01:21:49,760 --> 01:21:53,679
question yeah actually I plan not to go

1811
01:21:51,639 --> 01:21:55,080
into the the but it's so beautiful so I

1812
01:21:53,679 --> 01:21:59,360
will

1813
01:21:55,080 --> 01:22:01,040
a yeah so the question was uh what is

1814
01:21:59,360 --> 01:22:03,320
the definition actually of zero

1815
01:22:01,040 --> 01:22:04,400
knowledge and the definition of zero

1816
01:22:03,320 --> 01:22:06,920
knowledge

1817
01:22:04,400 --> 01:22:10,520
says that what does it mean you don't

1818
01:22:06,920 --> 01:22:15,199
learn anything so the definition says

1819
01:22:10,520 --> 01:22:15,199
that so this is the definition of zero

1820
01:22:15,320 --> 01:22:21,760
knowledge what it says

1821
01:22:18,400 --> 01:22:25,159
is the verifier actually it's it says

1822
01:22:21,760 --> 01:22:26,760
it's stronger it says for every verifier

1823
01:22:25,159 --> 01:22:28,800
not just the honest verifier even

1824
01:22:26,760 --> 01:22:30,520
malicious ver there's you can talk about

1825
01:22:28,800 --> 01:22:33,120
honest verifier you an object the honest

1826
01:22:30,520 --> 01:22:35,679
verifier who just does what it should do

1827
01:22:33,120 --> 01:22:37,000
and just listens doesn't learn anything

1828
01:22:35,679 --> 01:22:42,320
but actually there's a stronger notion

1829
01:22:37,000 --> 01:22:42,320
of malicious so I say even for malicious

1830
01:22:43,320 --> 01:22:49,440
verifier you want to say what he learned

1831
01:22:46,600 --> 01:22:53,280
he could have simulated on his

1832
01:22:49,440 --> 01:22:56,280
own so the definition says for every uh

1833
01:22:53,280 --> 01:22:58,920
so you okay for every verifier if you

1834
01:22:56,280 --> 01:22:58,920
look the

1835
01:22:59,320 --> 01:23:08,239
transcript of and and for every X and

1836
01:23:05,800 --> 01:23:10,760
L for every X if you look at the

1837
01:23:08,239 --> 01:23:12,199
transcript between the honest prover and

1838
01:23:10,760 --> 01:23:15,360
the

1839
01:23:12,199 --> 01:23:16,960
verifier the prover has a witness but

1840
01:23:15,360 --> 01:23:19,000
the verifier

1841
01:23:16,960 --> 01:23:20,880
doesn't what he learned from this

1842
01:23:19,000 --> 01:23:22,960
transcript or what the verify maybe

1843
01:23:20,880 --> 01:23:26,440
sorry let me write it differently let me

1844
01:23:22,960 --> 01:23:26,440
say The View

1845
01:23:26,600 --> 01:23:33,920
of V Star while interacting with

1846
01:23:31,120 --> 01:23:37,280
P an input

1847
01:23:33,920 --> 01:23:43,679
X so whatever varar

1848
01:23:37,280 --> 01:23:43,679
learned he could have simulated on his

1849
01:23:46,199 --> 01:23:51,880
own so it says there

1850
01:23:49,880 --> 01:23:54,040
exists a

1851
01:23:51,880 --> 01:23:56,440
simulator and this is efficient and

1852
01:23:54,040 --> 01:23:56,440
efficient

1853
01:23:56,880 --> 01:24:00,360
simulator such

1854
01:24:01,520 --> 01:24:07,239
that the simulator efficiently can

1855
01:24:04,560 --> 01:24:10,560
generate this transcript on his

1856
01:24:07,239 --> 01:24:12,159
own if he has v he needs varar because

1857
01:24:10,560 --> 01:24:14,600
of course varar depends what he sends

1858
01:24:12,159 --> 01:24:15,679
and so on but he could generate it on

1859
01:24:14,600 --> 01:24:17,920
his

1860
01:24:15,679 --> 01:24:20,600
own

1861
01:24:17,920 --> 01:24:23,880
yeah on

1862
01:24:20,600 --> 01:24:26,480
than is it the same SIM for every oh my

1863
01:24:23,880 --> 01:24:29,040
God there's so many okay there's so so

1864
01:24:26,480 --> 01:24:31,639
many Notions of zero knowledge so for

1865
01:24:29,040 --> 01:24:33,440
example first of all it I'll answer your

1866
01:24:31,639 --> 01:24:36,159
question the question was is the

1867
01:24:33,440 --> 01:24:38,719
simulator only gets V Star as Oracle AIS

1868
01:24:36,159 --> 01:24:42,119
does it get as an input is it Universal

1869
01:24:38,719 --> 01:24:44,920
is it for there exist for every V is it

1870
01:24:42,119 --> 01:24:48,199
for every V there's a simulator moreover

1871
01:24:44,920 --> 01:24:53,520
let me continue is V all powerful is V

1872
01:24:48,199 --> 01:24:53,520
supposed to be PPT or poly siiz

1873
01:24:56,000 --> 01:25:01,400
and the answers there's many definitions

1874
01:25:03,199 --> 01:25:06,960
but yeah so

1875
01:25:08,159 --> 01:25:15,920
um originally all the protocols we had

1876
01:25:13,920 --> 01:25:21,159
used the verifiers of

1877
01:25:15,920 --> 01:25:25,119
blackbox uh however in 2001 I think was

1878
01:25:21,159 --> 01:25:27,679
it h BOS Barak was the first kind of

1879
01:25:25,119 --> 01:25:29,360
construct non blackbox Z knowledge where

1880
01:25:27,679 --> 01:25:32,280
the simulator used verifire as a non

1881
01:25:29,360 --> 01:25:35,040
blackbox and it was a really

1882
01:25:32,280 --> 01:25:38,040
breakthrough result because what he

1883
01:25:35,040 --> 01:25:40,000
managed to to get is a new Zer knowledge

1884
01:25:38,040 --> 01:25:43,719
proof that we didn't know of before it

1885
01:25:40,000 --> 01:25:45,760
was kind of constant round now you you

1886
01:25:43,719 --> 01:25:47,960
can say wait this is also constant round

1887
01:25:45,760 --> 01:25:51,040
what do you mean we didn't know before

1888
01:25:47,960 --> 01:25:51,040
but this is only sound as

1889
01:25:51,679 --> 01:25:57,679
half turns out if you want NE sound this

1890
01:25:56,000 --> 01:26:00,239
you need to repeat this protocol

1891
01:25:57,679 --> 01:26:02,320
sequentially you can if you repeat it in

1892
01:26:00,239 --> 01:26:05,600
parallel

1893
01:26:02,320 --> 01:26:07,360
it's it's not necessarily zero knowledge

1894
01:26:05,600 --> 01:26:08,800
actually yeah this one actually is not

1895
01:26:07,360 --> 01:26:10,639
zero knowledge if you're you're

1896
01:26:08,800 --> 01:26:14,560
repeating in parallel we we'll talk

1897
01:26:10,639 --> 01:26:16,679
about that and so using non blackbox

1898
01:26:14,560 --> 01:26:19,600
technique he managed to show the first

1899
01:26:16,679 --> 01:26:22,199
kind of Conant round zero knowledge

1900
01:26:19,600 --> 01:26:25,920
public coin zero knowledge proof so

1901
01:26:22,199 --> 01:26:28,400
there's there's many many variants okay

1902
01:26:25,920 --> 01:26:31,719
is is the

1903
01:26:28,400 --> 01:26:31,719
a the the

1904
01:26:32,040 --> 01:26:36,679
point okay but this is kind of a common

1905
01:26:34,360 --> 01:26:39,920
variant to think

1906
01:26:36,679 --> 01:26:42,440
about and also um so this is kind of

1907
01:26:39,920 --> 01:26:45,239
poly size or or V can have auxiliary

1908
01:26:42,440 --> 01:26:48,639
input so for every X and A or V Star is

1909
01:26:45,239 --> 01:26:51,760
poly size so we can have like auxilary

1910
01:26:48,639 --> 01:26:53,800
information about X even if he has ail

1911
01:26:51,760 --> 01:26:55,639
information about X still so V Star is

1912
01:26:53,800 --> 01:26:57,400
kind of has may have ex information

1913
01:26:55,639 --> 01:27:01,360
about

1914
01:26:57,400 --> 01:27:03,000
X still the two are

1915
01:27:01,360 --> 01:27:05,320
indistinguishable

1916
01:27:03,000 --> 01:27:08,239
yeah what if

1917
01:27:05,320 --> 01:27:12,840
the follow with

1918
01:27:08,239 --> 01:27:16,920
commitment where he create that matrices

1919
01:27:12,840 --> 01:27:19,239
that cycle in that matri Comm that wait

1920
01:27:16,920 --> 01:27:21,679
again what if the commit approver

1921
01:27:19,239 --> 01:27:25,800
commits to a cycle or no he commits to a

1922
01:27:21,679 --> 01:27:25,800
cycle but the cycle is not necessarily

1923
01:27:26,239 --> 01:27:33,360
it has nothing to do with G just commits

1924
01:27:27,960 --> 01:27:37,400
to any cycle he to CC that then able

1925
01:27:33,360 --> 01:27:38,679
to it's zero right yeah he'll be able to

1926
01:27:37,400 --> 01:27:40,520
exactly he'll be able to answer zero but

1927
01:27:38,679 --> 01:27:45,639
he won't be able to answer

1928
01:27:40,520 --> 01:27:47,159
one because that cycle must touch an

1929
01:27:45,639 --> 01:27:50,040
edge

1930
01:27:47,159 --> 01:27:52,320
because sorry that cycle must touch a

1931
01:27:50,040 --> 01:27:54,400
non-edge because if it only touched

1932
01:27:52,320 --> 01:27:57,760
edges

1933
01:27:54,400 --> 01:27:59,960
there is no cycle so that cycle you give

1934
01:27:57,760 --> 01:28:02,920
here Pi now the prover can the cheating

1935
01:27:59,960 --> 01:28:06,119
prover can give whatever Pi he wants but

1936
01:28:02,920 --> 01:28:09,960
the point is that the graph the permuted

1937
01:28:06,119 --> 01:28:11,360
graph doesn't have a hamiltonian cycle

1938
01:28:09,960 --> 01:28:12,840
because if G doesn't have a hamiltonian

1939
01:28:11,360 --> 01:28:15,800
cyle the permuted G also doesn't have a

1940
01:28:12,840 --> 01:28:18,840
hamiltonian cycle so this graph doesn't

1941
01:28:15,800 --> 01:28:20,960
have a hamiltonian cycle and that means

1942
01:28:18,840 --> 01:28:23,000
that the cycle that's here I don't care

1943
01:28:20,960 --> 01:28:26,560
how you generate whatever the cycle was

1944
01:28:23,000 --> 01:28:29,880
it must touch such a non

1945
01:28:26,560 --> 01:28:31,639
Edge so so the hamiltonan CLE says you

1946
01:28:29,880 --> 01:28:34,080
know there's an edge between i1 I2

1947
01:28:31,639 --> 01:28:36,560
there's an edge between I2 I3 there one

1948
01:28:34,080 --> 01:28:38,360
of them cannot be edge here it can't be

1949
01:28:36,560 --> 01:28:41,239
that all of them are edges here because

1950
01:28:38,360 --> 01:28:44,040
they're so because it doesn't have an

1951
01:28:41,239 --> 01:28:46,560
malonian cycle so one of them cannot be

1952
01:28:44,040 --> 01:28:48,600
an edge here and now what the what the

1953
01:28:46,560 --> 01:28:51,679
verifier is asking from the prover he

1954
01:28:48,600 --> 01:28:54,520
looks at all the I i1 and I all the I

1955
01:28:51,679 --> 01:28:56,000
and J that do not have an edge and he

1956
01:28:54,520 --> 01:28:58,679
open that edge I want to see that it's

1957
01:28:56,000 --> 01:29:01,440
zero I want I want you I want to see

1958
01:28:58,679 --> 01:29:03,960
that I gave you n squar safes so for

1959
01:29:01,440 --> 01:29:07,080
every inj there's a safe and it should

1960
01:29:03,960 --> 01:29:08,159
be one if there's an edge and zero other

1961
01:29:07,080 --> 01:29:11,000
I mean if there's an edge in the

1962
01:29:08,159 --> 01:29:13,639
hamiltonian cycle and zero otherwise now

1963
01:29:11,000 --> 01:29:16,639
with the with the verifier is asking the

1964
01:29:13,639 --> 01:29:19,000
prover for every J here that does not

1965
01:29:16,639 --> 01:29:20,840
have an edge I want you to open the safe

1966
01:29:19,000 --> 01:29:22,840
corresponding to that edge and I want to

1967
01:29:20,840 --> 01:29:24,920
see a zero there if there's a one there

1968
01:29:22,840 --> 01:29:27,800
I'm not happy I'm going to reject you

1969
01:29:24,920 --> 01:29:29,760
because this there should be on only on

1970
01:29:27,800 --> 01:29:31,880
the hamiltonian cycle and these are only

1971
01:29:29,760 --> 01:29:34,560
places that have an edge on your

1972
01:29:31,880 --> 01:29:38,000
graph but the problem

1973
01:29:34,560 --> 01:29:40,360
is on one of these I that don't have an

1974
01:29:38,000 --> 01:29:43,679
edge you'll see an edge because the

1975
01:29:40,360 --> 01:29:45,000
aonian tyo is not all on edges and then

1976
01:29:43,679 --> 01:29:49,400
I'm going to catch

1977
01:29:45,000 --> 01:29:49,400
you yeah

1978
01:29:51,760 --> 01:29:56,040
great any more questions

1979
01:30:02,239 --> 01:30:06,840
yeah slightly stronger that requires the

1980
01:30:05,280 --> 01:30:09,840
pro to actually

1981
01:30:06,840 --> 01:30:11,600
know the hamiltonian cycle right so here

1982
01:30:09,840 --> 01:30:15,360
the proof like with the second part say

1983
01:30:11,600 --> 01:30:16,639
that only guarante that if G is not

1984
01:30:15,360 --> 01:30:18,480
doesn't have a

1985
01:30:16,639 --> 01:30:23,400
hon proof

1986
01:30:18,480 --> 01:30:24,560
the cannot but do necess like Converse

1987
01:30:23,400 --> 01:30:27,960
like

1988
01:30:24,560 --> 01:30:31,119
is it possible for G to not know cyle

1989
01:30:27,960 --> 01:30:32,440
but still ver good G good good good

1990
01:30:31,119 --> 01:30:35,040
great question great question so the

1991
01:30:32,440 --> 01:30:39,159
question was or let me just answer the

1992
01:30:35,040 --> 01:30:41,480
question is the qu the question was wait

1993
01:30:39,159 --> 01:30:43,440
we just proved your soundness that if x

1994
01:30:41,480 --> 01:30:46,600
is an non the language on one of the

1995
01:30:43,440 --> 01:30:48,159
answers you'll fail but actually doesn't

1996
01:30:46,600 --> 01:30:50,280
this protocol give you something

1997
01:30:48,159 --> 01:30:52,560
stronger was the question and the answer

1998
01:30:50,280 --> 01:30:56,600
is yes so what what do we mean by some

1999
01:30:52,560 --> 01:30:58,480
something stronger let's say G is does

2000
01:30:56,600 --> 01:31:03,040
have a hamiltonian

2001
01:30:58,480 --> 01:31:05,440
cycle doesn't this protocol tell us not

2002
01:31:03,040 --> 01:31:06,480
only that g has a hamiltonian cycle if

2003
01:31:05,440 --> 01:31:08,080
you succeed let's say you succeed

2004
01:31:06,480 --> 01:31:09,159
probability one or you know with h more

2005
01:31:08,080 --> 01:31:11,800
more than

2006
01:31:09,159 --> 01:31:14,560
half this protocol tells us not only

2007
01:31:11,800 --> 01:31:17,239
that g has a hamiltonian cycle it means

2008
01:31:14,560 --> 01:31:19,679
that P must know the

2009
01:31:17,239 --> 01:31:23,320
cycle you can actually find you can

2010
01:31:19,679 --> 01:31:24,800
extract the cycle from from from p and

2011
01:31:23,320 --> 01:31:26,440
the answer is yes yes you can you can

2012
01:31:24,800 --> 01:31:29,159
actually this is what's called proof of

2013
01:31:26,440 --> 01:31:30,600
knowledge it means that P knows now I

2014
01:31:29,159 --> 01:31:32,719
can say what does it mean that P knows

2015
01:31:30,600 --> 01:31:35,239
what do we this is this is a theory

2016
01:31:32,719 --> 01:31:38,320
class mathematics what does no mean you

2017
01:31:35,239 --> 01:31:41,960
know so what what what we mean by P NOS

2018
01:31:38,320 --> 01:31:46,040
what we mean is that we can actually

2019
01:31:41,960 --> 01:31:47,400
efficiently extract the cycle from p and

2020
01:31:46,040 --> 01:31:48,560
how do we extract the cycle it's

2021
01:31:47,400 --> 01:31:51,239
actually very

2022
01:31:48,560 --> 01:31:53,560
easy we ask him he committed to

2023
01:31:51,239 --> 01:31:57,000
something he knows how to open both

2024
01:31:53,560 --> 01:32:00,800
that's assumption so first we'll ask him

2025
01:31:57,000 --> 01:32:00,800
okay open only the

2026
01:32:01,400 --> 01:32:07,280
cycle and

2027
01:32:03,400 --> 01:32:11,159
then give me the

2028
01:32:07,280 --> 01:32:14,199
pi once I know the pi and the cycle I

2029
01:32:11,159 --> 01:32:17,719
can I can undo I can I know what py gen

2030
01:32:14,199 --> 01:32:21,159
I can see I can actually find the aonian

2031
01:32:17,719 --> 01:32:23,239
cycle so it's it's more than just a

2032
01:32:21,159 --> 01:32:25,320
soundness it's a proof of knowledge he

2033
01:32:23,239 --> 01:32:30,440
must no I can actually use him to kind

2034
01:32:25,320 --> 01:32:30,440
of extract the the antonian cycle from

2035
01:32:31,080 --> 01:32:36,560
him any any other

2036
01:32:33,880 --> 01:32:38,880
questions okay so let's take a five

2037
01:32:36,560 --> 01:32:40,440
minute break and then after the break

2038
01:32:38,880 --> 01:32:42,679
I'm going to show you why this protocol

2039
01:32:40,440 --> 01:32:44,679
is not secure in the roral model but

2040
01:32:42,679 --> 01:32:47,360
we'll fix it don't worry okay I'll take

2041
01:32:44,679 --> 01:32:47,360
a break

