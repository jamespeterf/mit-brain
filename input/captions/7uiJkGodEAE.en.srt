1
00:00:00,848 --> 00:00:04,200
(Logo whooshes)

2
00:00:04,200 --> 00:00:06,030
Hi everyone, very happy to be here.

3
00:00:06,030 --> 00:00:07,920
I am Armando Solar-Lezama.

4
00:00:07,920 --> 00:00:10,290
I am a distinguished
professor of computing

5
00:00:10,290 --> 00:00:13,950
here in the Schwarzman
College of Computing at MIT,

6
00:00:13,950 --> 00:00:15,810
and I'm also the associate director

7
00:00:15,810 --> 00:00:19,080
of the Computer Science and
Artificial Intelligence Lab,

8
00:00:19,080 --> 00:00:21,570
also known as CSAIL.

9
00:00:21,570 --> 00:00:23,490
And I'm very excited to be here today

10
00:00:23,490 --> 00:00:25,680
to answer all of your questions

11
00:00:25,680 --> 00:00:29,160
about the future of AI and programming.

12
00:00:29,160 --> 00:00:33,210
And so let's start with
the first question.

13
00:00:33,210 --> 00:00:37,080
How is AI reshaping the
very idea of programming,

14
00:00:37,080 --> 00:00:38,850
what it means to write code?

15
00:00:38,850 --> 00:00:43,850
And what remains uniquely
human about that process

16
00:00:43,890 --> 00:00:46,050
as AI grows more capable?

17
00:00:46,050 --> 00:00:48,720
I think what's going to remain very human,

18
00:00:48,720 --> 00:00:51,240
regardless of whether
you're writing research code

19
00:00:51,240 --> 00:00:56,240
or whether you are doing
brand new development

20
00:00:56,760 --> 00:00:59,910
for a startup, is going
to be this question of

21
00:00:59,910 --> 00:01:02,790
how do we actually tell the system,

22
00:01:02,790 --> 00:01:04,410
what is it that you're trying to do?

23
00:01:04,410 --> 00:01:07,350
What are you actually
trying to accomplish?

24
00:01:07,350 --> 00:01:11,680
And this is where software
developers bring a lot of their

25
00:01:13,260 --> 00:01:16,800
human knowledge and human
expertise about, you know,

26
00:01:16,800 --> 00:01:19,890
what should this piece
of software actually do?

27
00:01:19,890 --> 00:01:24,240
And how do we break down what
might be a very high level,

28
00:01:24,240 --> 00:01:27,060
very ambiguous statement of the goals

29
00:01:27,060 --> 00:01:30,330
that we're trying to accomplish
with this piece of code

30
00:01:30,330 --> 00:01:35,330
down to a very precise
description of step-by-step

31
00:01:36,210 --> 00:01:39,750
what needs to happen in this process.

32
00:01:39,750 --> 00:01:44,070
And now exactly how you do it
and the nature of the notation

33
00:01:44,070 --> 00:01:48,030
and the tools that you do
this are probably going

34
00:01:48,030 --> 00:01:50,220
to change quite dramatically
in the next few years,

35
00:01:50,220 --> 00:01:53,220
just as they have changed
quite dramatically,

36
00:01:53,220 --> 00:01:56,980
even in the time that, you
know, I have been working

37
00:01:57,904 --> 00:01:59,460
with computers for example.

38
00:01:59,460 --> 00:02:04,020
But I think what's going to
remain very uniquely human

39
00:02:04,020 --> 00:02:06,390
is this creative process of figuring out

40
00:02:06,390 --> 00:02:11,250
how do we bridge from the needs
to what we expect this piece

41
00:02:11,250 --> 00:02:13,533
of software to do in a very precise way.

42
00:02:15,660 --> 00:02:17,700
So question number two.

43
00:02:17,700 --> 00:02:21,720
Do you see programming
shifting from writing code

44
00:02:21,720 --> 00:02:26,010
to simply expressing intent,
where human specified goals

45
00:02:26,010 --> 00:02:29,520
and the AI handles the implementation?

46
00:02:29,520 --> 00:02:33,660
So I think one of the
things to make clear is that

47
00:02:33,660 --> 00:02:37,830
already today for people
doing software development,

48
00:02:37,830 --> 00:02:41,970
a lot of programming is
about expressing intent.

49
00:02:41,970 --> 00:02:44,340
We have a remarkable ability

50
00:02:44,340 --> 00:02:47,340
with modern programming
languages to abstract away

51
00:02:47,340 --> 00:02:51,120
a lot of complexity so that
the focus of the programming

52
00:02:51,120 --> 00:02:55,170
really is on expressing your intent.

53
00:02:55,170 --> 00:02:57,240
It is true that people who are starting

54
00:02:57,240 --> 00:03:00,030
to program often struggle with the syntax

55
00:03:00,030 --> 00:03:03,510
and the unnaturalness of the notation.

56
00:03:03,510 --> 00:03:06,390
But the fact of the matter is,
once people get to the point

57
00:03:06,390 --> 00:03:08,730
where they're writing
software for a living,

58
00:03:08,730 --> 00:03:12,930
the core challenge becomes
expressing their intent

59
00:03:12,930 --> 00:03:15,780
at a level that is detailed
enough and precise enough

60
00:03:15,780 --> 00:03:18,450
to actually build software.

61
00:03:18,450 --> 00:03:20,160
However, there is no question

62
00:03:20,160 --> 00:03:23,430
that these new programming
tools are going to allow us

63
00:03:23,430 --> 00:03:26,490
to be able to express
things more concisely,

64
00:03:26,490 --> 00:03:29,370
to be able to lift the
level of abstraction

65
00:03:29,370 --> 00:03:31,050
at which we describe things.

66
00:03:31,050 --> 00:03:34,230
And to get around some
of those limitations

67
00:03:34,230 --> 00:03:35,640
of the current programming tools

68
00:03:35,640 --> 00:03:37,860
where sometimes you still need to write

69
00:03:37,860 --> 00:03:41,013
very large amounts of
code to do what you want.

70
00:03:45,060 --> 00:03:47,250
In your recent CSAIL study

71
00:03:47,250 --> 00:03:48,870
on autonomous software engineering,

72
00:03:48,870 --> 00:03:51,720
you identified key roadblocks.

73
00:03:51,720 --> 00:03:55,380
Which ones do you think will fall first?

74
00:03:55,380 --> 00:03:59,730
So making predictions about
this technology is difficult

75
00:03:59,730 --> 00:04:04,410
because of how quickly the
technology is developing.

76
00:04:04,410 --> 00:04:05,520
For example, one of the things

77
00:04:05,520 --> 00:04:09,210
that we've seen in recent
years is this reasoning models

78
00:04:09,210 --> 00:04:12,630
that are able to think
through challenging problems

79
00:04:12,630 --> 00:04:16,110
step by step, and in many
cases, solve problems

80
00:04:16,110 --> 00:04:19,380
that they have never seen before in ways

81
00:04:19,380 --> 00:04:22,320
that are really exciting and surprising.

82
00:04:22,320 --> 00:04:27,030
One of the big challenges
that we see in tools today is

83
00:04:27,030 --> 00:04:32,030
their inability though, to
do this at scale, right?

84
00:04:32,310 --> 00:04:36,150
And to do this at the scale
of reasoning that is required

85
00:04:36,150 --> 00:04:40,350
when you're dealing
with a large code base.

86
00:04:40,350 --> 00:04:43,110
However, we have a lot of tools coming

87
00:04:43,110 --> 00:04:47,250
from more traditional
programming systems technology

88
00:04:47,250 --> 00:04:50,520
that can help us manage some of that scale

89
00:04:50,520 --> 00:04:52,740
and manage some of that complexity.

90
00:04:52,740 --> 00:04:55,950
And so I do believe that

91
00:04:55,950 --> 00:04:59,760
as we get better at incorporating
some of that knowledge

92
00:04:59,760 --> 00:05:04,760
and some of those tools into
the current AI based processes,

93
00:05:05,970 --> 00:05:08,490
we're probably going to
be doing much, much better

94
00:05:08,490 --> 00:05:12,960
at dealing with larger and
larger software systems.

95
00:05:12,960 --> 00:05:17,250
Now, this is just to one
dimension in which current tools

96
00:05:17,250 --> 00:05:19,500
still have shortcomings,

97
00:05:19,500 --> 00:05:21,660
but I think it will actually
make a really big difference

98
00:05:21,660 --> 00:05:25,650
in terms of using these
tools in the context

99
00:05:25,650 --> 00:05:30,650
of harder, larger scale
software engineering tasks.

100
00:05:32,700 --> 00:05:36,330
Now, we have another question.

101
00:05:36,330 --> 00:05:41,330
How close are we to truly
automated debugging, testing,

102
00:05:41,970 --> 00:05:46,970
and refactoring at the scale
of real production systems?

103
00:05:47,640 --> 00:05:52,560
So all of these thing:;
debugging, testing and refactoring

104
00:05:52,560 --> 00:05:56,280
come at many different flavors
and many different scales.

105
00:05:56,280 --> 00:06:01,050
Debugging for example, you can
have a bug that is, you know,

106
00:06:01,050 --> 00:06:03,780
just one line of code that
is doing the wrong thing.

107
00:06:03,780 --> 00:06:07,800
And once you identify it and
fix it, the software works.

108
00:06:07,800 --> 00:06:12,690
We have also seen bugs where you realize

109
00:06:12,690 --> 00:06:15,990
in analyzing the bug
that there is a problem

110
00:06:15,990 --> 00:06:18,030
in the way you structured your computation

111
00:06:18,030 --> 00:06:21,840
and in the way you
architected your solution

112
00:06:21,840 --> 00:06:26,310
that actually is going to make
that bug really hard to fix.

113
00:06:26,310 --> 00:06:28,800
And so the first kind of bug,

114
00:06:28,800 --> 00:06:31,380
I think we're actually
already there, right?

115
00:06:31,380 --> 00:06:34,230
You can already use many of these tools

116
00:06:34,230 --> 00:06:39,060
to identify those kind of
finger error type of bugs

117
00:06:39,060 --> 00:06:41,910
where all it takes is a
small change in your code

118
00:06:41,910 --> 00:06:43,680
in order to fix it.

119
00:06:43,680 --> 00:06:45,330
And once you see it, it's very clear

120
00:06:45,330 --> 00:06:46,650
that there is a bug there.

121
00:06:46,650 --> 00:06:49,350
By contrast, the kind of bugs that arise

122
00:06:49,350 --> 00:06:52,830
from a faulty reasoning
and faulty assumptions

123
00:06:52,830 --> 00:06:54,600
about your problem domain.

124
00:06:54,600 --> 00:06:56,880
I think we're probably still many years

125
00:06:56,880 --> 00:06:58,630
before we can have systems

126
00:06:59,564 --> 00:07:01,470
that can do that kind of debugging.

127
00:07:01,470 --> 00:07:03,990
And I think similar things have to do

128
00:07:03,990 --> 00:07:06,810
with things like testing
and refactoring, right?

129
00:07:06,810 --> 00:07:09,450
There are some refactorings
that are very standardized

130
00:07:09,450 --> 00:07:11,520
and relatively simple

131
00:07:11,520 --> 00:07:14,700
and that can be implemented
pretty mechanically

132
00:07:14,700 --> 00:07:19,440
even with tools that
existed prior to LLMs.

133
00:07:19,440 --> 00:07:22,680
But the really challenging
refactorings are those

134
00:07:22,680 --> 00:07:27,600
that really require rethinking
the architecture of the code

135
00:07:27,600 --> 00:07:30,300
that require very non-standard changes

136
00:07:30,300 --> 00:07:32,160
that span the entire code base.

137
00:07:32,160 --> 00:07:34,980
And again, I think those
are the kind of things

138
00:07:34,980 --> 00:07:37,500
that we're probably many, many years

139
00:07:37,500 --> 00:07:40,980
before we would trust a
completely automated tool

140
00:07:40,980 --> 00:07:42,630
to do them.

141
00:07:42,630 --> 00:07:47,070
So I think to reframe these questions,

142
00:07:47,070 --> 00:07:49,920
I think it's not so much about the scale

143
00:07:49,920 --> 00:07:51,270
of the production systems,

144
00:07:51,270 --> 00:07:53,550
but about the complexity of the task

145
00:07:53,550 --> 00:07:55,383
that you're trying to perform.

146
00:07:57,960 --> 00:08:02,850
So now we have a question
here about the research

147
00:08:02,850 --> 00:08:05,670
that we actually do in my research group.

148
00:08:05,670 --> 00:08:09,000
The question says, in
DreamCoder, you showed

149
00:08:09,000 --> 00:08:13,050
how AI can learn reusable abstractions.

150
00:08:13,050 --> 00:08:14,460
Could this lead to systems

151
00:08:14,460 --> 00:08:17,970
that invent domain specific
languages on the fly?

152
00:08:17,970 --> 00:08:21,150
So for those of you who are
not familiar with my research,

153
00:08:21,150 --> 00:08:23,100
let me give you a little bit of context.

154
00:08:23,100 --> 00:08:27,780
One of the challenges
in software synthesis

155
00:08:27,780 --> 00:08:31,200
in generating programs is
that you're often restricted

156
00:08:31,200 --> 00:08:34,050
to the building blocks
and the abstractions

157
00:08:34,050 --> 00:08:37,740
that were already there present
in the existing software,

158
00:08:37,740 --> 00:08:41,280
in the libraries that the
system has already seen

159
00:08:41,280 --> 00:08:42,780
in order to produce the code.

160
00:08:42,780 --> 00:08:44,520
And one of the things
that we're trying to do

161
00:08:44,520 --> 00:08:49,140
with this DreamCoder project
was to allow the system

162
00:08:49,140 --> 00:08:52,380
to discover its own building blocks,

163
00:08:52,380 --> 00:08:56,460
to identify common recurring
patterns in the solutions

164
00:08:56,460 --> 00:09:01,050
that it generates, and abstract
these into new components

165
00:09:01,050 --> 00:09:03,870
that can then make it
easier to build new software

166
00:09:03,870 --> 00:09:07,170
in a similar way that humans
build software, right?

167
00:09:07,170 --> 00:09:09,840
The first time around you might just write

168
00:09:09,840 --> 00:09:12,480
a whole bunch of code, but
then you start thinking about

169
00:09:12,480 --> 00:09:15,570
how do I abstract this so
that the next time I have

170
00:09:15,570 --> 00:09:19,530
to solve the same problem, I
can build on the abstractions

171
00:09:19,530 --> 00:09:22,620
and I can build on these building
blocks that I had before.

172
00:09:22,620 --> 00:09:25,080
And so this is a really
powerful capability

173
00:09:25,080 --> 00:09:28,290
to give our AI systems.

174
00:09:28,290 --> 00:09:32,850
And I do believe that in
the future it will help us

175
00:09:32,850 --> 00:09:35,820
not just write code

176
00:09:35,820 --> 00:09:38,310
and write solutions for the
problems we have at hand,

177
00:09:38,310 --> 00:09:40,470
but actually allow us to do more

178
00:09:40,470 --> 00:09:43,320
of what real software engineerings do,

179
00:09:43,320 --> 00:09:45,330
which is plan for the future, right?

180
00:09:45,330 --> 00:09:49,350
And plan for those abstractions
that will not just help me

181
00:09:49,350 --> 00:09:51,450
solve the current problem at hand,

182
00:09:51,450 --> 00:09:54,720
but that will be useful
to build the problems

183
00:09:54,720 --> 00:09:57,900
that I'm likely to
encounter in the future.

184
00:09:57,900 --> 00:10:02,900
So the next question here
is about natural language.

185
00:10:02,910 --> 00:10:05,340
We talk to each other in natural language.

186
00:10:05,340 --> 00:10:07,200
We would really like
to talk to our machines

187
00:10:07,200 --> 00:10:08,610
in natural language as well.

188
00:10:08,610 --> 00:10:09,780
And this is one of the things

189
00:10:09,780 --> 00:10:12,840
that this large language models
really brings to the table.

190
00:10:12,840 --> 00:10:15,060
And so the question here is,

191
00:10:15,060 --> 00:10:17,460
what role do you see
natural language playing?

192
00:10:17,460 --> 00:10:21,960
Could English or other spoken
languages effectively become

193
00:10:21,960 --> 00:10:24,240
the new programming interface?

194
00:10:24,240 --> 00:10:27,123
So, no.

195
00:10:28,350 --> 00:10:30,930
Being able to speak in
natural language is great

196
00:10:30,930 --> 00:10:33,870
and you know, this is
what we're familiar with

197
00:10:33,870 --> 00:10:35,850
from the time we were children.

198
00:10:35,850 --> 00:10:38,790
This is what we used to
talk to our colleagues.

199
00:10:38,790 --> 00:10:43,680
However, when it comes to
building really big systems,

200
00:10:43,680 --> 00:10:47,460
natural language is very
insufficient, right?

201
00:10:47,460 --> 00:10:50,850
If you've ever tried to read
the terms and conditions

202
00:10:50,850 --> 00:10:53,670
of some of the software you use,

203
00:10:53,670 --> 00:10:56,340
you've probably run into
some of the limitations

204
00:10:56,340 --> 00:10:59,310
of natural language when it
comes to communicating things

205
00:10:59,310 --> 00:11:02,100
that are really detail
oriented and complex, right?

206
00:11:02,100 --> 00:11:04,950
Any kind of legal document, you know,

207
00:11:04,950 --> 00:11:08,550
natural language very quickly
starts feeling very unnatural

208
00:11:08,550 --> 00:11:11,460
once you start having
to communicate things

209
00:11:11,460 --> 00:11:13,230
above a certain level of precision

210
00:11:13,230 --> 00:11:15,480
and above a certain scale.

211
00:11:15,480 --> 00:11:19,230
And this is where programming
languages really shine, right?

212
00:11:19,230 --> 00:11:23,190
As much as we like to
complain about the fact

213
00:11:23,190 --> 00:11:25,830
that programming languages are too brittle

214
00:11:25,830 --> 00:11:26,970
and they're too clunky

215
00:11:26,970 --> 00:11:29,070
and it's hard to learn how to use them,

216
00:11:29,070 --> 00:11:33,450
the fact of the matter is,
they are the best notation

217
00:11:33,450 --> 00:11:35,190
and the most sophisticated notation

218
00:11:35,190 --> 00:11:38,190
that we've been ever
been able to come up with

219
00:11:38,190 --> 00:11:43,190
to describe really complex
behaviors at scale.

220
00:11:43,680 --> 00:11:47,100
And so, no, I actually
don't see natural language

221
00:11:47,100 --> 00:11:51,180
completely replacing traditional
programming languages

222
00:11:51,180 --> 00:11:53,700
as the programming interface of choice.

223
00:11:53,700 --> 00:11:57,180
It doesn't mean that there
won't be a really important role

224
00:11:57,180 --> 00:12:00,060
for natural language in how we interact

225
00:12:00,060 --> 00:12:01,950
with our programming tools

226
00:12:01,950 --> 00:12:06,950
and how we talk about our goals
with the software systems.

227
00:12:07,410 --> 00:12:10,530
But at the end of the day,
it's really important to have

228
00:12:10,530 --> 00:12:13,740
that notation that can
support the precision

229
00:12:13,740 --> 00:12:18,123
and the scale that we need
for software development.

