1
00:00:12,559 --> 00:00:17,359
Okay. So I want to start with a

2
00:00:15,679 --> 00:00:19,279
timeline.

3
00:00:17,359 --> 00:00:21,920
So

4
00:00:19,279 --> 00:00:24,080
Shannon

5
00:00:21,920 --> 00:00:27,760
1948

6
00:00:24,080 --> 00:00:31,439
discovered um

7
00:00:27,760 --> 00:00:31,439
the noisy coding theorem.

8
00:00:36,559 --> 00:00:41,320
um

9
00:00:38,320 --> 00:00:41,320
Hamming

10
00:00:42,960 --> 00:00:45,960
discovered

11
00:00:46,000 --> 00:00:51,840
um

12
00:00:48,480 --> 00:00:54,320
Hamming codes in 1950.

13
00:00:51,840 --> 00:00:58,399
Um

14
00:00:54,320 --> 00:01:01,520
Reed and Solomon discovered

15
00:00:58,399 --> 00:01:04,879
Reed Solomon codes

16
00:01:01,520 --> 00:01:09,880
in 1960.

17
00:01:04,879 --> 00:01:09,880
Um, concatenated codes

18
00:01:12,720 --> 00:01:22,280
were discovered in 1966.

19
00:01:18,080 --> 00:01:22,280
and Burleamp

20
00:01:23,759 --> 00:01:29,880
Massie

21
00:01:26,320 --> 00:01:29,880
decoding algorithm

22
00:01:31,439 --> 00:01:35,640
for read Solomon codes

23
00:01:35,680 --> 00:01:40,040
was discovered in 1969.

24
00:01:41,200 --> 00:01:47,200
So this is a lot of steps and it turns

25
00:01:45,200 --> 00:01:49,040
out that the burlac massi decoding

26
00:01:47,200 --> 00:01:54,159
algorithm for read solomman codes along

27
00:01:49,040 --> 00:01:57,159
with concatenated codes was what made

28
00:01:54,159 --> 00:01:57,159
um

29
00:01:57,680 --> 00:02:05,040
using eric recting codes practical.

30
00:02:02,880 --> 00:02:08,040
And in

31
00:02:05,040 --> 00:02:08,040
Voyager

32
00:02:08,160 --> 00:02:11,479
deep space

33
00:02:14,160 --> 00:02:20,480
was 1977

34
00:02:17,680 --> 00:02:24,560
and one of the Voyager aircrafts is

35
00:02:20,480 --> 00:02:27,360
still transmitting signals to Earth

36
00:02:24,560 --> 00:02:29,599
and they're doing that using Reed

37
00:02:27,360 --> 00:02:31,280
Solomon codes which as I'm going to

38
00:02:29,599 --> 00:02:35,680
which is what I'm going to tell you

39
00:02:31,280 --> 00:02:39,040
about later in the lecture. And after

40
00:02:35,680 --> 00:02:44,319
all this stuff, Reed Solomon codes were

41
00:02:39,040 --> 00:02:46,879
still used until um

42
00:02:44,319 --> 00:02:49,360
oh, I don't know around

43
00:02:46,879 --> 00:02:51,040
19 mid 1990s.

44
00:02:49,360 --> 00:02:53,440
Actually, they were still used until

45
00:02:51,040 --> 00:02:57,599
probably around 2000. But in the mid

46
00:02:53,440 --> 00:03:00,560
1990s, these three French engineers.

47
00:02:57,599 --> 00:03:03,440
So read Solomon codes do not actually

48
00:03:00,560 --> 00:03:06,560
meet Shannon's bound from the noisy

49
00:03:03,440 --> 00:03:08,560
coding theorem. Reed Solomon codes come

50
00:03:06,560 --> 00:03:13,200
within a factor within a constant factor

51
00:03:08,560 --> 00:03:17,519
of it. But you know between 1948 for the

52
00:03:13,200 --> 00:03:21,840
next 40some years coding theorist has

53
00:03:17,519 --> 00:03:25,599
struggled to find a technique

54
00:03:21,840 --> 00:03:27,440
for actually meeting Shannon's bound

55
00:03:25,599 --> 00:03:30,799
and

56
00:03:27,440 --> 00:03:32,640
in 199 something

57
00:03:30,799 --> 00:03:34,879
this paper appeared by three French

58
00:03:32,640 --> 00:03:38,000
engineers.

59
00:03:34,879 --> 00:03:39,920
I mean, they weren't even

60
00:03:38,000 --> 00:03:44,879
they weren't even coding theorists. They

61
00:03:39,920 --> 00:03:47,920
were three people at a

62
00:03:44,879 --> 00:03:52,000
at a French telecom company and they

63
00:03:47,920 --> 00:03:54,319
claimed to meet Shannon's bound with a

64
00:03:52,000 --> 00:03:56,959
completely different technique and none

65
00:03:54,319 --> 00:03:59,840
of the coding theorist researchers

66
00:03:56,959 --> 00:04:01,519
believed it until they programmed up and

67
00:03:59,840 --> 00:04:05,519
it worked

68
00:04:01,519 --> 00:04:08,080
and even that it took many years for

69
00:04:05,519 --> 00:04:09,920
them to explain why it worked and in

70
00:04:08,080 --> 00:04:12,480
fact they still don't understand why it

71
00:04:09,920 --> 00:04:16,239
worked, why turbo codes work. They do

72
00:04:12,480 --> 00:04:20,720
understand why uh similar type of codes

73
00:04:16,239 --> 00:04:23,280
called LDP C codes work really well. But

74
00:04:20,720 --> 00:04:24,880
um

75
00:04:23,280 --> 00:04:28,960
so

76
00:04:24,880 --> 00:04:31,120
now um you know after this discovery

77
00:04:28,960 --> 00:04:34,240
read Solomon codes gradually faded out

78
00:04:31,120 --> 00:04:38,320
of use in new applications and turbo

79
00:04:34,240 --> 00:04:40,639
codes and LDPC codes and polar codes

80
00:04:38,320 --> 00:04:43,280
which were discovered in the 2000s took

81
00:04:40,639 --> 00:04:46,280
over.

82
00:04:43,280 --> 00:04:46,280
So,

83
00:04:54,240 --> 00:04:58,320
but I, you know, I find it kind of

84
00:04:55,919 --> 00:05:02,080
amazing that you needed

85
00:04:58,320 --> 00:05:04,320
something like three discoveries

86
00:05:02,080 --> 00:05:08,160
to actually make

87
00:05:04,320 --> 00:05:12,600
Shannon's Thurm practical.

88
00:05:08,160 --> 00:05:12,600
So, what is a Reed Solomon code?

89
00:05:17,199 --> 00:05:24,680
Okay. Well, it's based on a

90
00:05:20,560 --> 00:05:24,680
ancient theorem from mathematics

91
00:05:25,360 --> 00:05:28,600
uh polomial

92
00:05:32,000 --> 00:05:35,720
of degree D

93
00:05:38,320 --> 00:05:43,560
over

94
00:05:39,840 --> 00:05:43,560
a finite field.

95
00:05:47,039 --> 00:05:52,479
has

96
00:05:49,280 --> 00:05:56,680
at most

97
00:05:52,479 --> 00:05:56,680
d roots.

98
00:05:58,944 --> 00:06:00,964
[sighs]

99
00:06:02,560 --> 00:06:07,639
Okay. So a read Solomon code

100
00:06:09,759 --> 00:06:13,319
you have a message

101
00:06:14,319 --> 00:06:18,360
M0 through MK

102
00:06:22,319 --> 00:06:27,919
well MK minus one because we're starting

103
00:06:25,039 --> 00:06:31,720
with zero.

104
00:06:27,919 --> 00:06:31,720
Associate the polomial

105
00:06:38,720 --> 00:06:53,400
P of X = M0 + M1 X + M2 X^2 +

106
00:06:47,919 --> 00:06:53,400
M K -1 X K -1.

107
00:06:58,560 --> 00:07:03,520
So

108
00:07:00,160 --> 00:07:05,840
this is the message and once you have

109
00:07:03,520 --> 00:07:09,759
the message you

110
00:07:05,840 --> 00:07:12,759
construct this polomial although um I

111
00:07:09,759 --> 00:07:12,759
mean

112
00:07:13,120 --> 00:07:17,440
we're not going to actually um transmit

113
00:07:16,080 --> 00:07:21,800
the polinomial what we're going to

114
00:07:17,440 --> 00:07:21,800
transmit is

115
00:07:24,880 --> 00:07:28,479
um

116
00:07:26,800 --> 00:07:31,520
the code

117
00:07:28,479 --> 00:07:33,360
which is P of

118
00:07:31,520 --> 00:07:38,639
0,

119
00:07:33,360 --> 00:07:42,639
P of 1, P of 2, all the way up through P

120
00:07:38,639 --> 00:07:46,560
of N minus one.

121
00:07:42,639 --> 00:07:51,880
Now you know to do this we need

122
00:07:46,560 --> 00:07:51,880
n is less than or equal to

123
00:07:54,560 --> 00:08:00,400
okay so this is over a finite field and

124
00:07:58,879 --> 00:08:04,560
for this lecture we will assume the

125
00:08:00,400 --> 00:08:06,560
finite field is the integers mod p in

126
00:08:04,560 --> 00:08:08,720
real life

127
00:08:06,560 --> 00:08:12,319
um

128
00:08:08,720 --> 00:08:14,080
read mo read sol read read solomon codes

129
00:08:12,319 --> 00:08:17,120
were actually they actually use the

130
00:08:14,080 --> 00:08:20,319
polomial Z over the finite field with 2

131
00:08:17,120 --> 00:08:25,120
to the K elements but that's because

132
00:08:20,319 --> 00:08:27,840
they're using binary and 2 to the K is

133
00:08:25,120 --> 00:08:30,400
very convenient for binary

134
00:08:27,840 --> 00:08:34,080
but the theory is exactly the same if we

135
00:08:30,400 --> 00:08:38,320
take Z subp and um so for this well we

136
00:08:34,080 --> 00:08:40,240
need n minus one different elements in

137
00:08:38,320 --> 00:08:41,839
the field

138
00:08:40,240 --> 00:08:45,519
and are n different elements in the

139
00:08:41,839 --> 00:08:48,000
field and for that we need n

140
00:08:45,519 --> 00:08:52,279
is

141
00:08:48,000 --> 00:08:52,279
is at most p

142
00:08:56,240 --> 00:09:05,279
and in fact as an aside you don't have

143
00:08:59,519 --> 00:09:09,240
to use 0 1 2 through n minus one

144
00:09:05,279 --> 00:09:09,240
for the um

145
00:09:09,600 --> 00:09:15,519
for these points points. You could just

146
00:09:11,120 --> 00:09:18,160
use any n distinct points, but

147
00:09:15,519 --> 00:09:20,800
you know, the lecture notes start out by

148
00:09:18,160 --> 00:09:24,080
saying choose end points and then they

149
00:09:20,800 --> 00:09:25,839
say later we'll use the points 0 through

150
00:09:24,080 --> 00:09:30,360
n minus one. So I'm just going to start

151
00:09:25,839 --> 00:09:30,360
out with 0 through n minus one.

152
00:09:30,399 --> 00:09:33,399
Okay.

153
00:09:41,279 --> 00:09:45,839
and

154
00:09:43,040 --> 00:09:49,880
note

155
00:09:45,839 --> 00:09:49,880
read Solomon's codes

156
00:09:54,880 --> 00:09:59,320
are linear

157
00:09:59,600 --> 00:10:05,760
and the generator matrix G

158
00:10:02,720 --> 00:10:10,279
is equal to

159
00:10:05,760 --> 00:10:10,279
1 0 0 0 0

160
00:10:10,800 --> 00:10:14,200
1 1 1

161
00:10:14,480 --> 00:10:20,240
2 4

162
00:10:16,959 --> 00:10:26,360
um 8

163
00:10:20,240 --> 00:10:26,360
etc. 2 to the k -1

164
00:10:27,360 --> 00:10:41,480
3 9 27 etc. and 3 to the k minus one

165
00:10:35,279 --> 00:10:41,480
all the way up to well how many um

166
00:10:42,399 --> 00:10:47,600
how many values of the polomial are

167
00:10:45,680 --> 00:10:50,600
there

168
00:10:47,600 --> 00:10:50,600
are

169
00:10:52,000 --> 00:10:56,959
I mean how many numbers do you plug into

170
00:10:54,800 --> 00:11:00,560
the polomial there are n minus one so

171
00:10:56,959 --> 00:11:08,880
this last row last column is one n minus

172
00:11:00,560 --> 00:11:12,480
1 n -1^ 2ar through n -1 to the k -1

173
00:11:08,880 --> 00:11:18,560
and I should note that these numbers are

174
00:11:12,480 --> 00:11:22,399
all mod z subp. So if P was 13, this

175
00:11:18,560 --> 00:11:26,447
entry would not be 27 but one.

176
00:11:22,399 --> 00:11:27,760
Oh well, I mean 27 is one mod 13 but

177
00:11:26,447 --> 00:11:32,480
[snorts]

178
00:11:27,760 --> 00:11:37,120
yeah. So this is the generary matrix G.

179
00:11:32,480 --> 00:11:40,160
And if you put in m0 m1

180
00:11:37,120 --> 00:11:47,360
through mk,

181
00:11:40,160 --> 00:11:53,760
the i entry in the code word is just 1 +

182
00:11:47,360 --> 00:12:00,440
m1 * 3 1st + m2 * 3 2 + m3 * 3 cubed

183
00:11:53,760 --> 00:12:00,440
etc. Which is the value of p of x at 3.

184
00:12:02,320 --> 00:12:07,279
So they're linear codes

185
00:12:04,880 --> 00:12:10,000
which

186
00:12:07,279 --> 00:12:13,839
means that

187
00:12:10,000 --> 00:12:17,639
um we want to find how many

188
00:12:13,839 --> 00:12:17,639
errors they can correct.

189
00:12:36,639 --> 00:12:42,320
So remember

190
00:12:39,440 --> 00:12:43,920
okay so

191
00:12:42,320 --> 00:12:46,320
need

192
00:12:43,920 --> 00:12:47,839
to find

193
00:12:46,320 --> 00:12:52,160
minimum

194
00:12:47,839 --> 00:12:54,480
weight non zero

195
00:12:52,160 --> 00:12:54,480
code

196
00:12:57,200 --> 00:13:01,560
If weight

197
00:13:02,720 --> 00:13:11,160
let's give this a name C. If weight of C

198
00:13:05,760 --> 00:13:11,160
is equal to D we can correct

199
00:13:11,440 --> 00:13:17,399
D -1 / 2 errors.

200
00:13:28,160 --> 00:13:31,160
thermum

201
00:13:32,560 --> 00:13:38,800
and that's because the minimum distance

202
00:13:35,200 --> 00:13:42,360
between any two code words is d minus

203
00:13:38,800 --> 00:13:42,360
one / two

204
00:13:43,200 --> 00:13:46,200
minimum

205
00:13:46,399 --> 00:13:52,440
Wait.

206
00:13:48,560 --> 00:13:52,440
Nonzero code word

207
00:13:59,440 --> 00:14:03,320
has weight

208
00:14:05,920 --> 00:14:11,720
n - k + 1.

209
00:14:19,920 --> 00:14:22,920
proof

210
00:14:22,959 --> 00:14:26,519
the code word.

211
00:14:26,560 --> 00:14:31,440
Well, we know what the code word is.

212
00:14:28,800 --> 00:14:34,680
It's just P of 0, P of 1 through P of N

213
00:14:31,440 --> 00:14:34,680
minus one.

214
00:14:51,040 --> 00:14:58,800
where

215
00:14:52,959 --> 00:15:03,839
P = M0 + M1 X +

216
00:14:58,800 --> 00:15:07,639
M K -1 X to the K -1

217
00:15:03,839 --> 00:15:07,639
is the

218
00:15:09,040 --> 00:15:13,639
is a polomial of degree K

219
00:15:14,880 --> 00:15:19,519
and remember that the polomial this

220
00:15:17,279 --> 00:15:21,760
polomial is actually the coefficients

221
00:15:19,519 --> 00:15:25,040
are the message so it could be any

222
00:15:21,760 --> 00:15:28,440
polinomial of degree K of degree K minus

223
00:15:25,040 --> 00:15:28,440
one sorry

224
00:15:29,360 --> 00:15:35,120
and now we use this theorem that I

225
00:15:32,480 --> 00:15:37,760
reminded you a A little while ago, a

226
00:15:35,120 --> 00:15:42,120
polomial of degree D has at most d

227
00:15:37,760 --> 00:15:42,120
roots. So

228
00:15:43,199 --> 00:15:53,720
P of X has at most

229
00:15:49,040 --> 00:15:53,720
k minus one zeros.

230
00:15:56,720 --> 00:16:04,920
So at most k minus one of these entries

231
00:15:59,519 --> 00:16:04,920
are zero, which means at least

232
00:16:07,440 --> 00:16:13,240
n minus k + one

233
00:16:13,839 --> 00:16:16,839
um

234
00:16:17,920 --> 00:16:22,560
values

235
00:16:19,680 --> 00:16:27,320
of p subi

236
00:16:22,560 --> 00:16:27,320
are non zero

237
00:16:30,399 --> 00:16:37,360
because you have

238
00:16:33,519 --> 00:16:40,800
n values in the code word k minus one of

239
00:16:37,360 --> 00:16:43,920
them or fewer are zero which means this

240
00:16:40,800 --> 00:16:47,240
many have to be non zero. So the minimum

241
00:16:43,920 --> 00:16:47,240
Hamming weight

242
00:16:53,440 --> 00:17:00,360
is n - k + 1.

243
00:17:09,760 --> 00:17:13,880
Suppose we want to correct

244
00:17:18,319 --> 00:17:24,240
um

245
00:17:20,799 --> 00:17:26,480
e errors.

246
00:17:24,240 --> 00:17:30,039
Well, we need

247
00:17:26,480 --> 00:17:30,039
minimum distance

248
00:17:30,320 --> 00:17:37,000
to be greater than equal to 2 e + 1.

249
00:17:37,200 --> 00:17:43,120
And

250
00:17:39,520 --> 00:17:47,360
that means we need

251
00:17:43,120 --> 00:17:51,520
n - k + 1 greater than or equal to 2 e +

252
00:17:47,360 --> 00:17:54,840
1 or n minus k is greater than equal to

253
00:17:51,520 --> 00:17:54,840
2 e.

254
00:17:56,080 --> 00:18:02,919
Okay. So that are our read solomon

255
00:17:59,919 --> 00:18:02,919
codes.

256
00:18:03,120 --> 00:18:07,039
Now

257
00:18:04,720 --> 00:18:10,039
remember that

258
00:18:07,039 --> 00:18:10,039
to

259
00:18:10,880 --> 00:18:18,720
have an have a usable code, we not only

260
00:18:15,600 --> 00:18:20,400
need to be able to

261
00:18:18,720 --> 00:18:23,039
encode,

262
00:18:20,400 --> 00:18:27,200
but we also need to be able to correct

263
00:18:23,039 --> 00:18:31,039
errors and decode. So the question is

264
00:18:27,200 --> 00:18:33,120
how do you decode?

265
00:18:31,039 --> 00:18:37,200
So this is what I will spend probably

266
00:18:33,120 --> 00:18:40,200
the next half hour telling you.

267
00:18:37,200 --> 00:18:40,200
Okay.

268
00:18:43,840 --> 00:18:48,679
And I am not going to give you the

269
00:18:49,039 --> 00:18:54,240
not going to give you the burlac massie

270
00:18:51,919 --> 00:18:58,799
decoding algorithm

271
00:18:54,240 --> 00:19:00,400
because that is conceptually very

272
00:18:58,799 --> 00:19:04,000
or I shouldn't say very that's

273
00:19:00,400 --> 00:19:06,720
conceptually fairly difficult and I'm

274
00:19:04,000 --> 00:19:08,960
going to give you a much easier

275
00:19:06,720 --> 00:19:11,120
decoding algorithm to explain which is

276
00:19:08,960 --> 00:19:14,160
not as efficient as a burleamp Massie

277
00:19:11,120 --> 00:19:16,640
decoding algorithm and there's another

278
00:19:14,160 --> 00:19:20,400
decoding algorithm which is probably

279
00:19:16,640 --> 00:19:23,679
equally efficient which is based on the

280
00:19:20,400 --> 00:19:26,080
uklidian algorithm for finding you know

281
00:19:23,679 --> 00:19:27,280
greatest common divisor but I'm not

282
00:19:26,080 --> 00:19:30,160
going to give you that one either

283
00:19:27,280 --> 00:19:32,559
because again that's fairly difficult

284
00:19:30,160 --> 00:19:32,559
conceptually

285
00:19:51,840 --> 00:19:58,000
How do we

286
00:19:55,120 --> 00:20:01,120
decode?

287
00:19:58,000 --> 00:20:04,120
So this decoding algorithm is based on a

288
00:20:01,120 --> 00:20:04,120
theorem.

289
00:20:16,559 --> 00:20:19,679
So

290
00:20:18,080 --> 00:20:22,400
the

291
00:20:19,679 --> 00:20:25,960
suppose

292
00:20:22,400 --> 00:20:25,960
we have

293
00:20:26,960 --> 00:20:30,600
a code word

294
00:20:32,960 --> 00:20:42,039
C equals P of 0 P of 1 through P of N

295
00:20:38,720 --> 00:20:42,039
minus one

296
00:20:42,960 --> 00:20:50,320
we get the transmission H

297
00:20:48,000 --> 00:20:56,039
rather we receive

298
00:20:50,320 --> 00:20:56,039
the thing the um

299
00:20:56,799 --> 00:21:05,280
code word with some errors in it.

300
00:21:00,480 --> 00:21:08,480
C tilda equals R comma R1 comma R2

301
00:21:05,280 --> 00:21:11,120
through R NUS1.

302
00:21:08,480 --> 00:21:14,559
And these guys

303
00:21:11,120 --> 00:21:21,360
are not going to have a polomial where

304
00:21:14,559 --> 00:21:23,679
RA equals P of I. For some of these,

305
00:21:21,360 --> 00:21:26,640
we have

306
00:21:23,679 --> 00:21:29,960
RA equals P of I. But for some others,

307
00:21:26,640 --> 00:21:29,960
we won't.

308
00:21:32,559 --> 00:21:40,400
Assume

309
00:21:35,200 --> 00:21:43,400
there are L less than E

310
00:21:40,400 --> 00:21:43,400
errors.

311
00:21:48,240 --> 00:21:54,679
Then there

312
00:21:50,240 --> 00:21:54,679
are positions

313
00:21:57,760 --> 00:22:04,360
I1 I2 through IIL where

314
00:22:04,880 --> 00:22:12,360
P of I subL is not equal to R.

315
00:22:14,080 --> 00:22:21,280
P sub I sub K is not equal to R of

316
00:22:19,120 --> 00:22:24,240
R sub

317
00:22:21,280 --> 00:22:26,880
I subK.

318
00:22:24,240 --> 00:22:29,360
So we have at most L errors and we

319
00:22:26,880 --> 00:22:33,320
assume there are positions in positions

320
00:22:29,360 --> 00:22:33,320
I1 through IIL

321
00:22:33,600 --> 00:22:39,360
and L is less than or equal to E because

322
00:22:36,640 --> 00:22:44,520
we're assuming there are fewer errors

323
00:22:39,360 --> 00:22:44,520
than the code is able to decode.

324
00:22:44,799 --> 00:22:49,440
So this is the hypothesis of the theorem

325
00:22:47,440 --> 00:22:52,000
and I need to put the theorem itself on

326
00:22:49,440 --> 00:22:55,240
a different board

327
00:22:52,000 --> 00:22:55,240
are the

328
00:22:59,440 --> 00:23:02,440
then

329
00:23:04,799 --> 00:23:07,799
um

330
00:23:09,120 --> 00:23:12,120
continued

331
00:23:16,720 --> 00:23:23,159
There are nonzero polomials

332
00:23:28,080 --> 00:23:31,880
f and q

333
00:23:34,816 --> 00:23:39,520
[clears throat] and q of x

334
00:23:37,360 --> 00:23:42,000
of degree

335
00:23:39,520 --> 00:23:47,400
less than or equal

336
00:23:42,000 --> 00:23:47,400
K + E - 1

337
00:23:51,760 --> 00:23:55,480
such that

338
00:23:56,000 --> 00:24:04,679
Q of I is equal to

339
00:23:59,440 --> 00:24:04,679
R subi * F sub I.

340
00:24:06,240 --> 00:24:09,240
Okay.

341
00:24:09,360 --> 00:24:13,679
So this looks like a totally crazy

342
00:24:11,919 --> 00:24:15,440
theorem. What does it have to do with

343
00:24:13,679 --> 00:24:18,159
decoding?

344
00:24:15,440 --> 00:24:21,200
Well,

345
00:24:18,159 --> 00:24:22,480
um I mean you will see what have to do

346
00:24:21,200 --> 00:24:24,400
with decoding when I give you the

347
00:24:22,480 --> 00:24:27,720
decoding algorithm. But first let's

348
00:24:24,400 --> 00:24:27,720
prove the theorem.

349
00:24:32,080 --> 00:24:37,799
Let f ofx equal

350
00:24:39,039 --> 00:24:47,520
x - i1

351
00:24:41,520 --> 00:24:53,120
x - i2 through x - i subl is equal to

352
00:24:47,520 --> 00:24:55,120
the product of x - i subk k = 1 through

353
00:24:53,120 --> 00:24:58,240
l.

354
00:24:55,120 --> 00:25:00,720
So this is

355
00:24:58,240 --> 00:25:03,360
you just take all the positions which

356
00:25:00,720 --> 00:25:05,679
are in error. Of course you don't know

357
00:25:03,360 --> 00:25:10,000
which positions are in error when you

358
00:25:05,679 --> 00:25:12,880
receive this

359
00:25:10,000 --> 00:25:15,360
this word which is you know the code

360
00:25:12,880 --> 00:25:18,640
word with at most e errors. [snorts] But

361
00:25:15,360 --> 00:25:22,320
we'll let f ofx be that

362
00:25:18,640 --> 00:25:24,960
because and um

363
00:25:22,320 --> 00:25:26,960
and we will let

364
00:25:24,960 --> 00:25:32,440
q of x

365
00:25:26,960 --> 00:25:32,440
= p of x * f ofx.

366
00:25:58,880 --> 00:26:01,880
Okay.

367
00:26:02,799 --> 00:26:06,440
Oh, I think we

368
00:26:12,640 --> 00:26:15,640
If

369
00:26:19,120 --> 00:26:26,799
I I should have put this down.

370
00:26:23,120 --> 00:26:33,200
Q of I= R subi F subi

371
00:26:26,799 --> 00:26:39,000
for I = 0 1 through N minus one. So this

372
00:26:33,200 --> 00:26:39,000
is only true at the positions

373
00:26:39,600 --> 00:26:46,400
which give you values in the code.

374
00:26:43,360 --> 00:26:49,360
And of course this

375
00:26:46,400 --> 00:26:53,919
you know r subi is not defined for any

376
00:26:49,360 --> 00:26:57,799
position other than 0 1 through n minus

377
00:26:53,919 --> 00:26:57,799
one. So

378
00:26:58,720 --> 00:27:04,159
this condition is probably a little bit

379
00:27:01,120 --> 00:27:07,600
unnecessary but still I'm going to write

380
00:27:04,159 --> 00:27:13,039
it. So if

381
00:27:07,600 --> 00:27:15,840
I is in I1

382
00:27:13,039 --> 00:27:18,840
through I sub

383
00:27:15,840 --> 00:27:18,840
L.

384
00:27:20,880 --> 00:27:26,000
Then

385
00:27:22,799 --> 00:27:30,320
f of

386
00:27:26,000 --> 00:27:32,880
i equals zero. Right?

387
00:27:30,320 --> 00:27:36,640
Because

388
00:27:32,880 --> 00:27:41,520
f ofx was just the product of x minus i

389
00:27:36,640 --> 00:27:44,559
sub k where i is

390
00:27:41,520 --> 00:27:47,559
in this set

391
00:27:44,559 --> 00:27:47,559
and

392
00:27:50,320 --> 00:27:57,360
q of x = p of x f ofx

393
00:27:55,200 --> 00:28:02,480
= z

394
00:27:57,360 --> 00:28:05,880
or q of i = p of I * f of i

395
00:28:02,480 --> 00:28:05,880
equals z.

396
00:28:07,039 --> 00:28:11,919
So

397
00:28:09,360 --> 00:28:19,240
we wanted to show that q of i = r sub i

398
00:28:11,919 --> 00:28:19,240
* f of i. Q of I = R subi * F of I

399
00:28:22,799 --> 00:28:27,840
equals Z

400
00:28:25,360 --> 00:28:30,399
because remember Q of X was P of X * F

401
00:28:27,840 --> 00:28:35,840
ofX.

402
00:28:30,399 --> 00:28:38,240
Okay. So the other alternative is if I

403
00:28:35,840 --> 00:28:42,960
is not in

404
00:28:38,240 --> 00:28:45,120
the set of positions where things are in

405
00:28:42,960 --> 00:28:48,120
error

406
00:28:45,120 --> 00:28:48,120
then

407
00:28:48,159 --> 00:28:58,919
well if there are no errors then

408
00:28:53,200 --> 00:28:58,919
r subi equals p of i

409
00:28:59,760 --> 00:29:06,520
and q of I is equal to P of I *

410
00:29:08,399 --> 00:29:11,960
R sub I

411
00:29:12,640 --> 00:29:15,640
um

412
00:29:26,320 --> 00:29:32,080
Q of I equals R P Q of I= P of I * F of

413
00:29:30,320 --> 00:29:35,520
I

414
00:29:32,080 --> 00:29:39,200
which is equal to since RA I equals P of

415
00:29:35,520 --> 00:29:42,679
I it's R subi *

416
00:29:39,200 --> 00:29:42,679
F of I

417
00:29:44,559 --> 00:29:50,880
and that's what we wanted Q of I= R

418
00:29:47,279 --> 00:29:53,520
subi* F of I. So whether or not I is in

419
00:29:50,880 --> 00:29:58,240
the position containing the errors Q of

420
00:29:53,520 --> 00:30:01,279
I= P of I * F of I.

421
00:29:58,240 --> 00:30:03,840
Okay, so that's the theorem. We have

422
00:30:01,279 --> 00:30:05,679
these

423
00:30:03,840 --> 00:30:09,919
um

424
00:30:05,679 --> 00:30:14,120
two polomials f ofx and q of x which

425
00:30:09,919 --> 00:30:14,120
have this relation between them.

426
00:30:16,559 --> 00:30:21,799
How do we decode

427
00:30:23,120 --> 00:30:26,840
linear algebra?

428
00:30:28,320 --> 00:30:35,600
So the lecture notes give you a explicit

429
00:30:31,760 --> 00:30:39,200
example of how to decode but I am not

430
00:30:35,600 --> 00:30:44,320
going to go through it in class because

431
00:30:39,200 --> 00:30:47,440
you know it's really fairly tedious to

432
00:30:44,320 --> 00:30:51,240
um go through and I will just

433
00:30:47,440 --> 00:30:51,240
explain the theory.

434
00:30:52,960 --> 00:31:00,559
So we have Q of I = R subi * F of I. So

435
00:30:57,679 --> 00:31:09,440
this is a whole bunch of equations. Q of

436
00:31:00,559 --> 00:31:16,320
0 = R0 * F of 0. Q of 1 = R1 * F of 1. Q

437
00:31:09,440 --> 00:31:20,000
of 2 = R2 * F of 2 all the way down to Q

438
00:31:16,320 --> 00:31:25,840
of N -1

439
00:31:20,000 --> 00:31:28,880
= R sub N -1 * F N -1.

440
00:31:25,840 --> 00:31:31,360
So these equations

441
00:31:28,880 --> 00:31:34,399
you can think of these equations as

442
00:31:31,360 --> 00:31:37,559
linear equations and the coefficients of

443
00:31:34,399 --> 00:31:37,559
the polinomials.

444
00:31:46,720 --> 00:31:49,720
And

445
00:31:51,200 --> 00:31:58,720
okay, so what do they look like in terms

446
00:31:54,640 --> 00:32:01,200
of the linear equations in the um well Q

447
00:31:58,720 --> 00:32:03,679
of 0?

448
00:32:01,200 --> 00:32:12,480
Well, I should probably say what the

449
00:32:03,679 --> 00:32:14,080
coefficients are. Q of X = Q0 + Q1 X +

450
00:32:12,480 --> 00:32:16,799
Q

451
00:32:14,080 --> 00:32:21,760
sub

452
00:32:16,799 --> 00:32:29,360
um K + C - 1

453
00:32:21,760 --> 00:32:34,000
X to the K + E - one and F of X = F0

454
00:32:29,360 --> 00:32:38,120
plus F_sub_1X plus

455
00:32:34,000 --> 00:32:38,120
so this has degree e.

456
00:32:38,880 --> 00:32:48,200
Um so it's f sub e

457
00:32:43,360 --> 00:32:48,200
um x to the e.

458
00:32:48,480 --> 00:32:51,480
Okay.

459
00:32:57,440 --> 00:33:03,039
So what do these equations look like?

460
00:32:59,600 --> 00:33:09,159
Well, the first one q of 0 is just q0.

461
00:33:03,039 --> 00:33:09,159
So it's Q0 equals R0 F0.

462
00:33:09,440 --> 00:33:18,720
The next one is Q of 1. So it's just Q0

463
00:33:13,440 --> 00:33:23,840
plus Q1 + Q2 plus dot dot dot plus Q.

464
00:33:18,720 --> 00:33:26,240
And what was the degree? K + E minus one

465
00:33:23,840 --> 00:33:33,279
is equal to

466
00:33:26,240 --> 00:33:40,480
R1 F0 + F1 plus D plus F sub. And the

467
00:33:33,279 --> 00:33:47,840
next one is F of 2. So it's q0 + 4 + 2

468
00:33:40,480 --> 00:33:50,240
q1 + 4 q2 + dot dot dot + 2 to the k + e

469
00:33:47,840 --> 00:33:54,720
minus one

470
00:33:50,240 --> 00:34:01,200
q sub k + e minus one. Of course

471
00:33:54,720 --> 00:34:04,880
this is mod p. So you don't

472
00:34:01,200 --> 00:34:07,440
so the numbers don't actually grow huge.

473
00:34:04,880 --> 00:34:10,440
And this equals

474
00:34:07,440 --> 00:34:10,440
um

475
00:34:15,520 --> 00:34:26,520
R sub 2 F0 + 2 F1 plus dot dot dot plus

476
00:34:22,079 --> 00:34:26,520
2 to the E F sub.

477
00:34:32,000 --> 00:34:36,879
Okay, I'm going to claim this is a

478
00:34:34,800 --> 00:34:38,720
linear

479
00:34:36,879 --> 00:34:40,240
equation

480
00:34:38,720 --> 00:34:43,040
in

481
00:34:40,240 --> 00:34:44,639
coefficients

482
00:34:43,040 --> 00:34:47,839
of

483
00:34:44,639 --> 00:34:52,320
Q and R. Well, what are the coefficients

484
00:34:47,839 --> 00:34:56,399
of Q1 and R? Well, there's Q0, Q1, Q2, Q

485
00:34:52,320 --> 00:34:59,960
plus C minus one, and F0, F_sub_1

486
00:34:56,399 --> 00:34:59,960
through F sub.

487
00:35:00,000 --> 00:35:05,960
And it's clearly a linear equation in

488
00:35:02,720 --> 00:35:05,960
the coefficients.

489
00:35:41,599 --> 00:35:45,280
So

490
00:35:43,280 --> 00:35:48,280
linear

491
00:35:45,280 --> 00:35:48,280
algebra.

492
00:35:51,119 --> 00:35:55,200
Okay.

493
00:35:52,240 --> 00:35:58,079
We have a bunch of linear equations

494
00:35:55,200 --> 00:36:01,880
and a bunch of variables. How many

495
00:35:58,079 --> 00:36:01,880
solutions do they have?

496
00:36:18,079 --> 00:36:21,079
Well,

497
00:36:25,440 --> 00:36:32,359
Let's see

498
00:36:28,720 --> 00:36:32,359
how many variables.

499
00:36:40,400 --> 00:36:47,680
Well, there are e + one variables in f

500
00:36:44,000 --> 00:36:51,760
ofx because they're e+1 coefficients.

501
00:36:47,680 --> 00:36:54,560
And there are k + e minus one + one

502
00:36:51,760 --> 00:36:58,400
variables in q of x because there are k

503
00:36:54,560 --> 00:37:01,680
plus e coefficients.

504
00:36:58,400 --> 00:37:05,040
So a variable, how many variables there

505
00:37:01,680 --> 00:37:08,440
are? K

506
00:37:05,040 --> 00:37:08,440
plus E

507
00:37:10,480 --> 00:37:15,480
um plus E + 1.

508
00:37:18,960 --> 00:37:24,280
How many

509
00:37:21,280 --> 00:37:24,280
equations?

510
00:37:25,760 --> 00:37:30,800
Well,

511
00:37:28,000 --> 00:37:33,440
there are n equations because we have

512
00:37:30,800 --> 00:37:36,680
one for q0, q1 all the way up to q of n

513
00:37:33,440 --> 00:37:36,680
minus one.

514
00:37:37,359 --> 00:37:40,839
n equations.

515
00:37:44,079 --> 00:37:52,599
But somewhere we have n minus k

516
00:37:48,320 --> 00:37:52,599
equals 2 e.

517
00:38:00,560 --> 00:38:06,960
And up there we said we needed n minus k

518
00:38:04,800 --> 00:38:08,720
greater than or equal to 2 e to correct

519
00:38:06,960 --> 00:38:11,359
the errors. But let's assume that n

520
00:38:08,720 --> 00:38:14,320
minus k equals 2 e because that's the

521
00:38:11,359 --> 00:38:17,200
minimum

522
00:38:14,320 --> 00:38:18,800
that's the minimum we need to correct e

523
00:38:17,200 --> 00:38:27,200
errors.

524
00:38:18,800 --> 00:38:30,240
So n minus k = 2 e. So we have k + 2 e

525
00:38:27,200 --> 00:38:35,440
+ 1 variables

526
00:38:30,240 --> 00:38:38,160
and k + 2 e equations.

527
00:38:35,440 --> 00:38:43,560
And these equations are all linearly

528
00:38:38,160 --> 00:38:43,560
independent. And how do you see that?

529
00:38:45,520 --> 00:38:52,960
Okay, I'm not going to really

530
00:38:48,560 --> 00:38:52,960
explain this in full detail.

531
00:39:00,480 --> 00:39:13,920
But remember G is equal to 1 0 0 0

532
00:39:06,160 --> 00:39:16,920
1 1 1 through 1 1 2 4 8 through 2 to the

533
00:39:13,920 --> 00:39:16,920
um

534
00:39:17,119 --> 00:39:27,040
n minus one

535
00:39:19,359 --> 00:39:32,119
3 9 27 through 3 to the nus1 etc.

536
00:39:27,040 --> 00:39:32,119
So this is a Vandermon matrix

537
00:39:37,760 --> 00:39:42,040
and Vandermon matrices

538
00:39:48,000 --> 00:39:53,079
have

539
00:39:49,760 --> 00:39:53,079
full rank.

540
00:39:55,680 --> 00:40:01,280
And this is a theorem which we could

541
00:39:58,320 --> 00:40:05,040
easily have proved at some point in our

542
00:40:01,280 --> 00:40:08,960
course but we didn't and I'm not going

543
00:40:05,040 --> 00:40:11,359
to prove it today. But this is the

544
00:40:08,960 --> 00:40:16,240
generating function. This is sorry the

545
00:40:11,359 --> 00:40:20,400
generating ma matrix for our code and it

546
00:40:16,240 --> 00:40:23,119
has full rank. And by using

547
00:40:20,400 --> 00:40:26,560
that fact and a similar fact on the

548
00:40:23,119 --> 00:40:31,040
right hand side for the fs, you can show

549
00:40:26,560 --> 00:40:35,440
that these linear equations have full

550
00:40:31,040 --> 00:40:40,160
rank. Which means that um

551
00:40:35,440 --> 00:40:44,640
we have n minus k equals

552
00:40:40,160 --> 00:40:49,359
we have k + 2 e um linearly independent

553
00:40:44,640 --> 00:40:52,000
equations and k + 2 e + 1 variables and

554
00:40:49,359 --> 00:40:54,720
that means

555
00:40:52,000 --> 00:40:58,240
there exist

556
00:40:54,720 --> 00:41:02,000
there exists

557
00:40:58,240 --> 00:41:05,000
a nonzero So

558
00:41:02,000 --> 00:41:05,000
solution

559
00:41:08,480 --> 00:41:12,040
and in fact

560
00:41:13,440 --> 00:41:20,000
um

561
00:41:15,200 --> 00:41:23,280
you can use the fact that f sub equals 1

562
00:41:20,000 --> 00:41:25,359
because f was

563
00:41:23,280 --> 00:41:29,240
yeah

564
00:41:25,359 --> 00:41:29,240
f was this

565
00:41:29,520 --> 00:41:34,440
and so f sub equals 1.

566
00:41:34,720 --> 00:41:41,640
Use f subb = 1 to get a unique solution

567
00:41:49,920 --> 00:41:52,920
assuming

568
00:41:53,920 --> 00:41:57,880
l equals e.

569
00:41:58,400 --> 00:42:03,359
Okay, I don't know what happens when l

570
00:42:01,119 --> 00:42:05,119
is the number of actual errors is

571
00:42:03,359 --> 00:42:08,319
smaller than e. the maximum number of

572
00:42:05,119 --> 00:42:10,880
errors you can correct. Um,

573
00:42:08,319 --> 00:42:14,720
and other error correction algorithms

574
00:42:10,880 --> 00:42:16,480
for um, read Solomon codes, you

575
00:42:14,720 --> 00:42:18,240
basically have to go through all

576
00:42:16,480 --> 00:42:20,720
possibilities

577
00:42:18,240 --> 00:42:24,319
of

578
00:42:20,720 --> 00:42:26,079
how big L is and check each one out.

579
00:42:24,319 --> 00:42:28,400
Except there are usually much simpler

580
00:42:26,079 --> 00:42:31,254
ways to do that than going through all

581
00:42:28,400 --> 00:42:33,119
of these um, possibilities.

582
00:42:31,254 --> 00:42:36,000
[clears throat]

583
00:42:33,119 --> 00:42:38,319
Okay, so we have

584
00:42:36,000 --> 00:42:43,079
one solution

585
00:42:38,319 --> 00:42:43,079
to all of these equations.

586
00:42:43,520 --> 00:42:51,520
And that means we can figure out what

587
00:42:48,560 --> 00:42:56,720
q of x and f ofx are

588
00:42:51,520 --> 00:42:59,280
because we know that q of x and sorry q

589
00:42:56,720 --> 00:43:03,839
of x and p of x are because we know that

590
00:42:59,280 --> 00:43:06,839
q of x and p of x satisfy these

591
00:43:03,839 --> 00:43:06,839
um

592
00:43:08,560 --> 00:43:17,200
I'm sorry we know we can figure out what

593
00:43:11,359 --> 00:43:20,079
f ofx and q ofx are because we had

594
00:43:17,200 --> 00:43:22,720
um linear equations

595
00:43:20,079 --> 00:43:28,520
for the coefficients of q of x and f

596
00:43:22,720 --> 00:43:28,520
ofx. So we can deduce q ofx and f ofx.

597
00:43:40,160 --> 00:43:44,319
So linear

598
00:43:42,640 --> 00:43:46,480
algebra

599
00:43:44,319 --> 00:43:51,119
gives

600
00:43:46,480 --> 00:43:54,480
q of x and f ofx

601
00:43:51,119 --> 00:43:57,920
and we had p of x

602
00:43:54,480 --> 00:44:00,079
this was the message

603
00:43:57,920 --> 00:44:03,520
* f ofx

604
00:44:00,079 --> 00:44:08,880
= q of x.

605
00:44:03,520 --> 00:44:12,319
So p of x = q ofx

606
00:44:08,880 --> 00:44:17,000
over f ofx

607
00:44:12,319 --> 00:44:17,000
and we have gotten the message back.

608
00:44:20,160 --> 00:44:23,160
Okay,

609
00:44:24,079 --> 00:44:29,040
so that's how to decode read Solomon

610
00:44:26,319 --> 00:44:31,839
codes.

611
00:44:29,040 --> 00:44:38,160
The last thing I want to do is tell you

612
00:44:31,839 --> 00:44:42,000
about concatenated codes and what

613
00:44:38,160 --> 00:44:45,480
and why these make read Solomon codes

614
00:44:42,000 --> 00:44:45,480
truly practical.

615
00:45:02,319 --> 00:45:11,480
So we have n = k + e

616
00:45:07,680 --> 00:45:11,480
plus 2 e sorry

617
00:45:12,079 --> 00:45:17,240
for read solen codes

618
00:45:22,000 --> 00:45:25,119
and let's assume

619
00:45:26,400 --> 00:45:32,960
Assume

620
00:45:28,800 --> 00:45:35,280
the Reed Solomon codes

621
00:45:32,960 --> 00:45:37,920
over

622
00:45:35,280 --> 00:45:41,599
the finite field

623
00:45:37,920 --> 00:45:43,520
with 2 to the eth elements.

624
00:45:41,599 --> 00:45:46,079
So

625
00:45:43,520 --> 00:45:47,920
I don't know whether professor Mitra

626
00:45:46,079 --> 00:45:52,880
mentioned it before but there's a finite

627
00:45:47,920 --> 00:45:55,440
field for every power of a prime and no

628
00:45:52,880 --> 00:45:57,440
one of the very common finite fields

629
00:45:55,440 --> 00:46:01,160
used for read Solomon codes in practice

630
00:45:57,440 --> 00:46:01,160
is 2 to the eth.

631
00:46:02,240 --> 00:46:08,560
So

632
00:46:05,119 --> 00:46:13,200
let's say n =

633
00:46:08,560 --> 00:46:17,560
256 that's 2 8

634
00:46:13,200 --> 00:46:17,560
k = 150

635
00:46:17,839 --> 00:46:25,760
and that implies that e = n -

636
00:46:22,560 --> 00:46:28,319
k / 2

637
00:46:25,760 --> 00:46:32,480
because we had

638
00:46:28,319 --> 00:46:39,880
um n minus k= 2

639
00:46:32,480 --> 00:46:39,880
And 256 - 150 / 2 is 53

640
00:46:41,440 --> 00:46:47,240
can

641
00:46:44,240 --> 00:46:47,240
encode

642
00:46:48,079 --> 00:46:56,960
let's see K was 150 150 bytes

643
00:46:53,200 --> 00:46:58,720
if we assume a bite is eight bits

644
00:46:56,960 --> 00:47:01,839
into

645
00:46:58,720 --> 00:47:01,839
256 bytes

646
00:47:04,640 --> 00:47:10,000
Correct.

647
00:47:06,800 --> 00:47:12,400
53 errors,

648
00:47:10,000 --> 00:47:14,400
which means 53

649
00:47:12,400 --> 00:47:17,800
is the number of bytes that can have

650
00:47:14,400 --> 00:47:17,800
errors in them.

651
00:47:20,000 --> 00:47:25,480
And

652
00:47:21,680 --> 00:47:25,480
if you think about this

653
00:47:26,160 --> 00:47:29,480
in general

654
00:47:30,640 --> 00:47:35,359
cannot

655
00:47:32,880 --> 00:47:39,160
correct

656
00:47:35,359 --> 00:47:39,160
an error rate

657
00:47:39,520 --> 00:47:44,880
greater than n / two

658
00:47:43,440 --> 00:47:47,839
because the number of errors you can

659
00:47:44,880 --> 00:47:49,920
correct is n minus k / 2 And even if you

660
00:47:47,839 --> 00:47:55,760
use the smallest possible code which

661
00:47:49,920 --> 00:47:58,480
encodes a single bite that's eight bits

662
00:47:55,760 --> 00:48:01,960
um you cannot correct more than any of

663
00:47:58,480 --> 00:48:01,960
our two errors.

664
00:48:02,319 --> 00:48:05,319
Okay.

665
00:48:22,640 --> 00:48:30,440
Let's assume

666
00:48:26,319 --> 00:48:30,440
the bit error rate

667
00:48:31,680 --> 00:48:35,493
is Um [sighs]

668
00:48:46,960 --> 00:48:52,160
10%.

669
00:48:49,520 --> 00:48:54,480
So you're transmitting zeros and ones

670
00:48:52,160 --> 00:48:56,640
and you're

671
00:48:54,480 --> 00:49:03,359
um grouping them into blocks of eight

672
00:48:56,640 --> 00:49:06,400
bits, but each of your bit is

673
00:49:03,359 --> 00:49:10,520
likely to be

674
00:49:06,400 --> 00:49:10,520
have a 10% error.

675
00:49:10,800 --> 00:49:15,599
Probability

676
00:49:12,800 --> 00:49:18,720
a bite

677
00:49:15,599 --> 00:49:23,119
that's a group of eight bits

678
00:49:18,720 --> 00:49:26,960
is in error

679
00:49:23,119 --> 00:49:30,160
is 1 -

680
00:49:26,960 --> 00:49:33,480
1 - 110th

681
00:49:30,160 --> 00:49:33,480
to the 8th.

682
00:49:37,440 --> 00:49:40,440
Okay.

683
00:49:41,920 --> 00:49:46,520
which equals 57%.

684
00:49:48,559 --> 00:49:54,960
I mean this is the probability that each

685
00:49:50,319 --> 00:49:57,040
of your bits is not an error. So you

686
00:49:54,960 --> 00:49:59,359
raise it

687
00:49:57,040 --> 00:50:02,319
to the eth. That's the probability that

688
00:49:59,359 --> 00:50:04,160
all of your bits do not have an error.

689
00:50:02,319 --> 00:50:06,559
And the probability of an error is one

690
00:50:04,160 --> 00:50:08,400
minus this. That's 57%.

691
00:50:06,559 --> 00:50:13,280
So if you're trying to use a read

692
00:50:08,400 --> 00:50:15,359
Solomon code with blocks of size eight,

693
00:50:13,280 --> 00:50:18,079
um

694
00:50:15,359 --> 00:50:21,880
you cannot find parameters that will let

695
00:50:18,079 --> 00:50:21,880
it correct the error.

696
00:50:28,319 --> 00:50:34,200
I want to say what do you do? You use

697
00:50:30,319 --> 00:50:34,200
concatenated codes.

698
00:50:56,319 --> 00:51:03,480
You can look

699
00:50:59,200 --> 00:51:03,480
in code tables.

700
00:51:04,319 --> 00:51:09,920
And these are available on the web.

701
00:51:08,079 --> 00:51:11,599
Find

702
00:51:09,920 --> 00:51:15,160
that

703
00:51:11,599 --> 00:51:15,160
there is

704
00:51:16,480 --> 00:51:21,119
uh

705
00:51:18,160 --> 00:51:26,280
19

706
00:51:21,119 --> 00:51:26,280
8 seven code.

707
00:51:29,520 --> 00:51:32,839
This encodes

708
00:51:33,280 --> 00:51:37,680
eight bits

709
00:51:35,680 --> 00:51:40,240
into

710
00:51:37,680 --> 00:51:43,200
19 bits

711
00:51:40,240 --> 00:51:46,640
and the distance

712
00:51:43,200 --> 00:51:50,520
is equal to seven which means it

713
00:51:46,640 --> 00:51:50,520
corrects three errors.

714
00:51:57,920 --> 00:52:03,800
Okay.

715
00:51:59,440 --> 00:52:03,800
So, we should call that code something.

716
00:52:04,079 --> 00:52:10,359
So, why don't we call it

717
00:52:06,800 --> 00:52:10,359
C inner?

718
00:52:12,319 --> 00:52:16,960
Okay.

719
00:52:14,240 --> 00:52:19,200
and

720
00:52:16,960 --> 00:52:23,880
use

721
00:52:19,200 --> 00:52:23,880
read Solomon code

722
00:52:26,240 --> 00:52:32,480
and somewhere I had

723
00:52:29,839 --> 00:52:34,160
this example

724
00:52:32,480 --> 00:52:38,800
of

725
00:52:34,160 --> 00:52:43,200
150 bytes into 256 bytes and corrects 53

726
00:52:38,800 --> 00:52:45,920
errors. So I guess that is the

727
00:52:43,200 --> 00:52:51,800
250

728
00:52:45,920 --> 00:52:51,800
that's n and 150

729
00:52:51,920 --> 00:52:59,480
and um corrects 53 errors because the

730
00:52:56,079 --> 00:52:59,480
distance is

731
00:52:59,599 --> 00:53:02,599
7.

732
00:53:08,800 --> 00:53:13,880
So how do you canatenate two codes?

733
00:53:25,839 --> 00:53:31,720
So the first thing you do is apply

734
00:53:36,880 --> 00:53:41,559
the outer code to your message.

735
00:53:43,839 --> 00:53:46,839
Wait.

736
00:53:48,880 --> 00:53:51,880
Yeah.

737
00:53:59,680 --> 00:54:06,319
What does that look like? Well, your

738
00:54:01,119 --> 00:54:08,720
message you break into blocks of of

739
00:54:06,319 --> 00:54:11,040
eight bits and eight eight bits can be

740
00:54:08,720 --> 00:54:14,160
represented as numbers between 1 and 25

741
00:54:11,040 --> 00:54:16,000
between 0 and 256. So your message might

742
00:54:14,160 --> 00:54:18,640
look like

743
00:54:16,000 --> 00:54:20,559
um 317,

744
00:54:18,640 --> 00:54:23,559
251,

745
00:54:20,559 --> 00:54:23,559
109,

746
00:54:24,720 --> 00:54:29,520
113,

747
00:54:26,240 --> 00:54:31,200
75, etc.

748
00:54:29,520 --> 00:54:36,760
And

749
00:54:31,200 --> 00:54:36,760
it has 150 of these

750
00:54:40,720 --> 00:54:48,400
150 of these things.

751
00:54:44,079 --> 00:54:50,640
So now you encode it in

752
00:54:48,400 --> 00:54:55,319
your read Solomon code using your read

753
00:54:50,640 --> 00:54:55,319
Solomon code and you get 250

754
00:54:55,520 --> 00:54:59,760
code word

755
00:54:57,599 --> 00:55:01,520
length

756
00:54:59,760 --> 00:55:09,359
250

757
00:55:01,520 --> 00:55:12,359
looks pretty much the same 113 11 17 257

758
00:55:09,359 --> 00:55:12,359
etc.

759
00:55:12,640 --> 00:55:21,800
And there are 250 of these numbers.

760
00:55:17,440 --> 00:55:21,800
Take each of these numbers

761
00:55:29,680 --> 00:55:34,599
code

762
00:55:31,599 --> 00:55:34,599
using

763
00:55:35,440 --> 00:55:42,559
C inner.

764
00:55:38,400 --> 00:55:46,960
And now to decode you first decode CN

765
00:55:42,559 --> 00:55:49,440
and you get this code word and now you

766
00:55:46,960 --> 00:55:53,280
decode it using the

767
00:55:49,440 --> 00:55:55,599
code the um

768
00:55:53,280 --> 00:56:00,040
decoding algorithm for read Solomon

769
00:55:55,599 --> 00:56:00,040
codes and you get your message.

770
00:56:12,000 --> 00:56:18,200
And you have

771
00:56:14,559 --> 00:56:18,200
taken your message

772
00:56:20,559 --> 00:56:30,680
um take

773
00:56:23,119 --> 00:56:30,680
I guess 8 * 150 is equal to um

774
00:56:30,960 --> 00:56:35,040
I think 1,200 bits.

775
00:56:35,599 --> 00:56:38,599
N2

776
00:56:38,960 --> 00:56:42,520
what was our

777
00:56:45,599 --> 00:56:53,440
1987 bits codes into

778
00:56:49,839 --> 00:56:55,599
19 * 256

779
00:56:53,440 --> 00:56:57,280
which okay I did not do this

780
00:56:55,599 --> 00:57:00,000
multiplication

781
00:56:57,280 --> 00:57:07,520
before I

782
00:57:00,000 --> 00:57:11,720
before class so 250 * 20 is um

783
00:57:07,520 --> 00:57:11,720
is around 5,000 bits.

784
00:57:15,200 --> 00:57:20,839
So you've taken 1,200 bits to 5,000

785
00:57:17,839 --> 00:57:20,839
bits.

786
00:57:21,200 --> 00:57:25,160
You have um

787
00:57:26,559 --> 00:57:34,400
and you can ask what

788
00:57:30,480 --> 00:57:37,839
is the probability

789
00:57:34,400 --> 00:57:40,839
you decode

790
00:57:37,839 --> 00:57:40,839
successfully

791
00:57:43,520 --> 00:57:51,559
with a 10%

792
00:57:46,960 --> 00:57:51,559
bit error rate.

793
00:57:58,720 --> 00:58:07,200
Okay, so I used um Mathematica for this

794
00:58:02,960 --> 00:58:10,200
but at a 10% error rate

795
00:58:07,200 --> 00:58:10,200
um

796
00:58:16,240 --> 00:58:22,680
if you have

797
00:58:19,359 --> 00:58:22,680
Eight bits

798
00:58:22,799 --> 00:58:27,480
10% error rate

799
00:58:28,720 --> 00:58:33,440
probability of greater than equal to

800
00:58:30,480 --> 00:58:35,440
three errors

801
00:58:33,440 --> 00:58:38,440
is

802
00:58:35,440 --> 00:58:38,440
11%.

803
00:58:44,079 --> 00:58:50,480
And now the chance

804
00:58:46,799 --> 00:58:57,119
and what did we have? We have an 11%

805
00:58:50,480 --> 00:59:00,799
error rate in the bytes. We have

806
00:58:57,119 --> 00:59:04,960
256 bytes. And if there are fewer than

807
00:59:00,799 --> 00:59:07,359
53 of them in error, you can decode

808
00:59:04,960 --> 00:59:09,359
with high probability.

809
00:59:07,359 --> 00:59:11,280
And you know how with from probability

810
00:59:09,359 --> 00:59:14,319
theory, you know how to figure out the

811
00:59:11,280 --> 00:59:18,760
probability that you cannot decode. But

812
00:59:14,319 --> 00:59:18,760
the probability you cannot decode

813
00:59:26,079 --> 00:59:32,559
is approximately

814
00:59:28,960 --> 00:59:35,559
10 to the -60th

815
00:59:32,559 --> 00:59:35,559
which

816
00:59:36,079 --> 00:59:45,880
is really incredibly small.

817
00:59:41,520 --> 00:59:45,880
So that means that

818
00:59:46,079 --> 00:59:52,559
you can you know if you take a

819
00:59:48,400 --> 00:59:55,280
canatinated code and use this code for

820
00:59:52,559 --> 00:59:58,240
the outer code and this code for the

821
00:59:55,280 --> 01:00:00,559
inner code and you have a 10% error rate

822
00:59:58,240 --> 01:00:04,400
on your bits,

823
01:00:00,559 --> 01:00:08,280
your information almost always gets

824
01:00:04,400 --> 01:00:08,280
through completely intact.

825
01:00:09,680 --> 01:00:18,400
And actually so this

826
01:00:13,359 --> 01:00:21,680
you know 10% error rate um

827
01:00:18,400 --> 01:00:24,799
we've taken 1 1200 bits to 5,000 bits

828
01:00:21,680 --> 01:00:26,960
we've multiplied the number of bits by

829
01:00:24,799 --> 01:00:28,880
four. Now if you look at Shannon's

830
01:00:26,960 --> 01:00:32,559
theorem

831
01:00:28,880 --> 01:00:36,480
if you have 1 1200 bits and a 10% error

832
01:00:32,559 --> 01:00:39,040
rate you should be able to get by with

833
01:00:36,480 --> 01:00:42,559
multiplying the number of bits by two.

834
01:00:39,040 --> 01:00:45,599
So the ideal code would give us 2400

835
01:00:42,559 --> 01:00:50,319
bits and we've used twice that many

836
01:00:45,599 --> 01:00:53,040
5,000 bits. So that's not that horrible.

837
01:00:50,319 --> 01:00:57,119
I mean if we use turbo codes or LDBC

838
01:00:53,040 --> 01:00:59,760
codes or um polar codes which were

839
01:00:57,119 --> 01:01:02,480
invented much later than Reed Solomon

840
01:00:59,760 --> 01:01:08,319
codes, we would reduce that to something

841
01:01:02,480 --> 01:01:13,119
very close to the to Shannon's bound.

842
01:01:08,319 --> 01:01:17,640
But you know this was good enough for

843
01:01:13,119 --> 01:01:17,640
you know let's see

844
01:01:19,832 --> 01:01:23,200
[snorts]

845
01:01:20,720 --> 01:01:27,200
yeah so this was good enough for 30

846
01:01:23,200 --> 01:01:30,720
years I mean

847
01:01:27,200 --> 01:01:32,319
the um all the machinery for using read

848
01:01:30,720 --> 01:01:36,319
Solomon codes had been discovered by

849
01:01:32,319 --> 01:01:37,920
1970 and they remained in widespread use

850
01:01:36,319 --> 01:01:41,760
well they remain in widespread use

851
01:01:37,920 --> 01:01:43,359
Today, anytime you play a CD,

852
01:01:41,760 --> 01:01:45,599
of course, very few people are playing

853
01:01:43,359 --> 01:01:50,119
CDs anymore, but anytime you play a CD,

854
01:01:45,599 --> 01:01:50,119
you're using Reed Sullivan codes.

855
01:01:51,599 --> 01:01:56,079
Okay, [snorts]

856
01:01:53,839 --> 01:01:57,839
there's one last thing I want to say.

857
01:01:56,079 --> 01:01:59,760
Um,

858
01:01:57,839 --> 01:02:02,480
well, I've told you how to decode the

859
01:01:59,760 --> 01:02:05,480
outer code. How can you decode the inner

860
01:02:02,480 --> 01:02:05,480
code?

861
01:02:41,040 --> 01:02:44,920
I mean, it's a 198

862
01:02:45,520 --> 01:02:49,000
seven code.

863
01:02:50,799 --> 01:02:58,319
There are 2 to the 19th which is

864
01:02:55,599 --> 01:03:01,200
approximately

865
01:02:58,319 --> 01:03:04,520
um 500,000

866
01:03:01,200 --> 01:03:04,520
code words

867
01:03:08,000 --> 01:03:16,960
and can use table lookup for these.

868
01:03:14,240 --> 01:03:19,839
You have your computer

869
01:03:16,960 --> 01:03:26,839
have in your computer a complete table

870
01:03:19,839 --> 01:03:26,839
of all now there are 500,000 um possible

871
01:03:31,440 --> 01:03:38,480
yeah there are only 256 code words but

872
01:03:34,720 --> 01:03:41,480
those get mapped into 19bit

873
01:03:38,480 --> 01:03:41,480
um

874
01:03:41,760 --> 01:03:48,880
words And there are 500,000 19 bit

875
01:03:46,079 --> 01:03:52,160
words. And you can use table lookup to

876
01:03:48,880 --> 01:03:54,799
decode. You can just list all possible

877
01:03:52,160 --> 01:03:57,119
500,000

878
01:03:54,799 --> 01:03:59,920
words you might receive. And to decode

879
01:03:57,119 --> 01:04:03,520
them, you look up in the table to find

880
01:03:59,920 --> 01:04:05,200
the nearest code word. And that's the

881
01:04:03,520 --> 01:04:09,280
decoding.

882
01:04:05,200 --> 01:04:13,200
And nowadays, this is incredibly easy.

883
01:04:09,280 --> 01:04:17,599
In 1977 when Voyager did it, I suspect

884
01:04:13,200 --> 01:04:20,079
that the Voyager spacecraft did not have

885
01:04:17,599 --> 01:04:21,359
enough memory for 500,000 table lookup

886
01:04:20,079 --> 01:04:24,000
words. So, they must have done something

887
01:04:21,359 --> 01:04:27,839
cleverer. Well, one thing you could do

888
01:04:24,000 --> 01:04:31,039
is instead of using um

889
01:04:27,839 --> 01:04:34,319
instead of using

890
01:04:31,039 --> 01:04:36,400
uh read Solomon codes with eight bits in

891
01:04:34,319 --> 01:04:38,480
each block, use ones with smaller number

892
01:04:36,400 --> 01:04:43,839
of bits in each block and then you will

893
01:04:38,480 --> 01:04:45,359
get a smaller um code word. Or another

894
01:04:43,839 --> 01:04:47,440
thing you could do is for the inner code

895
01:04:45,359 --> 01:04:49,280
you could use a Hamming code words and

896
01:04:47,440 --> 01:04:51,680
Hamming Hamming code and Hamming codes

897
01:04:49,280 --> 01:04:53,599
are very easy to decode.

898
01:04:51,680 --> 01:04:56,480
although

899
01:04:53,599 --> 01:04:59,920
they really do not get quite as good

900
01:04:56,480 --> 01:05:02,160
performance as you know three error

901
01:04:59,920 --> 01:05:03,839
correcting codes

902
01:05:02,160 --> 01:05:06,880
and there are other things you can do

903
01:05:03,839 --> 01:05:09,039
too so I don't actually know what they

904
01:05:06,880 --> 01:05:10,880
did

905
01:05:09,039 --> 01:05:13,520
for Voyager

906
01:05:10,880 --> 01:05:15,599
but I

907
01:05:13,520 --> 01:05:18,240
um it's probably somewhere on the line

908
01:05:15,599 --> 01:05:26,039
and I could look it up okay so that's

909
01:05:18,240 --> 01:05:26,039
all I have on Eric recting codes and um

910
01:05:26,559 --> 01:05:31,359
in fact this is my last lecture of the

911
01:05:28,880 --> 01:05:36,160
course because professor Mitra will be

912
01:05:31,359 --> 01:05:38,559
giving the next two non um

913
01:05:36,160 --> 01:05:42,760
non-exam lectures and we have one exam

914
01:05:38,559 --> 01:05:42,760
for you. Okay.

