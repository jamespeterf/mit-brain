1
00:00:11,120 --> 00:00:15,200
Okay. So, today we're going to be

2
00:00:12,880 --> 00:00:16,800
talking about

3
00:00:15,200 --> 00:00:19,439
um

4
00:00:16,800 --> 00:00:24,160
error correcting codes.

5
00:00:19,439 --> 00:00:27,199
So, on Thursday, Professor Mitra told

6
00:00:24,160 --> 00:00:29,599
you about um Shannon's noisy coding

7
00:00:27,199 --> 00:00:31,920
theorem. And I don't know if he drew

8
00:00:29,599 --> 00:00:34,960
this picture or not. It's not in the

9
00:00:31,920 --> 00:00:36,960
notes. So um and it's a picture

10
00:00:34,960 --> 00:00:38,879
everybody draws when they talk about

11
00:00:36,960 --> 00:00:42,920
Shannon's noisy coding theorem. So you

12
00:00:38,879 --> 00:00:42,920
have some message

13
00:00:43,760 --> 00:00:50,120
message

14
00:00:46,239 --> 00:00:50,120
drawn from M

15
00:00:51,920 --> 00:00:56,719
which is some set of messages.

16
00:00:54,879 --> 00:01:00,520
And now

17
00:00:56,719 --> 00:01:00,520
you encode it.

18
00:01:05,680 --> 00:01:10,600
And now you have a noisy channel

19
00:01:16,479 --> 00:01:21,680
and

20
00:01:18,240 --> 00:01:26,799
you get C tilda

21
00:01:21,680 --> 00:01:30,600
or you get the received code word which

22
00:01:26,799 --> 00:01:30,600
maybe I should call it

23
00:01:30,880 --> 00:01:35,560
C tilda. And now you decode

24
00:01:37,439 --> 00:01:41,680
and you get something which I'll call M

25
00:01:39,840 --> 00:01:43,680
tilda

26
00:01:41,680 --> 00:01:46,680
and

27
00:01:43,680 --> 00:01:46,680
Shannon

28
00:01:48,560 --> 00:01:54,280
if

29
00:01:50,880 --> 00:01:54,280
the noise

30
00:01:54,720 --> 00:01:57,720
um

31
00:01:58,159 --> 00:02:07,360
at the rate

32
00:02:01,840 --> 00:02:09,840
which I want to A is

33
00:02:07,360 --> 00:02:14,599
um

34
00:02:09,840 --> 00:02:14,599
log K over.

35
00:02:14,959 --> 00:02:20,200
Okay. What is the rate? It's K over N,

36
00:02:17,200 --> 00:02:20,200
right?

37
00:02:20,640 --> 00:02:31,800
K over N. So these messages are k bits

38
00:02:26,640 --> 00:02:31,800
and this code is n bits

39
00:02:32,400 --> 00:02:37,160
is less than the channel capacity.

40
00:02:43,040 --> 00:02:48,400
There exists a code

41
00:02:45,760 --> 00:02:53,280
such that

42
00:02:48,400 --> 00:02:56,000
as n goes to infinity and k / n remains

43
00:02:53,280 --> 00:02:59,040
the same

44
00:02:56,000 --> 00:03:04,640
the probability that

45
00:02:59,040 --> 00:03:11,000
m tilda equals m goes to one.

46
00:03:04,640 --> 00:03:11,000
So in the limit of long block lengths

47
00:03:11,040 --> 00:03:14,879
I don't know how much coding theory

48
00:03:12,800 --> 00:03:18,640
terminology

49
00:03:14,879 --> 00:03:22,920
um anchor used but

50
00:03:18,640 --> 00:03:22,920
n is called the block length.

51
00:03:27,760 --> 00:03:31,519
Then

52
00:03:29,360 --> 00:03:35,440
the

53
00:03:31,519 --> 00:03:37,840
error rate goes to zero.

54
00:03:35,440 --> 00:03:40,799
So that is the noisy channel coding

55
00:03:37,840 --> 00:03:44,519
therm. So did um professor mo put this

56
00:03:40,799 --> 00:03:44,519
diagram on the board?

57
00:03:46,879 --> 00:03:51,159
Okay. Oh well.

58
00:03:52,879 --> 00:03:55,879
And

59
00:04:01,439 --> 00:04:09,400
Shannon used

60
00:04:04,799 --> 00:04:09,400
random codes to prove his theorem.

61
00:04:19,759 --> 00:04:25,720
And these are totally impractical for

62
00:04:22,320 --> 00:04:25,720
large N.

63
00:04:38,000 --> 00:04:43,360
Because what you have is you have a list

64
00:04:40,800 --> 00:04:46,000
of code words which is

65
00:04:43,360 --> 00:04:50,639
exponential inn

66
00:04:46,000 --> 00:04:52,639
and you get a receive word and you want

67
00:04:50,639 --> 00:04:57,680
to find which of these code words it's

68
00:04:52,639 --> 00:05:00,080
closest to and we don't know any way of

69
00:04:57,680 --> 00:05:02,479
doing this that is substantially better

70
00:05:00,080 --> 00:05:06,400
than going through the entire list of

71
00:05:02,479 --> 00:05:09,280
code words computing the distance and um

72
00:05:06,400 --> 00:05:13,199
finding the shortest one and in fact you

73
00:05:09,280 --> 00:05:16,240
can show that this is uh np P hard

74
00:05:13,199 --> 00:05:18,720
problem which means that there probably

75
00:05:16,240 --> 00:05:22,560
isn't such a way.

76
00:05:18,720 --> 00:05:25,039
So what you need is you need

77
00:05:22,560 --> 00:05:28,680
to find

78
00:05:25,039 --> 00:05:28,680
specific codes

79
00:05:32,320 --> 00:05:38,440
with

80
00:05:34,000 --> 00:05:38,440
practical decoding algorithms.

81
00:05:46,160 --> 00:05:50,960
And

82
00:05:48,080 --> 00:05:55,120
today and Thursday I will tell you about

83
00:05:50,960 --> 00:05:58,400
two of these codes and um

84
00:05:55,120 --> 00:06:00,800
they will basically

85
00:05:58,400 --> 00:06:04,199
you know stand in for the whole class of

86
00:06:00,800 --> 00:06:04,199
linear codes.

87
00:06:08,639 --> 00:06:11,639
So,

88
00:06:13,520 --> 00:06:21,240
so Shannon found, you know, Shannon

89
00:06:16,479 --> 00:06:21,240
proved his theorem in 1948

90
00:06:23,840 --> 00:06:28,039
and two years later,

91
00:06:32,880 --> 00:06:40,919
Hamming found the first

92
00:06:36,160 --> 00:06:40,919
um error correcting code

93
00:06:41,199 --> 00:06:46,160
having

94
00:06:43,360 --> 00:06:47,759
1950

95
00:06:46,160 --> 00:06:49,840
found actually found a whole class of

96
00:06:47,759 --> 00:06:51,440
Eric reckoning codes but the first part

97
00:06:49,840 --> 00:06:53,919
of the talk I'll just talk about the

98
00:06:51,440 --> 00:06:57,039
simplest one in this class

99
00:06:53,919 --> 00:06:59,039
um can

100
00:06:57,039 --> 00:07:02,080
encode

101
00:06:59,039 --> 00:07:03,599
four bits

102
00:07:02,080 --> 00:07:05,919
into

103
00:07:03,599 --> 00:07:10,039
seven bits

104
00:07:05,919 --> 00:07:10,039
and correct one error.

105
00:07:15,599 --> 00:07:21,039
So if you have

106
00:07:18,160 --> 00:07:24,479
I don't know a million bits that you

107
00:07:21,039 --> 00:07:29,360
want to send and their rate is their

108
00:07:24,479 --> 00:07:31,520
error rate is one in a 100 then um this

109
00:07:29,360 --> 00:07:34,960
is not going to work because you can

110
00:07:31,520 --> 00:07:37,840
break the million bits into blocks of

111
00:07:34,960 --> 00:07:41,919
seven of blocks of four and transmit

112
00:07:37,840 --> 00:07:46,240
each of them in seven bits. But chances

113
00:07:41,919 --> 00:07:49,919
are very high that in these million bits

114
00:07:46,240 --> 00:07:52,479
you will find one block of four which

115
00:07:49,919 --> 00:07:54,879
has two errors in it which means it will

116
00:07:52,479 --> 00:07:56,720
not be corrected.

117
00:07:54,879 --> 00:07:59,520
So what you really would like is you

118
00:07:56,720 --> 00:08:04,479
would like a way of encoding say a

119
00:07:59,520 --> 00:08:06,319
th00and bits into 1500 bits that correct

120
00:08:04,479 --> 00:08:08,080
10 errors.

121
00:08:06,319 --> 00:08:09,599
And we will get to something like that

122
00:08:08,080 --> 00:08:12,599
with

123
00:08:09,599 --> 00:08:12,599
um

124
00:08:12,639 --> 00:08:17,440
read Solomon codes which we'll talk

125
00:08:15,120 --> 00:08:20,319
about on Thursday. But what is the

126
00:08:17,440 --> 00:08:23,280
Hammond code?

127
00:08:20,319 --> 00:08:25,520
So I'm going to give you a first a very

128
00:08:23,280 --> 00:08:29,520
simple description of the Hammond code

129
00:08:25,520 --> 00:08:32,479
and then a more complicated one.

130
00:08:29,520 --> 00:08:35,599
And a simple description.

131
00:08:32,479 --> 00:08:37,760
We're going to start with a vin diagram

132
00:08:35,599 --> 00:08:40,760
with

133
00:08:37,760 --> 00:08:40,760
um

134
00:08:46,560 --> 00:08:53,240
four

135
00:08:48,080 --> 00:08:53,240
bits. Well, with three

136
00:08:55,839 --> 00:08:58,839
um

137
00:08:59,200 --> 00:09:03,279
regions and these regions are actually

138
00:09:01,120 --> 00:09:06,680
going to be correspond to specific bits

139
00:09:03,279 --> 00:09:06,680
of this code.

140
00:09:08,720 --> 00:09:12,000
Okay,

141
00:09:10,320 --> 00:09:16,839
now

142
00:09:12,000 --> 00:09:16,839
let me see if I can do this. Um

143
00:09:22,399 --> 00:09:31,440
I want to do this. So let's take the

144
00:09:26,000 --> 00:09:34,080
four bits to be bit A, bit B, bit C and

145
00:09:31,440 --> 00:09:38,279
bit D.

146
00:09:34,080 --> 00:09:38,279
So these are the message bits.

147
00:09:44,399 --> 00:09:50,839
And now what we're going to do is add

148
00:09:46,800 --> 00:09:50,839
three parody check bits.

149
00:09:57,360 --> 00:10:03,279
And these, you know, 4 + 3 is seven,

150
00:10:01,600 --> 00:10:07,839
which is why we're encoding four bits

151
00:10:03,279 --> 00:10:10,959
into seven bits. And these bits are

152
00:10:07,839 --> 00:10:14,399
going to give you

153
00:10:10,959 --> 00:10:18,760
the error correction ability. So let's

154
00:10:14,399 --> 00:10:18,760
say this is

155
00:10:19,120 --> 00:10:30,680
a + b. This is um a + b + d.

156
00:10:30,880 --> 00:10:36,160
This is b + c + d.

157
00:10:36,800 --> 00:10:42,279
And this is a + c plus d

158
00:10:43,839 --> 00:10:50,040
where the plus is exclusive r. So binary

159
00:10:47,040 --> 00:10:50,040
addition

160
00:10:57,920 --> 00:11:00,920
example

161
00:11:03,279 --> 00:11:08,519
let's take

162
00:11:05,519 --> 00:11:08,519
um

163
00:11:08,800 --> 00:11:15,240
one

164
00:11:10,640 --> 00:11:15,240
011 to be the message.

165
00:11:16,480 --> 00:11:19,720
And now

166
00:11:21,040 --> 00:11:31,640
Okay. So, one 0 one one. Oh, I'm sorry.

167
00:11:27,200 --> 00:11:31,640
One 0 one one.

168
00:11:33,519 --> 00:11:41,360
Okay. So now we want to compute the

169
00:11:36,399 --> 00:11:46,160
parity check bits. So what we do is we

170
00:11:41,360 --> 00:11:49,440
put a bit in here so that the sum of the

171
00:11:46,160 --> 00:11:54,320
bits in this circle is even. So that

172
00:11:49,440 --> 00:11:57,279
would be zero because 1 + 1 is zero.

173
00:11:54,320 --> 00:11:59,839
And similarly this is zero because 1

174
00:11:57,279 --> 00:12:04,480
plus 1 is zero. And this is one because

175
00:11:59,839 --> 00:12:07,680
1 plus 1 + 1 is one. And we know to add

176
00:12:04,480 --> 00:12:10,560
a one to make it zero.

177
00:12:07,680 --> 00:12:12,639
Okay.

178
00:12:10,560 --> 00:12:15,360
So our

179
00:12:12,639 --> 00:12:21,680
code

180
00:12:15,360 --> 00:12:26,279
is 1 0 1 1

181
00:12:21,680 --> 00:12:26,279
and now 0 0 1.

182
00:12:27,440 --> 00:12:32,720
Okay. Now let's send it through the

183
00:12:30,240 --> 00:12:35,120
channel and we will change one of the

184
00:12:32,720 --> 00:12:38,920
bits. Does anybody have a suggestion for

185
00:12:35,120 --> 00:12:38,920
which bit we want to change?

186
00:12:41,839 --> 00:12:49,360
Who wants to change the second bit?

187
00:12:44,880 --> 00:12:55,360
Okay, we'll do that. So it's 1 one 1 0 0

188
00:12:49,360 --> 00:12:57,680
1. Okay. So what we do now is we

189
00:12:55,360 --> 00:13:04,560
compute

190
00:12:57,680 --> 00:13:07,880
uh let's call these A b C D E F G and

191
00:13:04,560 --> 00:13:07,880
this was

192
00:13:09,519 --> 00:13:18,360
A B C D E F G I believe.

193
00:13:19,440 --> 00:13:30,079
Yeah. So now we compute a + d + c + g. a

194
00:13:26,720 --> 00:13:32,720
+ c + d + g.

195
00:13:30,079 --> 00:13:35,519
Um

196
00:13:32,720 --> 00:13:40,000
that is

197
00:13:35,519 --> 00:13:41,680
zero. So this circle is

198
00:13:40,000 --> 00:13:46,079
correct.

199
00:13:41,680 --> 00:13:50,560
Now we compute a plus e plus b + d. a +

200
00:13:46,079 --> 00:13:53,360
c + b + d. That's one. So this circle is

201
00:13:50,560 --> 00:13:57,440
incorrect.

202
00:13:53,360 --> 00:14:00,880
And B + C plus D plus F B plus C plus D

203
00:13:57,440 --> 00:14:04,480
plus F that

204
00:14:00,880 --> 00:14:07,519
B C D F that's also equal to one. So

205
00:14:04,480 --> 00:14:11,440
this circle is also incorrect. And so

206
00:14:07,519 --> 00:14:13,760
now we know the incorrect bit is not in

207
00:14:11,440 --> 00:14:16,480
this region but is in the intersection

208
00:14:13,760 --> 00:14:21,480
of this region and this region.

209
00:14:16,480 --> 00:14:21,480
And that means it is B.

210
00:14:24,800 --> 00:14:31,120
So the received um

211
00:14:28,160 --> 00:14:34,120
word is that

212
00:14:31,120 --> 00:14:34,120
incorrect

213
00:14:34,720 --> 00:14:42,240
bit is B.

214
00:14:37,920 --> 00:14:46,880
And now we change B. So we get one zero

215
00:14:42,240 --> 00:14:49,880
one one zero zero one

216
00:14:46,880 --> 00:14:49,880
right

217
00:14:52,000 --> 00:14:56,240
and

218
00:14:54,399 --> 00:14:58,880
well you might have noticed that the

219
00:14:56,240 --> 00:15:02,519
message was the first four bits. So this

220
00:14:58,880 --> 00:15:02,519
is the message.

221
00:15:09,680 --> 00:15:12,680
Okay.

222
00:15:30,639 --> 00:15:36,480
Okay. So now I'm going to tell you about

223
00:15:32,720 --> 00:15:40,480
general linear codes and then

224
00:15:36,480 --> 00:15:40,480
general Hamming codes.

225
00:15:48,639 --> 00:15:53,160
Uh linear code

226
00:15:54,160 --> 00:15:59,600
over

227
00:15:56,320 --> 00:16:02,600
a field

228
00:15:59,600 --> 00:16:02,600
f

229
00:16:02,959 --> 00:16:07,000
is a collection

230
00:16:08,160 --> 00:16:13,440
of

231
00:16:10,000 --> 00:16:16,839
length n

232
00:16:13,440 --> 00:16:16,839
strings enough.

233
00:16:21,680 --> 00:16:24,680
So

234
00:16:25,680 --> 00:16:35,240
if C1 C2 are in the code,

235
00:16:30,639 --> 00:16:35,240
I should probably call this a code C,

236
00:16:35,360 --> 00:16:42,000
then

237
00:16:37,360 --> 00:16:44,480
C1 plus C2 is in the code.

238
00:16:42,000 --> 00:16:49,839
And if

239
00:16:44,480 --> 00:16:55,240
C1 is in the code and alpha is in F,

240
00:16:49,839 --> 00:16:55,240
alpha * C1 is in the code.

241
00:16:55,519 --> 00:17:02,920
So any linear combination of code words

242
00:16:58,959 --> 00:17:02,920
is also a code word.

243
00:17:04,400 --> 00:17:09,839
And it's fairly easy to see that this

244
00:17:06,720 --> 00:17:15,120
holds for this um

245
00:17:09,839 --> 00:17:18,720
you know this Hamming code because

246
00:17:15,120 --> 00:17:21,199
if you add two

247
00:17:18,720 --> 00:17:24,160
if you have a set of bits that satisfies

248
00:17:21,199 --> 00:17:26,559
this. So the sum of these sum of these

249
00:17:24,160 --> 00:17:28,240
and sum of these is all zero. And you

250
00:17:26,559 --> 00:17:31,200
have another set of bits that satisfies

251
00:17:28,240 --> 00:17:33,919
this. Then when you take the sum of

252
00:17:31,200 --> 00:17:37,039
these sets of bits,

253
00:17:33,919 --> 00:17:39,120
the sum of things within the circle is

254
00:17:37,039 --> 00:17:40,799
the sum of the things from the first

255
00:17:39,120 --> 00:17:42,480
code word in this circle plus the sum of

256
00:17:40,799 --> 00:17:46,960
things and the second code word in this

257
00:17:42,480 --> 00:17:50,200
circle and 0 + 0 equals 0. So it's also

258
00:17:46,960 --> 00:17:50,200
a code.

259
00:17:50,640 --> 00:17:56,360
Okay, so we have this is a linear code.

260
00:18:10,240 --> 00:18:15,960
by

261
00:18:12,480 --> 00:18:15,960
linear algebra.

262
00:18:20,960 --> 00:18:24,559
Every

263
00:18:22,960 --> 00:18:31,160
code

264
00:18:24,559 --> 00:18:31,160
C has a generating matrix

265
00:18:36,160 --> 00:18:39,160
G

266
00:18:39,840 --> 00:18:43,960
such that

267
00:18:44,320 --> 00:18:47,320
um

268
00:18:47,440 --> 00:18:51,160
C is

269
00:18:51,760 --> 00:19:00,039
the row sums

270
00:18:55,919 --> 00:19:00,039
of G.

271
00:19:00,640 --> 00:19:04,799
So now I'm going to write down the

272
00:19:02,400 --> 00:19:07,679
Hamling code in a different way and

273
00:19:04,799 --> 00:19:11,080
actually you're not going to get quite

274
00:19:07,679 --> 00:19:11,080
the same.

275
00:19:13,360 --> 00:19:17,000
Well, I mean,

276
00:19:20,880 --> 00:19:25,679
I'm going to write down the Hamming code

277
00:19:22,880 --> 00:19:27,280
in a different way. And let's see. We

278
00:19:25,679 --> 00:19:31,760
have

279
00:19:27,280 --> 00:19:36,520
um 1 0 0 0.

280
00:19:31,760 --> 00:19:36,520
And now the first

281
00:19:37,440 --> 00:19:44,960
So this is the first bit. So now the

282
00:19:42,480 --> 00:19:48,160
first two bits of the parody check

283
00:19:44,960 --> 00:19:53,520
matrix are both one here.

284
00:19:48,160 --> 00:19:56,320
So 1 0 0 0 1 1 0.

285
00:19:53,520 --> 00:20:00,640
So when you put that when you put these

286
00:19:56,320 --> 00:20:04,559
bits in the vin diagram

287
00:20:00,640 --> 00:20:07,840
they will be um

288
00:20:04,559 --> 00:20:10,640
assuming I've done this right they will

289
00:20:07,840 --> 00:20:16,160
satisfy the parody checks and then

290
00:20:10,640 --> 00:20:22,000
there's 0 1 0 0 and that's just one 0

291
00:20:16,160 --> 00:20:25,440
one one and 0 0 1 0 and this is going to

292
00:20:22,000 --> 00:20:32,120
be 1 0 1

293
00:20:25,440 --> 00:20:32,120
and 0 0 0 1 1

294
00:20:32,960 --> 00:20:38,720
because this fourth bit is the center

295
00:20:36,320 --> 00:20:41,120
region of the vend diagram and that

296
00:20:38,720 --> 00:20:43,840
means all three parody checks need to be

297
00:20:41,120 --> 00:20:47,440
one for the

298
00:20:43,840 --> 00:20:51,400
for them to satisfy that. sub g is equal

299
00:20:47,440 --> 00:20:51,400
to this

300
00:20:56,880 --> 00:21:03,720
and

301
00:20:58,799 --> 00:21:03,720
there are 16 code words in C

302
00:21:06,480 --> 00:21:11,360
in C

303
00:21:08,320 --> 00:21:14,159
and um

304
00:21:11,360 --> 00:21:14,159
what do I want to

305
00:21:18,159 --> 00:21:26,720
and they're the rose terms

306
00:21:21,679 --> 00:21:30,000
of G and 000000

307
00:21:26,720 --> 00:21:32,720
is in C. And actually the all zeros

308
00:21:30,000 --> 00:21:35,840
vector is a

309
00:21:32,720 --> 00:21:37,520
is a code word of every linear code

310
00:21:35,840 --> 00:21:40,159
because

311
00:21:37,520 --> 00:21:44,320
we know that

312
00:21:40,159 --> 00:21:47,440
um if C1 is in C and alpha is an F then

313
00:21:44,320 --> 00:21:50,640
alpha C1 is in C and if alpha is zero

314
00:21:47,440 --> 00:21:52,720
then alpha C1 is the all zeros vector.

315
00:21:50,640 --> 00:21:56,120
So every linear code has the all zeros

316
00:21:52,720 --> 00:21:56,120
vector in it.

317
00:21:57,840 --> 00:22:00,840
Okay.

318
00:22:11,520 --> 00:22:14,520
Correct.

319
00:22:14,799 --> 00:22:19,640
Oh,

320
00:22:16,640 --> 00:22:19,640
okay.

321
00:22:29,360 --> 00:22:34,480
We need some more um we need some more

322
00:22:32,960 --> 00:22:39,400
definitions

323
00:22:34,480 --> 00:22:39,400
before I can continue.

324
00:22:41,440 --> 00:22:45,559
The Hamming weight

325
00:22:49,039 --> 00:22:52,440
of a vector

326
00:22:55,440 --> 00:23:03,400
Okay.

327
00:22:57,679 --> 00:23:03,400
And let me see if I can find what

328
00:23:12,960 --> 00:23:16,760
W of V

329
00:23:17,600 --> 00:23:22,679
is the

330
00:23:19,679 --> 00:23:22,679
number

331
00:23:24,400 --> 00:23:29,360
of non

332
00:23:27,200 --> 00:23:33,440
Wait,

333
00:23:29,360 --> 00:23:37,880
I I did this wrong. The having weight

334
00:23:33,440 --> 00:23:37,880
w of v of a vector v

335
00:23:41,440 --> 00:23:45,640
is a number of nonzeros

336
00:23:46,720 --> 00:23:50,120
v contains.

337
00:23:53,679 --> 00:23:58,520
Let v equ=

338
00:23:58,960 --> 00:24:08,600
0 1 3 2 0 4 1. Say

339
00:24:08,880 --> 00:24:14,640
the Hamming weight

340
00:24:11,200 --> 00:24:19,480
is the number of nonzeros. It's 1 2 3 4

341
00:24:14,640 --> 00:24:19,480
5 is equal to five.

342
00:24:25,279 --> 00:24:29,080
The hamming distance

343
00:24:32,720 --> 00:24:36,360
of D and W

344
00:24:41,120 --> 00:24:46,360
as a number of places where V and W

345
00:24:43,360 --> 00:24:46,360
differ.

346
00:25:03,840 --> 00:25:12,760
So let's pick an easier example. 013

347
00:25:09,760 --> 00:25:12,760
and

348
00:25:15,200 --> 00:25:18,200
Okay.

349
00:25:21,120 --> 00:25:26,640
Okay. I I want to I want to use the same

350
00:25:23,919 --> 00:25:31,080
notation for Hamming distances in the

351
00:25:26,640 --> 00:25:31,080
notes and

352
00:25:34,480 --> 00:25:37,480
Okay.

353
00:25:38,880 --> 00:25:49,120
So this is d subh of vw

354
00:25:45,200 --> 00:25:50,720
and 1 2

355
00:25:49,120 --> 00:25:52,480
is

356
00:25:50,720 --> 00:25:55,480
well how many places do they differ

357
00:25:52,480 --> 00:25:55,480
anybody?

358
00:25:55,760 --> 00:25:58,760
Two.

359
00:25:58,880 --> 00:26:05,000
So call this C1

360
00:26:01,600 --> 00:26:05,000
and C2.

361
00:26:05,120 --> 00:26:13,120
So the hamming distance between C1 C2 is

362
00:26:09,520 --> 00:26:18,880
equal to 2. And it's easy to see that

363
00:26:13,120 --> 00:26:22,480
the Hamming weight of C1 minus C2 is

364
00:26:18,880 --> 00:26:24,480
equal to the Hamming distance between C1

365
00:26:22,480 --> 00:26:26,400
and C2

366
00:26:24,480 --> 00:26:29,600
because

367
00:26:26,400 --> 00:26:31,679
if two bits are the same then their

368
00:26:29,600 --> 00:26:33,840
difference is zero and if two bits are

369
00:26:31,679 --> 00:26:35,039
different then their difference is non

370
00:26:33,840 --> 00:26:41,760
zero.

371
00:26:35,039 --> 00:26:44,000
So here C1 minus C2 is equal to

372
00:26:41,760 --> 00:26:47,600
-1

373
00:26:44,000 --> 00:26:51,360
0 1

374
00:26:47,600 --> 00:26:54,360
has handling weight

375
00:26:51,360 --> 00:26:54,360
2.

376
00:26:55,520 --> 00:26:59,159
So theorem

377
00:27:03,840 --> 00:27:10,200
a code can correct

378
00:27:07,200 --> 00:27:10,200
um

379
00:27:14,480 --> 00:27:20,440
let

380
00:27:17,440 --> 00:27:20,440
D

381
00:27:23,120 --> 00:27:27,440
of a code

382
00:27:25,279 --> 00:27:33,600
B

383
00:27:27,440 --> 00:27:37,279
minimum over C1 C2 in the code C1 not

384
00:27:33,600 --> 00:27:41,480
equal to C2 the Hamming distance between

385
00:27:37,279 --> 00:27:41,480
C1 and C2

386
00:27:42,000 --> 00:27:47,600
so it's the smallest Hamming distance

387
00:27:44,720 --> 00:27:50,600
between two non-equal

388
00:27:47,600 --> 00:27:50,600
vectors

389
00:27:51,120 --> 00:27:56,559
Then

390
00:27:53,520 --> 00:28:00,360
the code

391
00:27:56,559 --> 00:28:00,360
can correct.

392
00:28:03,200 --> 00:28:10,279
T is equal to

393
00:28:07,279 --> 00:28:10,279
um

394
00:28:10,399 --> 00:28:20,200
DH of

395
00:28:13,200 --> 00:28:20,200
C over two floor errors.

396
00:28:37,520 --> 00:28:41,000
What's the proof?

397
00:28:44,640 --> 00:28:49,399
Well, let's assume.

398
00:28:52,880 --> 00:29:01,520
Ah, I'm sorry.

399
00:28:55,919 --> 00:29:05,320
I wrote this formula down wrong. dus one

400
00:29:01,520 --> 00:29:05,320
over two errors.

401
00:29:09,200 --> 00:29:12,200
Suppose

402
00:29:15,919 --> 00:29:19,480
it cannot

403
00:29:24,399 --> 00:29:32,559
then there is uh well there's a received

404
00:29:30,399 --> 00:29:34,240
word

405
00:29:32,559 --> 00:29:37,960
uh

406
00:29:34,240 --> 00:29:37,960
received word

407
00:29:40,799 --> 00:29:45,640
C

408
00:29:42,640 --> 00:29:45,640
tilda

409
00:29:46,640 --> 00:29:54,120
such that

410
00:29:49,679 --> 00:29:54,120
two code words could have

411
00:30:03,679 --> 00:30:10,039
well the two code words could have

412
00:30:05,679 --> 00:30:10,039
resulted in B tilda.

413
00:30:16,159 --> 00:30:19,520
So

414
00:30:17,919 --> 00:30:23,360
I mean this is just saying that if you

415
00:30:19,520 --> 00:30:26,960
can correct every code word to its

416
00:30:23,360 --> 00:30:30,720
unique every if you can correct every

417
00:30:26,960 --> 00:30:35,279
word with errors to a unique code word

418
00:30:30,720 --> 00:30:37,679
assuming there are fewer than T errors

419
00:30:35,279 --> 00:30:39,919
then

420
00:30:37,679 --> 00:30:41,679
the code can correct T errors. So what

421
00:30:39,919 --> 00:30:44,880
they cannot correct here is there must

422
00:30:41,679 --> 00:30:47,919
be some word c tilda so that there are

423
00:30:44,880 --> 00:30:50,240
two code words which are in dist in that

424
00:30:47,919 --> 00:30:51,760
are in a hamming distance

425
00:30:50,240 --> 00:30:54,080
t

426
00:30:51,760 --> 00:30:59,080
of c tilda.

427
00:30:54,080 --> 00:30:59,080
So t is equal to

428
00:31:01,120 --> 00:31:04,440
c tilda

429
00:31:05,200 --> 00:31:09,279
or actually t is greater than or equal

430
00:31:07,360 --> 00:31:12,960
to

431
00:31:09,279 --> 00:31:14,720
the hamming distance between c tilda and

432
00:31:12,960 --> 00:31:17,520
c1

433
00:31:14,720 --> 00:31:20,799
and

434
00:31:17,520 --> 00:31:22,640
t is greater than equal to the hamming

435
00:31:20,799 --> 00:31:24,559
distance

436
00:31:22,640 --> 00:31:27,880
between c tilda

437
00:31:24,559 --> 00:31:27,880
and C2.

438
00:31:28,640 --> 00:31:34,520
Then

439
00:31:30,720 --> 00:31:34,520
the distance between

440
00:31:34,559 --> 00:31:42,399
C1 and C2

441
00:31:37,840 --> 00:31:45,440
must be less than or equal to

442
00:31:42,399 --> 00:31:48,480
the distance from

443
00:31:45,440 --> 00:31:50,480
C1 to C tilda

444
00:31:48,480 --> 00:31:52,559
plus

445
00:31:50,480 --> 00:31:54,080
the distance

446
00:31:52,559 --> 00:31:57,600
between

447
00:31:54,080 --> 00:32:00,159
C tilda and C2.

448
00:31:57,600 --> 00:32:03,919
And this is just because Hamming

449
00:32:00,159 --> 00:32:08,399
distance is a metric. Which means if the

450
00:32:03,919 --> 00:32:10,960
distance between C1 and C tilda is say T

451
00:32:08,399 --> 00:32:14,159
and distance between C tilda and C2 is

452
00:32:10,960 --> 00:32:18,279
T, then the distance between C1 and C2

453
00:32:14,159 --> 00:32:18,279
is at most 2T.

454
00:32:19,279 --> 00:32:24,480
But this is equal to less than or equal

455
00:32:22,320 --> 00:32:28,200
to

456
00:32:24,480 --> 00:32:28,200
2 t

457
00:32:28,240 --> 00:32:37,559
by this these um inequalities.

458
00:32:32,880 --> 00:32:37,559
And that is less than or equal to

459
00:32:37,840 --> 00:32:43,480
I guess the Hamming distance for the

460
00:32:40,480 --> 00:32:43,480
code.

461
00:32:44,159 --> 00:32:49,519
But we know by the definition of a

462
00:32:46,159 --> 00:32:51,919
hamming distance from the code that it's

463
00:32:49,519 --> 00:32:55,519
the minimum

464
00:32:51,919 --> 00:32:59,480
distance between two code words.

465
00:32:55,519 --> 00:32:59,480
So this is a contradiction.

466
00:33:00,720 --> 00:33:08,640
I should say less than here

467
00:33:04,320 --> 00:33:13,039
because t was one less than the distance

468
00:33:08,640 --> 00:33:16,039
of code divided by two.

469
00:33:13,039 --> 00:33:16,039
Okay.

470
00:33:49,919 --> 00:33:54,440
for a linear code.

471
00:33:56,960 --> 00:34:03,760
Let

472
00:33:59,840 --> 00:34:08,919
D equal the minimum

473
00:34:03,760 --> 00:34:08,919
over all code words in the code

474
00:34:11,440 --> 00:34:15,919
of the Hamming distance or Hamming

475
00:34:13,599 --> 00:34:18,639
weight.

476
00:34:15,919 --> 00:34:24,280
Um

477
00:34:18,639 --> 00:34:24,280
what did we use for Hamming weight? Um

478
00:34:24,720 --> 00:34:29,320
W. Okay, so W of C

479
00:34:30,079 --> 00:34:35,839
and we have to specify that C is not

480
00:34:32,720 --> 00:34:40,839
equal to zero here. So the minimum

481
00:34:35,839 --> 00:34:40,839
weight of any nonzero code word

482
00:34:44,000 --> 00:34:49,320
then

483
00:34:45,599 --> 00:34:49,320
C can correct

484
00:34:50,320 --> 00:34:57,960
um

485
00:34:52,240 --> 00:34:57,960
D -1 / 2 errors

486
00:35:02,960 --> 00:35:09,320
proof.

487
00:35:05,200 --> 00:35:09,320
Well, we're going to use this theorem.

488
00:35:14,079 --> 00:35:19,359
Might as well call this a theorem, too.

489
00:35:16,560 --> 00:35:22,359
Proof.

490
00:35:19,359 --> 00:35:22,359
Um

491
00:35:29,839 --> 00:35:36,880
so the minimum

492
00:35:32,560 --> 00:35:41,200
over C1 C2

493
00:35:36,880 --> 00:35:46,000
2 in C of the distance between the two

494
00:35:41,200 --> 00:35:49,800
code words is equal to

495
00:35:46,000 --> 00:35:49,800
the minimum um

496
00:35:50,640 --> 00:35:58,520
C and C the weight of C

497
00:35:55,520 --> 00:35:58,520
because

498
00:35:58,720 --> 00:36:07,599
well why because the weight of

499
00:36:03,200 --> 00:36:12,920
C1 minus C2 is equal to the Hamming

500
00:36:07,599 --> 00:36:12,920
distance between C1 and C2.

501
00:36:13,200 --> 00:36:19,280
So for a linear code C, you want C to be

502
00:36:16,560 --> 00:36:23,880
able to correct

503
00:36:19,280 --> 00:36:23,880
D minus one over two errors.

504
00:36:34,000 --> 00:36:37,000
Okay.

505
00:37:09,440 --> 00:37:15,240
So the generating G for Hammond code

506
00:37:19,359 --> 00:37:29,040
was G equal

507
00:37:21,839 --> 00:37:40,920
one 1 0 0 1 1 0 0 1 0 0

508
00:37:29,040 --> 00:37:40,920
1 0 1 1 0 0 1 0 1 0 1 and 0 0 1 one one

509
00:37:43,440 --> 00:37:49,680
okay I want to claim you can define a

510
00:37:46,480 --> 00:37:53,480
Hamming code with block length 2 to the

511
00:37:49,680 --> 00:37:53,480
k minus on.

512
00:38:09,040 --> 00:38:13,640
Okay.

513
00:38:10,640 --> 00:38:13,640
I

514
00:38:26,560 --> 00:38:37,520
n = 2 to the k

515
00:38:31,280 --> 00:38:40,480
um 2 to the n minus k minus one.

516
00:38:37,520 --> 00:38:42,480
So here for this hamming code K which is

517
00:38:40,480 --> 00:38:44,720
the number of

518
00:38:42,480 --> 00:38:46,960
bits it encodes

519
00:38:44,720 --> 00:38:51,520
is four

520
00:38:46,960 --> 00:38:56,560
and the block length is 7 which is 2 7 -

521
00:38:51,520 --> 00:38:59,560
4 that's 8 - 1 is 7. And how do we do

522
00:38:56,560 --> 00:38:59,560
that?

523
00:39:22,079 --> 00:39:29,440
Okay. Well, we're going to do the same

524
00:39:23,760 --> 00:39:31,599
thing as we did before. one one one

525
00:39:29,440 --> 00:39:34,400
um

526
00:39:31,599 --> 00:39:39,160
one one.

527
00:39:34,400 --> 00:39:39,160
So that you see is

528
00:39:56,880 --> 00:40:03,040
And then okay so we put the identity

529
00:39:59,680 --> 00:40:06,040
matrix here and now we're going to put

530
00:40:03,040 --> 00:40:06,040
all

531
00:40:06,560 --> 00:40:10,599
all binary strings

532
00:40:13,280 --> 00:40:16,760
length K

533
00:40:19,200 --> 00:40:22,920
length um

534
00:40:24,560 --> 00:40:28,400
s

535
00:40:26,800 --> 00:40:32,000
with

536
00:40:28,400 --> 00:40:36,160
at most two

537
00:40:32,000 --> 00:40:46,079
with at least two ones.

538
00:40:36,160 --> 00:40:50,160
So 1 1 0 0 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1

539
00:40:46,079 --> 00:40:55,599
0 0 1 1

540
00:40:50,160 --> 00:40:58,760
So I guess there's six here then four

541
00:40:55,599 --> 00:40:58,760
1 one

542
00:40:58,960 --> 00:41:04,640
one

543
00:41:00,800 --> 00:41:08,760
so this is 11

544
00:41:04,640 --> 00:41:08,760
and this is 15.

545
00:41:13,520 --> 00:41:17,800
So here k= 11

546
00:41:17,839 --> 00:41:23,920
n= 15

547
00:41:20,720 --> 00:41:26,480
um k equals

548
00:41:23,920 --> 00:41:30,240
well there are two to the s strings of

549
00:41:26,480 --> 00:41:33,200
left s total and if we remove the ones

550
00:41:30,240 --> 00:41:39,319
with one one and the ones with zero ones

551
00:41:33,200 --> 00:41:39,319
you get 2 s - s - one

552
00:41:42,960 --> 00:41:51,760
and n has s more rows or s more columns

553
00:41:49,040 --> 00:41:54,400
than

554
00:41:51,760 --> 00:41:56,720
I mean so this identity matrix has an

555
00:41:54,400 --> 00:42:00,640
equal number of rows and columns. So we

556
00:41:56,720 --> 00:42:02,640
have s more

557
00:42:00,640 --> 00:42:04,720
um

558
00:42:02,640 --> 00:42:08,640
columns

559
00:42:04,720 --> 00:42:13,839
than k. So that's

560
00:42:08,640 --> 00:42:19,800
k + s = 2 s -1.

561
00:42:13,839 --> 00:42:19,800
So this is the 1511 hamming code.

562
00:42:27,280 --> 00:42:30,280
Okay.

563
00:42:34,720 --> 00:42:40,359
And now we have to explain why does it

564
00:42:37,359 --> 00:42:40,359
correct.

565
00:43:12,160 --> 00:43:19,200
Why does

566
00:43:16,000 --> 00:43:22,599
it correct

567
00:43:19,200 --> 00:43:22,599
one error?

568
00:43:26,240 --> 00:43:29,720
need to show

569
00:43:31,119 --> 00:43:35,319
all row sums

570
00:43:39,359 --> 00:43:45,079
minimum

571
00:43:41,119 --> 00:43:45,079
weight three

572
00:43:47,200 --> 00:43:52,760
are all nonzero row sums have minimum

573
00:43:49,520 --> 00:43:52,760
weight three.

574
00:43:54,079 --> 00:43:59,160
So let's start start with easy case.

575
00:44:03,040 --> 00:44:09,119
All rows

576
00:44:05,599 --> 00:44:12,079
have minimum

577
00:44:09,119 --> 00:44:16,160
weight three or rather all rows have

578
00:44:12,079 --> 00:44:19,520
weight at least three. Why is that?

579
00:44:16,160 --> 00:44:24,599
Well, let's pick any row.

580
00:44:19,520 --> 00:44:24,599
Let's say this one.

581
00:44:34,800 --> 00:44:41,760
The um

582
00:44:37,599 --> 00:44:43,760
the identity matrix has one

583
00:44:41,760 --> 00:44:45,760
bit in it

584
00:44:43,760 --> 00:44:49,400
and the parity check bits have at least

585
00:44:45,760 --> 00:44:49,400
two bits in them.

586
00:44:59,200 --> 00:45:05,000
One bit

587
00:45:01,280 --> 00:45:05,000
parody check bits

588
00:45:08,240 --> 00:45:11,480
two bits.

589
00:45:14,319 --> 00:45:20,440
Okay.

590
00:45:16,240 --> 00:45:20,440
any sum of two rows.

591
00:45:25,760 --> 00:45:31,079
Well, let's

592
00:45:28,079 --> 00:45:31,079
um

593
00:45:33,200 --> 00:45:39,280
take

594
00:45:35,839 --> 00:45:41,599
two rows and look at their sum. There

595
00:45:39,280 --> 00:45:44,800
are two different

596
00:45:41,599 --> 00:45:47,359
um ones in the identity matrix part. So

597
00:45:44,800 --> 00:45:49,839
we need at least one one in the parody

598
00:45:47,359 --> 00:45:52,240
check bits. But we arranged these parody

599
00:45:49,839 --> 00:45:55,599
check bits so that they were all

600
00:45:52,240 --> 00:45:57,839
different. And when you take two non-

601
00:45:55,599 --> 00:46:00,960
different strings and you sum them mod

602
00:45:57,839 --> 00:46:02,640
two you don't get zero you get at least

603
00:46:00,960 --> 00:46:07,400
one.

604
00:46:02,640 --> 00:46:07,400
So here the addended matrix part

605
00:46:08,079 --> 00:46:14,119
has two bits

606
00:46:10,400 --> 00:46:14,119
on the parity check

607
00:46:15,680 --> 00:46:20,240
at least one bit.

608
00:46:18,880 --> 00:46:23,240
I should have said at least two bits

609
00:46:20,240 --> 00:46:23,240
there.

610
00:46:23,599 --> 00:46:27,880
And any sum of three rows

611
00:46:30,560 --> 00:46:35,920
or more,

612
00:46:33,520 --> 00:46:38,160
the um

613
00:46:35,920 --> 00:46:42,200
identity part

614
00:46:38,160 --> 00:46:42,200
has at least three bits.

615
00:46:51,680 --> 00:46:55,680
Okay.

616
00:46:53,599 --> 00:46:58,319
So, the last thing I want to do today is

617
00:46:55,680 --> 00:47:01,680
tell you how to correct

618
00:46:58,319 --> 00:47:05,720
errors in

619
00:47:01,680 --> 00:47:05,720
um linear codes

620
00:47:05,920 --> 00:47:08,920
because

621
00:47:11,920 --> 00:47:14,920
um

622
00:47:16,720 --> 00:47:25,000
>> I have a question.

623
00:47:18,160 --> 00:47:25,000
>> Yeah. Why is that k 23 - 5?

624
00:47:25,680 --> 00:47:32,560
>> Okay, so we're looking at all binary

625
00:47:28,960 --> 00:47:34,319
strings of length s with at least two

626
00:47:32,560 --> 00:47:36,319
ones.

627
00:47:34,319 --> 00:47:39,920
So how many binary strings of length s

628
00:47:36,319 --> 00:47:42,960
are there? There are two to the s binary

629
00:47:39,920 --> 00:47:45,280
strings of length s. And now we have to

630
00:47:42,960 --> 00:47:48,000
subtract out the ones that have one one

631
00:47:45,280 --> 00:47:50,000
or zero ones. There are s1's with one

632
00:47:48,000 --> 00:47:52,800
one because the one can be in any of the

633
00:47:50,000 --> 00:47:55,119
s positions and there's one string with

634
00:47:52,800 --> 00:47:58,000
zero ones which is the all zero strings.

635
00:47:55,119 --> 00:48:00,640
So the number of binary strings with at

636
00:47:58,000 --> 00:48:03,520
least two ones is 2 to the s minus s

637
00:48:00,640 --> 00:48:07,839
minus one.

638
00:48:03,520 --> 00:48:09,839
And then to and that's the number of

639
00:48:07,839 --> 00:48:12,720
rows in this matrix. To get the number

640
00:48:09,839 --> 00:48:15,520
of columns in this matrix, well, we just

641
00:48:12,720 --> 00:48:17,040
take the number of rows because the

642
00:48:15,520 --> 00:48:21,680
identity matrix has an equal number of

643
00:48:17,040 --> 00:48:24,880
rows and columns and add s and that's

644
00:48:21,680 --> 00:48:27,280
2 to the s minus one.

645
00:48:24,880 --> 00:48:31,440
So this is a this is the class of

646
00:48:27,280 --> 00:48:34,440
Hamming codes and

647
00:48:31,440 --> 00:48:34,440
um

648
00:48:36,400 --> 00:48:40,559
okay I should I should say something

649
00:48:37,920 --> 00:48:45,400
about them later but let me first tell

650
00:48:40,559 --> 00:48:45,400
you how to correct errors in

651
00:48:46,400 --> 00:48:51,400
um

652
00:48:47,920 --> 00:48:51,400
linear codes.

653
00:49:11,680 --> 00:49:14,680
Okay.

654
00:49:17,599 --> 00:49:22,640
Oh, wait. I want to pull this down.

655
00:49:31,760 --> 00:49:34,760
Well,

656
00:49:36,160 --> 00:49:40,520
to work with a code

657
00:49:43,760 --> 00:49:47,359
need

658
00:49:45,440 --> 00:49:51,160
to

659
00:49:47,359 --> 00:49:51,160
encode a age.

660
00:49:55,680 --> 00:50:02,280
Identify

661
00:49:58,400 --> 00:50:02,280
positions with error.

662
00:50:05,119 --> 00:50:09,280
And once you've identified the positions

663
00:50:06,720 --> 00:50:12,680
with the errors, you can fix them and

664
00:50:09,280 --> 00:50:12,680
then decode.

665
00:50:19,680 --> 00:50:24,000
And

666
00:50:21,839 --> 00:50:28,200
we

667
00:50:24,000 --> 00:50:28,200
defined generator matrices.

668
00:50:43,920 --> 00:50:49,319
generator

669
00:50:45,599 --> 00:50:49,319
matrix for code

670
00:50:53,680 --> 00:50:57,079
G equals

671
00:50:57,839 --> 00:51:03,040
code

672
00:51:00,800 --> 00:51:06,319
is

673
00:51:03,040 --> 00:51:06,319
set of all row sums.

674
00:51:16,079 --> 00:51:19,559
to encode

675
00:51:20,720 --> 00:51:27,760
use

676
00:51:22,319 --> 00:51:31,520
C= M * G. So M is the message,

677
00:51:27,760 --> 00:51:35,000
C is the code code word and G is a

678
00:51:31,520 --> 00:51:35,000
generator matrix.

679
00:51:42,319 --> 00:51:45,319
So

680
00:51:47,119 --> 00:51:54,160
if m = 1 0 01,

681
00:51:51,839 --> 00:51:56,880
mg

682
00:51:54,160 --> 00:51:59,200
is the sum

683
00:51:56,880 --> 00:52:02,000
of the first row and the last row

684
00:51:59,200 --> 00:52:09,960
because this is this is the first one

685
00:52:02,000 --> 00:52:09,960
and the last one. So it's 1 0 0 1 0 0 1.

686
00:52:14,000 --> 00:52:18,359
So encoding is easy

687
00:52:20,640 --> 00:52:25,720
to decode. We need the parity check

688
00:52:22,720 --> 00:52:25,720
matrix.

689
00:52:40,480 --> 00:52:44,680
H is defined

690
00:52:46,160 --> 00:52:50,800
as

691
00:52:48,240 --> 00:52:55,520
well.

692
00:52:50,800 --> 00:52:58,960
We want GH equals zero

693
00:52:55,520 --> 00:53:02,280
and we want H to have maximum rank. So

694
00:52:58,960 --> 00:53:02,280
that GH

695
00:53:04,160 --> 00:53:08,839
H maximum rank

696
00:53:09,920 --> 00:53:16,040
with

697
00:53:11,599 --> 00:53:16,040
this condition.

698
00:53:24,559 --> 00:53:27,559
Okay.

699
00:53:34,720 --> 00:53:37,720
Um,

700
00:53:38,160 --> 00:53:41,960
let's leave this up

701
00:53:51,119 --> 00:53:55,160
and I will say something.

702
00:53:57,200 --> 00:54:04,200
for all codes, all linear codes,

703
00:54:08,319 --> 00:54:15,319
we can find

704
00:54:11,119 --> 00:54:15,319
a generator matrix G

705
00:54:21,599 --> 00:54:25,000
of the form

706
00:54:27,599 --> 00:54:33,119
one one one one.

707
00:54:30,640 --> 00:54:35,280
So this is the identity matrix and some

708
00:54:33,119 --> 00:54:38,760
matrix here S.

709
00:54:35,280 --> 00:54:38,760
So you see

710
00:54:42,240 --> 00:54:47,280
here here

711
00:54:44,800 --> 00:54:50,760
the second part is S and this first part

712
00:54:47,280 --> 00:54:50,760
is the identity.

713
00:54:50,880 --> 00:54:55,920
and by general linear algebra

714
00:54:53,359 --> 00:54:58,000
configurations.

715
00:54:55,920 --> 00:55:02,760
Proof

716
00:54:58,000 --> 00:55:02,760
proof is really Gaussian elimination.

717
00:55:10,480 --> 00:55:15,599
You take the code and you do Gaussian

718
00:55:12,720 --> 00:55:19,280
elimination on it and then you rearrange

719
00:55:15,599 --> 00:55:20,960
the order of the coordinates to get this

720
00:55:19,280 --> 00:55:22,640
identity.

721
00:55:20,960 --> 00:55:24,000
And

722
00:55:22,640 --> 00:55:27,200
you know, I'm not going to go into

723
00:55:24,000 --> 00:55:31,839
further details because they're not that

724
00:55:27,200 --> 00:55:36,680
important for this. And the um

725
00:55:31,839 --> 00:55:36,680
and they're not in the um notes either.

726
00:55:43,440 --> 00:55:48,240
And I want to claim that here h is equal

727
00:55:46,480 --> 00:55:53,680
to

728
00:55:48,240 --> 00:55:57,040
minus s i

729
00:55:53,680 --> 00:56:00,079
where you have a minus s here and an i

730
00:55:57,040 --> 00:56:03,079
of the right form.

731
00:56:00,079 --> 00:56:03,079
So,

732
00:56:08,240 --> 00:56:16,160
h is equal to -1 -1 0.

733
00:56:13,520 --> 00:56:22,920
I feel stupid putting these minus1's on

734
00:56:16,160 --> 00:56:22,920
because minus1 equals one in the um

735
00:56:24,319 --> 00:56:35,359
there's another row here. -1 -1 - one 1

736
00:56:30,960 --> 00:56:39,920
because min -1 equals 1 in binary. So

737
00:56:35,359 --> 00:56:43,839
this really could be simplified to

738
00:56:39,920 --> 00:56:47,559
this but for non-binary codes you really

739
00:56:43,839 --> 00:56:47,559
need the minus s.

740
00:56:48,319 --> 00:56:52,119
And you can see that.

741
00:56:52,160 --> 00:56:57,480
Oh

742
00:56:53,839 --> 00:56:57,480
well, I will explain

743
00:57:02,640 --> 00:57:11,359
and G equals I S. And note this I is a

744
00:57:09,359 --> 00:57:17,520
different size identity matrix than this

745
00:57:11,359 --> 00:57:21,760
I. But anyway, G H is equal to

746
00:57:17,520 --> 00:57:24,319
um I S

747
00:57:21,760 --> 00:57:26,160
minus S I.

748
00:57:24,319 --> 00:57:32,400
And when you do matrix multiplication

749
00:57:26,160 --> 00:57:37,400
here, you get I * - S plus S * I equals

750
00:57:32,400 --> 00:57:37,400
I * - S

751
00:57:40,319 --> 00:57:49,799
+ S * I equals zero.

752
00:57:45,680 --> 00:57:49,799
So G is

753
00:57:50,960 --> 00:57:57,839
um

754
00:57:53,119 --> 00:57:59,839
so GH is zero which was our condition

755
00:57:57,839 --> 00:58:01,520
for

756
00:57:59,839 --> 00:58:04,240
um

757
00:58:01,520 --> 00:58:07,920
parody check matrix. And you can also

758
00:58:04,240 --> 00:58:15,400
see that H is a maximum

759
00:58:07,920 --> 00:58:15,400
rank matrix such as GH equals Z because

760
00:58:15,599 --> 00:58:23,640
um well that's linear algebra 2. Um

761
00:58:20,640 --> 00:58:23,640
H.

762
00:58:25,839 --> 00:58:28,839
Um

763
00:58:35,839 --> 00:58:42,200
I mean I'm going to say H gener um

764
00:58:42,720 --> 00:58:49,000
yeah

765
00:58:44,799 --> 00:58:49,000
H transpose generates

766
00:58:50,000 --> 00:58:55,720
the um perpendicular space

767
00:58:57,119 --> 00:59:03,040
space

768
00:58:59,359 --> 00:59:08,160
2 G

769
00:59:03,040 --> 00:59:12,559
and the dimension of H transpose plus

770
00:59:08,160 --> 00:59:15,440
the dimension of G is equal to N, the

771
00:59:12,559 --> 00:59:19,119
dimension of the entire space.

772
00:59:15,440 --> 00:59:22,160
And this is true for any

773
00:59:19,119 --> 00:59:24,799
spaces over

774
00:59:22,160 --> 00:59:28,240
for any linear spaces

775
00:59:24,799 --> 00:59:30,319
even those over finite fields

776
00:59:28,240 --> 00:59:33,680
even though

777
00:59:30,319 --> 00:59:38,520
g intersect hrpose

778
00:59:33,680 --> 00:59:38,520
might be non-mpt.

779
00:59:38,720 --> 00:59:44,480
So um I mean you you guys are used to

780
00:59:42,480 --> 00:59:49,440
thinking of linear algebra over the

781
00:59:44,480 --> 00:59:53,440
reals and then you have a space s and a

782
00:59:49,440 --> 00:59:57,119
perpendicular space surp and s intersect

783
00:59:53,440 --> 01:00:00,119
sp is just zero. This isn't true here.

784
00:59:57,119 --> 01:00:00,119
Um

785
01:00:01,200 --> 01:00:06,839
let's see.

786
01:00:03,839 --> 01:00:06,839
Um

787
01:00:14,319 --> 01:00:20,400
look at the last row in G. It's

788
01:00:17,359 --> 01:00:25,559
perpendicular to itself. So the last row

789
01:00:20,400 --> 01:00:25,559
in G is also in

790
01:00:25,920 --> 01:00:30,559
H

791
01:00:28,000 --> 01:00:35,280
in the row space of H transpose because

792
01:00:30,559 --> 01:00:39,839
everything that's perpendicular to

793
01:00:35,280 --> 01:00:42,319
um all the guys in G

794
01:00:39,839 --> 01:00:46,400
is an H transpose and you can see that

795
01:00:42,319 --> 01:00:48,400
the last row is per all the other rows

796
01:00:46,400 --> 01:00:50,640
in G.

797
01:00:48,400 --> 01:00:54,400
So there's some linear combination of

798
01:00:50,640 --> 01:00:56,480
rows in H which gives you this and you

799
01:00:54,400 --> 01:00:58,160
can see that it's or some linear

800
01:00:56,480 --> 01:01:00,079
combination of columns in H that gives

801
01:00:58,160 --> 01:01:02,400
you that and you can see it's the sum of

802
01:01:00,079 --> 01:01:04,079
all three columns because you need one

803
01:01:02,400 --> 01:01:07,040
one one

804
01:01:04,079 --> 01:01:11,720
and the last three entries in the column

805
01:01:07,040 --> 01:01:11,720
and then the

806
01:01:11,920 --> 01:01:17,079
sum of the first three is

807
01:01:17,760 --> 01:01:25,480
is

808
01:01:19,520 --> 01:01:25,480
the sum of these four columns is 0001.

809
01:01:25,760 --> 01:01:28,760
So

810
01:01:30,240 --> 01:01:36,000
a space and its perpendicular space can

811
01:01:33,839 --> 01:01:41,480
intersect but that doesn't matter. So

812
01:01:36,000 --> 01:01:41,480
this is the parody check matrix.

813
01:01:43,520 --> 01:01:46,760
And now

814
01:01:47,359 --> 01:01:51,160
suppose we have

815
01:01:52,640 --> 01:01:58,359
uh

816
01:01:54,880 --> 01:01:58,359
linear code

817
01:01:59,280 --> 01:02:06,640
with

818
01:02:01,200 --> 01:02:08,400
G and H are the generators matrix and

819
01:02:06,640 --> 01:02:13,000
the

820
01:02:08,400 --> 01:02:13,000
um parody check matrix.

821
01:02:15,520 --> 01:02:20,880
End code

822
01:02:17,440 --> 01:02:23,680
we get mg

823
01:02:20,880 --> 01:02:26,000
error.

824
01:02:23,680 --> 01:02:29,040
We have mg

825
01:02:26,000 --> 01:02:33,119
+ e.

826
01:02:29,040 --> 01:02:36,440
And the next step is compute

827
01:02:33,119 --> 01:02:36,440
the syndrome

828
01:02:37,599 --> 01:02:45,559
of C tilda. And that's c t k t k t k t k

829
01:02:41,599 --> 01:02:45,559
t k t k t k t k t k t kilda * h.

830
01:02:46,960 --> 01:02:54,319
This is mg + e

831
01:02:49,920 --> 01:02:58,400
* h is equal to

832
01:02:54,319 --> 01:03:00,880
mg h + eh

833
01:02:58,400 --> 01:03:06,280
which is just eh

834
01:03:00,880 --> 01:03:06,280
because remember g * h was zero

835
01:03:08,319 --> 01:03:12,079
and this is called syndrome.

836
01:03:35,280 --> 01:03:40,880
And it's called the syndrome because

837
01:03:38,559 --> 01:03:43,880
it's what you use to diagnosed the

838
01:03:40,880 --> 01:03:43,880
error.

839
01:03:44,400 --> 01:03:47,400
So

840
01:03:51,520 --> 01:03:57,160
syndrome

841
01:03:54,160 --> 01:03:57,160
depends

842
01:03:57,520 --> 01:04:03,160
only on the error and not on the encoded

843
01:03:59,920 --> 01:04:03,160
code word.

844
01:04:07,760 --> 01:04:13,079
not on the message.

845
01:04:13,680 --> 01:04:16,680
Okay.

846
01:04:18,880 --> 01:04:27,240
How do you go

847
01:04:24,240 --> 01:04:27,240
from

848
01:04:28,720 --> 01:04:33,000
S to E?

849
01:04:33,760 --> 01:04:36,760
Well,

850
01:04:38,480 --> 01:04:42,200
it's not easy.

851
01:04:42,319 --> 01:04:48,480
Depends

852
01:04:44,880 --> 01:04:50,480
on the code.

853
01:04:48,480 --> 01:04:52,240
There's no

854
01:04:50,480 --> 01:04:54,160
efficient algorithm for taking a

855
01:04:52,240 --> 01:04:56,319
syndrome for an arbitrary code and

856
01:04:54,160 --> 01:05:00,720
computing the error. You have to do

857
01:04:56,319 --> 01:05:03,359
something that is code dependent. And

858
01:05:00,720 --> 01:05:05,920
we're not going to um

859
01:05:03,359 --> 01:05:07,680
I mean there could be lots and lots of

860
01:05:05,920 --> 01:05:09,760
different ways going from the syndrome

861
01:05:07,680 --> 01:05:11,599
to the error depending on the code and

862
01:05:09,760 --> 01:05:14,079
some of them can be quite complicated

863
01:05:11,599 --> 01:05:17,720
some of them are easy for Hammond codes

864
01:05:14,079 --> 01:05:17,720
it's very easy

865
01:05:27,200 --> 01:05:32,240
code.

866
01:05:29,599 --> 01:05:34,079
Assume

867
01:05:32,240 --> 01:05:35,599
error

868
01:05:34,079 --> 01:05:38,160
has

869
01:05:35,599 --> 01:05:42,079
one bit

870
01:05:38,160 --> 01:05:44,319
our Hamming weight one.

871
01:05:42,079 --> 01:05:47,480
So one bit equal one and all the others

872
01:05:44,319 --> 01:05:47,480
are zero.

873
01:05:47,520 --> 01:05:56,599
0 0 1 0 0.

874
01:05:52,240 --> 01:05:56,599
Let's make this the K bit.

875
01:05:57,920 --> 01:06:05,200
times the Hamming matrix

876
01:06:02,000 --> 01:06:09,839
is kith

877
01:06:05,200 --> 01:06:12,559
not Hamming matrix times the um

878
01:06:09,839 --> 01:06:15,520
parody check matrix. So the if you have

879
01:06:12,559 --> 01:06:17,440
a one if you have a vector with one and

880
01:06:15,520 --> 01:06:21,640
you multiply it by the matrix you just

881
01:06:17,440 --> 01:06:21,640
get the kith row of the matrix

882
01:06:42,960 --> 01:06:50,000
So because the Hamming code can only

883
01:06:46,319 --> 01:06:53,839
correct one bit errors, we only need to

884
01:06:50,000 --> 01:06:56,559
worry about the case where

885
01:06:53,839 --> 01:07:00,480
the

886
01:06:56,559 --> 01:07:03,359
error E has one bit in it and that case

887
01:07:00,480 --> 01:07:06,000
is easy to decode. So let's do an

888
01:07:03,359 --> 01:07:07,680
example.

889
01:07:06,000 --> 01:07:09,440
Because I think we have just enough.

890
01:07:07,680 --> 01:07:14,039
Well, we pro probably have more than

891
01:07:09,440 --> 01:07:14,039
enough time for an example, but

892
01:07:14,559 --> 01:07:21,039
we should do an example.

893
01:07:18,400 --> 01:07:27,599
End code

894
01:07:21,039 --> 01:07:33,559
1 1 0. Oh gosh. One one zero in

895
01:07:27,599 --> 01:07:33,559
our seven bit Hammond code.

896
01:07:36,960 --> 01:07:41,920
So there's our seven bit hamming code up

897
01:07:39,039 --> 01:07:46,400
there. We sum the first three rows

898
01:07:41,920 --> 01:07:51,039
because one one we have the first three

899
01:07:46,400 --> 01:07:59,520
entries of our message are one.

900
01:07:51,039 --> 01:08:02,079
M= 111. So that's um well it's 1 one 1 0

901
01:07:59,520 --> 01:08:05,400
um

902
01:08:02,079 --> 01:08:05,400
0 0

903
01:08:13,680 --> 01:08:17,319
add error

904
01:08:20,640 --> 01:08:29,440
and you get Let's say E equals 0 0 0

905
01:08:25,679 --> 01:08:31,120
1 0. We get 1 1 1

906
01:08:29,440 --> 01:08:34,440
0 0

907
01:08:31,120 --> 01:08:34,440
1 0.

908
01:08:36,239 --> 01:08:42,480
So now we have mg

909
01:08:38,880 --> 01:08:44,719
plus e * h.

910
01:08:42,480 --> 01:08:46,560
So that's the first sum the first three

911
01:08:44,719 --> 01:08:49,600
rows of h

912
01:08:46,560 --> 01:08:54,560
and that's uh zeros. and then add the

913
01:08:49,600 --> 01:09:00,759
fifth row of h that's uh 0 1 0

914
01:08:54,560 --> 01:09:00,759
equals 0 1 0. And this is a syndrome

915
01:09:02,080 --> 01:09:08,040
0 1 0 is

916
01:09:05,040 --> 01:09:08,040
um

917
01:09:08,400 --> 01:09:13,440
the sixth row of h.

918
01:09:11,440 --> 01:09:16,080
Oh, this I I think I said fifth when

919
01:09:13,440 --> 01:09:19,239
here, but I meant sixth. The sixth row

920
01:09:16,080 --> 01:09:19,239
of H.

921
01:09:20,560 --> 01:09:24,440
error in position six

922
01:09:30,480 --> 01:09:34,319
0 0 0

923
01:09:32,480 --> 01:09:37,199
1 0

924
01:09:34,319 --> 01:09:41,600
and um

925
01:09:37,199 --> 01:09:44,920
this was C tilda. So C tilda plus E is

926
01:09:41,600 --> 01:09:44,920
equal to

927
01:09:45,920 --> 01:09:54,440
1 1 1 0 0 0.

928
01:09:49,040 --> 01:09:54,440
And this first bit is the message.

929
01:10:08,320 --> 01:10:11,320
Okay.

930
01:10:11,840 --> 01:10:18,040
Now, there's one more piece of

931
01:10:22,800 --> 01:10:28,480
one more section in the notes about

932
01:10:25,920 --> 01:10:30,719
Hamming codes. I don't want to get to

933
01:10:28,480 --> 01:10:33,840
read Solomon codes this time because I

934
01:10:30,719 --> 01:10:36,960
want to do them all next time. And

935
01:10:33,840 --> 01:10:40,360
that's about perfect codes.

936
01:10:36,960 --> 01:10:40,360
Oh my.

937
01:11:12,239 --> 01:11:16,199
Oh, perfect code

938
01:11:30,000 --> 01:11:36,920
as one.

939
01:11:32,320 --> 01:11:36,920
All of whose

940
01:11:37,440 --> 01:11:40,440
syndromes

941
01:11:41,360 --> 01:11:44,360
correspond

942
01:11:45,199 --> 01:11:49,159
to an error of

943
01:11:49,360 --> 01:11:54,920
an error

944
01:11:51,920 --> 01:11:54,920
of

945
01:11:55,280 --> 01:12:00,800
T bits

946
01:11:57,840 --> 01:12:02,719
or fewer.

947
01:12:00,800 --> 01:12:06,400
If it's a T error correcting perfect

948
01:12:02,719 --> 01:12:08,560
code, all its syndromes correspond. So

949
01:12:06,400 --> 01:12:12,920
the binary

950
01:12:08,560 --> 01:12:12,920
the Hammond codes are perfect codes.

951
01:12:22,480 --> 01:12:27,320
So how many syndromes do they have?

952
01:12:36,080 --> 01:12:41,800
Well,

953
01:12:37,760 --> 01:12:41,800
they have um

954
01:12:48,080 --> 01:12:53,760
they have um

955
01:12:50,800 --> 01:12:56,760
their syndromes are length

956
01:12:53,760 --> 01:12:56,760
espits.

957
01:13:08,080 --> 01:13:13,800
So there's 2 to the s syndromes

958
01:13:16,080 --> 01:13:23,080
and the code has 2 to the sus1 bits.

959
01:13:34,560 --> 01:13:41,120
So I want to say first the zero syndrome

960
01:13:37,920 --> 01:13:43,760
corresponds to no error and every other

961
01:13:41,120 --> 01:13:46,880
one of these syndromes corresponds to

962
01:13:43,760 --> 01:13:51,000
exactly one bit. So there's exactly as

963
01:13:46,880 --> 01:13:51,000
many syndromes as bits.

964
01:13:51,600 --> 01:13:54,600
Okay.

965
01:13:56,000 --> 01:14:00,480
And you can ask,

966
01:13:58,400 --> 01:14:03,480
are there any perfect other perfect

967
01:14:00,480 --> 01:14:03,480
codes?

968
01:14:23,840 --> 01:14:26,840
Okay.

969
01:14:46,320 --> 01:14:53,480
So to have a perfect code,

970
01:14:49,360 --> 01:14:53,480
you need um

971
01:14:55,199 --> 01:15:00,400
you need

972
01:14:58,400 --> 01:15:05,679
sum

973
01:15:00,400 --> 01:15:09,840
all the possible errors. So um

974
01:15:05,679 --> 01:15:13,280
let's say L equals 0 through T.

975
01:15:09,840 --> 01:15:15,840
And how many errors are there with how

976
01:15:13,280 --> 01:15:17,760
many

977
01:15:15,840 --> 01:15:23,120
ways are there of getting an error of

978
01:15:17,760 --> 01:15:27,440
exactly L bits? It's n choose L

979
01:15:23,120 --> 01:15:29,360
is equal to 2 to the

980
01:15:27,440 --> 01:15:32,800
something

981
01:15:29,360 --> 01:15:34,960
to the number of bits in the syndrome.

982
01:15:32,800 --> 01:15:38,360
So this is a condition that you need for

983
01:15:34,960 --> 01:15:38,360
perfect codes.

984
01:15:39,920 --> 01:15:43,480
and it's satisfied

985
01:15:46,239 --> 01:15:51,960
or this is a solution you need for

986
01:15:48,080 --> 01:15:51,960
binary perfect codes

987
01:15:55,520 --> 01:16:00,360
for Hammond codes

988
01:16:02,159 --> 01:16:07,440
and it's also satisfied if I'm

989
01:16:03,920 --> 01:16:11,199
remembering these numbers right n= 23 3

990
01:16:07,440 --> 01:16:14,560
and t = 3.

991
01:16:11,199 --> 01:16:18,800
So there's exactly one solution other

992
01:16:14,560 --> 01:16:21,360
than the one you get for Hamming pots.

993
01:16:18,800 --> 01:16:23,440
And remarkably,

994
01:16:21,360 --> 01:16:25,520
maybe it's remarkably,

995
01:16:23,440 --> 01:16:30,960
this is

996
01:16:25,520 --> 01:16:34,000
something called the gole code.

997
01:16:30,960 --> 01:16:35,920
And I should have looked this up before

998
01:16:34,000 --> 01:16:38,640
um

999
01:16:35,920 --> 01:16:41,600
before coming to class, but I didn't get

1000
01:16:38,640 --> 01:16:43,199
around to it. This was discovered by

1001
01:16:41,600 --> 01:16:48,960
Gole

1002
01:16:43,199 --> 01:16:50,640
um sometime after Hamming's um paper.

1003
01:16:48,960 --> 01:16:54,000
But

1004
01:16:50,640 --> 01:16:55,520
the construction had already been found

1005
01:16:54,000 --> 01:16:58,560
by

1006
01:16:55,520 --> 01:17:01,360
uh football, although you should call

1007
01:16:58,560 --> 01:17:04,080
that soccer enthusiastic enthusiast who

1008
01:17:01,360 --> 01:17:06,880
I think was finished and coming up with

1009
01:17:04,080 --> 01:17:09,679
a betting system for soccer games,

1010
01:17:06,880 --> 01:17:14,679
football games I should say.

1011
01:17:09,679 --> 01:17:14,679
But um so

1012
01:17:17,360 --> 01:17:21,760
this is actually a remarkable

1013
01:17:20,000 --> 01:17:26,719
mathematical construction which is

1014
01:17:21,760 --> 01:17:30,239
related to finite simple groups but um I

1015
01:17:26,719 --> 01:17:32,239
don't have time to I mean

1016
01:17:30,239 --> 01:17:33,679
we don't have the mathematics to go into

1017
01:17:32,239 --> 01:17:38,080
that and I certainly don't have time to

1018
01:17:33,679 --> 01:17:41,199
go into that but this is the one

1019
01:17:38,080 --> 01:17:45,520
other binary very perfect code. There's

1020
01:17:41,199 --> 01:17:49,360
also a code over Z sub3 called the

1021
01:17:45,520 --> 01:17:56,560
turnary goalie code where

1022
01:17:49,360 --> 01:17:59,760
um you have a three to the S here and um

1023
01:17:56,560 --> 01:18:02,560
I guess uh

1024
01:17:59,760 --> 01:18:06,800
and a three to the something on this one

1025
01:18:02,560 --> 01:18:08,880
as well. Three to the L I think. But

1026
01:18:06,800 --> 01:18:12,280
anyway,

1027
01:18:08,880 --> 01:18:12,280
this is

1028
01:18:14,480 --> 01:18:19,040
if you want to use perfect code. I mean,

1029
01:18:17,120 --> 01:18:20,239
so at first, you know, after discovering

1030
01:18:19,040 --> 01:18:21,760
the Hamming code, you would say, well,

1031
01:18:20,239 --> 01:18:27,000
perfect codes are exactly what we want

1032
01:18:21,760 --> 01:18:27,000
to use, but there aren't enough of them.

