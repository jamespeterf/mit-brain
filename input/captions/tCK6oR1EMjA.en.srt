1
00:00:05,200 --> 00:00:11,679
It is my pleasure the second time in 24

2
00:00:08,240 --> 00:00:14,960
hours to introduce uh Armando Solar

3
00:00:11,679 --> 00:00:17,840
Lazama who is the he's a distinguished

4
00:00:14,960 --> 00:00:19,760
professor at the Schwarzman College of

5
00:00:17,840 --> 00:00:21,840
Computing and he is also the chief

6
00:00:19,760 --> 00:00:26,000
operating officer of the computer

7
00:00:21,840 --> 00:00:28,320
science and AI lab or Cesale and uh he

8
00:00:26,000 --> 00:00:31,359
is going to talk to you give a a kickoff

9
00:00:28,320 --> 00:00:33,680
speech to talk about how AI is impacting

10
00:00:31,359 --> 00:00:36,640
software engineering. So, uh let's let's

11
00:00:33,680 --> 00:00:36,640
hear it for

12
00:00:37,000 --> 00:00:42,800
Armando. Thank you. Thanks a lot. I'm

13
00:00:40,640 --> 00:00:45,200
very happy to be here. Uh before I

14
00:00:42,800 --> 00:00:48,640
start, just a quick show of hands. Um

15
00:00:45,200 --> 00:00:50,399
who was at my uh presentation yesterday?

16
00:00:48,640 --> 00:00:52,559
Okay, who was not at my presentation

17
00:00:50,399 --> 00:00:54,800
yesterday? Okay, great. So, we have

18
00:00:52,559 --> 00:00:56,480
about half and half. Um this was kind of

19
00:00:54,800 --> 00:00:58,160
meant to be an extended version of that

20
00:00:56,480 --> 00:01:00,079
presentation. I'll try to focus mostly

21
00:00:58,160 --> 00:01:02,480
on the stuff that I didn't talk uh

22
00:01:00,079 --> 00:01:04,640
yesterday but uh for those of you who

23
00:01:02,480 --> 00:01:07,439
are not yesterday don't worry I'll catch

24
00:01:04,640 --> 00:01:09,840
you up. So I've been working in this

25
00:01:07,439 --> 00:01:13,360
space of how do we get machines to help

26
00:01:09,840 --> 00:01:16,320
us write code for about 20 years now and

27
00:01:13,360 --> 00:01:21,119
in fact uh our very first paper in this

28
00:01:16,320 --> 00:01:23,600
space was back in 2005 and we were

29
00:01:21,119 --> 00:01:26,080
really fascinated that we could actually

30
00:01:23,600 --> 00:01:28,000
sort of semi-automatically help somebody

31
00:01:26,080 --> 00:01:30,479
write a program like hey what if I want

32
00:01:28,000 --> 00:01:31,759
to drop every third bit in a stream of

33
00:01:30,479 --> 00:01:35,439
bits and at the time it was very

34
00:01:31,759 --> 00:01:37,119
exciting um and uh it led to lots idea

35
00:01:35,439 --> 00:01:39,439
that had lots of traction. But you know

36
00:01:37,119 --> 00:01:41,360
by today's standards it looks a little

37
00:01:39,439 --> 00:01:44,640
um a little primitive right things have

38
00:01:41,360 --> 00:01:46,960
moved quite a bit in the last few years

39
00:01:44,640 --> 00:01:49,280
to the point where you know today people

40
00:01:46,960 --> 00:01:51,840
are really seriously questioning the uh

41
00:01:49,280 --> 00:01:54,479
the point of are people actually even

42
00:01:51,840 --> 00:01:58,320
have to learn to code uh is there any

43
00:01:54,479 --> 00:02:00,399
sense in learning uh programming at uh

44
00:01:58,320 --> 00:02:03,119
at this point right and there's just

45
00:02:00,399 --> 00:02:06,399
this big explosion of startups and uh

46
00:02:03,119 --> 00:02:09,759
tools and companies that are uh being

47
00:02:06,399 --> 00:02:12,720
set up to leverage this technology and

48
00:02:09,759 --> 00:02:17,599
producing tools that are producing real

49
00:02:12,720 --> 00:02:20,480
value to um to people in the field. And

50
00:02:17,599 --> 00:02:22,560
so um you know we've uh we've been

51
00:02:20,480 --> 00:02:24,879
working in this field for many years. In

52
00:02:22,560 --> 00:02:26,480
fact we wrote uh some of the earliest

53
00:02:24,879 --> 00:02:30,000
papers for example using auto

54
00:02:26,480 --> 00:02:32,879
reggressive models to actually generate

55
00:02:30,000 --> 00:02:37,200
uh code. Incidentally, our uh very first

56
00:02:32,879 --> 00:02:41,680
source of training data was actually uh

57
00:02:37,200 --> 00:02:43,200
uh edexm right and uh using uh code

58
00:02:41,680 --> 00:02:46,800
submitted by students so that we could

59
00:02:43,200 --> 00:02:50,640
later help students uh uh identify their

60
00:02:46,800 --> 00:02:52,720
mistakes in in their code. But you know

61
00:02:50,640 --> 00:02:54,800
like everybody else uh especially when

62
00:02:52,720 --> 00:02:57,599
GPT4 was released one of the first

63
00:02:54,800 --> 00:02:59,280
questions we had was you know should we

64
00:02:57,599 --> 00:03:02,239
still be working in this problem right?

65
00:02:59,280 --> 00:03:04,159
is there actually still uh some work to

66
00:03:02,239 --> 00:03:07,360
to do? And so we actually spent a fair

67
00:03:04,159 --> 00:03:11,599
bit of time trying to look a little bit

68
00:03:07,360 --> 00:03:13,120
more deeply into the capabilities of of

69
00:03:11,599 --> 00:03:15,040
some of these models and trying to

70
00:03:13,120 --> 00:03:17,680
understand, you know, yes, they can

71
00:03:15,040 --> 00:03:20,480
clearly solve problems that are very

72
00:03:17,680 --> 00:03:23,040
challenging for humans and uh you know,

73
00:03:20,480 --> 00:03:24,159
they seem to be able to uh do well on

74
00:03:23,040 --> 00:03:27,440
all these different programming

75
00:03:24,159 --> 00:03:30,319
competitions. But you know are they

76
00:03:27,440 --> 00:03:33,760
really actually good programmers right

77
00:03:30,319 --> 00:03:35,440
can they actually write uh good code so

78
00:03:33,760 --> 00:03:37,840
we embarked on a series of studies

79
00:03:35,440 --> 00:03:41,239
actually looking at trying to understand

80
00:03:37,840 --> 00:03:43,360
the capabilities of these LLMs for

81
00:03:41,239 --> 00:03:45,680
example one of the first things we

82
00:03:43,360 --> 00:03:49,120
wanted to see was

83
00:03:45,680 --> 00:03:51,680
uh you know people are using um some

84
00:03:49,120 --> 00:03:54,799
benchmarks like human eval to try to see

85
00:03:51,680 --> 00:03:57,120
you know how good are these models at

86
00:03:54,799 --> 00:03:59,040
solving algorithmic problems. But one of

87
00:03:57,120 --> 00:04:03,599
the questions we had was, you know, how

88
00:03:59,040 --> 00:04:05,840
representative are these tests for, you

89
00:04:03,599 --> 00:04:09,720
know, the kind of skills that you expect

90
00:04:05,840 --> 00:04:13,360
from a human uh programmer, right?

91
00:04:09,720 --> 00:04:16,239
And one of the things that we're also

92
00:04:13,360 --> 00:04:18,880
starting to see was a lot of new models

93
00:04:16,239 --> 00:04:23,120
coming up that claimed to be much

94
00:04:18,880 --> 00:04:25,520
simpler and much smaller than say GP4

95
00:04:23,120 --> 00:04:28,560
but were claiming results on these

96
00:04:25,520 --> 00:04:32,400
benchmarks that were you know on par or

97
00:04:28,560 --> 00:04:34,560
even above uh these uh these tools. And

98
00:04:32,400 --> 00:04:36,320
this, you know, was a little bit of an

99
00:04:34,560 --> 00:04:39,440
indication that maybe these tests were

100
00:04:36,320 --> 00:04:42,240
not really testing uh true code

101
00:04:39,440 --> 00:04:45,840
understanding and true coding uh skills.

102
00:04:42,240 --> 00:04:49,280
and so partner up with uh uh some

103
00:04:45,840 --> 00:04:51,759
colleagues at uh Meta AI to look at this

104
00:04:49,280 --> 00:04:54,479
question of you know how much do these

105
00:04:51,759 --> 00:04:56,240
models actually understand code and in

106
00:04:54,479 --> 00:04:59,000
particular what happens if you just

107
00:04:56,240 --> 00:05:02,880
throw at them some randomly generated

108
00:04:59,000 --> 00:05:06,240
programs and look for something very

109
00:05:02,880 --> 00:05:09,600
simple you can have you know fiveline

110
00:05:06,240 --> 00:05:11,919
programs fourline programs and ask hey

111
00:05:09,600 --> 00:05:14,000
if I feed this input

112
00:05:11,919 --> 00:05:15,840
what is going to be the output, right?

113
00:05:14,000 --> 00:05:19,199
This is the most basic skill that you

114
00:05:15,840 --> 00:05:20,880
expect from a first year programming

115
00:05:19,199 --> 00:05:22,720
student, right? Can you read code and

116
00:05:20,880 --> 00:05:25,680
actually figure out what this piece of

117
00:05:22,720 --> 00:05:27,360
code is going to uh do? We're actually

118
00:05:25,680 --> 00:05:31,039
very careful, for example, to avoid

119
00:05:27,360 --> 00:05:33,280
things that we knew LMS are not very

120
00:05:31,039 --> 00:05:36,080
good at, like doing arithmetic with big

121
00:05:33,280 --> 00:05:39,280
numbers. uh we also work very hard to

122
00:05:36,080 --> 00:05:41,199
avoid any kind of uh external libraries

123
00:05:39,280 --> 00:05:43,600
that the model might not be familiar

124
00:05:41,199 --> 00:05:45,520
with. Right? Just keep it really really

125
00:05:43,600 --> 00:05:47,759
simple. These are the kind of tests

126
00:05:45,520 --> 00:05:50,520
where you would expect a model that

127
00:05:47,759 --> 00:05:55,360
actually knows how to code to score

128
00:05:50,520 --> 00:05:58,080
100%. Right? And what we found was that

129
00:05:55,360 --> 00:06:02,000
you know GPT4 with chain of thought

130
00:05:58,080 --> 00:06:03,600
could get around 90% which again 90%

131
00:06:02,000 --> 00:06:07,440
sounds really good until you realize

132
00:06:03,600 --> 00:06:09,919
this are super simple five line programs

133
00:06:07,440 --> 00:06:12,319
right but it really went downhill from

134
00:06:09,919 --> 00:06:15,120
there right all the way to some of these

135
00:06:12,319 --> 00:06:17,199
models that claimed on par uh

136
00:06:15,120 --> 00:06:22,240
performance with GPT4 were actually

137
00:06:17,199 --> 00:06:25,360
doing on the order of 20 or 30% right So

138
00:06:22,240 --> 00:06:28,960
um you know one of the things that uh

139
00:06:25,360 --> 00:06:30,319
that you see here is that um you know

140
00:06:28,960 --> 00:06:32,080
just because the model is doing really

141
00:06:30,319 --> 00:06:35,440
well on a benchmark doesn't necessarily

142
00:06:32,080 --> 00:06:37,039
mean that it has the programming skills

143
00:06:35,440 --> 00:06:40,720
or the programming capabilities that

144
00:06:37,039 --> 00:06:42,960
would be implied by these uh this

145
00:06:40,720 --> 00:06:45,039
performance right similarly another

146
00:06:42,960 --> 00:06:47,919
really important capability that you

147
00:06:45,039 --> 00:06:50,880
would expect from a model that

148
00:06:47,919 --> 00:06:53,680
understands code is can it actually

149
00:06:50,880 --> 00:06:55,039
reason about its mistakes, right? If it

150
00:06:53,680 --> 00:06:57,600
makes a mistake and you tell it, hey,

151
00:06:55,039 --> 00:07:02,240
you made a mistake, can it reason about

152
00:06:57,600 --> 00:07:03,840
those um mistakes? And there's a lot of

153
00:07:02,240 --> 00:07:06,800
uh there was a lot of work, for example,

154
00:07:03,840 --> 00:07:08,720
showing that uh yeah, when the model uh

155
00:07:06,800 --> 00:07:10,960
makes a mistake, it can actually do a

156
00:07:08,720 --> 00:07:14,319
pretty good job often times correcting

157
00:07:10,960 --> 00:07:16,800
those mistakes. But we wanted to dig a

158
00:07:14,319 --> 00:07:19,080
little bit deeper. And in particular, we

159
00:07:16,800 --> 00:07:22,800
wanted to focus

160
00:07:19,080 --> 00:07:25,360
on something we called uh counterfeits.

161
00:07:22,800 --> 00:07:27,759
What does that mean? It means it's an

162
00:07:25,360 --> 00:07:29,440
incorrect solution that could pass as a

163
00:07:27,759 --> 00:07:32,080
correct solution, right? It's an

164
00:07:29,440 --> 00:07:35,599
incorrect solution that doesn't throw

165
00:07:32,080 --> 00:07:38,400
any errors, doesn't uh, you know, crash

166
00:07:35,599 --> 00:07:40,319
the program, doesn't uh give you type

167
00:07:38,400 --> 00:07:42,319
errors. It just runs. It gives you an

168
00:07:40,319 --> 00:07:45,199
answer. it just happens to not be the

169
00:07:42,319 --> 00:07:47,360
right answer or on some cases on some

170
00:07:45,199 --> 00:07:49,440
inputs it might even be the right answer

171
00:07:47,360 --> 00:07:53,120
but there's just some inputs on which it

172
00:07:49,440 --> 00:07:55,919
gives the wrong answer right and so this

173
00:07:53,120 --> 00:07:57,919
is the kind of buggy program that is

174
00:07:55,919 --> 00:08:00,000
most insidious right if you get a

175
00:07:57,919 --> 00:08:01,919
program out of your model and it crashes

176
00:08:00,000 --> 00:08:03,680
and you know it's wrong and you rerun it

177
00:08:01,919 --> 00:08:06,560
but if you run a program that you know

178
00:08:03,680 --> 00:08:11,199
runs to completion produces an output it

179
00:08:06,560 --> 00:08:14,840
even passes uh some simple tests then

180
00:08:11,199 --> 00:08:20,360
you know you might be a little bit more

181
00:08:14,840 --> 00:08:24,240
um um trusting of this program right and

182
00:08:20,360 --> 00:08:26,400
so what um what we found was that okay

183
00:08:24,240 --> 00:08:29,360
so there's this correct if you give it

184
00:08:26,400 --> 00:08:31,120
the model a problem there might be some

185
00:08:29,360 --> 00:08:32,560
correct answers and there's many

186
00:08:31,120 --> 00:08:36,399
different ways of getting correct

187
00:08:32,560 --> 00:08:38,479
answers and there are these incorrect

188
00:08:36,399 --> 00:08:41,760
answers that you know are very clearly

189
00:08:38,479 --> 00:08:43,440
incorrect right Uh sometimes the models

190
00:08:41,760 --> 00:08:44,880
produce things that don't even have

191
00:08:43,440 --> 00:08:49,360
code, right? They just have a bunch of

192
00:08:44,880 --> 00:08:52,240
comments. Um but what we're interested

193
00:08:49,360 --> 00:08:55,920
in are these examples where they could

194
00:08:52,240 --> 00:08:58,000
be right. They're just not. And so what

195
00:08:55,920 --> 00:09:01,760
you find first of all is that these are

196
00:08:58,000 --> 00:09:05,519
actually a non-trivial fraction of the

197
00:09:01,760 --> 00:09:09,480
uh solutions produced by um many of

198
00:09:05,519 --> 00:09:12,320
these uh by many of these models.

199
00:09:09,480 --> 00:09:17,680
But now we had a question, right? What

200
00:09:12,320 --> 00:09:19,760
if you go and you build a test set where

201
00:09:17,680 --> 00:09:22,000
half the programs in this test set are

202
00:09:19,760 --> 00:09:24,959
correct solutions to a problem and the

203
00:09:22,000 --> 00:09:26,560
other half are these counterfeits,

204
00:09:24,959 --> 00:09:27,959
right? And you mix them together and you

205
00:09:26,560 --> 00:09:30,240
ask the model,

206
00:09:27,959 --> 00:09:31,920
hey, which one of these are correct,

207
00:09:30,240 --> 00:09:34,880
right? Is this one correct? Is that one

208
00:09:31,920 --> 00:09:38,399
correct? Right? And uh you know you can

209
00:09:34,880 --> 00:09:42,000
see um again big difference between GPT4

210
00:09:38,399 --> 00:09:45,360
and everything else but still GPT4 is uh

211
00:09:42,000 --> 00:09:49,680
you know a little bit over 80% overall

212
00:09:45,360 --> 00:09:52,640
right um good but not uh good but not

213
00:09:49,680 --> 00:09:54,399
great right and um one of the things

214
00:09:52,640 --> 00:09:55,920
that you notice also is that for a lot

215
00:09:54,399 --> 00:09:58,720
of these other models there's a strong

216
00:09:55,920 --> 00:10:00,880
bias uh to just saying things are

217
00:09:58,720 --> 00:10:03,279
correct right yep they looked correct

218
00:10:00,880 --> 00:10:04,800
they're correct uh which means But the

219
00:10:03,279 --> 00:10:06,720
ones that are actually correct, the

220
00:10:04,800 --> 00:10:09,040
accuracy is very high. But the ones that

221
00:10:06,720 --> 00:10:12,399
are actually wrong, it's uh it's very

222
00:10:09,040 --> 00:10:15,120
low. Right? With GPT4, it's actually a

223
00:10:12,399 --> 00:10:18,640
little bit more skeptical about its own

224
00:10:15,120 --> 00:10:20,800
uh correctness, but again, these are

225
00:10:18,640 --> 00:10:23,839
pretty simple programs, right? And and

226
00:10:20,800 --> 00:10:25,760
not quite the correctness that uh that

227
00:10:23,839 --> 00:10:28,640
you would expect. Here's an interesting

228
00:10:25,760 --> 00:10:33,440
thing, though. If you take these models

229
00:10:28,640 --> 00:10:35,760
and you take these counterfeits and um

230
00:10:33,440 --> 00:10:37,680
you look at again the same test as

231
00:10:35,760 --> 00:10:40,320
before just if I give you the input can

232
00:10:37,680 --> 00:10:45,040
you predict what the output is going to

233
00:10:40,320 --> 00:10:47,040
be right so for just correct solutions

234
00:10:45,040 --> 00:10:50,079
you know it gets the right output some

235
00:10:47,040 --> 00:10:52,959
percentage of the time again uh the four

236
00:10:50,079 --> 00:10:54,480
tends to be better than everything else.

237
00:10:52,959 --> 00:10:56,720
Now, if you take some of these

238
00:10:54,480 --> 00:10:58,959
counterfeit programs, but you feed them

239
00:10:56,720 --> 00:11:00,399
an input on which they just happen to

240
00:10:58,959 --> 00:11:03,279
produce the right answer, right? The

241
00:11:00,399 --> 00:11:06,920
answer that you expected, then it's

242
00:11:03,279 --> 00:11:10,160
pretty much on par with the correct uh

243
00:11:06,920 --> 00:11:13,360
solutions. But if you give it an input

244
00:11:10,160 --> 00:11:16,480
on which it produces the wrong answer,

245
00:11:13,360 --> 00:11:20,800
you can see immediately there's a drop

246
00:11:16,480 --> 00:11:24,000
in the accuracy. And here's the really

247
00:11:20,800 --> 00:11:27,200
interesting bit. If you look at that

248
00:11:24,000 --> 00:11:30,720
answer that was produced and you judge

249
00:11:27,200 --> 00:11:32,720
it not on the basis of is this the

250
00:11:30,720 --> 00:11:35,160
actual output that when you run this

251
00:11:32,720 --> 00:11:38,880
code this is what it's going to give you

252
00:11:35,160 --> 00:11:40,720
then you know this uh this is the the

253
00:11:38,880 --> 00:11:44,399
success rate. But if you look at that

254
00:11:40,720 --> 00:11:46,480
output as is this the correct output for

255
00:11:44,399 --> 00:11:50,399
the problem that this was supposed to be

256
00:11:46,480 --> 00:11:53,760
the solution to right then you know you

257
00:11:50,399 --> 00:11:57,839
get something pretty non-trivially above

258
00:11:53,760 --> 00:12:00,720
zero right in other words the model even

259
00:11:57,839 --> 00:12:02,800
though it has this wrong code that that

260
00:12:00,720 --> 00:12:04,959
was produced by the model itself when

261
00:12:02,800 --> 00:12:06,560
being asked to emulate and and to

262
00:12:04,959 --> 00:12:08,720
predict what the output of this code is

263
00:12:06,560 --> 00:12:10,160
going to be often times it's thinking

264
00:12:08,720 --> 00:12:12,720
that this code is actually going to

265
00:12:10,160 --> 00:12:14,399
produce the right output to the problem

266
00:12:12,720 --> 00:12:16,240
even though we're not actually showing

267
00:12:14,399 --> 00:12:19,360
it what problem this is supposed to be

268
00:12:16,240 --> 00:12:22,160
solving. Right? In other words, there's

269
00:12:19,360 --> 00:12:25,839
a small amount of consistency here in

270
00:12:22,160 --> 00:12:27,040
the model actually uh being sufficiently

271
00:12:25,839 --> 00:12:29,680
convinced that this is the right

272
00:12:27,040 --> 00:12:31,200
solution to that problem that when you

273
00:12:29,680 --> 00:12:33,040
give it an input, it thinks that the

274
00:12:31,200 --> 00:12:35,040
output is what the output to that

275
00:12:33,040 --> 00:12:37,040
problem should be as opposed to what

276
00:12:35,040 --> 00:12:40,480
you're actually going to get when you

277
00:12:37,040 --> 00:12:43,680
run the program. Right? So this is again

278
00:12:40,480 --> 00:12:45,440
some indication that the model is not

279
00:12:43,680 --> 00:12:48,399
really actually reasoning through the

280
00:12:45,440 --> 00:12:50,000
code but it's using a lot of signals

281
00:12:48,399 --> 00:12:51,360
from the shape of the code from the

282
00:12:50,000 --> 00:12:53,880
names of functions from the name of

283
00:12:51,360 --> 00:12:58,320
variables in making these predictions

284
00:12:53,880 --> 00:13:00,160
about what the code is going to to do

285
00:12:58,320 --> 00:13:02,079
right another interesting experiment

286
00:13:00,160 --> 00:13:05,920
here if you go and you tell the models

287
00:13:02,079 --> 00:13:09,839
hey um here's here's this incorrect

288
00:13:05,920 --> 00:13:12,200
solution please fix it right And uh and

289
00:13:09,839 --> 00:13:17,519
so we look at the

290
00:13:12,200 --> 00:13:19,839
um percentage of the time that it uh we

291
00:13:17,519 --> 00:13:21,360
look at the correctness rate of that

292
00:13:19,839 --> 00:13:22,880
versus the correctness rate of just

293
00:13:21,360 --> 00:13:27,519
going to the model and telling the

294
00:13:22,880 --> 00:13:30,880
model, hey, can you give me a new

295
00:13:27,519 --> 00:13:33,320
solution to this problem? Right? And it

296
00:13:30,880 --> 00:13:36,480
turns out

297
00:13:33,320 --> 00:13:37,920
that most of the time for most of these

298
00:13:36,480 --> 00:13:40,160
problems actually just going to the

299
00:13:37,920 --> 00:13:43,959
model and telling it just give me

300
00:13:40,160 --> 00:13:47,120
another solution succeeds way more often

301
00:13:43,959 --> 00:13:48,880
than if you actually tell it hey here is

302
00:13:47,120 --> 00:13:51,920
the wrong solution that you provided

303
00:13:48,880 --> 00:13:54,800
please go and fix this solution so it's

304
00:13:51,920 --> 00:13:56,240
not uh wrong anymore. Right? So in other

305
00:13:54,800 --> 00:13:58,320
words, actually just rolling the dice

306
00:13:56,240 --> 00:14:02,360
again and getting another solution turns

307
00:13:58,320 --> 00:14:05,360
out to actually be more effective.

308
00:14:02,360 --> 00:14:07,000
Now what um oh here's another

309
00:14:05,360 --> 00:14:11,040
interesting one.

310
00:14:07,000 --> 00:14:13,680
So you know you look at the performance

311
00:14:11,040 --> 00:14:16,240
on a lot of these competition problems,

312
00:14:13,680 --> 00:14:18,079
right? And on a lot of pretty hard uh

313
00:14:16,240 --> 00:14:21,519
programming problems and it looks pretty

314
00:14:18,079 --> 00:14:24,720
good, right? But here's an experiment

315
00:14:21,519 --> 00:14:27,120
that we run looking at uh lead code,

316
00:14:24,720 --> 00:14:29,040
right? So these are uh you know little

317
00:14:27,120 --> 00:14:31,600
coding contests that uh people

318
00:14:29,040 --> 00:14:34,560
participate in. And one interesting

319
00:14:31,600 --> 00:14:38,240
thing about this is that there's new

320
00:14:34,560 --> 00:14:40,800
problems coming out every uh I think

321
00:14:38,240 --> 00:14:43,760
it's every week or every month. Uh you

322
00:14:40,800 --> 00:14:46,000
have new problems coming out. And so we

323
00:14:43,760 --> 00:14:49,839
can take some of these models and

324
00:14:46,000 --> 00:14:51,199
actually uh test it on the problems that

325
00:14:49,839 --> 00:14:52,720
came out in May and the problems that

326
00:14:51,199 --> 00:14:55,279
came out in June and the problems that

327
00:14:52,720 --> 00:14:58,079
came out in July right month by month

328
00:14:55,279 --> 00:14:59,920
looking at how the model does on this

329
00:14:58,079 --> 00:15:03,760
problem. And first of all you can see

330
00:14:59,920 --> 00:15:06,560
you know a non-trivial downward uh trend

331
00:15:03,760 --> 00:15:11,680
but you can also see for example right

332
00:15:06,560 --> 00:15:15,360
here's the cutoff date for uh uh deepse

333
00:15:11,680 --> 00:15:17,440
uh in 33b right and you know there's

334
00:15:15,360 --> 00:15:19,360
there's a pretty clear even though it's

335
00:15:17,440 --> 00:15:22,959
a little bit of a noisy signal there's a

336
00:15:19,360 --> 00:15:25,680
pretty clear before and after uh on its

337
00:15:22,959 --> 00:15:28,959
performance on the problems that came

338
00:15:25,680 --> 00:15:30,959
out uh before the c time from the

339
00:15:28,959 --> 00:15:32,240
problems that came out after, right? And

340
00:15:30,959 --> 00:15:34,639
the problems that have been in the

341
00:15:32,240 --> 00:15:37,519
training set probably for longer, it's

342
00:15:34,639 --> 00:15:41,120
doing better than on the problems that

343
00:15:37,519 --> 00:15:44,320
just uh that just came out, right? And

344
00:15:41,120 --> 00:15:48,240
again, it's uh it's a noisy signal, but

345
00:15:44,320 --> 00:15:51,120
it gives some indication that u uh that

346
00:15:48,240 --> 00:15:53,399
there is some amount of memorization

347
00:15:51,120 --> 00:15:56,920
going on there. Right

348
00:15:53,399 --> 00:15:59,600
now, we shouldn't

349
00:15:56,920 --> 00:16:01,279
um you know, we shouldn't uh from this

350
00:15:59,600 --> 00:16:04,399
take the lesson that oh then these

351
00:16:01,279 --> 00:16:05,759
models are just uh uh you know,

352
00:16:04,399 --> 00:16:08,320
repeating what they've seen and they're

353
00:16:05,759 --> 00:16:10,320
not really doing any kind of thinking.

354
00:16:08,320 --> 00:16:12,880
Uh you know, it's not quite that, right?

355
00:16:10,320 --> 00:16:15,600
I mean in some level in some ways a lot

356
00:16:12,880 --> 00:16:17,040
of these tests yes the performance that

357
00:16:15,600 --> 00:16:19,199
they're getting on some of these

358
00:16:17,040 --> 00:16:21,759
synthetics tests is lower than what you

359
00:16:19,199 --> 00:16:23,920
would expect from somebody who has that

360
00:16:21,759 --> 00:16:27,120
level of skill at solving those kind of

361
00:16:23,920 --> 00:16:31,199
problems but it's not zero right and it

362
00:16:27,120 --> 00:16:33,600
does show a uh you know non-trivial

363
00:16:31,199 --> 00:16:35,600
reasoning abilities and you know

364
00:16:33,600 --> 00:16:37,360
considering that these are out of

365
00:16:35,600 --> 00:16:39,920
distribution problems where they're

366
00:16:37,360 --> 00:16:41,600
really being designed uh synthetically

367
00:16:39,920 --> 00:16:43,519
to test the reasoning ability

368
00:16:41,600 --> 00:16:45,839
specifically. It is actually quite

369
00:16:43,519 --> 00:16:49,199
surprising that that you're getting

370
00:16:45,839 --> 00:16:52,000
relatively high success rates. But the

371
00:16:49,199 --> 00:16:55,120
moral of the story here is that your

372
00:16:52,000 --> 00:16:58,079
mental model in thinking how these

373
00:16:55,120 --> 00:17:00,399
models are thinking about code, you

374
00:16:58,079 --> 00:17:02,320
shouldn't think of them as you know a

375
00:17:00,399 --> 00:17:04,079
human programmer, right? Uh we have

376
00:17:02,320 --> 00:17:06,160
certain expectations that if a human

377
00:17:04,079 --> 00:17:07,919
programmer knows how to do this, then

378
00:17:06,160 --> 00:17:10,079
clearly they must know how to do that,

379
00:17:07,919 --> 00:17:12,400
right? And and if a human programmer can

380
00:17:10,079 --> 00:17:14,400
pass these kind of tests then surely

381
00:17:12,400 --> 00:17:17,039
they must be able to write this kind of

382
00:17:14,400 --> 00:17:20,640
code right and you know these models are

383
00:17:17,039 --> 00:17:23,079
not people they're not uh they have just

384
00:17:20,640 --> 00:17:26,679
different strengths and different uh

385
00:17:23,079 --> 00:17:30,160
weaknesses than uh than human than human

386
00:17:26,679 --> 00:17:32,880
programmers. And um so actually just

387
00:17:30,160 --> 00:17:36,320
last week we uh we released this uh

388
00:17:32,880 --> 00:17:41,679
report looking in some detail at some of

389
00:17:36,320 --> 00:17:44,080
the open challenges for uh AI based uh

390
00:17:41,679 --> 00:17:46,640
coding tools, right? in particular these

391
00:17:44,080 --> 00:17:50,320
applications to to software engineering

392
00:17:46,640 --> 00:17:52,480
and what are some of the key open uh

393
00:17:50,320 --> 00:17:55,080
what are some of the key open problems

394
00:17:52,480 --> 00:17:58,640
uh uh here

395
00:17:55,080 --> 00:18:00,880
and some of these uh one really

396
00:17:58,640 --> 00:18:03,200
important one is you know out of

397
00:18:00,880 --> 00:18:05,280
distribution domains right and you know

398
00:18:03,200 --> 00:18:07,360
in some ways a lot of these experiments

399
00:18:05,280 --> 00:18:10,240
that we showed uh before right that

400
00:18:07,360 --> 00:18:12,120
they're dealing with these very out

401
00:18:10,240 --> 00:18:16,160
ofdistribution

402
00:18:12,120 --> 00:18:18,080
um problems. And uh you know this is

403
00:18:16,160 --> 00:18:20,240
something that is important to consider

404
00:18:18,080 --> 00:18:21,840
when you're using these uh these tools,

405
00:18:20,240 --> 00:18:23,919
right? If you're writing the kind of

406
00:18:21,840 --> 00:18:26,120
code that everybody has written a

407
00:18:23,919 --> 00:18:31,919
thousand times before, they're going to

408
00:18:26,120 --> 00:18:33,360
be super useful, right? And if uh uh you

409
00:18:31,919 --> 00:18:36,320
know in terms of writing sort of

410
00:18:33,360 --> 00:18:39,919
everyday uh throwaway code where you're

411
00:18:36,320 --> 00:18:42,240
trying to you know uh u chew on some

412
00:18:39,919 --> 00:18:44,080
data to get it into a different form,

413
00:18:42,240 --> 00:18:46,240
right? This is the code the kind of code

414
00:18:44,080 --> 00:18:49,520
that is very much in distribution and

415
00:18:46,240 --> 00:18:51,360
the tools are amazing. Right? If you're

416
00:18:49,520 --> 00:18:54,000
trying to write the sort of code that

417
00:18:51,360 --> 00:18:57,600
nobody has written before, right? and

418
00:18:54,000 --> 00:18:59,520
the sort of code where um you know it's

419
00:18:57,600 --> 00:19:01,919
a brand new application or it's

420
00:18:59,520 --> 00:19:04,640
something very specific to to your

421
00:19:01,919 --> 00:19:07,840
company uh you know mileage may vary

422
00:19:04,640 --> 00:19:09,520
right and these models um as I said it's

423
00:19:07,840 --> 00:19:11,600
not that they're not doing any reasoning

424
00:19:09,520 --> 00:19:14,080
at all there is a fair amount of

425
00:19:11,600 --> 00:19:17,520
reasoning that they're capable of doing

426
00:19:14,080 --> 00:19:20,960
u it's just not at the same level as uh

427
00:19:17,520 --> 00:19:23,559
as you would expect from a programmer

428
00:19:20,960 --> 00:19:26,799
with kind of a comparable level of

429
00:19:23,559 --> 00:19:30,000
skill, right? Program understanding is

430
00:19:26,799 --> 00:19:33,200
another um is another really big one.

431
00:19:30,000 --> 00:19:36,480
We've actually been uh doing a lot of

432
00:19:33,200 --> 00:19:41,440
work recently looking at combining more

433
00:19:36,480 --> 00:19:43,440
traditional program analysis with uh

434
00:19:41,440 --> 00:19:45,120
large language models in order to try to

435
00:19:43,440 --> 00:19:48,240
get a little bit of the best of both

436
00:19:45,120 --> 00:19:51,360
worlds, right? and to uh uh try to

437
00:19:48,240 --> 00:19:54,400
address the scalability challenges that

438
00:19:51,360 --> 00:19:58,799
come from having to reason across very

439
00:19:54,400 --> 00:20:01,760
large uh code bases where you might have

440
00:19:58,799 --> 00:20:03,440
to actually pull information from many

441
00:20:01,760 --> 00:20:07,840
different places in the code in order to

442
00:20:03,440 --> 00:20:11,760
figure out what is uh going on. Right?

443
00:20:07,840 --> 00:20:14,799
Software design is a really big one. uh

444
00:20:11,760 --> 00:20:17,440
a lot of these tools are very good at

445
00:20:14,799 --> 00:20:19,760
the sort of problems that you can check

446
00:20:17,440 --> 00:20:21,919
right you have a test suite you're

447
00:20:19,760 --> 00:20:24,720
looking for the algorithm that is going

448
00:20:21,919 --> 00:20:26,799
to pass the test suite uh if you throw

449
00:20:24,720 --> 00:20:29,240
enough compute power at it you will get

450
00:20:26,799 --> 00:20:31,760
your algorithm that passes the test

451
00:20:29,240 --> 00:20:34,000
suite but often times when you're

452
00:20:31,760 --> 00:20:35,520
writing code passing the test suite is

453
00:20:34,000 --> 00:20:37,760
just one of the things that we're

454
00:20:35,520 --> 00:20:41,440
looking for right we want to make sure

455
00:20:37,760 --> 00:20:44,640
that this code is actually going to be

456
00:20:41,440 --> 00:20:46,880
maintainable. We want a code base and a

457
00:20:44,640 --> 00:20:50,640
code structure that is going to survive,

458
00:20:46,880 --> 00:20:52,880
you know, the next uh few generations of

459
00:20:50,640 --> 00:20:54,880
our product. We want the kind of

460
00:20:52,880 --> 00:20:56,960
codebase that when we're trying to bring

461
00:20:54,880 --> 00:21:01,120
a new person up to speed, uh it's going

462
00:20:56,960 --> 00:21:04,799
to make sense, right? And these because

463
00:21:01,120 --> 00:21:07,360
it's much harder to uh automatically

464
00:21:04,799 --> 00:21:10,000
test. It's not it doesn't lend itself as

465
00:21:07,360 --> 00:21:12,480
well to this kind of generate and test

466
00:21:10,000 --> 00:21:15,039
approach that is kind of the bread and

467
00:21:12,480 --> 00:21:20,480
butter of a lot of these uh of a lot of

468
00:21:15,039 --> 00:21:24,480
these tools. And uh um the the other big

469
00:21:20,480 --> 00:21:26,240
thing is sophisticated reuse. And here

470
00:21:24,480 --> 00:21:29,440
we're talking not about the kind of

471
00:21:26,240 --> 00:21:31,200
reuse where you say, "Oh yeah, I wrote I

472
00:21:29,440 --> 00:21:34,159
wrote a function that does that a month

473
00:21:31,200 --> 00:21:36,559
ago and uh and now I'm going to use it

474
00:21:34,159 --> 00:21:38,880
in this place as well." That's the sort

475
00:21:36,559 --> 00:21:41,360
of reuse that you can get very easily

476
00:21:38,880 --> 00:21:43,919
and very effectively with retrieval

477
00:21:41,360 --> 00:21:45,840
augmented models, right? uh if the

478
00:21:43,919 --> 00:21:48,320
function that you're looking for already

479
00:21:45,840 --> 00:21:49,840
exists in your codebase, the model is

480
00:21:48,320 --> 00:21:52,400
going to find it and it's going to give

481
00:21:49,840 --> 00:21:53,919
it to you and it's going to pretty well

482
00:21:52,400 --> 00:21:56,080
figure out how to adjust all the

483
00:21:53,919 --> 00:21:57,679
parameters to get it to work well. The

484
00:21:56,080 --> 00:22:00,320
kind of reuse though that I'm talking

485
00:21:57,679 --> 00:22:03,679
about here is the kind of reuse where

486
00:22:00,320 --> 00:22:05,919
there's some brand new functionality but

487
00:22:03,679 --> 00:22:08,000
as a designer who is very familiar with

488
00:22:05,919 --> 00:22:11,600
the overall architecture of the software

489
00:22:08,000 --> 00:22:13,760
who is very familiar with uh you know

490
00:22:11,600 --> 00:22:17,440
the internals of the different building

491
00:22:13,760 --> 00:22:19,200
blocks. you can immediately tell oh yeah

492
00:22:17,440 --> 00:22:21,280
there is this other functionality over

493
00:22:19,200 --> 00:22:25,120
here that is completely different and is

494
00:22:21,280 --> 00:22:28,000
for uh another uh completely different

495
00:22:25,120 --> 00:22:29,840
thing but I can generalize that

496
00:22:28,000 --> 00:22:32,400
functionality so that it works for that

497
00:22:29,840 --> 00:22:34,400
and it also works for this right it's

498
00:22:32,400 --> 00:22:37,039
the kind of reuse that requires you to

499
00:22:34,400 --> 00:22:38,720
take uh you know this routine over here

500
00:22:37,039 --> 00:22:40,240
that was used for one thing and this

501
00:22:38,720 --> 00:22:42,720
routine over here that was used for

502
00:22:40,240 --> 00:22:47,039
another thing and figuring out how to

503
00:22:42,720 --> 00:22:49,679
weave them together with the right uh

504
00:22:47,039 --> 00:22:51,679
scaffolding in order to actually get the

505
00:22:49,679 --> 00:22:53,840
functionality that you want, right? And

506
00:22:51,679 --> 00:22:57,600
that's the kind of uh sophisticated

507
00:22:53,840 --> 00:23:02,400
reuse that uh you're not going to get

508
00:22:57,600 --> 00:23:05,440
just from a standard retrieval um uh

509
00:23:02,400 --> 00:23:08,480
model, right? And finally, we get to the

510
00:23:05,440 --> 00:23:10,640
specification challenge, right? This is

511
00:23:08,480 --> 00:23:13,440
uh you know in some sense the ultimate

512
00:23:10,640 --> 00:23:14,280
challenge for these tools at the end of

513
00:23:13,440 --> 00:23:17,200
the

514
00:23:14,280 --> 00:23:19,120
day writing software a big part of

515
00:23:17,200 --> 00:23:21,760
writing software is actually negotiating

516
00:23:19,120 --> 00:23:24,240
the interface right and figuring out

517
00:23:21,760 --> 00:23:28,559
negotiating the specification figuring

518
00:23:24,240 --> 00:23:32,880
out how to trade off um what the client

519
00:23:28,559 --> 00:23:36,919
wants with the costs with the u you know

520
00:23:32,880 --> 00:23:40,960
technical constraints right often times

521
00:23:36,919 --> 00:23:42,559
Um if you ask uh if you ask the person

522
00:23:40,960 --> 00:23:43,840
what if you ask the client what they

523
00:23:42,559 --> 00:23:45,280
want, they want unicorns, right?

524
00:23:43,840 --> 00:23:47,600
Everybody wants unicorns. Everybody

525
00:23:45,280 --> 00:23:49,360
loves unicorns. Uh but we can't get them

526
00:23:47,600 --> 00:23:50,880
unicorns, right? And so now we have to

527
00:23:49,360 --> 00:23:54,480
get into a negotiation. We have to

528
00:23:50,880 --> 00:23:56,880
figure out uh what is feasible to

529
00:23:54,480 --> 00:23:58,480
implement given the technological

530
00:23:56,880 --> 00:24:00,960
constraints? What are the trade-offs

531
00:23:58,480 --> 00:24:02,520
between functionality, performance,

532
00:24:00,960 --> 00:24:05,919
usability?

533
00:24:02,520 --> 00:24:08,480
Um and that is something that these

534
00:24:05,919 --> 00:24:10,799
models are just not very well suited to,

535
00:24:08,480 --> 00:24:13,039
right? Um except obviously to the extent

536
00:24:10,799 --> 00:24:14,720
that if you can iterate much faster,

537
00:24:13,039 --> 00:24:19,279
right? If you can build those prototypes

538
00:24:14,720 --> 00:24:21,679
much faster, you can get to um those

539
00:24:19,279 --> 00:24:24,120
decisions much more um much more

540
00:24:21,679 --> 00:24:26,880
effectively.

541
00:24:24,120 --> 00:24:30,000
So uh yesterday I talked a little bit

542
00:24:26,880 --> 00:24:33,520
about uh you know some ideas that we've

543
00:24:30,000 --> 00:24:35,600
uh experimented with uh dealing with

544
00:24:33,520 --> 00:24:39,200
some of these different some of these

545
00:24:35,600 --> 00:24:42,159
different problems. Um one uh one of

546
00:24:39,200 --> 00:24:44,720
these ideas for example was what to do

547
00:24:42,159 --> 00:24:46,559
in this situation. Um I realize I've

548
00:24:44,720 --> 00:24:49,120
been talking to one side of the room the

549
00:24:46,559 --> 00:24:50,679
whole time. uh sorry it's not that I

550
00:24:49,120 --> 00:24:56,159
don't like you

551
00:24:50,679 --> 00:24:58,880
but so um you know one of the uh um one

552
00:24:56,159 --> 00:25:02,559
of these uh challenges of how do you

553
00:24:58,880 --> 00:25:05,760
figure out what is it that the tool uh

554
00:25:02,559 --> 00:25:08,720
what is it that people want to build and

555
00:25:05,760 --> 00:25:11,120
uh you know humans have uh lots of

556
00:25:08,720 --> 00:25:13,919
different modalities that we can use to

557
00:25:11,120 --> 00:25:15,840
actually uh tell people what we want

558
00:25:13,919 --> 00:25:18,159
right and one of those modalities is

559
00:25:15,840 --> 00:25:20,080
actually just telling your colleague,

560
00:25:18,159 --> 00:25:22,480
hey, come look like have you seen this

561
00:25:20,080 --> 00:25:24,960
application here like the thing this

562
00:25:22,480 --> 00:25:27,440
application does like that's what I want

563
00:25:24,960 --> 00:25:30,559
right and often times these are things

564
00:25:27,440 --> 00:25:32,360
that are hard to capture in words you

565
00:25:30,559 --> 00:25:34,480
might not even have the right uh

566
00:25:32,360 --> 00:25:35,840
terminology and oftentimes when you're

567
00:25:34,480 --> 00:25:38,559
trying to implement some of these things

568
00:25:35,840 --> 00:25:40,080
even in the context of a framework that

569
00:25:38,559 --> 00:25:42,240
already has all the right building

570
00:25:40,080 --> 00:25:44,159
blocks to help you do this if you're not

571
00:25:42,240 --> 00:25:46,400
familiar with the framework if you don't

572
00:25:44,159 --> 00:25:48,320
know the internal language of this

573
00:25:46,400 --> 00:25:51,279
framework, you're not going to be able

574
00:25:48,320 --> 00:25:54,880
to do that, right? And so I showed this

575
00:25:51,279 --> 00:25:58,480
example that we had of um uh we're

576
00:25:54,880 --> 00:26:00,880
actually extending this uh uh editor

577
00:25:58,480 --> 00:26:02,720
which is uh you know a very nice uh

578
00:26:00,880 --> 00:26:05,760
framework. Uh many of you probably have

579
00:26:02,720 --> 00:26:07,840
used Eclipse at least uh many years ago.

580
00:26:05,760 --> 00:26:11,799
Uh but in addition to being just a nice

581
00:26:07,840 --> 00:26:15,360
IDE, it's a nice framework for writing

582
00:26:11,799 --> 00:26:18,159
uh new plugins for supporting new

583
00:26:15,360 --> 00:26:21,919
programming languages, right? Or new uh

584
00:26:18,159 --> 00:26:23,679
file formats in general. And um so it

585
00:26:21,919 --> 00:26:25,760
has all the functionality that you need

586
00:26:23,679 --> 00:26:28,000
to do something as simple as syntax

587
00:26:25,760 --> 00:26:33,159
highlighting or something as complicated

588
00:26:28,000 --> 00:26:35,840
as a full uh you know structure aware u

589
00:26:33,159 --> 00:26:38,080
editor. But just because the

590
00:26:35,840 --> 00:26:41,120
functionality is there doesn't mean that

591
00:26:38,080 --> 00:26:43,520
you can find it easily and it doesn't

592
00:26:41,120 --> 00:26:46,240
mean that you're going to quickly figure

593
00:26:43,520 --> 00:26:49,039
out how to use it, right? And in

594
00:26:46,240 --> 00:26:50,240
particular, what you find is that uh you

595
00:26:49,039 --> 00:26:52,159
know when you start looking at the

596
00:26:50,240 --> 00:26:53,279
internals of how to do this, pretty

597
00:26:52,159 --> 00:26:56,080
obvious that you're going to need some

598
00:26:53,279 --> 00:26:57,679
kind of a scanner if you're uh scanning

599
00:26:56,080 --> 00:27:00,159
for tokens so that you can give them

600
00:26:57,679 --> 00:27:03,679
different colors. But what might not be

601
00:27:00,159 --> 00:27:07,039
so obvious is that in order to actually

602
00:27:03,679 --> 00:27:08,960
get the framework to use your scanner,

603
00:27:07,039 --> 00:27:10,720
you have to override lots of things,

604
00:27:08,960 --> 00:27:12,559
right? There's this thing called source

605
00:27:10,720 --> 00:27:14,720
viewer configuration that you have to

606
00:27:12,559 --> 00:27:17,520
extend and within this there's this

607
00:27:14,720 --> 00:27:20,559
thing called a damage repairer and

608
00:27:17,520 --> 00:27:22,960
that's the thing that takes your scanner

609
00:27:20,559 --> 00:27:26,480
as input and then you have to register

610
00:27:22,960 --> 00:27:28,159
it with a presentation reconciler. What

611
00:27:26,480 --> 00:27:31,520
are those things? Right? Where did this

612
00:27:28,159 --> 00:27:33,919
come from? Um, if you understand the

613
00:27:31,520 --> 00:27:35,679
internal logic of this framework, it's

614
00:27:33,919 --> 00:27:37,440
very obvious, right? It has this model

615
00:27:35,679 --> 00:27:40,720
where there's this data structure that

616
00:27:37,440 --> 00:27:44,000
models the code and from that it decides

617
00:27:40,720 --> 00:27:46,080
how to present the code and when you

618
00:27:44,000 --> 00:27:47,840
type, you're breaking that you're

619
00:27:46,080 --> 00:27:49,440
damaging the relationship between this

620
00:27:47,840 --> 00:27:51,760
data structure and the presentation. So,

621
00:27:49,440 --> 00:27:54,640
you need this damage repairer to repair

622
00:27:51,760 --> 00:27:58,159
that relationship, right? And then you

623
00:27:54,640 --> 00:28:00,000
need to reconcile that uh uh internal

624
00:27:58,159 --> 00:28:02,080
representation with the view that the

625
00:28:00,000 --> 00:28:03,520
person gets. Right? Once you know that

626
00:28:02,080 --> 00:28:05,600
that's how it works. It's very obvious

627
00:28:03,520 --> 00:28:06,880
if you're not familiar with the inner

628
00:28:05,600 --> 00:28:10,000
workings, right? You're just saying,

629
00:28:06,880 --> 00:28:12,720
"Hey, that thing I want to do that thing

630
00:28:10,000 --> 00:28:15,159
that I saw the framework do in this

631
00:28:12,720 --> 00:28:17,679
other context or in this other

632
00:28:15,159 --> 00:28:19,200
situation, right? And this is a

633
00:28:17,679 --> 00:28:21,200
challenge, right? Even if you have an

634
00:28:19,200 --> 00:28:23,039
LLM, right? You can go and describe to

635
00:28:21,200 --> 00:28:26,559
the LLM what you're trying to do. And if

636
00:28:23,039 --> 00:28:28,320
you use the right um keywords and if you

637
00:28:26,559 --> 00:28:30,640
use the right class names you will

638
00:28:28,320 --> 00:28:33,279
actually get you know lots and lots of

639
00:28:30,640 --> 00:28:35,679
code and a little tutorial explaining

640
00:28:33,279 --> 00:28:38,720
how different parts of the code is.

641
00:28:35,679 --> 00:28:40,720
Turns out the code you get is not quite

642
00:28:38,720 --> 00:28:43,919
uh correct. It also at some point gets

643
00:28:40,720 --> 00:28:49,200
truncated because uh you run out of the

644
00:28:43,919 --> 00:28:50,720
buffer space. Um but more importantly um

645
00:28:49,200 --> 00:28:53,279
there's lots of different versions of

646
00:28:50,720 --> 00:28:56,399
this framework and it's uh using some

647
00:28:53,279 --> 00:28:59,679
combination of the different uh versions

648
00:28:56,399 --> 00:29:02,720
and um but critically you already have

649
00:28:59,679 --> 00:29:04,799
to know a fair bit about what you're

650
00:29:02,720 --> 00:29:07,279
asking for, what you want, how to ask

651
00:29:04,799 --> 00:29:08,720
for it. And this is kind of a best case

652
00:29:07,279 --> 00:29:10,480
scenario, right? This is a framework

653
00:29:08,720 --> 00:29:12,720
that has been around for a long time.

654
00:29:10,480 --> 00:29:15,600
There's lots of blog posts and

655
00:29:12,720 --> 00:29:17,240
tutorials. It's very well documented and

656
00:29:15,600 --> 00:29:20,640
all of that information was just

657
00:29:17,240 --> 00:29:23,760
ingested by these models at training

658
00:29:20,640 --> 00:29:26,880
time. What happens when you suddenly

659
00:29:23,760 --> 00:29:28,559
want to uh do this for your own internal

660
00:29:26,880 --> 00:29:30,720
framework that has been sitting inside

661
00:29:28,559 --> 00:29:32,640
your company that is not part of the

662
00:29:30,720 --> 00:29:36,240
training set that doesn't have all the

663
00:29:32,640 --> 00:29:39,120
nicely written blog posts. Um what are

664
00:29:36,240 --> 00:29:42,000
you going to do then? Right. Um in this

665
00:29:39,120 --> 00:29:45,760
case our approach was actually to allow

666
00:29:42,000 --> 00:29:47,440
you to record right to just pop up the

667
00:29:45,760 --> 00:29:49,760
application that is already using this

668
00:29:47,440 --> 00:29:51,760
framework uh press a button that says

669
00:29:49,760 --> 00:29:54,640
okay I'm about to show you something

670
00:29:51,760 --> 00:29:56,240
right and then you know demonstrate the

671
00:29:54,640 --> 00:29:59,000
functionality in this case we want to

672
00:29:56,240 --> 00:30:01,200
demonstrate this uh syntax uh

673
00:29:59,000 --> 00:30:03,919
highlighting and then you want to say

674
00:30:01,200 --> 00:30:05,440
okay now there that thing that just

675
00:30:03,919 --> 00:30:07,600
happened that's what I want to learn how

676
00:30:05,440 --> 00:30:08,960
to do right in the context of this

677
00:30:07,600 --> 00:30:13,120
framework work. How do I use this

678
00:30:08,960 --> 00:30:16,000
framework to make that thing happen?

679
00:30:13,120 --> 00:30:17,440
Right? And in this case, u we actually

680
00:30:16,000 --> 00:30:20,159
had some infrastructure that would

681
00:30:17,440 --> 00:30:22,559
record a little trace of everything that

682
00:30:20,159 --> 00:30:25,760
happened during that demonstration so

683
00:30:22,559 --> 00:30:27,919
that it could be fed as input to this

684
00:30:25,760 --> 00:30:30,880
whole process that helps you figure out

685
00:30:27,919 --> 00:30:34,480
how to do this, right? And so this is

686
00:30:30,880 --> 00:30:37,039
the sort of thing that is, you know,

687
00:30:34,480 --> 00:30:40,720
difficult to do at this point with just

688
00:30:37,039 --> 00:30:43,360
a plain vanilla um LLM. They're actually

689
00:30:40,720 --> 00:30:46,640
getting much better at supporting much

690
00:30:43,360 --> 00:30:49,279
more multimodal interactions. I don't

691
00:30:46,640 --> 00:30:51,600
doubt that within a few years you'll be

692
00:30:49,279 --> 00:30:54,000
able to take uh you know an actual just

693
00:30:51,600 --> 00:30:55,919
video capture of the functionality that

694
00:30:54,000 --> 00:30:57,600
happened and have the model be able to

695
00:30:55,919 --> 00:31:00,679
do that. But it's actually quite hard.

696
00:30:57,600 --> 00:31:03,520
It's actually quite hard to to do that

697
00:31:00,679 --> 00:31:05,720
because the model has to be able to make

698
00:31:03,520 --> 00:31:08,120
that connection between the observed

699
00:31:05,720 --> 00:31:12,799
behavior and

700
00:31:08,120 --> 00:31:14,600
the actual uh code that led to that

701
00:31:12,799 --> 00:31:18,080
behavior. And

702
00:31:14,600 --> 00:31:20,399
um if you have not trained the model to

703
00:31:18,080 --> 00:31:22,159
do this, then it's actually kind of hard

704
00:31:20,399 --> 00:31:24,080
for the model to know, right? It's not

705
00:31:22,159 --> 00:31:26,640
something that you can just derive from

706
00:31:24,080 --> 00:31:28,640
first principles by looking at the

707
00:31:26,640 --> 00:31:30,600
source code, right? Definitely not at

708
00:31:28,640 --> 00:31:33,919
that scale and noted with this

709
00:31:30,600 --> 00:31:35,600
complexity of um of behavior, right? So

710
00:31:33,919 --> 00:31:40,159
you need somebody to teach the model

711
00:31:35,600 --> 00:31:42,000
that this is what the framework does. Um

712
00:31:40,159 --> 00:31:44,320
we've actually been doing some work uh

713
00:31:42,000 --> 00:31:49,039
recently looking at okay so what does it

714
00:31:44,320 --> 00:31:50,880
take to show the model how these things

715
00:31:49,039 --> 00:31:52,799
uh work? How much time do we have by the

716
00:31:50,880 --> 00:31:55,919
way?

717
00:31:52,799 --> 00:31:59,760
Okay, so very quickly uh you know in the

718
00:31:55,919 --> 00:32:03,600
context of a different framework that is

719
00:31:59,760 --> 00:32:06,960
able to uh help you create textures for

720
00:32:03,600 --> 00:32:08,679
video games right um or you know in

721
00:32:06,960 --> 00:32:12,159
general for computer graphics

722
00:32:08,679 --> 00:32:14,559
programmatic textures for uh rendering

723
00:32:12,159 --> 00:32:16,240
so it turns out it has a Python uh if

724
00:32:14,559 --> 00:32:18,960
you're using Blender for example it has

725
00:32:16,240 --> 00:32:21,440
a Python API and what we want is we want

726
00:32:18,960 --> 00:32:23,919
to be able to take just a picture of a

727
00:32:21,440 --> 00:32:26,159
texture, give it to the model and have

728
00:32:23,919 --> 00:32:28,640
the model spit out to the code that is

729
00:32:26,159 --> 00:32:30,720
actually going to produce that texture

730
00:32:28,640 --> 00:32:33,200
or maybe a similar texture. You might

731
00:32:30,720 --> 00:32:35,600
need to do some local optimization to

732
00:32:33,200 --> 00:32:37,440
get exactly the right texture. But it's

733
00:32:35,600 --> 00:32:41,120
the same kind of problem, right? The

734
00:32:37,440 --> 00:32:44,720
model has to reason about the

735
00:32:41,120 --> 00:32:48,240
relationship between the code and this

736
00:32:44,720 --> 00:32:50,399
visual effect, this behavior that was

737
00:32:48,240 --> 00:32:53,519
not part of the training data. Even

738
00:32:50,399 --> 00:32:56,320
though the model has seen some uses of

739
00:32:53,519 --> 00:32:57,840
these um of this framework in the past,

740
00:32:56,320 --> 00:32:59,919
it just does not have sufficient

741
00:32:57,840 --> 00:33:03,519
information about that relationship

742
00:32:59,919 --> 00:33:06,559
between the code and its effects. It

743
00:33:03,519 --> 00:33:08,880
turns out though that by using some

744
00:33:06,559 --> 00:33:11,600
clever data augmentation techniques, it

745
00:33:08,880 --> 00:33:14,320
was actually possible to build a data

746
00:33:11,600 --> 00:33:16,880
set of about half a million such

747
00:33:14,320 --> 00:33:19,200
programs that allowed us to actually

748
00:33:16,880 --> 00:33:22,960
fine-tune this model. Right? Turns out

749
00:33:19,200 --> 00:33:25,600
that uh fine-tuning um in this case it

750
00:33:22,960 --> 00:33:31,200
was actually just a 9 billion parameter

751
00:33:25,600 --> 00:33:35,120
uh model um uh uh lava uh next which

752
00:33:31,200 --> 00:33:38,240
also has a visual component and it's

753
00:33:35,120 --> 00:33:41,360
actually within the scale of uh you know

754
00:33:38,240 --> 00:33:44,320
an academic lab to actually do that kind

755
00:33:41,360 --> 00:33:47,679
of uh fine-tuning and get the models to

756
00:33:44,320 --> 00:33:49,039
do this uh to do this. So the good news

757
00:33:47,679 --> 00:33:51,679
is that you can do it and you can

758
00:33:49,039 --> 00:33:53,440
actually get it to work pretty well. Um

759
00:33:51,679 --> 00:33:55,679
the bad news is that it's not something

760
00:33:53,440 --> 00:33:58,559
that you can get out of uh out of the

761
00:33:55,679 --> 00:34:00,720
box. If uh you know if you just use the

762
00:33:58,559 --> 00:34:02,960
models that you can get out of the box,

763
00:34:00,720 --> 00:34:04,960
you can see the results are actually not

764
00:34:02,960 --> 00:34:07,200
very good. Right? And these are other

765
00:34:04,960 --> 00:34:11,599
specialized algorithms and specialized

766
00:34:07,200 --> 00:34:15,119
uh baselines. Um but uh but you can see

767
00:34:11,599 --> 00:34:19,079
again that uh they're they're just not

768
00:34:15,119 --> 00:34:22,079
very uh they're just not very good.

769
00:34:19,079 --> 00:34:25,760
So you know the the final the final

770
00:34:22,079 --> 00:34:29,359
message here is that um you know these

771
00:34:25,760 --> 00:34:32,639
models are very powerful and um what

772
00:34:29,359 --> 00:34:34,320
we're going to see more and more is that

773
00:34:32,639 --> 00:34:38,399
the kind of programming that you could

774
00:34:34,320 --> 00:34:42,560
do just on a cheap laptop with you know

775
00:34:38,399 --> 00:34:44,960
your vi editor um is probably not going

776
00:34:42,560 --> 00:34:47,919
to be around for long right tools are

777
00:34:44,960 --> 00:34:50,879
going to be more and more essential

778
00:34:47,919 --> 00:34:54,159
uh part of programming. But there is

779
00:34:50,879 --> 00:34:56,720
still a very crucial role for human

780
00:34:54,159 --> 00:34:59,359
expertise and uh you know these tools

781
00:34:56,720 --> 00:35:02,079
can enable creativity and very fast

782
00:34:59,359 --> 00:35:04,960
experimentation. But I think it is

783
00:35:02,079 --> 00:35:07,920
important to protect the health of the

784
00:35:04,960 --> 00:35:11,599
software ecosystem and not uh be in this

785
00:35:07,920 --> 00:35:12,800
position where um all the old frameworks

786
00:35:11,599 --> 00:35:15,040
and all the frameworks that are very

787
00:35:12,800 --> 00:35:17,440
well documented are very easy to use and

788
00:35:15,040 --> 00:35:20,880
so nobody uses the new stuff because the

789
00:35:17,440 --> 00:35:23,520
models don't know as much about them. Um

790
00:35:20,880 --> 00:35:26,560
and uh you know we can use these tools

791
00:35:23,520 --> 00:35:29,040
to actually help us produce higher

792
00:35:26,560 --> 00:35:31,040
quality software, much better software

793
00:35:29,040 --> 00:35:33,359
or we can use them to produce lots of

794
00:35:31,040 --> 00:35:35,440
garbage very quickly. And I think there

795
00:35:33,359 --> 00:35:38,079
is going to be important decisions to

796
00:35:35,440 --> 00:35:41,720
make in the future about how we want to

797
00:35:38,079 --> 00:35:41,720
strike this trade-off.

798
00:35:42,000 --> 00:35:47,440
Thank you Armando. Uh I think we have uh

799
00:35:44,640 --> 00:35:49,760
as we ask the next speaker to come up so

800
00:35:47,440 --> 00:35:51,680
we could do a little AV switch. Uh maybe

801
00:35:49,760 --> 00:35:54,480
we'll take uh at least one question from

802
00:35:51,680 --> 00:35:57,599
the audience if uh anyone uh has

803
00:35:54,480 --> 00:35:59,920
something burning to ask. Okay.

804
00:35:57,599 --> 00:36:02,640
Amanda, thanks for this presentation. Uh

805
00:35:59,920 --> 00:36:05,040
if you have to summarize with like what

806
00:36:02,640 --> 00:36:07,599
what will be in your mind the five key

807
00:36:05,040 --> 00:36:09,960
skills of software engineering in like 5

808
00:36:07,599 --> 00:36:14,359
to 10 years.

809
00:36:09,960 --> 00:36:17,359
So software designed right uh high level

810
00:36:14,359 --> 00:36:19,560
global uh design of the architecture is

811
00:36:17,359 --> 00:36:22,320
going to be really

812
00:36:19,560 --> 00:36:23,839
crucial. How to actually orchestrate a

813
00:36:22,320 --> 00:36:26,800
lot of these tools right we're going to

814
00:36:23,839 --> 00:36:28,560
see a lot of programming be not about

815
00:36:26,800 --> 00:36:30,640
you know how to write the code line by

816
00:36:28,560 --> 00:36:33,280
line but how to actually throw the

817
00:36:30,640 --> 00:36:37,040
computing power into this problem to get

818
00:36:33,280 --> 00:36:39,839
the right solution. Um that's going to

819
00:36:37,040 --> 00:36:41,680
be kind of a very different style of uh

820
00:36:39,839 --> 00:36:46,720
of programming from what we have right

821
00:36:41,680 --> 00:36:48,480
now. Um the third one is actually uh

822
00:36:46,720 --> 00:36:51,440
what is already a very important skill

823
00:36:48,480 --> 00:36:54,640
for any developer be able to think very

824
00:36:51,440 --> 00:36:56,880
clearly about uh what is it that this

825
00:36:54,640 --> 00:36:58,960
program is supposed to do. Right? A lot

826
00:36:56,880 --> 00:37:00,880
of writing code is really about thinking

827
00:36:58,960 --> 00:37:03,359
clearly about what is this program

828
00:37:00,880 --> 00:37:07,359
supposed to do in all of these different

829
00:37:03,359 --> 00:37:09,599
uh situations. Uh reading code is still

830
00:37:07,359 --> 00:37:12,160
going to be an extremely essential

831
00:37:09,599 --> 00:37:14,160
skills, right? Most working developers

832
00:37:12,160 --> 00:37:16,640
spend way more time reading code than

833
00:37:14,160 --> 00:37:19,119
writing uh code, right? And learning how

834
00:37:16,640 --> 00:37:20,320
to find your way through a codebase.

835
00:37:19,119 --> 00:37:23,119
We're going to have really good tools to

836
00:37:20,320 --> 00:37:25,520
help us do that, but we're still going

837
00:37:23,119 --> 00:37:27,359
to have to ultimately be able to absorb

838
00:37:25,520 --> 00:37:32,000
all this information and be able to make

839
00:37:27,359 --> 00:37:34,880
decisions um uh with it, right? And uh

840
00:37:32,000 --> 00:37:38,320
and finally, actually talking to people,

841
00:37:34,880 --> 00:37:40,640
right? Talking to uh and talking to the

842
00:37:38,320 --> 00:37:43,200
customers, talking to the potential

843
00:37:40,640 --> 00:37:45,119
users of these uh code, actually being

844
00:37:43,200 --> 00:37:46,720
able to figure out what is it that we're

845
00:37:45,119 --> 00:37:49,920
supposed to build? What are we trying to

846
00:37:46,720 --> 00:37:49,920
build here?

847
00:37:50,000 --> 00:37:56,040
any comments about prize and the more

848
00:37:54,079 --> 00:37:58,960
bounded problem of

849
00:37:56,040 --> 00:38:01,520
getting to fix bugs like you're not

850
00:37:58,960 --> 00:38:04,400
saying reason about this saying generate

851
00:38:01,520 --> 00:38:08,320
something that passion

852
00:38:04,400 --> 00:38:12,880
so bug finding is a really broad problem

853
00:38:08,320 --> 00:38:14,800
right I've run into bugs where I realize

854
00:38:12,880 --> 00:38:16,560
oh you know this should have been a less

855
00:38:14,800 --> 00:38:19,839
than or equal instead of a less than

856
00:38:16,560 --> 00:38:21,839
right Yes, those are going to go away,

857
00:38:19,839 --> 00:38:22,599
right? And then I've run into bugs where

858
00:38:21,839 --> 00:38:26,800
I

859
00:38:22,599 --> 00:38:29,040
realized, oh crap, my entire uh

860
00:38:26,800 --> 00:38:31,760
understanding of the problem was wrong

861
00:38:29,040 --> 00:38:33,520
and I really need to rearchitect my

862
00:38:31,760 --> 00:38:35,839
solution in order to get this thing to

863
00:38:33,520 --> 00:38:39,119
work properly. Right? That's not the

864
00:38:35,839 --> 00:38:41,359
kind of uh bug fix that you can expect

865
00:38:39,119 --> 00:38:44,359
um from these kind of tools anytime

866
00:38:41,359 --> 00:38:44,359
soon.

867
00:38:45,280 --> 00:38:48,599
I don't know.

868
00:38:52,119 --> 00:38:57,760
that that we're probably relatively

869
00:38:54,880 --> 00:39:01,040
close, right? Um, as long as again

870
00:38:57,760 --> 00:39:04,400
you're you're focusing on the easy bugs

871
00:39:01,040 --> 00:39:06,960
and you're happy with uh the hard bugs.

872
00:39:04,400 --> 00:39:10,000
The tricky part for bug fixing tends to

873
00:39:06,960 --> 00:39:13,920
be the test suites, right? Because for a

874
00:39:10,000 --> 00:39:16,240
lot of bugs, it's very easy to write

875
00:39:13,920 --> 00:39:19,280
corrections that hide the bug instead of

876
00:39:16,240 --> 00:39:21,440
fixing it, right? And so you might not

877
00:39:19,280 --> 00:39:23,440
realize that you're in the hard case

878
00:39:21,440 --> 00:39:25,520
because there's a simple change you can

879
00:39:23,440 --> 00:39:27,440
make to the code that makes the bug

880
00:39:25,520 --> 00:39:30,079
manifestation go away without actually

881
00:39:27,440 --> 00:39:32,000
fixing it. So that's the caveat there

882
00:39:30,079 --> 00:39:34,560
that if you already know you're in the

883
00:39:32,000 --> 00:39:36,720
simple case, I think we can do that. But

884
00:39:34,560 --> 00:39:39,720
the hard case poses some of these

885
00:39:36,720 --> 00:39:39,720
challenges.

