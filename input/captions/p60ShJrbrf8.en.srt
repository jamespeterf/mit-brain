1
00:00:13,080 --> 00:00:18,880
so here so from this clim we can show

2
00:00:16,480 --> 00:00:22,480
this is in this relation R so in fact we

3
00:00:18,880 --> 00:00:25,119
also need a s for this relation R and

4
00:00:22,480 --> 00:00:28,760
this uh so in this construction we need

5
00:00:25,119 --> 00:00:31,880
a s Construction for this relation R and

6
00:00:28,760 --> 00:00:36,320
uh so this follows from the so for this

7
00:00:31,880 --> 00:00:38,360
kind of C it follows from the the work

8
00:00:36,320 --> 00:00:41,800
uh so it's

9
00:00:38,360 --> 00:00:44,559
almost almost can handle all of the SP

10
00:00:41,800 --> 00:00:46,360
relation up to some parallel repetition

11
00:00:44,559 --> 00:00:48,440
so I will not go into the detail of this

12
00:00:46,360 --> 00:00:51,559
work um so if you're interested you can

13
00:00:48,440 --> 00:00:54,719
read it yourself so this is the work uh

14
00:00:51,559 --> 00:00:57,239
so is c for efficiently verifiable

15
00:00:54,719 --> 00:01:02,320
product relation uh it's the beautiful

16
00:00:57,239 --> 00:01:05,920
work by uh so this is the home uh hrr

17
00:01:02,320 --> 00:01:05,920
home ground L Body and the Ros

18
00:01:06,040 --> 00:01:10,759
BL

19
00:01:07,759 --> 00:01:10,759
okay

20
00:01:14,680 --> 00:01:19,159
uh okay so finally

21
00:01:20,119 --> 00:01:27,280
uh so so let me ask a question okay yeah

22
00:01:24,640 --> 00:01:30,360
uh could you say again why we need like

23
00:01:27,280 --> 00:01:32,960
why the cih we saw in last week plus is

24
00:01:30,360 --> 00:01:35,119
good enough uh right good question so so

25
00:01:32,960 --> 00:01:38,000
last week the S you saw is for

26
00:01:35,119 --> 00:01:41,640
searchable relation so that means uh the

27
00:01:38,000 --> 00:01:46,560
relation so the relation

28
00:01:41,640 --> 00:01:46,560
here so the the S relation

29
00:01:49,280 --> 00:01:56,119
here

30
00:01:52,159 --> 00:01:58,159
uh so the right so the relation here

31
00:01:56,119 --> 00:02:01,840
need to satisfy the searchable property

32
00:01:58,159 --> 00:02:05,840
so it means uh so this beta so for any

33
00:02:01,840 --> 00:02:09,399
fixed Alpha there exist a unique beta uh

34
00:02:05,840 --> 00:02:11,480
such that this Alpha Beta is in this

35
00:02:09,399 --> 00:02:13,760
relation R and moreover there is a

36
00:02:11,480 --> 00:02:15,879
efficient algorithm uh some some

37
00:02:13,760 --> 00:02:17,640
efficient algorithm F such that it can

38
00:02:15,879 --> 00:02:20,560
take this Alpha and the output such a

39
00:02:17,640 --> 00:02:24,640
beta so that's a search efficiently

40
00:02:20,560 --> 00:02:26,440
searchable mean uh so here so here it's

41
00:02:24,640 --> 00:02:29,959
possible that for fixed Alpha there

42
00:02:26,440 --> 00:02:32,760
there might be multiple uh multiple beta

43
00:02:29,959 --> 00:02:35,560
that can satisfy this relation because

44
00:02:32,760 --> 00:02:37,640
for a fixed PCP uh there might be

45
00:02:35,560 --> 00:02:42,040
multiple queries that can make the per

46
00:02:37,640 --> 00:02:46,920
PCP be accepted yes good question

47
00:02:42,040 --> 00:02:49,040
yeah so what what the hrr shows that uh

48
00:02:46,920 --> 00:02:52,080
if the if the sparse relation has

49
00:02:49,040 --> 00:02:55,120
efficient W fire algorithm then uh most

50
00:02:52,080 --> 00:02:57,959
of the then you can you can build a s

51
00:02:55,120 --> 00:03:01,840
for them up to some par repetition yeah

52
00:02:57,959 --> 00:03:01,840
roughly speaking it's a yeah

53
00:03:04,000 --> 00:03:11,040
so okay so so uh so now we have a

54
00:03:08,239 --> 00:03:14,239
construction of snarks but let's see

55
00:03:11,040 --> 00:03:14,239
what's the proof size for this

56
00:03:15,080 --> 00:03:22,959
snark so uh so the so the proof size

57
00:03:20,319 --> 00:03:25,680
consist of the first message and the

58
00:03:22,959 --> 00:03:29,400
thir R message so the first run message

59
00:03:25,680 --> 00:03:31,879
consist of l l of hash values so you can

60
00:03:29,400 --> 00:03:35,439
think each H value is also F separate

61
00:03:31,879 --> 00:03:39,640
text so it's a PO Lambda bits so in

62
00:03:35,439 --> 00:03:41,920
total the first round message uh consist

63
00:03:39,640 --> 00:03:45,879
of uh po

64
00:03:41,920 --> 00:03:45,879
c times po

65
00:03:47,760 --> 00:03:57,439
L but is but it's independent of the

66
00:03:51,280 --> 00:03:57,439
K and the third R message uh is K

67
00:03:57,480 --> 00:04:03,760
times poly log

68
00:04:00,360 --> 00:04:06,519
c times

69
00:04:03,760 --> 00:04:10,519
Pol because for each in the thir R

70
00:04:06,519 --> 00:04:15,599
message for for each instance you send

71
00:04:10,519 --> 00:04:18,079
uh Q PCP answers so the size of Q is uh

72
00:04:15,599 --> 00:04:22,320
is Lambda times poly log

73
00:04:18,079 --> 00:04:26,199
C so in total you have you send K of the

74
00:04:22,320 --> 00:04:28,280
K of them so in total it's K times

75
00:04:26,199 --> 00:04:31,080
this okay so so this is already

76
00:04:28,280 --> 00:04:32,960
non-trivial because it's a uh so this

77
00:04:31,080 --> 00:04:37,960
this number it could be much smaller

78
00:04:32,960 --> 00:04:40,880
than K * K * W so right because the

79
00:04:37,960 --> 00:04:44,479
second term is almost order of K and the

80
00:04:40,880 --> 00:04:46,680
first term is almost C so yeah so this

81
00:04:44,479 --> 00:04:48,560
is already non- trial but it's still

82
00:04:46,680 --> 00:04:51,960
large

83
00:04:48,560 --> 00:04:55,960
so uh so the Bigg issue is if you look

84
00:04:51,960 --> 00:04:59,479
at the verification time so

85
00:04:55,960 --> 00:05:01,639
the the verification time is you all see

86
00:04:59,479 --> 00:05:01,639
is

87
00:05:01,840 --> 00:05:08,360
uh uh K * policy the reason is the

88
00:05:07,039 --> 00:05:11,680
verifier need

89
00:05:08,360 --> 00:05:15,160
to uh verify the PCP answers for each of

90
00:05:11,680 --> 00:05:20,160
the instances for for X1 to

91
00:05:15,160 --> 00:05:22,560
XK so the so in this step so each PCP

92
00:05:20,160 --> 00:05:27,039
verification need to take C time and in

93
00:05:22,560 --> 00:05:27,039
total it need to take K times

94
00:05:27,280 --> 00:05:33,720
policy yeah why is there a PO

95
00:05:30,919 --> 00:05:38,199
oh so that's the that's because the each

96
00:05:33,720 --> 00:05:42,160
each query is uh so each query so if you

97
00:05:38,199 --> 00:05:45,680
remember yeah so here so each quy sze is

98
00:05:42,160 --> 00:05:45,680
Lambda times poog

99
00:05:47,919 --> 00:05:52,800
C so it's a yeah so they're not just

100
00:05:53,520 --> 00:05:59,039
single uh right so so here so here we

101
00:05:57,440 --> 00:06:02,240
have a Lambda term because we need to do

102
00:05:59,039 --> 00:06:05,639
the parallel ation so you take a you

103
00:06:02,240 --> 00:06:10,319
take a PCP with constant uh uh s this

104
00:06:05,639 --> 00:06:14,160
arrow and you amplify it uh LDA Times by

105
00:06:10,319 --> 00:06:14,160
parall repetition

106
00:06:15,120 --> 00:06:20,800
want yeah so you can have PCP with

107
00:06:18,400 --> 00:06:23,000
perfect perfect complains yeah so you

108
00:06:20,800 --> 00:06:26,479
don't need to worry about the when you

109
00:06:23,000 --> 00:06:29,199
do the par reputation okay so so the

110
00:06:26,479 --> 00:06:31,039
verification time is still very large uh

111
00:06:29,199 --> 00:06:33,039
so in fact you don't have any savings if

112
00:06:31,039 --> 00:06:37,520
you do this directly so on the

113
00:06:33,039 --> 00:06:39,520
verification time so and the so let's

114
00:06:37,520 --> 00:06:44,440
consider uh for

115
00:06:39,520 --> 00:06:46,880
a for a general snarks for B MP or barks

116
00:06:44,440 --> 00:06:50,199
so what's the verification time so

117
00:06:46,880 --> 00:06:52,560
remember the wif fire in in a bark the

118
00:06:50,199 --> 00:06:55,599
wif fire need to read uh at least the

119
00:06:52,560 --> 00:07:00,240
CRS and all of the statement to verify

120
00:06:55,599 --> 00:07:02,840
the proof so so the verifier uh need to

121
00:07:00,240 --> 00:07:04,919
at least read all of the instance so it

122
00:07:02,840 --> 00:07:07,319
seems that there is a lower Bond on the

123
00:07:04,919 --> 00:07:11,599
verification time the lower bond is just

124
00:07:07,319 --> 00:07:11,599
at least K * X

125
00:07:14,360 --> 00:07:19,120
okay

126
00:07:15,879 --> 00:07:20,759
so uh so next I will show you how to

127
00:07:19,120 --> 00:07:25,280
reduce the verification time and the

128
00:07:20,759 --> 00:07:27,039
proof size of barks but uh uh we will uh

129
00:07:25,280 --> 00:07:29,879
first

130
00:07:27,039 --> 00:07:31,919
uh right so we will uh consider a

131
00:07:29,879 --> 00:07:33,720
variant of bark and it don't have this

132
00:07:31,919 --> 00:07:37,360
lower bound on verification

133
00:07:33,720 --> 00:07:40,160
time so the idea so I will Define a new

134
00:07:37,360 --> 00:07:45,199
notion of uh

135
00:07:40,160 --> 00:07:45,199
barks uh let me re erase this

136
00:08:10,039 --> 00:08:15,720
so in this notion of Bo is called uh so

137
00:08:14,240 --> 00:08:19,240
it's called

138
00:08:15,720 --> 00:08:19,240
the index

139
00:08:20,080 --> 00:08:24,280
SP or you can also call it a

140
00:08:25,720 --> 00:08:31,280
snarks for uh batch index

141
00:08:36,919 --> 00:08:43,360
so so the idea is so in the original

142
00:08:41,000 --> 00:08:45,240
definition of barks the Wi-Fi need to

143
00:08:43,360 --> 00:08:47,399
read off the instance because the

144
00:08:45,240 --> 00:08:49,560
instance are nonuniform so in this

145
00:08:47,399 --> 00:08:52,680
notion uh we will consider a special

146
00:08:49,560 --> 00:08:54,880
case when this uh instance are uniform

147
00:08:52,680 --> 00:08:57,880
so intuitively it means there exists

148
00:08:54,880 --> 00:09:01,519
some circular

149
00:08:57,880 --> 00:09:05,480
U such that the is instance is generated

150
00:09:01,519 --> 00:09:08,200
by using the circuit U and the

151
00:09:05,480 --> 00:09:11,240
index so so

152
00:09:08,200 --> 00:09:13,160
intuitively it says the instance can be

153
00:09:11,240 --> 00:09:16,680
described in a uniform Way by only use

154
00:09:13,160 --> 00:09:20,079
the index and if this is the case

155
00:09:16,680 --> 00:09:24,519
then then what the pro try to prove is

156
00:09:20,079 --> 00:09:28,920
X1 to XK is all in this language

157
00:09:24,519 --> 00:09:32,600
l so so now it is equivalent to say uh

158
00:09:28,920 --> 00:09:32,600
so for index for each index

159
00:09:32,720 --> 00:09:41,440
I there exist witness wi uh such that

160
00:09:37,760 --> 00:09:47,519
this c c and the

161
00:09:41,440 --> 00:09:49,640
UI W equals 1 so so then we can Define

162
00:09:47,519 --> 00:09:53,079
so essentially this is you can build

163
00:09:49,640 --> 00:09:57,680
this as a new uh MP relation so the new

164
00:09:53,079 --> 00:10:00,920
MP relation is the is defined as follows

165
00:09:57,680 --> 00:10:03,480
so the instance is just index and it

166
00:10:00,920 --> 00:10:06,839
verifies uh there exist a

167
00:10:03,480 --> 00:10:06,839
wi such

168
00:10:15,279 --> 00:10:23,360
that so this is just a rewriting of this

169
00:10:19,760 --> 00:10:23,360
right so so

170
00:10:23,920 --> 00:10:28,440
this

171
00:10:25,440 --> 00:10:31,399
so uh right and then you can you can

172
00:10:28,440 --> 00:10:34,079
view this as a new new uh mp uh MP

173
00:10:31,399 --> 00:10:38,000
verification circuit that s c Prime so

174
00:10:34,079 --> 00:10:40,000
it only takes wi and the I and the wi

175
00:10:38,000 --> 00:10:43,160
input and it internally compute this you

176
00:10:40,000 --> 00:10:46,360
and the Wii C so this Inspire us to

177
00:10:43,160 --> 00:10:49,399
define a new notion called uh index bark

178
00:10:46,360 --> 00:10:49,399
so a index

179
00:10:50,519 --> 00:10:56,279
bark definition uh a index SP

180
00:11:01,279 --> 00:11:03,839
uh is a

181
00:11:05,360 --> 00:11:12,320
bark uh for this uh for this kind of

182
00:11:08,480 --> 00:11:15,720
relation so it it is for this uh this

183
00:11:12,320 --> 00:11:17,880
kind of language where the the language

184
00:11:15,720 --> 00:11:22,120
is just some general NP language but the

185
00:11:17,880 --> 00:11:22,120
instance is treated as an index

186
00:11:33,079 --> 00:11:40,079
for this

187
00:11:35,240 --> 00:11:46,399
language and the prover so the

188
00:11:40,079 --> 00:11:46,399
pro the we still have a uh CRS and

189
00:11:46,680 --> 00:11:53,720
the the prover tries to convince the

190
00:11:49,079 --> 00:12:00,360
wiif fire that uh all of the indices

191
00:11:53,720 --> 00:12:00,360
from one two ET to K is in this language

192
00:12:00,959 --> 00:12:07,720
so the only Pro also so only Pro only to

193
00:12:03,959 --> 00:12:12,120
read index K and uh it has witness from

194
00:12:07,720 --> 00:12:15,120
W1 to WK for each of the index and the

195
00:12:12,120 --> 00:12:18,440
WiFi only need to take K as

196
00:12:15,120 --> 00:12:21,440
input so so now the

197
00:12:18,440 --> 00:12:24,199
verifier so this K can be represented as

198
00:12:21,440 --> 00:12:27,639
log K bits because it's just the index

199
00:12:24,199 --> 00:12:31,160
so so what's the uh best verification

200
00:12:27,639 --> 00:12:31,160
time we can hope for

201
00:12:33,399 --> 00:12:35,880
uh anyone

202
00:12:40,199 --> 00:12:46,000
else so oh good so the verification time

203
00:12:43,920 --> 00:12:48,880
is uh so the verification so the wif

204
00:12:46,000 --> 00:12:53,720
only to read this index K and the

205
00:12:48,880 --> 00:12:56,839
proof so the wif can be as small as uh

206
00:12:53,720 --> 00:12:59,959
verification time only need to be uh

207
00:12:56,839 --> 00:13:02,160
some log k

208
00:12:59,959 --> 00:13:06,800
can be as small as this much so only

209
00:13:02,160 --> 00:13:10,320
depends on l k and the Lambda

210
00:13:06,800 --> 00:13:12,600
so okay so this is

211
00:13:10,320 --> 00:13:15,199
uh uh

212
00:13:12,600 --> 00:13:16,360
right and for this index bar we also

213
00:13:15,199 --> 00:13:19,040
require the completeness and the

214
00:13:16,360 --> 00:13:22,240
soundness uh in the same way as

215
00:13:19,040 --> 00:13:25,959
before uh any questions yeah actually

216
00:13:22,240 --> 00:13:29,959
should I think this you think part

217
00:13:25,959 --> 00:13:32,160
in yeah so you can think it's a

218
00:13:29,959 --> 00:13:35,399
yeah so you can think it it's uh you can

219
00:13:32,160 --> 00:13:37,000
always uh absorb it in the in the

220
00:13:35,399 --> 00:13:39,360
relation circuit so you can you can

221
00:13:37,000 --> 00:13:40,920
think it's part of the relation right I

222
00:13:39,360 --> 00:13:42,800
guess are we going to pay for the size

223
00:13:40,920 --> 00:13:45,519
of description of you anywhere or is

224
00:13:42,800 --> 00:13:47,120
that uh right right good so the

225
00:13:45,519 --> 00:13:49,240
verification circuit in fact they need

226
00:13:47,120 --> 00:13:53,600
also to depend on C right because the

227
00:13:49,240 --> 00:13:53,600
verifier need to read the circuit

228
00:13:54,440 --> 00:14:01,040
yes and is there like a unique instance

229
00:13:57,079 --> 00:14:01,040
to this problem then like

230
00:14:01,560 --> 00:14:06,000
yeah so so now the the point is now the

231
00:14:04,600 --> 00:14:08,320
verification time don't depends on

232
00:14:06,000 --> 00:14:10,920
linear in K so previously you need to

233
00:14:08,320 --> 00:14:13,800
read all the instance and now you the

234
00:14:10,920 --> 00:14:18,680
verification only gr log in

235
00:14:13,800 --> 00:14:24,120
yeah think of C as part of the input

236
00:14:18,680 --> 00:14:25,839
c c as part of the input uh So

237
00:14:24,120 --> 00:14:29,720
like

238
00:14:25,839 --> 00:14:33,800
um or I guess C Prime which like stor

239
00:14:29,720 --> 00:14:37,320
you in it uh right yes yes right okay so

240
00:14:33,800 --> 00:14:38,920
that is then how would so V still has to

241
00:14:37,320 --> 00:14:42,839
read

242
00:14:38,920 --> 00:14:44,680
what a lot of yeah so you can uh so it

243
00:14:42,839 --> 00:14:46,880
depends on how you define it so you can

244
00:14:44,680 --> 00:14:48,920
Define it for a fixed C and you have

245
00:14:46,880 --> 00:14:51,160
such a proof system or you can define a

246
00:14:48,920 --> 00:14:52,720
proof system for any c then you need to

247
00:14:51,160 --> 00:14:55,320
you need the verification time to grow

248
00:14:52,720 --> 00:14:57,680
with the c size C is it defining it for

249
00:14:55,320 --> 00:14:59,959
a f c kind of

250
00:14:57,680 --> 00:15:04,040
like like not that helpful because we

251
00:14:59,959 --> 00:15:07,199
just solving bch for like a b

252
00:15:04,040 --> 00:15:11,199
Set uh but you can you choose C to be

253
00:15:07,199 --> 00:15:11,199
universal circuit then it's a

254
00:15:12,199 --> 00:15:18,360
yeah then it's

255
00:15:14,839 --> 00:15:20,240
General uh good question so right I

256
00:15:18,360 --> 00:15:24,440
think yeah if you take a universal you

257
00:15:20,240 --> 00:15:28,759
need to you to use the U maybe yeah yeah

258
00:15:24,440 --> 00:15:28,759
it's good to think c as the input

259
00:15:31,399 --> 00:15:39,720
yeah okay so and uh and the and uh so in

260
00:15:38,360 --> 00:15:43,199
the remaining time of this lecture we

261
00:15:39,720 --> 00:15:45,319
all prove uh we all prove the following

262
00:15:43,199 --> 00:15:49,199
theorem

263
00:15:45,319 --> 00:15:52,639
so there exist a

264
00:15:49,199 --> 00:15:52,639
a index

265
00:15:55,480 --> 00:16:01,680
Spark from lwe and the Pro proof

266
00:16:02,160 --> 00:16:10,519
size is

267
00:16:04,480 --> 00:16:14,240
uh po uh log so you grow log in

268
00:16:10,519 --> 00:16:14,240
K uh C and

269
00:16:14,720 --> 00:16:18,880
Lambda and the verification

270
00:16:21,759 --> 00:16:29,079
time is uh log K C Lambda

271
00:16:29,199 --> 00:16:35,680
okay so both of them are

272
00:16:32,319 --> 00:16:38,759
uh uh almost match the best you can hope

273
00:16:35,680 --> 00:16:38,759
for up to some

274
00:16:40,360 --> 00:16:45,680
polinomial

275
00:16:42,279 --> 00:16:45,680
so and

276
00:16:45,959 --> 00:16:51,279
uh okay so here I want to emphasize

277
00:16:51,319 --> 00:16:56,480
the so I want to emphasize here

278
00:17:08,839 --> 00:17:13,520
that in fact you can if you know how to

279
00:17:11,400 --> 00:17:16,240
build uh this index bark then you can

280
00:17:13,520 --> 00:17:19,360
build barks with almost the same

281
00:17:16,240 --> 00:17:19,360
verification time and proof

282
00:17:20,240 --> 00:17:26,559
size so in other words uh in fact any uh

283
00:17:24,039 --> 00:17:32,120
a batch of instance are without a loss

284
00:17:26,559 --> 00:17:32,120
of generality uniform uh in sense

285
00:17:32,440 --> 00:17:37,200
so

286
00:17:34,000 --> 00:17:40,840
so so what I will show you is uh in fact

287
00:17:37,200 --> 00:17:43,400
if you know how to build index

288
00:17:40,840 --> 00:17:45,880
Mark then you can use it in a generic

289
00:17:43,400 --> 00:17:45,880
way to build

290
00:17:46,440 --> 00:17:52,600
barks so the reduction works as follows

291
00:17:50,960 --> 00:17:55,960
so suppose we

292
00:17:52,600 --> 00:18:00,840
have so so now we want to build a bark

293
00:17:55,960 --> 00:18:00,840
uh for a bunch of instance from X1 to XK

294
00:18:03,159 --> 00:18:10,840
so the idea is uh we will first build a

295
00:18:07,120 --> 00:18:10,840
mirle harsh of all of the

296
00:18:12,799 --> 00:18:19,840
instance

297
00:18:15,799 --> 00:18:19,840
so and we have some has

298
00:18:22,679 --> 00:18:28,159
root so now uh we have the prover send

299
00:18:25,600 --> 00:18:31,159
this has root to the wif fire and the

300
00:18:28,159 --> 00:18:35,760
prove that and use and then we have the

301
00:18:31,159 --> 00:18:35,760
approver to show that for any index

302
00:18:36,400 --> 00:18:40,880
I uh there exist a local

303
00:18:45,880 --> 00:18:50,960
opening row

304
00:18:48,120 --> 00:18:53,640
I uh so the local opening remember is

305
00:18:50,960 --> 00:18:59,559
the root two Le path for each of the

306
00:18:53,640 --> 00:18:59,559
leaf okay so there ex local opening

307
00:19:00,280 --> 00:19:05,520
row I for

308
00:19:03,120 --> 00:19:08,520
XI such

309
00:19:05,520 --> 00:19:08,520
that

310
00:19:10,120 --> 00:19:16,840
um such that the local verification will

311
00:19:13,440 --> 00:19:16,840
pass for this

312
00:19:19,799 --> 00:19:23,200
XI local

313
00:19:25,600 --> 00:19:29,840
verification so the local verification

314
00:19:27,559 --> 00:19:31,600
algorithm will take the h root and the

315
00:19:29,840 --> 00:19:35,400
index I and the

316
00:19:31,600 --> 00:19:38,400
XI which is the open value and also this

317
00:19:35,400 --> 00:19:42,320
local opening which is the root2 de

318
00:19:38,400 --> 00:19:48,760
pass and moreover uh there is also exist

319
00:19:42,320 --> 00:19:48,760
a wi such that the original circuit is

320
00:19:50,120 --> 00:19:56,320
satisfied so so the idea is you just has

321
00:19:53,080 --> 00:20:00,280
all of the instance from X1 to XK and

322
00:19:56,320 --> 00:20:03,240
you send the uh H value to the wifire

323
00:20:00,280 --> 00:20:07,880
then you prove for each indexi there

324
00:20:03,240 --> 00:20:12,200
exist opening XI to this has and uh this

325
00:20:07,880 --> 00:20:16,640
uh C of XI is satisfied so in this way

326
00:20:12,200 --> 00:20:21,280
you convert uh gener so you convert a

327
00:20:16,640 --> 00:20:22,840
batch of NP instance to a index uh to a

328
00:20:21,280 --> 00:20:25,240
batch index in

329
00:20:22,840 --> 00:20:28,039
instance because so now now the

330
00:20:25,240 --> 00:20:31,240
statement only grow so so it prove

331
00:20:28,039 --> 00:20:34,679
something for each index I so you can

332
00:20:31,240 --> 00:20:37,200
view so you can view this uh so you can

333
00:20:34,679 --> 00:20:37,200
view this

334
00:20:37,440 --> 00:20:43,600
part so you can view this part as some

335
00:20:40,600 --> 00:20:48,799
circuit c c Prime so C Prime will take

336
00:20:43,600 --> 00:20:52,240
index I and the winess row i w i and

337
00:20:48,799 --> 00:20:55,760
check the check the two

338
00:20:52,240 --> 00:20:59,159
things then you can generate generate a

339
00:20:55,760 --> 00:21:03,400
uh index bark for this instance for for

340
00:20:59,159 --> 00:21:05,880
each of the instance from X1 from one to

341
00:21:03,400 --> 00:21:09,159
K

342
00:21:05,880 --> 00:21:11,880
so and and this uh uh and then you

343
00:21:09,159 --> 00:21:16,240
generate a index bark for for this kind

344
00:21:11,880 --> 00:21:18,279
of instance so so now you send this to

345
00:21:16,240 --> 00:21:19,799
the wifire and this is your

346
00:21:18,279 --> 00:21:21,679
bark

347
00:21:19,799 --> 00:21:26,960
yeah

348
00:21:21,679 --> 00:21:29,440
so okay so the so if the if the uh if Pi

349
00:21:26,960 --> 00:21:34,240
is small and the H is small your total

350
00:21:29,440 --> 00:21:34,240
proof size is also small so that's the

351
00:21:38,400 --> 00:21:44,240
idea so next uh I will only focus on so

352
00:21:42,120 --> 00:21:47,159
we'll come back to this point later uh

353
00:21:44,240 --> 00:21:49,120
when we uh so because the proof of

354
00:21:47,159 --> 00:21:52,080
soundness of this transformation is not

355
00:21:49,120 --> 00:21:55,360
trivial because in fact you all you all

356
00:21:52,080 --> 00:21:57,640
see this is not so so the nonadaptive

357
00:21:55,360 --> 00:21:59,200
soundness previously is not sufficient

358
00:21:57,640 --> 00:22:00,799
to prove the soundness

359
00:21:59,200 --> 00:22:04,279
because this circuit will depends on

360
00:22:00,799 --> 00:22:06,279
this hash and is chosen adaptively by

361
00:22:04,279 --> 00:22:08,320
the adversary so we will come back to

362
00:22:06,279 --> 00:22:11,240
this point later to show how to prove

363
00:22:08,320 --> 00:22:11,240
the soundness of this

364
00:22:11,720 --> 00:22:17,039
transformation okay so next I will show

365
00:22:13,799 --> 00:22:17,039
you how to build this index

366
00:22:23,320 --> 00:22:34,159
Park so so our starting point is uh

367
00:22:29,520 --> 00:22:36,760
is still this protocol so as I just said

368
00:22:34,159 --> 00:22:39,520
uh earlier so the first round message is

369
00:22:36,760 --> 00:22:41,679
small because it only depends on C but

370
00:22:39,520 --> 00:22:44,200
the thiron message is large so how can

371
00:22:41,679 --> 00:22:48,200
we further compress the thiron

372
00:22:44,200 --> 00:22:48,200
message okay

373
00:23:14,320 --> 00:23:18,600
so so in the context of index bark all

374
00:23:16,559 --> 00:23:21,559
of the instance are just indices so I

375
00:23:18,600 --> 00:23:21,559
can replace them with one

376
00:23:26,320 --> 00:23:32,600
Tok and the idea is a we're going to

377
00:23:29,360 --> 00:23:34,960
dedicate we're going to uh remove this

378
00:23:32,600 --> 00:23:34,960
round

379
00:23:36,400 --> 00:23:41,000
message we're going to remove this round

380
00:23:38,640 --> 00:23:44,760
of message and

381
00:23:41,000 --> 00:23:46,840
uh so we're going to dedicate this uh uh

382
00:23:44,760 --> 00:23:49,679
verif the verification of this message

383
00:23:46,840 --> 00:23:53,320
to the prover so the prover will have

384
00:23:49,679 --> 00:23:55,760
this this uh open the query The Columns

385
00:23:53,320 --> 00:23:58,080
in his hand but uh he is not going to

386
00:23:55,760 --> 00:24:00,320
send them to the wifire instead the

387
00:23:58,080 --> 00:24:02,799
prover is going to verify do the

388
00:24:00,320 --> 00:24:05,559
verification by itself and prove to the

389
00:24:02,799 --> 00:24:10,880
verifier those verification is indeed

390
00:24:05,559 --> 00:24:12,200
correct so so the uh construction work

391
00:24:10,880 --> 00:24:14,159
like

392
00:24:12,200 --> 00:24:17,200
this so the

393
00:24:14,159 --> 00:24:20,039
pro still send this

394
00:24:17,200 --> 00:24:22,600
uh H1 to

395
00:24:20,039 --> 00:24:24,760
HL to the

396
00:24:22,600 --> 00:24:28,679
wifire and the prover is going to

397
00:24:24,760 --> 00:24:28,679
compute this uh

398
00:24:29,039 --> 00:24:32,440
uh PCP query using the

399
00:24:34,000 --> 00:24:41,159
cush and then the approver and the wiif

400
00:24:36,559 --> 00:24:41,159
fire is going to run another protocol

401
00:24:42,640 --> 00:24:50,120
so another snar

402
00:24:45,919 --> 00:24:53,720
uh and this snark uh on the prover side

403
00:24:50,120 --> 00:24:58,640
he has he's going to uh use the columns

404
00:24:53,720 --> 00:24:58,640
the open columns uh

405
00:24:59,640 --> 00:25:04,960
as the input to this

406
00:25:02,640 --> 00:25:08,399
protocol and in the end the WiFi is

407
00:25:04,960 --> 00:25:12,240
convinced that this uh

408
00:25:08,399 --> 00:25:15,120
uh the the third round message verifies

409
00:25:12,240 --> 00:25:17,159
so what does this mean is the pro is

410
00:25:15,120 --> 00:25:20,840
going to prove

411
00:25:17,159 --> 00:25:23,840
for uh so the prover is going to prove

412
00:25:20,840 --> 00:25:23,840
for there

413
00:25:24,399 --> 00:25:28,960
exist the pro is going to prove to this

414
00:25:27,120 --> 00:25:32,840
ware in this protocol

415
00:25:28,960 --> 00:25:35,559
the following language so there exist uh

416
00:25:32,840 --> 00:25:35,559
L

417
00:25:36,039 --> 00:25:40,880
columns Q such

418
00:25:40,919 --> 00:25:48,679
that yes such that uh two things so one

419
00:25:45,120 --> 00:25:48,679
is uh

420
00:25:49,000 --> 00:25:57,679
the one is for each uh for each column

421
00:25:53,000 --> 00:25:58,840
for each Que in the query the set the

422
00:25:57,679 --> 00:26:00,799
has

423
00:25:58,840 --> 00:26:05,640
is competed correctly it's consistent

424
00:26:00,799 --> 00:26:06,600
with the first message so the HQ is is

425
00:26:05,640 --> 00:26:08,919
the

426
00:26:06,600 --> 00:26:13,760
SSB of

427
00:26:08,919 --> 00:26:18,080
the column the Q is column so I omit the

428
00:26:13,760 --> 00:26:19,520
uh SSB key here okay and the second for

429
00:26:18,080 --> 00:26:25,320
each

430
00:26:19,520 --> 00:26:28,360
PCP for each instance so for any I in K

431
00:26:25,320 --> 00:26:32,840
so here the instance is just the index I

432
00:26:28,360 --> 00:26:35,799
the is instance XI just XI so he will

433
00:26:32,840 --> 00:26:39,120
verify this

434
00:26:35,799 --> 00:26:39,120
uh so

435
00:26:40,000 --> 00:26:47,360
the PCP verification of

436
00:26:43,960 --> 00:26:47,360
I uh

437
00:26:49,159 --> 00:26:57,240
Q

438
00:26:51,600 --> 00:27:00,760
yes and the The Q's column

439
00:26:57,240 --> 00:27:04,919
uh the ice coordinate of the Qs

440
00:27:00,760 --> 00:27:04,919
column and we collect them

441
00:27:05,679 --> 00:27:12,279
together okay

442
00:27:08,799 --> 00:27:15,720
so so this is the this is the statement

443
00:27:12,279 --> 00:27:19,039
this protocol wants to prove and the pro

444
00:27:15,720 --> 00:27:23,480
is going to supply it with the uh

445
00:27:19,039 --> 00:27:26,919
widness which is this

446
00:27:23,480 --> 00:27:31,279
okay so that's the high level

447
00:27:26,919 --> 00:27:34,279
idea so but to achieve this uh so so

448
00:27:31,279 --> 00:27:38,000
suppose we can rewrite this uh statement

449
00:27:34,279 --> 00:27:40,600
as a batch index statement then I can uh

450
00:27:38,000 --> 00:27:43,080
apply the same construction again on top

451
00:27:40,600 --> 00:27:45,760
of this statement so we can apply the

452
00:27:43,080 --> 00:27:48,399
same thing again to this through this

453
00:27:45,760 --> 00:27:52,880
new statement and uh I can do the

454
00:27:48,399 --> 00:27:54,880
recursing so that's the idea so how do I

455
00:27:52,880 --> 00:27:59,240
but the issue is how do I represent this

456
00:27:54,880 --> 00:28:02,600
as a batch index language so how do I

457
00:27:59,240 --> 00:28:05,519
how do I represent is as a index as a

458
00:28:02,600 --> 00:28:08,480
batch of index language so how do I

459
00:28:05,519 --> 00:28:08,480
represent it as a batch of

460
00:28:10,360 --> 00:28:17,240
index so so now you can see uh maybe you

461
00:28:14,399 --> 00:28:19,640
think okay so this is a almost index

462
00:28:17,240 --> 00:28:22,840
because index language because this is

463
00:28:19,640 --> 00:28:25,679
at least this part is uh this is clear

464
00:28:22,840 --> 00:28:29,640
for any index I

465
00:28:25,679 --> 00:28:32,360
so right this is for any index uh index

466
00:28:29,640 --> 00:28:34,159
I in K there is something so this is

467
00:28:32,360 --> 00:28:35,480
similar to our index language but this

468
00:28:34,159 --> 00:28:41,640
part is not

469
00:28:35,480 --> 00:28:41,640
clear so the the reason is uh Q is very

470
00:28:42,320 --> 00:28:48,480
small uh but the MP widness is very

471
00:28:45,399 --> 00:28:53,120
large so so if you if you treat this Q

472
00:28:48,480 --> 00:28:56,519
as a instance then the widness size is K

473
00:28:53,120 --> 00:28:59,159
because each column has uh K entries so

474
00:28:56,519 --> 00:29:01,720
for each column contains the PCP

475
00:28:59,159 --> 00:29:03,200
coordinate for each of the instance so

476
00:29:01,720 --> 00:29:08,559
the column size is

477
00:29:03,200 --> 00:29:13,240
K but if if I treat this column uh

478
00:29:08,559 --> 00:29:15,200
column Q as a widness then uh when I do

479
00:29:13,240 --> 00:29:18,559
the recursion the proof size will grow

480
00:29:15,200 --> 00:29:20,760
with the size of K because because it

481
00:29:18,559 --> 00:29:23,640
because the because again I will have

482
00:29:20,760 --> 00:29:27,440
this kind of this kind of hash

483
00:29:23,640 --> 00:29:29,919
values some some L Prime but for but

484
00:29:27,440 --> 00:29:34,080
those actual to l l

485
00:29:29,919 --> 00:29:35,960
Prime H1 Prime to h l prime prime so

486
00:29:34,080 --> 00:29:38,039
they are for the for the new protocol

487
00:29:35,960 --> 00:29:40,880
and the new instance so they will grow

488
00:29:38,039 --> 00:29:44,919
with the size of K so that's too large

489
00:29:40,880 --> 00:29:48,679
we cannot uh afford that

490
00:29:44,919 --> 00:29:52,919
so so next I will uh rewrite this

491
00:29:48,679 --> 00:29:55,679
instance as a batch of uh statements and

492
00:29:52,919 --> 00:29:56,840
the statement size will be K but the MP

493
00:29:55,679 --> 00:30:00,720
widness will be

494
00:29:56,840 --> 00:30:05,159
small okay so how do I rewrite

495
00:30:00,720 --> 00:30:07,360
it so so let's look at what what this do

496
00:30:05,159 --> 00:30:11,240
this verification do

497
00:30:07,360 --> 00:30:12,840
so so for each this verification we have

498
00:30:11,240 --> 00:30:16,799
a column Q

499
00:30:12,840 --> 00:30:16,799
so and this size is

500
00:30:18,679 --> 00:30:25,320
K so it will it will recompute this s SB

501
00:30:22,480 --> 00:30:28,760
and check uh if it is if it's the same

502
00:30:25,320 --> 00:30:30,360
with some HQ which is the h was sent in

503
00:30:28,760 --> 00:30:32,000
the first

504
00:30:30,360 --> 00:30:36,440
round

505
00:30:32,000 --> 00:30:38,799
so so the idea is that suppose this

506
00:30:36,440 --> 00:30:42,600
SSB uh suppose we have some more

507
00:30:38,799 --> 00:30:46,360
structure of this s s hash then I can uh

508
00:30:42,600 --> 00:30:50,360
local verify it so that means uh if I

509
00:30:46,360 --> 00:30:50,360
build this SSB with

510
00:30:51,200 --> 00:30:58,120
some so

511
00:30:54,720 --> 00:31:01,399
see for example if the SSB is built in

512
00:30:58,120 --> 00:31:05,840
merco tree as a merco tree then I can

513
00:31:01,399 --> 00:31:08,080
replace this verification by verify

514
00:31:05,840 --> 00:31:13,080
that uh for

515
00:31:08,080 --> 00:31:17,080
each uh index I for each index I in

516
00:31:13,080 --> 00:31:18,639
K there exist a local opening row

517
00:31:17,080 --> 00:31:22,399
i

518
00:31:18,639 --> 00:31:26,639
q so row IQ is the local opening for the

519
00:31:22,399 --> 00:31:28,519
you can think for each index I I have a

520
00:31:26,639 --> 00:31:33,320
I have a

521
00:31:28,519 --> 00:31:35,559
I have an entry the entry is uh column Q

522
00:31:33,320 --> 00:31:37,880
the highest position of the column q and

523
00:31:35,559 --> 00:31:39,639
I have a local opening for

524
00:31:37,880 --> 00:31:42,519
that row

525
00:31:39,639 --> 00:31:44,679
IQ so I only to show there exist such a

526
00:31:42,519 --> 00:31:51,480
local opening for this

527
00:31:44,679 --> 00:31:58,000
has so so here HQ is the has value right

528
00:31:51,480 --> 00:31:58,000
so for uh for HQ

529
00:32:00,279 --> 00:32:03,519
yeah I only to verify

530
00:32:07,360 --> 00:32:14,240
this so now now I get a a batch of MP

531
00:32:16,799 --> 00:32:22,760
instance right

532
00:32:20,240 --> 00:32:28,080
so

533
00:32:22,760 --> 00:32:28,080
uh yeah so let me rewrite this

534
00:32:41,080 --> 00:32:48,320
so suppose I have a uh SSB buil in the

535
00:32:44,720 --> 00:32:48,320
mer Treeway

536
00:32:48,760 --> 00:32:55,880
then so the protocol will uh work like

537
00:32:52,120 --> 00:32:59,840
this so initially we have H1 to

538
00:32:55,880 --> 00:32:59,840
HL and we have this

539
00:33:03,559 --> 00:33:09,600
Q so in the new

540
00:33:06,519 --> 00:33:12,880
protocol uh we are going to the Pro is

541
00:33:09,600 --> 00:33:14,279
going to supply with with the quired

542
00:33:12,880 --> 00:33:19,960
column

543
00:33:14,279 --> 00:33:22,320
uh for this que and also a bunch of

544
00:33:19,960 --> 00:33:26,000
local openings for each coordinate in

545
00:33:22,320 --> 00:33:26,000
this uh Q

546
00:33:31,360 --> 00:33:34,120
okay

547
00:33:36,039 --> 00:33:42,919
so so and this protocol will

548
00:33:39,320 --> 00:33:45,960
prove uh so this protocol is a new

549
00:33:42,919 --> 00:33:48,919
uh index spk

550
00:33:45,960 --> 00:33:51,880
protocol it will prove for a new

551
00:33:48,919 --> 00:33:53,240
instance L for for new language l l

552
00:33:51,880 --> 00:33:55,840
Prime let's denote

553
00:33:53,240 --> 00:34:00,799
it so L

554
00:33:55,840 --> 00:34:00,799
prime it contains all the index

555
00:34:01,320 --> 00:34:09,520
I and uh for each index I I need to show

556
00:34:06,279 --> 00:34:12,960
there exist a

557
00:34:09,520 --> 00:34:15,159
uh witness which

558
00:34:12,960 --> 00:34:18,159
is column

559
00:34:15,159 --> 00:34:18,159
q

560
00:34:22,320 --> 00:34:31,000
i so this is the is uh PCP answer and

561
00:34:27,720 --> 00:34:34,599
and uh and they are corresponding I also

562
00:34:31,000 --> 00:34:34,599
need this Q row

563
00:34:41,760 --> 00:34:47,359
IQ uh such

564
00:34:44,159 --> 00:34:51,359
that so first I need to verify the PCP

565
00:34:47,359 --> 00:34:51,359
answers right

566
00:35:13,040 --> 00:35:19,320
and the second I need to verify the

567
00:35:16,079 --> 00:35:22,640
local opening is correct so I need to

568
00:35:19,320 --> 00:35:25,000
verify the so there is some local

569
00:35:22,640 --> 00:35:27,079
opening verification

570
00:35:25,000 --> 00:35:29,599
algorithm the local verification

571
00:35:27,079 --> 00:35:31,880
algorithm will take the H root uh for

572
00:35:29,599 --> 00:35:31,880
each

573
00:35:32,000 --> 00:35:37,920
q and uh so I need to verify this for

574
00:35:35,760 --> 00:35:37,920
for

575
00:35:42,839 --> 00:35:50,880
areq and this local verification

576
00:35:45,440 --> 00:35:50,880
algorithm of SSB will verify row IQ

577
00:36:09,400 --> 00:36:17,240
yeah uh any questions so this is the

578
00:36:13,400 --> 00:36:20,760
new so this is the new

579
00:36:17,240 --> 00:36:20,760
instance new L

580
00:36:22,960 --> 00:36:31,040
Prim so for each I uh and so the pro

581
00:36:27,599 --> 00:36:37,440
need to prove uh so the pro need to

582
00:36:31,040 --> 00:36:37,440
prove one two 2K are all in this l l

583
00:36:38,240 --> 00:36:41,240
PR

584
00:36:51,280 --> 00:36:57,560
right so yeah uh any questions

585
00:37:09,000 --> 00:37:16,359
yeah we this and the idea is that the

586
00:37:13,839 --> 00:37:19,839
the number the same but the Witnesses

587
00:37:16,359 --> 00:37:22,720
are not gr uh good question so if you do

588
00:37:19,839 --> 00:37:25,040
this recre it will forever because the

589
00:37:22,720 --> 00:37:26,640
because uh from the beginning we have K

590
00:37:25,040 --> 00:37:28,040
instances and then in the next level of

591
00:37:26,640 --> 00:37:31,040
the recursion we still have havek

592
00:37:28,040 --> 00:37:31,040
instances

593
00:37:32,160 --> 00:37:36,160
so exactly so that's what what we will

594
00:37:34,720 --> 00:37:41,000
do

595
00:37:36,160 --> 00:37:46,079
next uh any question yeah so HQ is a he

596
00:37:41,000 --> 00:37:49,040
of statements sorry HQ oh right so HQ is

597
00:37:46,079 --> 00:37:52,200
part of the statement right

598
00:37:49,040 --> 00:37:55,599
so the statement X1 to

599
00:37:52,200 --> 00:38:00,280
xq uh oh you mean where is the X where

600
00:37:55,599 --> 00:38:04,079
is HQ comes from yes oh good so HQ is

601
00:38:00,280 --> 00:38:06,960
the same as HQ here so so you have so

602
00:38:04,079 --> 00:38:09,280
initially we have a bunch of statement

603
00:38:06,960 --> 00:38:13,560
from one to K and each of them has NP

604
00:38:09,280 --> 00:38:16,440
witness from Omega 1 to Omega K and we

605
00:38:13,560 --> 00:38:19,160
arrange this uh we compute this PCP

606
00:38:16,440 --> 00:38:21,079
Matrix and for each column we has it to

607
00:38:19,160 --> 00:38:25,720
H1 to

608
00:38:21,079 --> 00:38:29,800
HL so and the HQ is just the q's Q's

609
00:38:25,720 --> 00:38:36,960
column of this m of this h12

610
00:38:29,800 --> 00:38:36,960
HQ yeah the the index Q among this h12

611
00:38:39,880 --> 00:38:47,040
hqe local version of the SSP is some

612
00:38:42,920 --> 00:38:50,720
variant of the F A yeah so that's what

613
00:38:47,040 --> 00:38:54,520
I'm going to talk about next yeah so so

614
00:38:50,720 --> 00:38:58,680
now you may ask uh so how do we

615
00:38:54,520 --> 00:39:01,400
construct such a SSB with uh merco style

616
00:38:58,680 --> 00:39:03,680
construction

617
00:39:01,400 --> 00:39:06,400
so because the construction I just

618
00:39:03,680 --> 00:39:10,160
showed you doesn't satisfy this property

619
00:39:06,400 --> 00:39:10,160
so this is a

620
00:39:16,760 --> 00:39:24,200
SSB so SSV with this local opening

621
00:39:20,200 --> 00:39:27,160
property so what it says is uh the idea

622
00:39:24,200 --> 00:39:30,319
is so if we build the H like a merco

623
00:39:27,160 --> 00:39:32,520
tree we have this uh local opening so

624
00:39:30,319 --> 00:39:32,520
for

625
00:39:32,839 --> 00:39:39,240
example and

626
00:39:34,760 --> 00:39:41,680
the the issue is how do we uh how do we

627
00:39:39,240 --> 00:39:43,760
still have the someware this someware St

628
00:39:41,680 --> 00:39:46,800
isal binding property so the idea is

629
00:39:43,760 --> 00:39:49,720
just uh so at each note of the tree

630
00:39:46,800 --> 00:39:52,200
we're are going to um pick under the

631
00:39:49,720 --> 00:39:54,880
hood of f one of each

632
00:39:52,200 --> 00:39:59,319
children so so you can think uh

633
00:39:54,880 --> 00:40:03,119
initially we have some X1 2 XK

634
00:39:59,319 --> 00:40:06,440
uh in the clear and uh we we have some

635
00:40:03,119 --> 00:40:09,359
so at each at each level we are going to

636
00:40:06,440 --> 00:40:12,119
pick either is is left child or right

637
00:40:09,359 --> 00:40:14,800
child for each noes in this level for

638
00:40:12,119 --> 00:40:18,440
example in this level so suppose this is

639
00:40:14,800 --> 00:40:20,079
your index I then what we can do is for

640
00:40:18,440 --> 00:40:23,160
each node in this level we're going to

641
00:40:20,079 --> 00:40:26,920
pick uh pick the left

642
00:40:23,160 --> 00:40:29,839
child and uh and at this level we're

643
00:40:26,920 --> 00:40:29,839
going to pick pick the right

644
00:40:31,960 --> 00:40:36,680
child

645
00:40:33,680 --> 00:40:40,040
so so at each each level we're going to

646
00:40:36,680 --> 00:40:40,040
have some uh

647
00:40:41,119 --> 00:40:49,760
fhe homic encryption of some bit so some

648
00:40:45,560 --> 00:40:51,760
bit B1 and uh so let's say this is

649
00:40:49,760 --> 00:40:54,880
B2 and each level we're going to

650
00:40:51,760 --> 00:40:58,880
homologically evaluate this using this

651
00:40:54,880 --> 00:41:02,319
B12 and B2 to uh

652
00:40:58,880 --> 00:41:05,160
to choose to pick the children on the

653
00:41:02,319 --> 00:41:08,640
hood of FH in the same way as

654
00:41:05,160 --> 00:41:09,599
before so so this can give you SSB with

655
00:41:08,640 --> 00:41:14,359
local

656
00:41:09,599 --> 00:41:16,760
opening okay but uh what we will so so

657
00:41:14,359 --> 00:41:21,280
one property we uh further require about

658
00:41:16,760 --> 00:41:23,000
this uh SSB is the local opening

659
00:41:21,280 --> 00:41:26,240
correctness

660
00:41:23,000 --> 00:41:28,200
okay so we require this property because

661
00:41:26,240 --> 00:41:32,280
uh remember in the s

662
00:41:28,200 --> 00:41:34,119
proof we need to ensure uh if the wifire

663
00:41:32,280 --> 00:41:37,200
if the proof is accepted in the thir

664
00:41:34,119 --> 00:41:39,640
round then the proof the proof con

665
00:41:37,200 --> 00:41:42,599
contains some opening of the

666
00:41:39,640 --> 00:41:45,560
SSB and we need to show this opening

667
00:41:42,599 --> 00:41:48,319
must be consistent with the uh SSB

668
00:41:45,560 --> 00:41:51,920
extracted value so originally this is

669
00:41:48,319 --> 00:41:54,880
easy to ensure because the Wii sees the

670
00:41:51,920 --> 00:41:57,680
entire opening but now it's not clear

671
00:41:54,880 --> 00:41:59,920
whether this can still holds because so

672
00:41:57,680 --> 00:42:01,720
now the verifier only sees a local

673
00:41:59,920 --> 00:42:05,640
opening of the

674
00:42:01,720 --> 00:42:08,680
SSB okay so it does not uh SE all the

675
00:42:05,640 --> 00:42:13,280
X12 XK it only sees the root to leave

676
00:42:08,680 --> 00:42:18,440
path of some XI so we need to we need

677
00:42:13,280 --> 00:42:18,440
our further uh local opening correctness

678
00:42:28,240 --> 00:42:33,160
so the correctness of local opening says

679
00:42:30,520 --> 00:42:36,440
that

680
00:42:33,160 --> 00:42:39,599
uh so so this uh SSV with local opening

681
00:42:36,440 --> 00:42:42,720
has some uh local verification

682
00:42:39,599 --> 00:42:47,920
algorithm so it will take uh it will

683
00:42:42,720 --> 00:42:51,240
take the H root H and the some index I

684
00:42:47,920 --> 00:42:53,760
and the x i and the root to pass for

685
00:42:51,240 --> 00:42:57,440
this XI and it can decide whether to

686
00:42:53,760 --> 00:43:00,319
accept or reject okay and the local

687
00:42:57,440 --> 00:43:06,960
opening property says that for any uh

688
00:43:00,319 --> 00:43:06,960
index i h x i and row I so if

689
00:43:07,280 --> 00:43:12,040
the so if this

690
00:43:12,200 --> 00:43:16,359
uh uh local verification

691
00:43:20,800 --> 00:43:25,480
passes then it must be case

692
00:43:25,680 --> 00:43:29,119
that uh

693
00:43:30,440 --> 00:43:38,000
the extract the

694
00:43:32,400 --> 00:43:40,559
value uh of the hash equals this XI so

695
00:43:38,000 --> 00:43:42,640
so here

696
00:43:40,559 --> 00:43:47,800
uh

697
00:43:42,640 --> 00:43:50,200
yeah the local verification let me

698
00:43:47,800 --> 00:43:52,520
see so the local verification also need

699
00:43:50,200 --> 00:43:57,920
to use the SSB

700
00:43:52,520 --> 00:43:57,920
key to check this okay

701
00:43:58,119 --> 00:44:07,359
so here uh if this is true and uh the

702
00:44:02,480 --> 00:44:07,359
SSB key is generated for

703
00:44:08,839 --> 00:44:14,079
the for the index

704
00:44:11,160 --> 00:44:17,440
I yeah then I

705
00:44:14,079 --> 00:44:20,160
need if the local appication passes then

706
00:44:17,440 --> 00:44:23,280
the exed value must be XI so this is not

707
00:44:20,160 --> 00:44:27,079
triv correct this is not Tri hold if you

708
00:44:23,280 --> 00:44:30,680
use just this construction because uh um

709
00:44:27,079 --> 00:44:33,559
ious so a malicious f it will contain

710
00:44:30,680 --> 00:44:36,680
the RO to pass to this

711
00:44:33,559 --> 00:44:38,760
XI but it also need to contain the

712
00:44:36,680 --> 00:44:41,119
siblings of this so in this

713
00:44:38,760 --> 00:44:44,280
authenticated path it also need to

714
00:44:41,119 --> 00:44:46,720
contain the siblings of each node in the

715
00:44:44,280 --> 00:44:50,760
past but those siblings may not be well

716
00:44:46,720 --> 00:44:53,359
formed FH SE text so so indeed you need

717
00:44:50,760 --> 00:44:57,280
to further add some put strum mechanism

718
00:44:53,359 --> 00:44:59,440
here so you need to Hally encrypt the so

719
00:44:57,280 --> 00:45:02,200
at each level of the F you need to use a

720
00:44:59,440 --> 00:45:05,040
different F key and at the next level

721
00:45:02,200 --> 00:45:07,520
you need to you need to hopic decrypt

722
00:45:05,040 --> 00:45:10,040
the F SE text at the previous level to

723
00:45:07,520 --> 00:45:11,839
ensure it's a Well phone SE text so I'm

724
00:45:10,040 --> 00:45:15,839
not going to the detail but you can you

725
00:45:11,839 --> 00:45:20,559
can fix this this easily by your own

726
00:45:15,839 --> 00:45:22,359
yes okay so so now so

727
00:45:20,559 --> 00:45:25,040
now

728
00:45:22,359 --> 00:45:27,800
uh uh any question with this constrction

729
00:45:25,040 --> 00:45:33,160
yeah why

730
00:45:27,800 --> 00:45:36,119
using SSB in a m fre style instead

731
00:45:33,160 --> 00:45:40,040
of uh good question so if you directly

732
00:45:36,119 --> 00:45:42,280
use SSV in a m tree style uh um maybe

733
00:45:40,040 --> 00:45:44,960
there is some uh separate Tech size blow

734
00:45:42,280 --> 00:45:48,000
up so each time you yeah so each time

735
00:45:44,960 --> 00:45:50,119
the sear T size is Lambda times larger

736
00:45:48,000 --> 00:45:52,079
and the

737
00:45:50,119 --> 00:45:55,680
yeah this new

738
00:45:52,079 --> 00:45:58,079
version index bar when when we hash the

739
00:45:55,680 --> 00:46:03,079
column yeah we have has it in the mic

740
00:45:58,079 --> 00:46:07,000
side instead of hasing it in one uh

741
00:46:03,079 --> 00:46:09,000
right right you mean we don't has it U

742
00:46:07,000 --> 00:46:11,440
as entirely we we has in the M tree

743
00:46:09,000 --> 00:46:14,040
style yes yes yes yes yes that's where

744
00:46:11,440 --> 00:46:14,040
are what we are

745
00:46:15,800 --> 00:46:19,359
doing okay any

746
00:46:21,440 --> 00:46:26,559
question okay

747
00:46:24,040 --> 00:46:29,119
so uh so if you do this contraction

748
00:46:26,559 --> 00:46:31,760
directly then uh this contraction will

749
00:46:29,119 --> 00:46:33,440
Loop forever because the recursion will

750
00:46:31,760 --> 00:46:35,160
never end so initially we have K

751
00:46:33,440 --> 00:46:38,720
instances and at the next level it still

752
00:46:35,160 --> 00:46:42,280
has K instances so next what we will do

753
00:46:38,720 --> 00:46:44,800
is we will use a two to one trick to

754
00:46:42,280 --> 00:46:48,960
reduce the number of instance each time

755
00:46:44,800 --> 00:46:48,960
so let me

756
00:47:02,079 --> 00:47:08,839
so so let's denote

757
00:47:05,440 --> 00:47:12,200
the so let's denote this circuit so this

758
00:47:08,839 --> 00:47:15,079
part of the circuit as some C

759
00:47:12,200 --> 00:47:18,079
Prime okay some C Prime so C Prime will

760
00:47:15,079 --> 00:47:20,599
take some index I and the widness wi

761
00:47:18,079 --> 00:47:27,800
Prime so the winess wi Prime correspond

762
00:47:20,599 --> 00:47:31,599
to this part so so this part is the uh I

763
00:47:27,800 --> 00:47:34,720
prime okay so the so the two to the one

764
00:47:31,599 --> 00:47:34,720
trick is

765
00:47:40,119 --> 00:47:46,000
this uh suppose you have K instances so

766
00:47:51,200 --> 00:47:57,720
for so now you want to verify all them

767
00:47:54,400 --> 00:48:01,119
uh are so you have in instance from 1

768
00:47:57,720 --> 00:48:03,800
Tok and their winess are W1 Prime to WK

769
00:48:01,119 --> 00:48:06,480
Prime and you want to ensure so the pro

770
00:48:03,800 --> 00:48:09,880
wants to prove to the warier that all of

771
00:48:06,480 --> 00:48:13,280
them are correct are in this language Al

772
00:48:09,880 --> 00:48:15,040
PR okay so what you do

773
00:48:13,280 --> 00:48:19,680
is

774
00:48:15,040 --> 00:48:21,040
uh you look at any two adjacent indices

775
00:48:19,680 --> 00:48:24,160
uh

776
00:48:21,040 --> 00:48:27,760
instances and uh just the

777
00:48:24,160 --> 00:48:30,920
combiner Okay so

778
00:48:27,760 --> 00:48:36,240
so now the combined instance is still

779
00:48:30,920 --> 00:48:39,839
one but it's a uh but the Witnesses are

780
00:48:36,240 --> 00:48:44,400
concatenated together so you have this

781
00:48:39,839 --> 00:48:48,800
uh W1 Prem and W2 Prem and

782
00:48:44,400 --> 00:48:51,599
uh and the next two instance are W are

783
00:48:48,800 --> 00:48:56,440
three and four so you have this three

784
00:48:51,599 --> 00:48:56,440
prime and the W4 Prime

785
00:48:57,000 --> 00:49:05,079
and you the final one is K and the w k

786
00:49:01,040 --> 00:49:07,839
so you combine each adjon one to get to

787
00:49:05,079 --> 00:49:07,839
get the second

788
00:49:09,880 --> 00:49:17,400
instance and you do this for any two two

789
00:49:13,079 --> 00:49:21,319
of them so in the end you have K by two

790
00:49:17,400 --> 00:49:24,000
instances but the cost of doing this is

791
00:49:21,319 --> 00:49:27,720
the size of the winess will blow up by a

792
00:49:24,000 --> 00:49:30,359
factor of two so

793
00:49:27,720 --> 00:49:35,359
okay so so now we obtain so let's say

794
00:49:30,359 --> 00:49:38,799
the original uh language is L Prime so

795
00:49:35,359 --> 00:49:41,760
it contains of I uh such that there

796
00:49:38,799 --> 00:49:41,760
exist w i

797
00:49:42,319 --> 00:49:45,319
Prime

798
00:49:48,400 --> 00:49:55,480
uh so now so c c Prime is the

799
00:49:52,079 --> 00:49:57,720
verification cir of L Prime then then

800
00:49:55,480 --> 00:50:01,480
here the new

801
00:49:57,720 --> 00:50:05,839
instances uh is the following so it

802
00:50:01,480 --> 00:50:09,160
defines a new language Al L double Prim

803
00:50:05,839 --> 00:50:13,839
so double Prim is still contains all I

804
00:50:09,160 --> 00:50:17,280
but it uh the winess are uh 2 I minus

805
00:50:13,839 --> 00:50:20,880
one and the 2 I and the W 2

806
00:50:17,280 --> 00:50:25,200
I uh 2 I

807
00:50:20,880 --> 00:50:27,480
prime so so this is this concatenation

808
00:50:25,200 --> 00:50:30,799
concatenated witness is a new

809
00:50:27,480 --> 00:50:34,720
uh MP winess for this L double and you

810
00:50:30,799 --> 00:50:41,240
need to verify uh C Prime of this uh 2

811
00:50:34,720 --> 00:50:45,960
IUS one W 2 IUS one is one and

812
00:50:41,240 --> 00:50:48,400
also 2 I and 2 I is

813
00:50:45,960 --> 00:50:53,079
one

814
00:50:48,400 --> 00:50:55,319
okay so so by doing this the size of the

815
00:50:53,079 --> 00:50:57,839
the the number of the instance will half

816
00:50:55,319 --> 00:51:03,760
each time when you do the recursion

817
00:50:57,839 --> 00:51:07,160
so so after so right so in fact we will

818
00:51:03,760 --> 00:51:11,160
prove this for L double par and uh and

819
00:51:07,160 --> 00:51:14,200
we only proove for one 2K uh by two they

820
00:51:11,160 --> 00:51:14,200
are all in L double

821
00:51:14,319 --> 00:51:21,280
par yeah in in the recursion yeah so

822
00:51:18,480 --> 00:51:21,280
that's what we all

823
00:51:22,520 --> 00:51:28,920
do okay so so now the question is uh at

824
00:51:26,720 --> 00:51:32,760
the end of the recre

825
00:51:28,920 --> 00:51:35,319
so uh at the end of the recre each time

826
00:51:32,760 --> 00:51:37,280
um so at each level of the recession the

827
00:51:35,319 --> 00:51:39,440
number of instance were half so at the

828
00:51:37,280 --> 00:51:43,119
end there will only be one instance so

829
00:51:39,440 --> 00:51:45,400
what will we do uh at that

830
00:51:43,119 --> 00:51:47,000
point uh anyone

831
00:51:45,400 --> 00:51:50,000
knows

832
00:51:47,000 --> 00:51:52,480
directly yes yes right so we directly

833
00:51:50,000 --> 00:51:54,280
send the witness and the Wii can verify

834
00:51:52,480 --> 00:51:59,079
it

835
00:51:54,280 --> 00:52:02,079
okay so so now let's calculate the

836
00:51:59,079 --> 00:52:06,720
uh so this is the construction and let's

837
00:52:02,079 --> 00:52:06,720
calculate the proof size for this

838
00:52:15,200 --> 00:52:22,640
construction so the so initially um so

839
00:52:19,599 --> 00:52:27,680
initially we send this uh H1

840
00:52:22,640 --> 00:52:28,920
to HL and that cost so so so the size of

841
00:52:27,680 --> 00:52:32,400
that is

842
00:52:28,920 --> 00:52:32,400
uh po

843
00:52:32,880 --> 00:52:40,000
C right uh policy policy and

844
00:52:37,920 --> 00:52:42,319
Lambda and

845
00:52:40,000 --> 00:52:47,200
uh and we have this

846
00:52:42,319 --> 00:52:47,200
Q uh competed by the

847
00:52:47,920 --> 00:52:55,160
S uh but at the next level of the

848
00:52:51,760 --> 00:52:57,640
recursion so so at the next level of the

849
00:52:55,160 --> 00:53:01,000
recursion we will we also have this

850
00:52:57,640 --> 00:53:08,240
first run message for that for

851
00:53:01,000 --> 00:53:12,079
that uh so let's denote it by uh H uh H

852
00:53:08,240 --> 00:53:15,079
Prime so what's the CLE of this message

853
00:53:12,079 --> 00:53:18,720
so remember this is the index bark for L

854
00:53:15,079 --> 00:53:22,160
double PR and it has circuit the

855
00:53:18,720 --> 00:53:22,160
verification circuit C double

856
00:53:24,520 --> 00:53:29,720
print so what is the size of this

857
00:53:32,799 --> 00:53:36,640
message so this is a

858
00:53:40,920 --> 00:53:47,079
efficiency

859
00:53:43,920 --> 00:53:49,880
yes so so in the next level of

860
00:53:47,079 --> 00:53:53,280
verication we all do the same for the

861
00:53:49,880 --> 00:53:55,520
using the same protocol so so originally

862
00:53:53,280 --> 00:53:58,160
the verif the NP verification circuit is

863
00:53:55,520 --> 00:54:00,200
C so we have first R message this much

864
00:53:58,160 --> 00:54:04,760
so in the next level the MP verification

865
00:54:00,200 --> 00:54:11,200
circuit is see double par so so the size

866
00:54:04,760 --> 00:54:15,000
of this message is uh poy cble Prim

867
00:54:11,200 --> 00:54:17,760
Lambda but there is a issue uh if you do

868
00:54:15,000 --> 00:54:20,880
this recursion directly

869
00:54:17,760 --> 00:54:24,319
so so let's exam what is size of C

870
00:54:20,880 --> 00:54:26,920
double PR so C double PR will contain so

871
00:54:24,319 --> 00:54:29,160
each C double PR will contains uh two

872
00:54:26,920 --> 00:54:31,359
copy of c c

873
00:54:29,160 --> 00:54:34,960
Prime right

874
00:54:31,359 --> 00:54:40,000
so so C double

875
00:54:34,960 --> 00:54:43,359
Prime uh oh I should say okay so I right

876
00:54:40,000 --> 00:54:43,359
so I should say this is

877
00:54:44,640 --> 00:54:53,480
the so this is the couble prime so right

878
00:54:49,960 --> 00:54:56,960
so it I'll take index I and this as the

879
00:54:53,480 --> 00:55:01,480
winess and verify these two things so so

880
00:54:56,960 --> 00:55:02,960
the size of the couble Prime is roughly

881
00:55:01,480 --> 00:55:07,119
uh 2 *

882
00:55:02,960 --> 00:55:11,760
C and the so what is the size of C uh C

883
00:55:07,119 --> 00:55:14,880
Prime so the C Prime so C Prime is here

884
00:55:11,760 --> 00:55:17,720
uh so C Prime the first part of the C

885
00:55:14,880 --> 00:55:20,079
Prime is the PCP verification so here we

886
00:55:17,720 --> 00:55:22,119
will have a issue because the because

887
00:55:20,079 --> 00:55:24,359
the PCP verifier need to know what is

888
00:55:22,119 --> 00:55:29,280
the he at Le need to know what is the NP

889
00:55:24,359 --> 00:55:33,359
relation so the PCP verifier runs in C

890
00:55:29,280 --> 00:55:35,920
time right so so the so we all have a

891
00:55:33,359 --> 00:55:35,920
issue here

892
00:55:36,480 --> 00:55:43,240
because because the C Prime is uh

893
00:55:39,799 --> 00:55:47,359
roughly C uh at least

894
00:55:43,240 --> 00:55:50,640
C so if we do this directly so you can

895
00:55:47,359 --> 00:55:53,640
think at the top level we have this poly

896
00:55:50,640 --> 00:55:58,559
C and uh at the next level we have this

897
00:55:53,640 --> 00:56:01,359
poy C Prime which is uh 2 C so so this

898
00:55:58,559 --> 00:56:05,039
is 2 C and at the next level of

899
00:56:01,359 --> 00:56:08,039
recursion we have 4 C so so we have uh

900
00:56:05,039 --> 00:56:10,240
log K level of recursion because each

901
00:56:08,039 --> 00:56:13,680
time the number of instance

902
00:56:10,240 --> 00:56:18,880
half so the number of uh so the depth is

903
00:56:13,680 --> 00:56:22,440
l k so in the end we have K * C which is

904
00:56:18,880 --> 00:56:26,520
large so so the proof will grow with K

905
00:56:22,440 --> 00:56:29,319
time K time C which is large so so the

906
00:56:26,520 --> 00:56:32,160
final idea is uh we are going to use a

907
00:56:29,319 --> 00:56:35,480
PCP uh with some special property so

908
00:56:32,160 --> 00:56:38,160
this this kind of PCP has this uh online

909
00:56:35,480 --> 00:56:40,920
offline verification property so this is

910
00:56:38,160 --> 00:56:44,280
called

911
00:56:40,920 --> 00:56:44,280
PCP with

912
00:56:44,640 --> 00:56:48,119
fast online

913
00:56:51,079 --> 00:56:56,559
verification

914
00:56:52,640 --> 00:57:00,319
so so those PCP uh has the property that

915
00:56:56,559 --> 00:57:03,280
so for any PCP prover and verifier so

916
00:57:00,319 --> 00:57:04,960
given any NP instance X and W you can

917
00:57:03,280 --> 00:57:08,119
generate a long

918
00:57:04,960 --> 00:57:10,720
proof right so so this is just a normal

919
00:57:08,119 --> 00:57:15,280
PCP but the verification algorithm of

920
00:57:10,720 --> 00:57:17,760
the PCP is uh has more structure so the

921
00:57:15,280 --> 00:57:21,760
verification algorithm so originally the

922
00:57:17,760 --> 00:57:23,880
PCP verifier need to verify for x q and

923
00:57:21,760 --> 00:57:27,920
the PCP

924
00:57:23,880 --> 00:57:30,599
Q so so now the PCP verifier uh can be

925
00:57:27,920 --> 00:57:32,920
composed decomposed to two parts so

926
00:57:30,599 --> 00:57:34,920
first uh so there is a offline

927
00:57:32,920 --> 00:57:37,039
pre-processing phase so the

928
00:57:34,920 --> 00:57:38,559
pre-processing phase only depends on the

929
00:57:37,039 --> 00:57:44,319
relation circuit

930
00:57:38,559 --> 00:57:44,319
C okay so this is a PCP for the language

931
00:57:49,839 --> 00:57:57,200
l so the pre-processing phase will take

932
00:57:53,839 --> 00:58:00,400
the relation circuit as input and uh it

933
00:57:57,200 --> 00:58:04,319
will use the query to generate some

934
00:58:00,400 --> 00:58:07,440
State and this state will only grow uh

935
00:58:04,319 --> 00:58:08,400
the size of the state is polinomial in s

936
00:58:07,440 --> 00:58:13,200
in

937
00:58:08,400 --> 00:58:15,920
X so so the point is uh so in some case

938
00:58:13,200 --> 00:58:18,480
when the relation circuit is very

939
00:58:15,920 --> 00:58:20,799
large so the pre-processing phase will

940
00:58:18,480 --> 00:58:23,039
gr well runs in the size of the relation

941
00:58:20,799 --> 00:58:24,760
circuit but it will output of a very

942
00:58:23,039 --> 00:58:28,000
short

943
00:58:24,760 --> 00:58:29,920
State and the uh secondly in the online

944
00:58:28,000 --> 00:58:32,160
phase there is a online verification

945
00:58:29,920 --> 00:58:35,760
part so the online verification will

946
00:58:32,160 --> 00:58:41,079
only used such a short State and the

947
00:58:35,760 --> 00:58:45,400
X and the right and the Q and the PCP

948
00:58:41,079 --> 00:58:48,079
verific uh and the PCP answer to decide

949
00:58:45,400 --> 00:58:51,480
whether to accept or reject so the point

950
00:58:48,079 --> 00:58:54,760
is uh the online verification phase uh

951
00:58:51,480 --> 00:58:57,200
only depends on the so it's a polom Time

952
00:58:54,760 --> 00:59:00,559
algorithm so which means it only depends

953
00:58:57,200 --> 00:59:04,400
on X and the size of

954
00:59:00,559 --> 00:59:07,359
Q okay so so you can imagine if the c c

955
00:59:04,400 --> 00:59:09,760
is the C is a very big circuit and the X

956
00:59:07,359 --> 00:59:12,799
instance is small then this means the

957
00:59:09,760 --> 00:59:14,680
pre-processing phase will uh the

958
00:59:12,799 --> 00:59:16,559
pre-processing phase will take most of

959
00:59:14,680 --> 00:59:18,720
the time but the online verification

960
00:59:16,559 --> 00:59:20,280
will be very fast it only depends on the

961
00:59:18,720 --> 00:59:23,640
instant

962
00:59:20,280 --> 00:59:25,720
size and the S of the query so this this

963
00:59:23,640 --> 00:59:28,960
property is Satisfied by most of the

964
00:59:25,720 --> 00:59:32,000
algeb right construction of PCP

965
00:59:28,960 --> 00:59:34,200
so yeah uh any

966
00:59:32,000 --> 00:59:38,799
questions so I will not go into the

967
00:59:34,200 --> 00:59:41,039
detail because the so it uh so in fact

968
00:59:38,799 --> 00:59:43,319
this property is used in many practical

969
00:59:41,039 --> 00:59:44,839
snug construction because in the

970
00:59:43,319 --> 00:59:48,359
Practical snar construction they also

971
00:59:44,839 --> 00:59:51,440
need to use PCP or some form of the PCP

972
00:59:48,359 --> 00:59:53,039
such as linear PCP so in those

973
00:59:51,440 --> 00:59:55,280
construction you also have the problem

974
00:59:53,039 --> 00:59:57,400
that the relation circuit is very large

975
00:59:55,280 --> 00:59:59,280
but you want the ification to be small

976
00:59:57,400 --> 01:00:02,000
so what they do is they can do some

977
00:59:59,280 --> 01:00:04,599
pre-processing on the relation uh to

978
01:00:02,000 --> 01:00:06,119
generate some short verification State

979
01:00:04,599 --> 01:00:09,680
and given the verification State you can

980
01:00:06,119 --> 01:00:11,760
verify the statement in a short

981
01:00:09,680 --> 01:00:16,720
time

982
01:00:11,760 --> 01:00:21,720
okay so so so now we will use this uh

983
01:00:16,720 --> 01:00:24,680
PCP with this uh uh this uh

984
01:00:21,720 --> 01:00:27,960
further with this uh property and uh

985
01:00:24,680 --> 01:00:27,960
then we can

986
01:00:28,720 --> 01:00:34,960
so then we can further modify the

987
01:00:31,520 --> 01:00:37,400
construction to to only do the online

988
01:00:34,960 --> 01:00:41,520
verification here in C

989
01:00:37,400 --> 01:00:41,520
plan okay

990
01:00:43,670 --> 01:00:46,760
[Applause]

991
01:00:51,280 --> 01:00:56,839
so so what we will do here is uh we

992
01:00:54,200 --> 01:00:59,480
first generate the s

993
01:00:56,839 --> 01:01:01,799
using the S to generate que and then we

994
01:00:59,480 --> 01:01:04,839
do the pre-processing to this queue uh

995
01:01:01,799 --> 01:01:04,839
to generate some short

996
01:01:05,520 --> 01:01:11,960
State and this will use the relation

997
01:01:08,520 --> 01:01:14,640
circuit C so we can do this because uh

998
01:01:11,960 --> 01:01:20,720
we use the same PCP query for all of the

999
01:01:14,640 --> 01:01:22,400
uh PCP pcps so right so so is for all of

1000
01:01:20,720 --> 01:01:26,960
the PCP they are using the same PCP

1001
01:01:22,400 --> 01:01:26,960
query so I can do this pre-processing

1002
01:01:29,400 --> 01:01:33,880
so once I have this state I this short

1003
01:01:31,640 --> 01:01:37,480
State I can hard code it in this

1004
01:01:33,880 --> 01:01:38,920
construction of C Prime so I I replace

1005
01:01:37,480 --> 01:01:45,440
this with the

1006
01:01:38,920 --> 01:01:48,039
online oh sorry so this is a local where

1007
01:01:45,440 --> 01:01:50,319
verification so this online verification

1008
01:01:48,039 --> 01:01:50,319
of the

1009
01:01:52,279 --> 01:01:58,400
PCP so it will take the state and all

1010
01:01:56,920 --> 01:02:01,359
the

1011
01:01:58,400 --> 01:02:04,240
rest so now this will solve this

1012
01:02:01,359 --> 01:02:07,359
recursion issue because the because now

1013
01:02:04,240 --> 01:02:12,079
the circuit C Prime will will not

1014
01:02:07,359 --> 01:02:12,079
depends on C instead it will be poog in

1015
01:02:13,119 --> 01:02:21,279
C the reason is that so here uh you so

1016
01:02:17,880 --> 01:02:22,720
you can check here because the C world

1017
01:02:21,279 --> 01:02:25,880
uh it will only involve online

1018
01:02:22,720 --> 01:02:27,559
verification so it only so it's uh part

1019
01:02:25,880 --> 01:02:32,319
IAL of

1020
01:02:27,559 --> 01:02:36,520
the is a polom in the lens of I which is

1021
01:02:32,319 --> 01:02:36,520
log K and the

1022
01:02:36,599 --> 01:02:42,440
yeah uh right and and the and the local

1023
01:02:39,880 --> 01:02:46,240
appication of the merco has is also

1024
01:02:42,440 --> 01:02:48,480
small so it's also po some poog in K so

1025
01:02:46,240 --> 01:02:51,680
that you can check is

1026
01:02:48,480 --> 01:02:56,760
a so this is

1027
01:02:51,680 --> 01:02:58,640
poog log K and Lambda and then you can

1028
01:02:56,760 --> 01:03:02,400
you can take this recreation in inside

1029
01:02:58,640 --> 01:03:05,680
of this uh analysis and see uh finally

1030
01:03:02,400 --> 01:03:08,799
the proof size is only poly

1031
01:03:05,680 --> 01:03:11,039
loging so the proof size is the total

1032
01:03:08,799 --> 01:03:14,359
proof size is

1033
01:03:11,039 --> 01:03:18,319
uh poog

1034
01:03:14,359 --> 01:03:21,520
in in C and the poog in

1035
01:03:18,319 --> 01:03:21,520
K and

1036
01:03:22,799 --> 01:03:27,760
polyda yeah

1037
01:03:26,079 --> 01:03:30,359
oh I

1038
01:03:27,760 --> 01:03:35,160
guess the

1039
01:03:30,359 --> 01:03:38,480
Bas yes yes so the so the so in fact

1040
01:03:35,160 --> 01:03:40,720
after you do this once so at one level

1041
01:03:38,480 --> 01:03:43,000
of the recre the witness is already very

1042
01:03:40,720 --> 01:03:45,880
small so because the witness is just

1043
01:03:43,000 --> 01:03:50,119
it's just the PCP opening so it's poly

1044
01:03:45,880 --> 01:03:54,880
loogy so finally the at the end the

1045
01:03:50,119 --> 01:03:54,880
final level winess is also very small

1046
01:04:05,440 --> 01:04:09,680
so I I don't I probably don't have time

1047
01:04:07,440 --> 01:04:11,839
to cover all the security proof but I

1048
01:04:09,680 --> 01:04:14,839
will show you the most important part of

1049
01:04:11,839 --> 01:04:14,839
it and

1050
01:04:15,799 --> 01:04:22,240
uh so the so the so how do we prove the

1051
01:04:20,000 --> 01:04:24,279
security of this

1052
01:04:22,240 --> 01:04:26,799
construction so so now the construction

1053
01:04:24,279 --> 01:04:29,920
is here so

1054
01:04:26,799 --> 01:04:32,279
to prove the security it's natural to

1055
01:04:29,920 --> 01:04:34,880
use the so suppose we have some security

1056
01:04:32,279 --> 01:04:36,520
of this uh index bar then maybe we can

1057
01:04:34,880 --> 01:04:37,559
use it recursively to prove the security

1058
01:04:36,520 --> 01:04:40,480
of the entire

1059
01:04:37,559 --> 01:04:44,440
construction but uh but we have a issue

1060
01:04:40,480 --> 01:04:47,319
here so isue is L double Prim it all

1061
01:04:44,440 --> 01:04:51,480
depends on the first

1062
01:04:47,319 --> 01:04:55,200
message because the so L Prim will use

1063
01:04:51,480 --> 01:04:58,319
this L PR so this C so this c will

1064
01:04:55,200 --> 01:05:00,960
depend well use the hash root this HQ so

1065
01:04:58,319 --> 01:05:04,039
this H root come comes from this hash

1066
01:05:00,960 --> 01:05:09,160
this hash value and of the h12

1067
01:05:04,039 --> 01:05:12,079
HL so so this means the adversary can

1068
01:05:09,160 --> 01:05:15,200
potentially choose this uh uh choose the

1069
01:05:12,079 --> 01:05:18,640
next statement depends on the CRS

1070
01:05:15,200 --> 01:05:20,599
because CRS is first cud anniversary so

1071
01:05:18,640 --> 01:05:22,680
this is not captured by the nonadaptive

1072
01:05:20,599 --> 01:05:26,160
sound soundness before so we need a new

1073
01:05:22,680 --> 01:05:26,160
definition of soundness

1074
01:05:37,920 --> 01:05:42,240
and the issue is that we don't know how

1075
01:05:39,559 --> 01:05:44,119
to achieve fully adaptive soundness so

1076
01:05:42,240 --> 01:05:45,920
the Adaptive soundness means that the

1077
01:05:44,119 --> 01:05:50,039
cheating adversary can choose the

1078
01:05:45,920 --> 01:05:52,279
instance depending on the CRS and the so

1079
01:05:50,039 --> 01:05:55,680
what we what we prove is some semi

1080
01:05:52,279 --> 01:05:55,680
adaptive soundness

1081
01:06:03,880 --> 01:06:08,880
so this this s this notion is not only

1082
01:06:06,760 --> 01:06:11,440
important in this security proof it will

1083
01:06:08,880 --> 01:06:15,039
also be crucial for your next lecture so

1084
01:06:11,440 --> 01:06:16,799
when you compile this uh batch index to

1085
01:06:15,039 --> 01:06:18,720
of snar 4

1086
01:06:16,799 --> 01:06:22,480
P

1087
01:06:18,720 --> 01:06:24,319
so so it defin as follows so it says

1088
01:06:22,480 --> 01:06:26,760
that so it allows the cheating improver

1089
01:06:24,319 --> 01:06:29,480
to choose the relation Circ

1090
01:06:26,760 --> 01:06:31,920
uh but it cannot choose which uh index

1091
01:06:29,480 --> 01:06:36,760
to cheat

1092
01:06:31,920 --> 01:06:36,760
so so let me Define it so we

1093
01:06:42,079 --> 01:06:45,079
say

1094
01:06:45,240 --> 01:06:50,279
uh uh index spk is

1095
01:06:59,319 --> 01:07:06,440
sound if there

1096
01:07:01,599 --> 01:07:09,559
exist if so first I need a another uh

1097
01:07:06,440 --> 01:07:13,920
key generation algorithm uh CRS

1098
01:07:09,559 --> 01:07:17,400
generator so I'll call it uh generate

1099
01:07:13,920 --> 01:07:20,039
bar so it will take

1100
01:07:17,400 --> 01:07:24,279
the security parameter as input and

1101
01:07:20,039 --> 01:07:28,680
index I star and will generate some s

1102
01:07:24,279 --> 01:07:28,680
star okay and uh I

1103
01:07:32,240 --> 01:07:39,000
require and this uh

1104
01:07:35,200 --> 01:07:40,720
CRS uh generator is IND distinguishable

1105
01:07:39,000 --> 01:07:44,680
with

1106
01:07:40,720 --> 01:07:44,680
the real uh

1107
01:07:45,720 --> 01:07:53,760
CRS and furthermore uh for each uh

1108
01:07:51,200 --> 01:07:56,440
nonuniform PBT adversary cheating

1109
01:07:53,760 --> 01:07:58,799
improver P star we need to have the

1110
01:07:56,440 --> 01:07:58,799
following

1111
01:07:59,240 --> 01:08:04,240
property

1112
01:08:00,960 --> 01:08:04,240
so P

1113
01:08:05,079 --> 01:08:10,319
star when P star received the CRS

1114
01:08:08,440 --> 01:08:15,119
generated by

1115
01:08:10,319 --> 01:08:15,119
the by this this generator

1116
01:08:17,279 --> 01:08:24,799
star uh it can choose as relation

1117
01:08:20,239 --> 01:08:28,480
circuit c and a maliciously chosen

1118
01:08:24,799 --> 01:08:28,480
relation circuit C and a p

1119
01:08:29,400 --> 01:08:39,880
star such that uh the probability that

1120
01:08:34,400 --> 01:08:39,880
the wirefire uh accept for this

1121
01:08:41,000 --> 01:08:44,319
uh this

1122
01:08:45,520 --> 01:08:52,839
K and the the is instance uh the I Stars

1123
01:08:49,640 --> 01:08:54,440
instance is not in the relation circuit

1124
01:08:52,839 --> 01:08:58,440
defined by

1125
01:08:54,440 --> 01:08:58,440
this C star is

1126
01:09:05,759 --> 01:09:08,759
negligible

1127
01:09:12,520 --> 01:09:20,120
so yes uh so the intution is that so

1128
01:09:16,839 --> 01:09:22,279
suppose uh the intution is that the SSB

1129
01:09:20,120 --> 01:09:25,920
is binding for some location for some

1130
01:09:22,279 --> 01:09:28,640
for some instance so you just set the uh

1131
01:09:25,920 --> 01:09:31,600
generator bar as the generator that

1132
01:09:28,640 --> 01:09:33,640
output that kind of SSB so SSB will be

1133
01:09:31,600 --> 01:09:36,640
binding for the iar position then you

1134
01:09:33,640 --> 01:09:40,279
cannot cheat for the is IP instance but

1135
01:09:36,640 --> 01:09:43,400
you do uh you do have the option to so

1136
01:09:40,279 --> 01:09:46,640
cheat improver can choose a different

1137
01:09:43,400 --> 01:09:49,719
circuit relation circuit C but it cannot

1138
01:09:46,640 --> 01:09:54,320
cheat for those uh D starts

1139
01:09:49,719 --> 01:09:58,000
position uh right so that's

1140
01:09:54,320 --> 01:09:59,719
uh that's a semi adaptive sness so to

1141
01:09:58,000 --> 01:10:02,880
prove this uh sness for this

1142
01:09:59,719 --> 01:10:05,520
construction the idea is that uh so for

1143
01:10:02,880 --> 01:10:09,040
any for any I star that is not in the

1144
01:10:05,520 --> 01:10:11,719
language so you can you can see uh so

1145
01:10:09,040 --> 01:10:13,679
from the correlation intractability so

1146
01:10:11,719 --> 01:10:16,520
so essentially the idea is that if I

1147
01:10:13,679 --> 01:10:19,120
star is not in the language and uh for

1148
01:10:16,520 --> 01:10:19,120
any cheating

1149
01:10:20,520 --> 01:10:29,120
proof uh right so you just uh switch

1150
01:10:24,880 --> 01:10:33,679
this uh generat bar to for this

1151
01:10:29,120 --> 01:10:37,199
iar and uh and you can argue if iar is

1152
01:10:33,679 --> 01:10:40,440
not in the language then I star over

1153
01:10:37,199 --> 01:10:43,080
two so because we do the two2 one trick

1154
01:10:40,440 --> 01:10:46,719
so it will translate to a new instance

1155
01:10:43,080 --> 01:10:46,719
at the next level

1156
01:10:47,960 --> 01:10:55,880
then it's also in not in this it's not

1157
01:10:52,480 --> 01:10:57,800
it's also not in the out dou PR so if

1158
01:10:55,880 --> 01:11:03,800
the if the allary doesn't cheat for the

1159
01:10:57,800 --> 01:11:03,800
CR so that's the idea so that means

1160
01:11:06,600 --> 01:11:10,080
the so for

1161
01:11:14,120 --> 01:11:23,840
any so so if it's not in the

1162
01:11:19,360 --> 01:11:27,120
yeah so if the if the if the query and

1163
01:11:23,840 --> 01:11:32,080
the hash values out by the chover does

1164
01:11:27,120 --> 01:11:33,360
not uh satisfy the the say relation R

1165
01:11:32,080 --> 01:11:37,639
then you have

1166
01:11:33,360 --> 01:11:40,800
this then if the I star I star position

1167
01:11:37,639 --> 01:11:42,880
is force then it translate to a another

1168
01:11:40,800 --> 01:11:46,960
new Force State

1169
01:11:42,880 --> 01:11:50,040
statements so you can so you can you can

1170
01:11:46,960 --> 01:11:52,560
use this uh claim to uh inductively

1171
01:11:50,040 --> 01:11:56,360
argue that uh initially if you have some

1172
01:11:52,560 --> 01:11:59,280
fixed iar then you can track C this uh

1173
01:11:56,360 --> 01:12:01,840
fixed I at each level by divide by two

1174
01:11:59,280 --> 01:12:05,000
and run up to it and finally you can

1175
01:12:01,840 --> 01:12:07,960
catch it because the last so the last

1176
01:12:05,000 --> 01:12:10,520
statement uh so in the in the last lbel

1177
01:12:07,960 --> 01:12:14,840
of the recursion we just send all the

1178
01:12:10,520 --> 01:12:19,360
witness so you must be able to catch it

1179
01:12:14,840 --> 01:12:21,199
so that's a idea okay so that's uh uh

1180
01:12:19,360 --> 01:12:27,159
that's all about

1181
01:12:21,199 --> 01:12:27,159
the class today yeah uh any questions

1182
01:12:38,639 --> 01:12:42,120
Construction

1183
01:12:40,159 --> 01:12:45,120
Construction sort of any sort of

1184
01:12:42,120 --> 01:12:46,880
adaptive soundness or is it like yes so

1185
01:12:45,120 --> 01:12:49,560
it only get this kind of adaptive

1186
01:12:46,880 --> 01:12:54,040
soundness I see like some notion of

1187
01:12:49,560 --> 01:12:56,239
this index oh so for the uh so for the

1188
01:12:54,040 --> 01:12:58,679
index bark we kind get a semi adap on

1189
01:12:56,239 --> 01:13:00,239
this and for General

1190
01:12:58,679 --> 01:13:03,520
barks

1191
01:13:00,239 --> 01:13:07,600
uh I need to uh I think it's also yeah

1192
01:13:03,520 --> 01:13:07,600
it also have some similar lotion meths I

1193
01:13:13,120 --> 01:13:19,360
think can you that like is there some

1194
01:13:15,560 --> 01:13:21,639
other construction ad or is very uh

1195
01:13:19,360 --> 01:13:23,480
that's a good question so so in general

1196
01:13:21,639 --> 01:13:26,360
so given any non-adaptive sound snark

1197
01:13:23,480 --> 01:13:29,840
you can always upgrade it to adoptive s

1198
01:13:26,360 --> 01:13:33,679
by using complexity leveraging so but

1199
01:13:29,840 --> 01:13:37,320
you are pay uh due to the instant size

1200
01:13:33,679 --> 01:13:42,360
in the security proof so but in the

1201
01:13:37,320 --> 01:13:44,199
barks uh if you the two so if you to the

1202
01:13:42,360 --> 01:13:48,320
uh the instant total instance size is K

1203
01:13:44,199 --> 01:13:51,639
times x so it's very large so yeah I'm

1204
01:13:48,320 --> 01:13:54,280
not sure you can really do that I see is

1205
01:13:51,639 --> 01:13:57,679
it clear PR that like only applies to

1206
01:13:54,280 --> 01:13:59,840
adap oh right so right right so there

1207
01:13:57,679 --> 01:14:03,280
seems to be a gap but I'm not sure how

1208
01:13:59,840 --> 01:14:05,440
how large is the gap so yeah so maybe

1209
01:14:03,280 --> 01:14:08,600
there's some maybe you can use it on

1210
01:14:05,440 --> 01:14:13,199
clber complexity leveraging to almost

1211
01:14:08,600 --> 01:14:13,199
close gap for example

