1
00:00:12,759 --> 00:00:17,000
yes of course if we argue if we want to

2
00:00:15,000 --> 00:00:18,600
prove to him that X is in the language

3
00:00:17,000 --> 00:00:21,720
it's essentially we're saying telling

4
00:00:18,600 --> 00:00:24,400
him if you evaluate X on circuit C

5
00:00:21,720 --> 00:00:26,800
you'll get one or maybe if there exists

6
00:00:24,400 --> 00:00:28,320
a witness of that c of the witness c and

7
00:00:26,800 --> 00:00:30,080
x and the witness gives you one of

8
00:00:28,320 --> 00:00:32,880
course we assume the verifier knows

9
00:00:30,080 --> 00:00:35,000
description of this circuit C and

10
00:00:32,880 --> 00:00:38,000
usually and for our purposes you think

11
00:00:35,000 --> 00:00:40,879
of C as being a uniform like a a tring

12
00:00:38,000 --> 00:00:42,120
machine okay so it's a it can be

13
00:00:40,879 --> 00:00:44,039
generated efficiently from a training

14
00:00:42,120 --> 00:00:46,039
machine but yes the verifier can

15
00:00:44,039 --> 00:00:48,640
generate can both the prover and

16
00:00:46,039 --> 00:00:52,440
verifier can generate the circuit that's

17
00:00:48,640 --> 00:00:54,199
uh so if you think of three s you know

18
00:00:52,440 --> 00:00:57,079
the circuit is takes input all the

19
00:00:54,199 --> 00:01:00,559
assignments and it checks that all the

20
00:00:57,079 --> 00:01:02,960
uh uh Clauses are satisfied

21
00:01:00,559 --> 00:01:08,680
that's an example of circuit

22
00:01:02,960 --> 00:01:11,080
yeah is that simar to running

23
00:01:08,680 --> 00:01:12,920
that yeah it's like just yeah so so the

24
00:01:11,080 --> 00:01:15,560
prover essentially computes the circuit

25
00:01:12,920 --> 00:01:18,840
all the gates in the circuit hashes it

26
00:01:15,560 --> 00:01:21,759
and then gives a bar that each and every

27
00:01:18,840 --> 00:01:25,400
gate of the circuit is satisfied that

28
00:01:21,759 --> 00:01:30,159
the value he hased satisfy

29
00:01:25,400 --> 00:01:30,159
each uh respect each gate

30
00:01:42,520 --> 00:01:47,280
because okay so the verifier doesn't

31
00:01:45,240 --> 00:01:49,680
know all these values all these bits

32
00:01:47,280 --> 00:01:52,360
he's getting just the the the verifier

33
00:01:49,680 --> 00:01:54,560
only knows the hash he gets only V he

34
00:01:52,360 --> 00:01:56,360
doesn't know all these things he and he

35
00:01:54,560 --> 00:01:59,079
can't it's there too many of them he

36
00:01:56,360 --> 00:02:00,840
doesn't he he can he knows what the

37
00:01:59,079 --> 00:02:02,079
circuit is but he doesn't run in time

38
00:02:00,840 --> 00:02:04,200
that depends on the circuit the circuit

39
00:02:02,079 --> 00:02:06,159
is too big he just kind of knows in his

40
00:02:04,200 --> 00:02:08,520
head how to generate each gate in the

41
00:02:06,159 --> 00:02:11,720
circuit but he can't uh so he doesn't

42
00:02:08,520 --> 00:02:15,560
know these bits all he knows is the hash

43
00:02:11,720 --> 00:02:17,599
value and the bar which is

44
00:02:15,560 --> 00:02:20,239
succinct

45
00:02:17,599 --> 00:02:22,959
okay any yeah security is going to give

46
00:02:20,239 --> 00:02:25,959
us some lower bound on L right it just

47
00:02:22,959 --> 00:02:27,959
happens a lower bound on what on L and L

48
00:02:25,959 --> 00:02:29,080
yes yeah okay yeah we're going to yeah

49
00:02:27,959 --> 00:02:30,840
yeah yeah we're going to talk now we're

50
00:02:29,080 --> 00:02:32,680
going to talk about sec a soundness so

51
00:02:30,840 --> 00:02:35,840
we'll see uh one thing I want to say

52
00:02:32,680 --> 00:02:39,920
before we we jump to soundness Just note

53
00:02:35,840 --> 00:02:42,040
because I said uh the CRS of the bar

54
00:02:39,920 --> 00:02:44,680
it's we generated with security

55
00:02:42,040 --> 00:02:46,360
parameter Lambda K which is the number

56
00:02:44,680 --> 00:02:48,360
of gates and then I said n Prime we'll

57
00:02:46,360 --> 00:02:50,800
see we'll see what n Prime is I just I

58
00:02:48,360 --> 00:02:53,200
forgot to this is n Prime it's just

59
00:02:50,800 --> 00:02:55,599
security parameter it's like the length

60
00:02:53,200 --> 00:02:57,800
of not n Prime will be the length of the

61
00:02:55,599 --> 00:03:02,599
hash key the length of V which grows

62
00:02:57,800 --> 00:03:03,840
with L and J that's kind of the N Prime

63
00:03:02,599 --> 00:03:06,319
I I'm just mentioning it because I

64
00:03:03,840 --> 00:03:09,440
forgot to Circle back to

65
00:03:06,319 --> 00:03:11,200
it okay are you ready to talk about

66
00:03:09,440 --> 00:03:14,519
analyzing this because that's actually

67
00:03:11,200 --> 00:03:17,519
the very interesting part okay so let's

68
00:03:14,519 --> 00:03:17,519
analyze

69
00:03:18,560 --> 00:03:23,680
a so okay we need to argue completeness

70
00:03:22,840 --> 00:03:25,599
and

71
00:03:23,680 --> 00:03:26,959
soundness completeness I don't want to

72
00:03:25,599 --> 00:03:28,400
waste our time because it's just trivial

73
00:03:26,959 --> 00:03:30,400
it just completeness just follows from

74
00:03:28,400 --> 00:03:33,439
the completeness of the bar and

75
00:03:30,400 --> 00:03:36,159
completeness of of the summer

76
00:03:33,439 --> 00:03:38,640
extractible hash okay so essentially if

77
00:03:36,159 --> 00:03:41,200
you're honest if x is in the language

78
00:03:38,640 --> 00:03:45,000
you compute all the wires

79
00:03:41,200 --> 00:03:46,959
correctly uh you hashed all the wires

80
00:03:45,000 --> 00:03:50,040
and you g if you hated all the wires

81
00:03:46,959 --> 00:03:51,560
correctly then you have a valid witness

82
00:03:50,040 --> 00:03:54,439
for all the wires so your bug will be

83
00:03:51,560 --> 00:03:55,680
accepted if you did everything correctly

84
00:03:54,439 --> 00:03:57,280
everything is going to be accepted

85
00:03:55,680 --> 00:03:58,959
because the completeness of the

86
00:03:57,280 --> 00:04:00,840
underlying primitive okay there's

87
00:03:58,959 --> 00:04:03,760
nothing interesting going on the

88
00:04:00,840 --> 00:04:05,720
interesting part is soundness okay so

89
00:04:03,760 --> 00:04:08,280
how do we know you cannot

90
00:04:05,720 --> 00:04:12,159
cheat

91
00:04:08,280 --> 00:04:15,000
and let me even jump and tell

92
00:04:12,159 --> 00:04:18,000
you this thing is not really

93
00:04:15,000 --> 00:04:18,000
sound

94
00:04:18,680 --> 00:04:23,560
but but we'll make it

95
00:04:20,799 --> 00:04:26,040
sound uh okay so let me okay so what do

96
00:04:23,560 --> 00:04:29,240
we know so sound this so what do we want

97
00:04:26,040 --> 00:04:29,240
to prove

98
00:04:33,320 --> 00:04:37,199
let's hope let's try to hope for so

99
00:04:35,240 --> 00:04:39,120
again there's non-adaptive and adaptive

100
00:04:37,199 --> 00:04:40,560
you can think of both but let's talk

101
00:04:39,120 --> 00:04:43,479
about what does it mean to be let's say

102
00:04:40,560 --> 00:04:49,160
adaptively sound so we need to prove

103
00:04:43,479 --> 00:04:52,360
that for any polinomial size cheating

104
00:04:49,160 --> 00:04:55,880
prover we want to say the

105
00:04:52,360 --> 00:04:59,440
probability that P star takes a

106
00:04:55,880 --> 00:05:03,160
CRS of the bar of the as snar so hash

107
00:04:59,440 --> 00:05:07,400
and CRS for the VAR okay takes the CRS

108
00:05:03,160 --> 00:05:11,080
it outputs some X and

109
00:05:07,400 --> 00:05:15,960
Pi such that X is not in the

110
00:05:11,080 --> 00:05:23,000
language and Pi the the snar is

111
00:05:15,960 --> 00:05:27,759
satisfied V on CRS x Pi outputs

112
00:05:23,000 --> 00:05:27,759
one you want to say that this is

113
00:05:28,400 --> 00:05:33,880
negligible that's we need to prove okay

114
00:05:31,479 --> 00:05:34,720
the probability that a cheating prover

115
00:05:33,880 --> 00:05:37,360
gets a

116
00:05:34,720 --> 00:05:39,840
CRS and generates any ex that's not in

117
00:05:37,360 --> 00:05:42,199
the language and a

118
00:05:39,840 --> 00:05:44,759
proof that's

119
00:05:42,199 --> 00:05:46,560
accepted you can't do that okay you can

120
00:05:44,759 --> 00:05:49,800
do that only with neg

121
00:05:46,560 --> 00:05:53,440
probability let me just mention another

122
00:05:49,800 --> 00:05:56,120
uh more uh a weaker definition is the

123
00:05:53,440 --> 00:05:58,800
non Adept which says for any p and for

124
00:05:56,120 --> 00:06:00,319
every X not so he gives X ahead of time

125
00:05:58,800 --> 00:06:03,240
for any P star

126
00:06:00,319 --> 00:06:05,240
and for any X not in the language when

127
00:06:03,240 --> 00:06:08,360
he gets a random CRS the probability

128
00:06:05,240 --> 00:06:11,039
that he manages to generate a fake proof

129
00:06:08,360 --> 00:06:12,759
that's accepted is negligible so there's

130
00:06:11,039 --> 00:06:17,319
two variants one one he needs to choose

131
00:06:12,759 --> 00:06:19,280
the X a given X for all the crs's or he

132
00:06:17,319 --> 00:06:21,400
can choose an X depending on the

133
00:06:19,280 --> 00:06:23,120
CRS let's talk about the Adaptive

134
00:06:21,400 --> 00:06:27,560
because it's just uh stronger and we can

135
00:06:23,120 --> 00:06:29,880
get it okay at least in some cases so

136
00:06:27,560 --> 00:06:31,440
today the snars in the literature some

137
00:06:29,880 --> 00:06:35,680
achieve adaptive some achieve

138
00:06:31,440 --> 00:06:38,080
nonadaptive and in general the the ones

139
00:06:35,680 --> 00:06:40,840
for the teristic computations are

140
00:06:38,080 --> 00:06:42,880
adaptive the one for nistic computations

141
00:06:40,840 --> 00:06:46,639
are more on the non-adaptive side and we

142
00:06:42,880 --> 00:06:48,400
don't have SN NP so at the end of the

143
00:06:46,639 --> 00:06:50,919
talk at the end of the class I'll leave

144
00:06:48,400 --> 00:06:52,639
kind of like 10 minutes to talk about

145
00:06:50,919 --> 00:06:55,759
kind of where we're standing as a

146
00:06:52,639 --> 00:06:57,240
community but um but both of them are

147
00:06:55,759 --> 00:06:59,120
kind of both definitions are relevant

148
00:06:57,240 --> 00:07:01,240
and we have results in both settings

149
00:06:59,120 --> 00:07:05,120
that adap in the non-adaptive but let's

150
00:07:01,240 --> 00:07:09,280
talk today uh on the Adaptive setting

151
00:07:05,120 --> 00:07:11,360
okay so that's what we want but the

152
00:07:09,280 --> 00:07:14,080
question do we get this so let's try to

153
00:07:11,360 --> 00:07:18,080
see what this construction actually

154
00:07:14,080 --> 00:07:20,879
gives us okay so what I'm going to argue

155
00:07:18,080 --> 00:07:24,280
is actually this construction does not

156
00:07:20,879 --> 00:07:28,879
give us soundness it doesn't give us

157
00:07:24,280 --> 00:07:31,400
what it gives us is kind of a a form of

158
00:07:28,879 --> 00:07:33,520
local soundness so I'll explain what

159
00:07:31,400 --> 00:07:36,240
this means so what I'm going to argue is

160
00:07:33,520 --> 00:07:36,240
that so

161
00:07:37,479 --> 00:07:45,440
claim the snar that I just

162
00:07:41,039 --> 00:07:47,199
constructed is let me call it

163
00:07:45,440 --> 00:07:50,919
locally

164
00:07:47,199 --> 00:07:53,240
sound or locally consistent it's also

165
00:07:50,919 --> 00:07:57,080
people call locally

166
00:07:53,240 --> 00:08:00,000
consistent and I'll explain what it

167
00:07:57,080 --> 00:08:01,879
is okay we want to prove something so

168
00:08:00,000 --> 00:08:03,680
what do we want to prove we want to

169
00:08:01,879 --> 00:08:06,960
prove

170
00:08:03,680 --> 00:08:08,840
that this nnar if you manage to say that

171
00:08:06,960 --> 00:08:10,240
the output is one there's actually an

172
00:08:08,840 --> 00:08:13,280
assignment to all the wires that give

173
00:08:10,240 --> 00:08:15,720
you one that means it's

174
00:08:13,280 --> 00:08:18,280
sound we can't prove

175
00:08:15,720 --> 00:08:22,159
that what can we

176
00:08:18,280 --> 00:08:23,680
prove we can prove that if you argue

177
00:08:22,159 --> 00:08:28,240
that the value is

178
00:08:23,680 --> 00:08:33,080
one I can use you to extract the value

179
00:08:28,240 --> 00:08:36,599
of any small set of wires how many l so

180
00:08:33,080 --> 00:08:38,719
remember our snar we're binding on

181
00:08:36,599 --> 00:08:41,919
allocations these allocation I can

182
00:08:38,719 --> 00:08:45,240
extract you gave me a v that's binding

183
00:08:41,919 --> 00:08:47,560
allocation I can extract I can get from

184
00:08:45,240 --> 00:08:51,320
you the L wire

185
00:08:47,560 --> 00:08:53,680
values so I get L wire's values from you

186
00:08:51,320 --> 00:08:56,760
what I can argue about these L wire

187
00:08:53,680 --> 00:09:00,040
values is that locally they're

188
00:08:56,760 --> 00:09:02,440
consistent so if there's a gate if if I

189
00:09:00,040 --> 00:09:05,040
if the l y vales three of them are

190
00:09:02,440 --> 00:09:06,399
connected with a gate I can argue that

191
00:09:05,040 --> 00:09:09,120
this gate is

192
00:09:06,399 --> 00:09:11,920
satisfied so I can argue this form with

193
00:09:09,120 --> 00:09:11,920
local

194
00:09:12,000 --> 00:09:16,560
consistency so I'm going to Define what

195
00:09:13,959 --> 00:09:19,959
local consistency is but just kind of

196
00:09:16,560 --> 00:09:23,600
high level what I can argue is not that

197
00:09:19,959 --> 00:09:25,560
I have a uh assignment of all the wires

198
00:09:23,600 --> 00:09:27,880
that kind of are consistent inside the

199
00:09:25,560 --> 00:09:29,920
output is is one which is what I want to

200
00:09:27,880 --> 00:09:33,040
argue I can argue that I have an

201
00:09:29,920 --> 00:09:35,959
assignment that I can kind of have a

202
00:09:33,040 --> 00:09:39,320
small window to the wires a window of

203
00:09:35,959 --> 00:09:41,120
size l so I can look at these L wires

204
00:09:39,320 --> 00:09:42,399
and they look consistent and I can look

205
00:09:41,120 --> 00:09:44,760
at these L wires and they look

206
00:09:42,399 --> 00:09:47,720
consistent and output is

207
00:09:44,760 --> 00:09:49,399
one so it seems like okay local now

208
00:09:47,720 --> 00:09:50,600
let's we only need to stitch all them

209
00:09:49,399 --> 00:09:53,519
together to get kind of a final

210
00:09:50,600 --> 00:09:54,800
assignment and we're done so the goal is

211
00:09:53,519 --> 00:09:57,440
we're going to say locally we're

212
00:09:54,800 --> 00:09:59,640
consistent and local consistency implies

213
00:09:57,440 --> 00:10:01,160
kind of global consistency and so we get

214
00:09:59,640 --> 00:10:04,560
to

215
00:10:01,160 --> 00:10:06,839
this okay so the plan we are going to

216
00:10:04,560 --> 00:10:09,079
prove local consistency so that's check

217
00:10:06,839 --> 00:10:12,399
and we're going to Define it and prove

218
00:10:09,079 --> 00:10:15,320
it the local consistency ples

219
00:10:12,399 --> 00:10:18,040
Global that turns out to be much more

220
00:10:15,320 --> 00:10:19,680
difficult than we thought so when we

221
00:10:18,040 --> 00:10:22,200
started working on this we're like oh

222
00:10:19,680 --> 00:10:23,800
local consistency yeah shouldn't PL glob

223
00:10:22,200 --> 00:10:25,600
that should be good so we worked really

224
00:10:23,800 --> 00:10:27,519
hard local local and then turns out

225
00:10:25,600 --> 00:10:29,800
local to Global was another 10 years of

226
00:10:27,519 --> 00:10:33,640
work and we're still we're in progress

227
00:10:29,800 --> 00:10:35,240
in progress so so that's what so what

228
00:10:33,640 --> 00:10:37,399
we're going to see today is how to get

229
00:10:35,240 --> 00:10:39,480
local consistency we're going to talk a

230
00:10:37,399 --> 00:10:42,720
little bit about why local implies

231
00:10:39,480 --> 00:10:44,800
Global and why not okay why is it

232
00:10:42,720 --> 00:10:47,279
doesn't it always imply Global and

233
00:10:44,800 --> 00:10:51,480
hopefully it will give you some food for

234
00:10:47,279 --> 00:10:52,880
thoughts okay so so so I'm G to argue

235
00:10:51,480 --> 00:10:54,399
that it's locally sound and let me tell

236
00:10:52,880 --> 00:10:57,480
you what locally sound means let me

237
00:10:54,399 --> 00:11:00,480
first Define it okay so the definition

238
00:10:57,480 --> 00:11:00,480
so

239
00:11:04,079 --> 00:11:09,720
okay so here's what it

240
00:11:06,079 --> 00:11:11,560
means it means that there exists so this

241
00:11:09,720 --> 00:11:12,800
is I'm now defining what this means it

242
00:11:11,560 --> 00:11:16,279
means that there

243
00:11:12,800 --> 00:11:18,959
exists an extractor we call sometime

244
00:11:16,279 --> 00:11:21,680
sometimes a local assignment it kind of

245
00:11:18,959 --> 00:11:24,680
so some extractor a

246
00:11:21,680 --> 00:11:24,680
local

247
00:11:25,680 --> 00:11:30,760
assignment generator that's another name

248
00:11:28,079 --> 00:11:34,880
we use

249
00:11:30,760 --> 00:11:37,399
e so we have an kind of an extractor

250
00:11:34,880 --> 00:11:40,519
that generates assignments for us this

251
00:11:37,399 --> 00:11:44,800
assignment takes only L wire values on

252
00:11:40,519 --> 00:11:48,480
the circuit so we have a circuit C okay

253
00:11:44,800 --> 00:11:52,519
this this uh extractor or local

254
00:11:48,480 --> 00:11:57,880
assignment generator it gets L wires i1

255
00:11:52,519 --> 00:12:01,800
up to I L they're all in uh the wires

256
00:11:57,880 --> 00:12:03,720
which we denoted by n okay so it takes L

257
00:12:01,800 --> 00:12:07,399
wires and it

258
00:12:03,720 --> 00:12:12,440
outputs some xar an in an

259
00:12:07,399 --> 00:12:16,079
instance and Y values and values wi i1

260
00:12:12,440 --> 00:12:19,360
up to w i this is what our our local

261
00:12:16,079 --> 00:12:22,839
assignment generator outputs for any i1

262
00:12:19,360 --> 00:12:26,000
up to I it outputs some instance and Y

263
00:12:22,839 --> 00:12:29,000
values that satisfy the following such

264
00:12:26,000 --> 00:12:29,000
that

265
00:12:31,680 --> 00:12:34,760
one is local

266
00:12:37,360 --> 00:12:44,120
consistency which means any two wires

267
00:12:41,240 --> 00:12:47,440
any any wires that are connected by a

268
00:12:44,120 --> 00:12:50,480
gate satisfy the gate and the output

269
00:12:47,440 --> 00:12:52,360
wire is a one and if one of them are

270
00:12:50,480 --> 00:12:55,320
connected to input wires then it's it's

271
00:12:52,360 --> 00:13:00,079
consistent with the input Wire yeah so

272
00:12:55,320 --> 00:13:00,079
local consistency just means it respects

273
00:13:00,880 --> 00:13:03,279
all

274
00:13:03,959 --> 00:13:11,399
Gates

275
00:13:05,720 --> 00:13:16,120
consistent with X1 up to xn and out

276
00:13:11,399 --> 00:13:16,120
and you know output

277
00:13:18,240 --> 00:13:24,720
one okay so of course if you just read

278
00:13:21,199 --> 00:13:26,440
wires here and here like uh very spread

279
00:13:24,720 --> 00:13:28,680
that are not connected with any Gates

280
00:13:26,440 --> 00:13:30,360
then the local consistency doesn't say

281
00:13:28,680 --> 00:13:32,160
anything because you can determine the

282
00:13:30,360 --> 00:13:35,399
value of any gate you don't but any gate

283
00:13:32,160 --> 00:13:38,199
for which you have any gate for which

284
00:13:35,399 --> 00:13:40,920
the input and output wires are these or

285
00:13:38,199 --> 00:13:43,240
the output wire or the input wires the

286
00:13:40,920 --> 00:13:46,279
gate should be

287
00:13:43,240 --> 00:13:47,320
satisfied okay that's number one and

288
00:13:46,279 --> 00:13:53,120
number

289
00:13:47,320 --> 00:13:53,120
two is what we call non- signaling I'll

290
00:13:55,720 --> 00:14:03,199
explain number the number two says the

291
00:13:59,160 --> 00:14:04,920
the Y values that he gives here that the

292
00:14:03,199 --> 00:14:06,680
extractor the local assignment

293
00:14:04,920 --> 00:14:09,720
assignment generator

294
00:14:06,680 --> 00:14:12,000
gives the distribution so this is an a

295
00:14:09,720 --> 00:14:15,560
randomized algorithm this extractor is a

296
00:14:12,000 --> 00:14:18,360
randomized algorithm he gives he gives

297
00:14:15,560 --> 00:14:22,639
given these wire he gives a distribution

298
00:14:18,360 --> 00:14:24,720
over xar and wire values the claim is

299
00:14:22,639 --> 00:14:28,880
the distribution of xar for

300
00:14:24,720 --> 00:14:32,040
example doesn't depend on i1 up to I so

301
00:14:28,880 --> 00:14:35,320
the distribution xar in

302
00:14:32,040 --> 00:14:39,079
computationally looks the same no matter

303
00:14:35,320 --> 00:14:41,040
which uh wires you give moreover the

304
00:14:39,079 --> 00:14:45,360
distribution of wi

305
00:14:41,040 --> 00:14:46,440
i1 doesn't depend on I2 up to I so let

306
00:14:45,360 --> 00:14:52,680
me say this

307
00:14:46,440 --> 00:14:55,440
formally formally for every set I and

308
00:14:52,680 --> 00:15:01,519
J of

309
00:14:55,440 --> 00:15:05,839
size L uh let me sorry for any I and J

310
00:15:01,519 --> 00:15:10,519
subset of n so for any set of wires of

311
00:15:05,839 --> 00:15:13,160
size l so take any set of wires like I

312
00:15:10,519 --> 00:15:15,279
went up to I L let me call the first set

313
00:15:13,160 --> 00:15:18,279
I the second set

314
00:15:15,279 --> 00:15:24,480
J what and what we know is if you look

315
00:15:18,279 --> 00:15:26,360
at the intersection of so if you look at

316
00:15:24,480 --> 00:15:29,480
um

317
00:15:26,360 --> 00:15:31,680
a how would I one second just think of

318
00:15:29,480 --> 00:15:36,519
notation so think of let's look at if

319
00:15:31,680 --> 00:15:40,000
you look at extractor and I but only

320
00:15:36,519 --> 00:15:44,440
restricted the coordinate in I intersect

321
00:15:40,000 --> 00:15:47,680
J so the W's there's many there's W for

322
00:15:44,440 --> 00:15:51,399
i1 I2 let's look only the W's and the

323
00:15:47,680 --> 00:15:51,399
location that are both in I and in

324
00:15:51,839 --> 00:15:55,079
J the

325
00:15:57,160 --> 00:16:02,399
distribution of them

326
00:16:00,440 --> 00:16:05,759
looks like it looks it's inting from the

327
00:16:02,399 --> 00:16:11,600
distribution if you looked at this these

328
00:16:05,759 --> 00:16:13,560
coordinates with set J in other words

329
00:16:11,600 --> 00:16:16,199
let's say the intersection of I and J or

330
00:16:13,560 --> 00:16:18,040
I don't know some set of wires put the

331
00:16:16,199 --> 00:16:21,360
set of wires in the

332
00:16:18,040 --> 00:16:24,040
beginning okay it the rest of the so if

333
00:16:21,360 --> 00:16:25,880
you look at a set of wires look at their

334
00:16:24,040 --> 00:16:29,399
distribution their

335
00:16:25,880 --> 00:16:32,319
distribution does not depend and what

336
00:16:29,399 --> 00:16:34,800
the other wires are if you look at the

337
00:16:32,319 --> 00:16:37,319
distribution of these they will look the

338
00:16:34,800 --> 00:16:40,240
same whether the rest of the eyes were

339
00:16:37,319 --> 00:16:42,319
have one form or another form at least

340
00:16:40,240 --> 00:16:44,079
computationally they look the same they

341
00:16:42,319 --> 00:16:46,480
they need not be exactly the same but

342
00:16:44,079 --> 00:16:50,040
nobody can distinguish between the

343
00:16:46,480 --> 00:16:54,839
two okay and this is including this this

344
00:16:50,040 --> 00:16:58,000
is including the xar okay so e is like

345
00:16:54,839 --> 00:17:02,040
uh when I when the extractor here it

346
00:16:58,000 --> 00:17:06,039
means kind of X star and the

347
00:17:02,040 --> 00:17:11,039
w i j

348
00:17:06,039 --> 00:17:13,280
for i j in in I so I include the xar so

349
00:17:11,039 --> 00:17:14,640
even with xar the xar here the xar here

350
00:17:13,280 --> 00:17:16,600
are

351
00:17:14,640 --> 00:17:20,160
indistinguishable okay xar I always

352
00:17:16,600 --> 00:17:22,679
include even if it's empty I include

353
00:17:20,160 --> 00:17:24,600
xar okay so that's a non signaling the

354
00:17:22,679 --> 00:17:27,240
distributions are

355
00:17:24,600 --> 00:17:30,280
indistinguishable and now I want to

356
00:17:27,240 --> 00:17:31,640
argue that we get I can I have this

357
00:17:30,280 --> 00:17:32,760
extractor I'm going to show you I'm

358
00:17:31,640 --> 00:17:34,200
going to construct this extractor

359
00:17:32,760 --> 00:17:37,240
actually very easy to construct this

360
00:17:34,200 --> 00:17:39,400
extractor so if you give me a cheating

361
00:17:37,240 --> 00:17:41,880
prover if you give me any prover forget

362
00:17:39,400 --> 00:17:42,960
about cheating you give me aover I can

363
00:17:41,880 --> 00:17:45,720
construct this local assignment

364
00:17:42,960 --> 00:17:48,080
generator from him and then all I need

365
00:17:45,720 --> 00:17:49,760
to do is argue that a local assignment

366
00:17:48,080 --> 00:17:54,320
gener implies that I can kind of I have

367
00:17:49,760 --> 00:17:56,840
a a a assignment for all like a not just

368
00:17:54,320 --> 00:17:58,280
locally cons consistent but a fully

369
00:17:56,840 --> 00:18:00,159
consistent assignment to all the wires

370
00:17:58,280 --> 00:18:01,440
that give give Alpha One and therefore X

371
00:18:00,159 --> 00:18:05,240
needs to be in the

372
00:18:01,440 --> 00:18:05,240
language that's kind of the proof

373
00:18:05,520 --> 00:18:10,960
strategy so what I'm going to do first

374
00:18:08,120 --> 00:18:14,600
is show you how we get so we're going to

375
00:18:10,960 --> 00:18:17,120
show how given any P star we can

376
00:18:14,600 --> 00:18:18,919
generate a local assignment generator we

377
00:18:17,120 --> 00:18:21,799
can give kind of local assignment to all

378
00:18:18,919 --> 00:18:25,280
the wires that are consistent and

379
00:18:21,799 --> 00:18:27,080
satisfy this kind of noning property and

380
00:18:25,280 --> 00:18:30,720
then we're going to show how to use this

381
00:18:27,080 --> 00:18:34,440
this local assignment generator to get

382
00:18:30,720 --> 00:18:38,320
soundness questions yeah is another

383
00:18:34,440 --> 00:18:41,640
issue with obtaining this

384
00:18:38,320 --> 00:18:41,640
sound comes

385
00:18:42,640 --> 00:18:48,880
fromi the the actually the semi adaptive

386
00:18:45,799 --> 00:18:52,200
soundness of bar is enough for me it's I

387
00:18:48,880 --> 00:18:55,039
I don't need to use you'll see actually

388
00:18:52,200 --> 00:18:57,360
I don't need full adaptive bars it's not

389
00:18:55,039 --> 00:18:59,960
it's I never use it I don't it's enough

390
00:18:57,360 --> 00:19:02,159
for me that the bar only has semi even

391
00:18:59,960 --> 00:19:03,200
though okay that's a good point note I

392
00:19:02,159 --> 00:19:04,880
want I'm going to prove adaptive

393
00:19:03,200 --> 00:19:06,520
soundness and what you're saying wait

394
00:19:04,880 --> 00:19:08,640
but the bar only has semi adaptive

395
00:19:06,520 --> 00:19:10,840
soundness is that enough is it enough to

396
00:19:08,640 --> 00:19:14,320
use only semi-adaptive bar and get fully

397
00:19:10,840 --> 00:19:16,640
adaptive snar yes I will not need the

398
00:19:14,320 --> 00:19:18,640
full adaptivity of the bar we'll see as

399
00:19:16,640 --> 00:19:22,159
we'll see it next I'll use it you'll see

400
00:19:18,640 --> 00:19:25,000
it doesn't come up so it's enough the

401
00:19:22,159 --> 00:19:27,600
problem is to to get this the local

402
00:19:25,000 --> 00:19:29,919
assignment I can get the problem why

403
00:19:27,600 --> 00:19:32,480
this kind of implies global so we'll see

404
00:19:29,919 --> 00:19:34,400
that but the semi it seems it seems

405
00:19:32,480 --> 00:19:36,480
counterintuitive but actually it's

406
00:19:34,400 --> 00:19:39,919
enough was there another question you

407
00:19:36,480 --> 00:19:42,840
have question yeah remember like the X

408
00:19:39,919 --> 00:19:47,720
star oh good good good this is any okay

409
00:19:42,840 --> 00:19:53,880
so the good what is xar no sorry

410
00:19:47,720 --> 00:19:56,840
okay it's okay yeah let me call XA uh

411
00:19:53,880 --> 00:19:59,120
this sorry let me you're right uh the

412
00:19:56,840 --> 00:20:01,640
extract okay

413
00:19:59,120 --> 00:20:04,960
yeah okay so let's think P star output's

414
00:20:01,640 --> 00:20:07,240
kind of a x tlda Crooked Kind of you

415
00:20:04,960 --> 00:20:08,760
know a cheating X so let's use Cricket

416
00:20:07,240 --> 00:20:11,159
like Tilda to den knowe kind of a

417
00:20:08,760 --> 00:20:13,480
cricket cheating thing and he's also

418
00:20:11,159 --> 00:20:17,280
gonna output some

419
00:20:13,480 --> 00:20:20,880
Tilda because it he his is also crooked

420
00:20:17,280 --> 00:20:24,760
and we want to argue that this crooked X

421
00:20:20,880 --> 00:20:27,280
is indistinguishable from the Crooked ax

422
00:20:24,760 --> 00:20:29,960
given by the cheating prover we're going

423
00:20:27,280 --> 00:20:33,159
to yeah and oh yeah so I need to say

424
00:20:29,960 --> 00:20:35,120
that sorry so good so let's say again

425
00:20:33,159 --> 00:20:39,480
the local assignment generator it

426
00:20:35,120 --> 00:20:41,320
outputs x a crooked x with assignments

427
00:20:39,480 --> 00:20:44,039
partial assignments to some of the wires

428
00:20:41,320 --> 00:20:46,760
to the L wires such

429
00:20:44,039 --> 00:20:49,919
that you it's

430
00:20:46,760 --> 00:20:53,760
consistent uh non- signaling and it's

431
00:20:49,919 --> 00:20:57,799
also non and sorry

432
00:20:53,760 --> 00:21:00,840
and X Tilda is indistinguishable from

433
00:20:57,799 --> 00:21:04,000
the X Tilda P star so P star also

434
00:21:00,840 --> 00:21:07,200
outputs X Delta they look the

435
00:21:04,000 --> 00:21:11,080
same note and if if it was non adaptive

436
00:21:07,200 --> 00:21:12,880
it would be fixed so then X XA is fixed

437
00:21:11,080 --> 00:21:15,600
ahead of time nobody will need to

438
00:21:12,880 --> 00:21:17,520
generate them anymore it's fixed and the

439
00:21:15,600 --> 00:21:21,400
and the extractor the local assignment

440
00:21:17,520 --> 00:21:25,720
generator will only give values to the

441
00:21:21,400 --> 00:21:28,200
wires but in the Adaptive setting the P

442
00:21:25,720 --> 00:21:31,520
star you give him CRS he gives you a

443
00:21:28,200 --> 00:21:32,840
different X star the X Tilda sorry now

444
00:21:31,520 --> 00:21:35,559
okay he gives you a different a

445
00:21:32,840 --> 00:21:38,320
different ex Tilda so every time he

446
00:21:35,559 --> 00:21:42,039
gives you a local kind of window it will

447
00:21:38,320 --> 00:21:45,039
be for a with a different X dilda

448
00:21:42,039 --> 00:21:46,520
possibly uh uh in the Adaptive setting

449
00:21:45,039 --> 00:21:50,039
in the nonadaptive setting it's always

450
00:21:46,520 --> 00:21:54,799
going to be with the same X

451
00:21:50,039 --> 00:21:54,799
till okay any any

452
00:21:55,360 --> 00:21:59,000
questions okay let's try to see why we

453
00:21:57,559 --> 00:22:00,400
get local how we can construct this

454
00:21:59,000 --> 00:22:03,080
local assignment

455
00:22:00,400 --> 00:22:05,840
generator okay so I have a cheating Pro

456
00:22:03,080 --> 00:22:12,000
so fix so

457
00:22:05,840 --> 00:22:12,000
proof so fix P star fix a poly

458
00:22:13,600 --> 00:22:19,080
size P

459
00:22:15,960 --> 00:22:22,679
star I want to get an assign uh kind of

460
00:22:19,080 --> 00:22:24,880
a window to the there's the circuit we

461
00:22:22,679 --> 00:22:28,880
have the circuit

462
00:22:24,880 --> 00:22:31,720
C that has X maybe a witness I want use

463
00:22:28,880 --> 00:22:34,760
the C star the P the cheating prover

464
00:22:31,720 --> 00:22:37,679
well he so he's going to give me okay so

465
00:22:34,760 --> 00:22:40,600
fix P star for any CRS he's going to

466
00:22:37,679 --> 00:22:42,919
give me X I'm going to get from him an X

467
00:22:40,600 --> 00:22:46,799
and a window to some of the wires of the

468
00:22:42,919 --> 00:22:49,080
circuit so let's see how so here's my

469
00:22:46,799 --> 00:22:50,480
extractor the extractor or the local

470
00:22:49,080 --> 00:22:52,080
assignment gener it's going to use P

471
00:22:50,480 --> 00:22:54,799
Star as an oracle it's going to make

472
00:22:52,080 --> 00:22:58,200
it's going to make use of P star he's

473
00:22:54,799 --> 00:23:00,720
going to get i1 up to I what does he do

474
00:22:58,200 --> 00:23:03,799
he wants to get the values of these

475
00:23:00,720 --> 00:23:06,480
wires okay what does he do he's going to

476
00:23:03,799 --> 00:23:11,240
run P star he's going to run P star in a

477
00:23:06,480 --> 00:23:11,240
CRS that he chooses so he's going to

478
00:23:12,360 --> 00:23:18,559
generate CRS we'll see how in a second

479
00:23:16,360 --> 00:23:23,039
and then he's going to run P star on the

480
00:23:18,559 --> 00:23:26,799
CRS to get a value and a snar and then

481
00:23:23,039 --> 00:23:29,960
he's going to kind of extract the wires

482
00:23:26,799 --> 00:23:33,480
from this hash value okay so let's see

483
00:23:29,960 --> 00:23:37,799
so how does he generate the CRS CRS is

484
00:23:33,480 --> 00:23:41,559
going to be a piie for uh um CRS bargain

485
00:23:37,799 --> 00:23:45,120
hash key yeah so he's going to

486
00:23:41,559 --> 00:23:49,159
generate he's going to generate hash Key

487
00:23:45,120 --> 00:23:52,120
by you by running gen on this location I

488
00:23:49,159 --> 00:23:55,039
went up to I so what is it so let me

489
00:23:52,120 --> 00:23:59,000
actually he's going to first generate

490
00:23:55,039 --> 00:23:59,000
hash key and trapo

491
00:23:59,159 --> 00:24:07,640
and gen Sumer extractable hash with uh

492
00:24:04,600 --> 00:24:11,279
one to the Lambda number of wires in C

493
00:24:07,640 --> 00:24:14,440
in the circuit and i1 up to I L these

494
00:24:11,279 --> 00:24:16,559
are the wires he wants to extract okay

495
00:24:14,440 --> 00:24:19,440
because he has I went up to I L he wants

496
00:24:16,559 --> 00:24:21,080
to extract the values of these wires so

497
00:24:19,440 --> 00:24:23,520
he's going to give you a hash key that's

498
00:24:21,080 --> 00:24:26,880
extractable on these

499
00:24:23,520 --> 00:24:34,559
locations and then it's also going to

500
00:24:26,880 --> 00:24:37,039
generate uh gen for the bar to get H CRS

501
00:24:34,559 --> 00:24:41,840
bar he's just going to do this honestly

502
00:24:37,039 --> 00:24:46,559
here we has one to the Lambda K and

503
00:24:41,840 --> 00:24:48,640
N and or this is n Prime the N Prime you

504
00:24:46,559 --> 00:24:51,039
know the he's going to generate exactly

505
00:24:48,640 --> 00:24:55,600
as as in the construction and then he

506
00:24:51,039 --> 00:25:02,399
gives he runs now

507
00:24:55,600 --> 00:25:05,880
run P star with hash key and CRS bar

508
00:25:02,399 --> 00:25:05,880
that's the CRS he gives P

509
00:25:06,120 --> 00:25:15,440
star and get V and Pi barg that's

510
00:25:12,640 --> 00:25:17,000
what the P star gives

511
00:25:15,440 --> 00:25:23,559
you

512
00:25:17,000 --> 00:25:30,720
now if this is rejected start again so

513
00:25:23,559 --> 00:25:34,520
if Pi Bar or if if V and Pi

514
00:25:30,720 --> 00:25:38,559
Bar so you know if the verifier with

515
00:25:34,520 --> 00:25:42,440
input oh wait sorry X star also X Tilda

516
00:25:38,559 --> 00:25:44,399
sorry he G so he G the P star gives what

517
00:25:42,440 --> 00:25:46,600
some X TAA because it's adaptive he

518
00:25:44,399 --> 00:25:49,559
gives him some X and a

519
00:25:46,600 --> 00:25:52,520
proof the proof is is a hash value and

520
00:25:49,559 --> 00:25:55,440
the bar that's what the proof is now he

521
00:25:52,520 --> 00:25:57,760
checks if V if the verifier rejects this

522
00:25:55,440 --> 00:25:59,120
proof it's it's not a good proof so if

523
00:25:57,760 --> 00:26:02,720
if V

524
00:25:59,120 --> 00:26:07,840
given CRS which is these two this is the

525
00:26:02,720 --> 00:26:09,760
CRS given CRS given X Tilda and given Pi

526
00:26:07,840 --> 00:26:15,840
this is

527
00:26:09,760 --> 00:26:15,840
pi output zero if it rejects try

528
00:26:18,200 --> 00:26:24,720
again what I mean by try again again

529
00:26:21,880 --> 00:26:27,840
generate a hash key generate a bar

530
00:26:24,720 --> 00:26:30,240
run if this is accept if it's rejected

531
00:26:27,840 --> 00:26:30,240
try again

532
00:26:30,520 --> 00:26:38,840
until I get something

533
00:26:32,640 --> 00:26:40,080
good okay now okay we want we okay until

534
00:26:38,840 --> 00:26:43,360
you get something good once you get

535
00:26:40,080 --> 00:26:47,320
something good you're happy what then

536
00:26:43,360 --> 00:26:49,840
what do you do you output so try again

537
00:26:47,320 --> 00:26:49,840
uh if

538
00:26:51,360 --> 00:26:54,640
success then

539
00:26:57,039 --> 00:27:03,440
output the X

540
00:26:59,799 --> 00:27:05,919
Tilda and what y values extract from the

541
00:27:03,440 --> 00:27:07,039
V so remember this V is Hash of all the

542
00:27:05,919 --> 00:27:09,360
wires of the

543
00:27:07,039 --> 00:27:12,799
circuit extract you'll get the wires

544
00:27:09,360 --> 00:27:15,559
corresponding to i1 of I so outut this

545
00:27:12,799 --> 00:27:15,559
and I'll put

546
00:27:15,880 --> 00:27:19,399
extract with

547
00:27:19,919 --> 00:27:28,960
trapo the value V to get W i1 up to W

548
00:27:25,760 --> 00:27:30,799
iil that's it that's what the extractor

549
00:27:28,960 --> 00:27:32,240
the local assignment generator does why

550
00:27:30,799 --> 00:27:36,000
can you do this I

551
00:27:32,240 --> 00:27:38,559
thought was adaptive so if you change

552
00:27:36,000 --> 00:27:41,440
CRS why can you fix it s no it's not

553
00:27:38,559 --> 00:27:44,960
fixed you're right so what do I do I

554
00:27:41,440 --> 00:27:47,840
generate hash key and a bar I run him he

555
00:27:44,960 --> 00:27:51,399
gives me XA if I'm happy with X if I'm

556
00:27:47,840 --> 00:27:55,760
happy with this proof I output XA the XA

557
00:27:51,399 --> 00:27:56,840
dependent on CRS so given I want to I

558
00:27:55,760 --> 00:27:59,399
I'm going to get a different I'm going

559
00:27:56,840 --> 00:28:04,000
to get a different X still the

560
00:27:59,399 --> 00:28:05,000
every time I get up i1 I generate H CRS

561
00:28:04,000 --> 00:28:09,159
for my

562
00:28:05,000 --> 00:28:11,679
snar I run the pro I get xtia and a

563
00:28:09,159 --> 00:28:14,600
proof If I'm happy with the proof I

564
00:28:11,679 --> 00:28:16,200
output xtia and the extracted wires W's

565
00:28:14,600 --> 00:28:18,399
are just wire values they're not

566
00:28:16,200 --> 00:28:20,880
Witnesses no they're wire values sorry

567
00:28:18,399 --> 00:28:24,440
these are not Witnesses yeah uh yeah I

568
00:28:20,880 --> 00:28:26,240
use W for you know wires but it's also

569
00:28:24,440 --> 00:28:28,799
witness it's

570
00:28:26,240 --> 00:28:30,559
a uh so

571
00:28:28,799 --> 00:28:33,720
sorry

572
00:28:30,559 --> 00:28:35,880
a a bit of abuse of notation sorry these

573
00:28:33,720 --> 00:28:38,640
are yre values okay forget about witness

574
00:28:35,880 --> 00:28:40,600
there's no Witnesses now just wires yeah

575
00:28:38,640 --> 00:28:43,120
yeah if you're like projection sampling

576
00:28:40,600 --> 00:28:45,320
until you get the verifi to accept then

577
00:28:43,120 --> 00:28:49,279
how is the distribution of X be the

578
00:28:45,320 --> 00:28:52,279
distribution of okay uh uh okay that's

579
00:28:49,279 --> 00:28:53,320
good so I'm gonna answer did you you

580
00:28:52,279 --> 00:28:54,559
it's a different question a different

581
00:28:53,320 --> 00:28:58,880
question okay let me first answer this

582
00:28:54,559 --> 00:29:00,880
question so okay I'm GNA um

583
00:28:58,880 --> 00:29:03,120
the question was first there's a couple

584
00:29:00,880 --> 00:29:05,399
issues first of all how many times am am

585
00:29:03,120 --> 00:29:06,799
I going to do this rejection sampling

586
00:29:05,399 --> 00:29:09,480
okay am I going to run forever what's

587
00:29:06,799 --> 00:29:10,480
going on here and the answer is no

588
00:29:09,480 --> 00:29:13,200
actually I'm not not going to run

589
00:29:10,480 --> 00:29:15,159
forever so fix a p star that let's say

590
00:29:13,200 --> 00:29:19,480
is

591
00:29:15,159 --> 00:29:19,480
accepted with non-n

592
00:29:23,480 --> 00:29:28,159
probability Epsilon okay Epsilon is not

593
00:29:26,399 --> 00:29:32,159
negligible

594
00:29:28,159 --> 00:29:32,159
I'm going to try again at

595
00:29:32,720 --> 00:29:40,120
most a I know poly in Lambda and 1 over

596
00:29:37,640 --> 00:29:40,120
Epsilon

597
00:29:42,080 --> 00:29:47,240
times so I'm going to do this only poom

598
00:29:44,880 --> 00:29:49,960
many times okay think of Epsilon as one

599
00:29:47,240 --> 00:29:51,679
over poly Lambda so I'm going to run in

600
00:29:49,960 --> 00:29:53,279
time poly in

601
00:29:51,679 --> 00:29:56,960
Lambda

602
00:29:53,279 --> 00:29:59,120
okay now given that and okay so the

603
00:29:56,960 --> 00:30:02,000
first thing I want to argue you is the

604
00:29:59,120 --> 00:30:03,960
probability that I will and so I'm going

605
00:30:02,000 --> 00:30:06,200
to run the most poly Lambda one overs on

606
00:30:03,960 --> 00:30:09,000
time that's it and you say what if all

607
00:30:06,200 --> 00:30:10,480
of them are reject then I'm going to say

608
00:30:09,000 --> 00:30:12,760
okay I I Was

609
00:30:10,480 --> 00:30:15,559
Defeated okay what is the probability

610
00:30:12,760 --> 00:30:17,960
that I'll be defeated negligible because

611
00:30:15,559 --> 00:30:20,799
each time I'm starting fresh and the

612
00:30:17,960 --> 00:30:25,440
probability of defeat is only ABS is is

613
00:30:20,799 --> 00:30:29,440
uh is one over ah the okay I'm re

614
00:30:25,440 --> 00:30:33,200
I'm I'm accepted I'm I'm okay I'm

615
00:30:29,440 --> 00:30:36,080
accepted with probability Epsilon if I

616
00:30:33,200 --> 00:30:38,720
repeat it you know Lambda over Epsilon

617
00:30:36,080 --> 00:30:40,559
Times by just concentration Bound by

618
00:30:38,720 --> 00:30:41,919
turn of bound I'm going to be accepted

619
00:30:40,559 --> 00:30:44,480
in one of them with very very high

620
00:30:41,919 --> 00:30:47,039
probability okay exponential like

621
00:30:44,480 --> 00:30:49,679
exponential in one like two the minus

622
00:30:47,039 --> 00:30:52,799
Lambda or something like that so if I

623
00:30:49,679 --> 00:30:55,039
repeat it enough times one of them I'm

624
00:30:52,799 --> 00:30:58,639
going to the probability of of Bot of me

625
00:30:55,039 --> 00:31:01,760
kind of being defeated is negligible

626
00:30:58,639 --> 00:31:04,120
okay so now then but now going back to

627
00:31:01,760 --> 00:31:06,840
your question the question is how do I

628
00:31:04,120 --> 00:31:10,600
know that XA here has the same

629
00:31:06,840 --> 00:31:12,519
distribution as the x of P star yeah

630
00:31:10,600 --> 00:31:16,440
that's the question

631
00:31:12,519 --> 00:31:19,880
so a good so

632
00:31:16,440 --> 00:31:23,080
a actually I was a bit sloppy when I say

633
00:31:19,880 --> 00:31:26,919
XA is inting from this I mean in the for

634
00:31:23,080 --> 00:31:29,080
XA condition and accept sorry yeah this

635
00:31:26,919 --> 00:31:32,919
is

636
00:31:29,080 --> 00:31:36,000
condition on P star

637
00:31:32,919 --> 00:31:38,720
accepting so p i can assume without loss

638
00:31:36,000 --> 00:31:40,960
of yeah so and let's think of P star

639
00:31:38,720 --> 00:31:42,399
either is outting bot there's no point

640
00:31:40,960 --> 00:31:44,559
in him giving a bad proof like he's

641
00:31:42,399 --> 00:31:48,440
going to be rejected either is like

642
00:31:44,559 --> 00:31:53,240
defeat or give x with a good proof okay

643
00:31:48,440 --> 00:31:55,039
so the pro so uh my X I always output XA

644
00:31:53,240 --> 00:31:57,519
with property one minus negligible and

645
00:31:55,039 --> 00:32:00,559
this XA is going to be distributed like

646
00:31:57,519 --> 00:32:03,559
X zilda condition on n on the P star not

647
00:32:00,559 --> 00:32:05,320
a boarding yeah those two distribs

648
00:32:03,559 --> 00:32:07,720
actually idal right up to the SL

649
00:32:05,320 --> 00:32:10,559
probability that you give up at the end

650
00:32:07,720 --> 00:32:12,840
no it's uh okay so the question one is

651
00:32:10,559 --> 00:32:16,039
the X Tilla of P star actually identical

652
00:32:12,840 --> 00:32:17,799
to the X Tilda of the extractor and the

653
00:32:16,039 --> 00:32:20,679
answer is not quite because the xti of

654
00:32:17,799 --> 00:32:21,799
the extractor runs gen with these

655
00:32:20,679 --> 00:32:25,320
specific

656
00:32:21,799 --> 00:32:26,919
eyes and X Tilda is run with P star with

657
00:32:25,320 --> 00:32:30,039
let's say one two three up to L I don't

658
00:32:26,919 --> 00:32:31,639
know like a fixed uh and this kind of

659
00:32:30,039 --> 00:32:32,720
the eyes change that's the only

660
00:32:31,639 --> 00:32:34,159
difference and that's why it's

661
00:32:32,720 --> 00:32:37,360
indistinguishable because the p star

662
00:32:34,159 --> 00:32:40,919
doesn't know that because of the index

663
00:32:37,360 --> 00:32:44,039
hiding P star has no idea what the indic

664
00:32:40,919 --> 00:32:47,080
which indices are sitting behind the

665
00:32:44,039 --> 00:32:49,240
hash key so the Exel that he he's given

666
00:32:47,080 --> 00:32:51,840
he gives is the same is

667
00:32:49,240 --> 00:32:55,960
indistinguishable nikan did you are

668
00:32:51,840 --> 00:32:58,240
you make sure last Point each trial here

669
00:32:55,960 --> 00:33:00,120
will work with probability Epsilon minus

670
00:32:58,240 --> 00:33:03,360
because of the index hiding right

671
00:33:00,120 --> 00:33:05,159
exactly you're right yeah you're right

672
00:33:03,360 --> 00:33:06,799
exactly Epson minus that's why the

673
00:33:05,159 --> 00:33:10,399
Epsilon has to be non- negligible

674
00:33:06,799 --> 00:33:11,720
because you lose negligible and if if

675
00:33:10,399 --> 00:33:12,960
you know it needs to be negligible

676
00:33:11,720 --> 00:33:15,760
compared to the

677
00:33:12,960 --> 00:33:18,159
Epsilon so my question was the extract

678
00:33:15,760 --> 00:33:21,799
algorithm for the is only required to

679
00:33:18,159 --> 00:33:25,399
extract when V is an eval of X

680
00:33:21,799 --> 00:33:29,480
right is that true or is that not true a

681
00:33:25,399 --> 00:33:29,480
okay one second

682
00:33:32,159 --> 00:33:42,080
good point uh no um okay the no the

683
00:33:37,600 --> 00:33:43,639
completeness was assuming you know holds

684
00:33:42,080 --> 00:33:47,679
but

685
00:33:43,639 --> 00:33:52,080
uh I didn't write it actually down good

686
00:33:47,679 --> 00:33:52,080
point Nikon thank you

687
00:33:56,360 --> 00:34:01,919
a the uh the summer extractable hash I

688
00:34:00,039 --> 00:34:04,639
didn't say soundness of the I didn't

689
00:34:01,919 --> 00:34:07,040
write like the soundness of this extract

690
00:34:04,639 --> 00:34:09,960
so

691
00:34:07,040 --> 00:34:16,560
uh the extract has the the following

692
00:34:09,960 --> 00:34:16,560
property if the cheating

693
00:34:17,919 --> 00:34:24,839
a if the cheating

694
00:34:20,560 --> 00:34:28,200
prover gives any hold on let me think

695
00:34:24,839 --> 00:34:28,200
for a second

696
00:34:30,440 --> 00:34:37,280
if the cheating prover gives an opening

697
00:34:32,919 --> 00:34:39,440
if if you're extract if the hash key

698
00:34:37,280 --> 00:34:43,440
okay thank you if the hash key is

699
00:34:39,440 --> 00:34:47,760
generated with Gen of I and if an

700
00:34:43,440 --> 00:34:50,159
adversary generated an opening of I a

701
00:34:47,760 --> 00:34:51,960
valid opening so he successfully opened

702
00:34:50,159 --> 00:34:56,200
the I

703
00:34:51,960 --> 00:34:58,760
bit somehow with a B then the extract

704
00:34:56,200 --> 00:35:01,800
will work and give you that same

705
00:34:58,760 --> 00:35:06,960
B so let me let me write it down because

706
00:35:01,800 --> 00:35:06,960
actually we need it here so uh

707
00:35:11,240 --> 00:35:17,000
okay okay uh for

708
00:35:14,000 --> 00:35:17,000
any

709
00:35:18,240 --> 00:35:29,119
uh for any a adversary and for every

710
00:35:25,599 --> 00:35:32,560
I the probability

711
00:35:29,119 --> 00:35:35,680
that a and hash key where the hash key

712
00:35:32,560 --> 00:35:40,560
is generated with I so hash key trapd

713
00:35:35,680 --> 00:35:43,440
door they're generated with Gen with uh

714
00:35:40,560 --> 00:35:47,240
one to the Lambda n and

715
00:35:43,440 --> 00:35:50,760
I if this if he managed to give me a

716
00:35:47,240 --> 00:35:57,440
value adversarial value but he manages

717
00:35:50,760 --> 00:36:02,040
to open with a a b and row so let me

718
00:35:57,440 --> 00:36:05,000
call it it b i and row I such

719
00:36:02,040 --> 00:36:07,359
that the verifier accept it such that

720
00:36:05,000 --> 00:36:11,839
ver so the probability that he gives me

721
00:36:07,359 --> 00:36:14,599
a verify uh um a tuple that verifies so

722
00:36:11,839 --> 00:36:19,240
hash key

723
00:36:14,599 --> 00:36:23,319
v i b row is

724
00:36:19,240 --> 00:36:25,720
one and but extraction fails is

725
00:36:23,319 --> 00:36:29,560
negligible so the probability that this

726
00:36:25,720 --> 00:36:29,560
accept but extract

727
00:36:32,119 --> 00:36:39,280
a is not

728
00:36:34,720 --> 00:36:39,280
b bi is

729
00:36:40,160 --> 00:36:45,280
negligible so if you opened it must be

730
00:36:42,920 --> 00:36:47,160
valid and if you think about the

731
00:36:45,280 --> 00:36:48,440
construction if you open it's like

732
00:36:47,160 --> 00:36:49,800
everything is in the correct encryption

733
00:36:48,440 --> 00:36:51,240
encryption encryption the encryption

734
00:36:49,800 --> 00:36:52,880
must be correct and the extractor will

735
00:36:51,240 --> 00:36:58,240
will

736
00:36:52,880 --> 00:36:59,720
decrypted that's kind of the a

737
00:36:58,240 --> 00:37:01,520
yeah so if he doesn't open anything V

738
00:36:59,720 --> 00:37:05,800
can be whatever you may not be able to

739
00:37:01,520 --> 00:37:09,560
extract but as long as he gave you uh

740
00:37:05,800 --> 00:37:11,200
the correct path then then okay so we'll

741
00:37:09,560 --> 00:37:17,119
use it here thank

742
00:37:11,200 --> 00:37:19,400
you okay uh okay so now let's see why is

743
00:37:17,119 --> 00:37:21,680
so this is but this is the extraction

744
00:37:19,400 --> 00:37:23,319
procedure okay we'll analyze it in a

745
00:37:21,680 --> 00:37:26,040
second we'll see why this is used but

746
00:37:23,319 --> 00:37:28,359
again let me let's just kind of R kind

747
00:37:26,040 --> 00:37:32,000
of uh recall what so what is the local

748
00:37:28,359 --> 00:37:35,599
assignment generator it takes L

749
00:37:32,000 --> 00:37:38,680
wires he will generate a CRS and give it

750
00:37:35,599 --> 00:37:41,119
to the cheating po the CRS he generates

751
00:37:38,680 --> 00:37:42,839
consists of a hash key and a bar and a

752
00:37:41,119 --> 00:37:45,280
CRS for the bar the CRS for the bar he

753
00:37:42,839 --> 00:37:48,160
just generates and the s for the hash

754
00:37:45,280 --> 00:37:52,800
key he generates with a trapo with

755
00:37:48,160 --> 00:37:55,319
respect to the wires that he needs to

756
00:37:52,800 --> 00:37:58,160
extract he gives this to the prover and

757
00:37:55,319 --> 00:38:00,480
the prover gives him

758
00:37:58,160 --> 00:38:04,440
hash value that's extractable on these

759
00:38:00,480 --> 00:38:05,920
wires and a bark proof If the bark proof

760
00:38:04,440 --> 00:38:07,200
is rejected he starts all over so we're

761
00:38:05,920 --> 00:38:09,280
going to do it until we have something

762
00:38:07,200 --> 00:38:13,480
accepted once it's accepted we're going

763
00:38:09,280 --> 00:38:15,720
to just extract these W these uh wires

764
00:38:13,480 --> 00:38:17,920
because we we have the trapo the the

765
00:38:15,720 --> 00:38:20,960
extractor has the trapo we're going to

766
00:38:17,920 --> 00:38:22,200
or the E here we're going to extract uh

767
00:38:20,960 --> 00:38:25,960
the wires and that's what we're going to

768
00:38:22,200 --> 00:38:28,400
Output okay the XA and the

769
00:38:25,960 --> 00:38:30,520
wires Okay so so now we need to argue

770
00:38:28,400 --> 00:38:31,880
non- signaling and we need to argue

771
00:38:30,520 --> 00:38:34,200
local

772
00:38:31,880 --> 00:38:36,640
consistency any questions before I go

773
00:38:34,200 --> 00:38:36,640
ahead and do

774
00:38:37,400 --> 00:38:43,640
it okay so let's see let's start with um

775
00:38:40,359 --> 00:38:45,400
with local consistency okay why why are

776
00:38:43,640 --> 00:38:48,839
things locally

777
00:38:45,400 --> 00:38:51,040
consistent so the I claim that local

778
00:38:48,839 --> 00:38:54,760
consistency follows from the soundness

779
00:38:51,040 --> 00:38:57,760
of the bar okay so let's see why this is

780
00:38:54,760 --> 00:38:57,760
um

781
00:39:04,920 --> 00:39:08,200
I want of

782
00:39:08,280 --> 00:39:12,040
okay what do we have

783
00:39:12,440 --> 00:39:15,440
here

784
00:39:16,560 --> 00:39:22,319
a okay oh well I'm just

785
00:39:19,960 --> 00:39:23,880
gonna we're going to kind of needed but

786
00:39:22,319 --> 00:39:28,119
it's

787
00:39:23,880 --> 00:39:28,119
okay okay so

788
00:39:31,040 --> 00:39:36,160
so local consistency I want to argue

789
00:39:33,960 --> 00:39:38,880
follows from the correctness of the bar

790
00:39:36,160 --> 00:39:41,560
from the soundness of the bar why

791
00:39:38,880 --> 00:39:41,560
suppose for

792
00:39:49,880 --> 00:39:57,119
contradiction so suppose at the

793
00:39:51,880 --> 00:39:58,240
extractor output X TAA and l y values

794
00:39:57,119 --> 00:40:01,599
the not

795
00:39:58,240 --> 00:40:03,480
consistent okay so the ly values are not

796
00:40:01,599 --> 00:40:06,960
consistent then what does they mean

797
00:40:03,480 --> 00:40:09,560
they're not consistent there's one gate

798
00:40:06,960 --> 00:40:11,560
that they don't

799
00:40:09,560 --> 00:40:15,400
respect

800
00:40:11,560 --> 00:40:19,040
now remember so okay so there's one gate

801
00:40:15,400 --> 00:40:19,040
that they don't respect so

802
00:40:19,680 --> 00:40:27,319
suppose e an input i1 up to I L output

803
00:40:27,760 --> 00:40:37,520
like W1 up to W i1 up to w i

804
00:40:33,800 --> 00:40:37,520
l that do not

805
00:40:42,280 --> 00:40:49,160
respect some gate let's fix a gate some

806
00:40:45,560 --> 00:40:50,520
gate J with non- Neal probability if

807
00:40:49,160 --> 00:40:52,359
there's one gate doesn't respect choose

808
00:40:50,520 --> 00:40:54,480
it one at random so won't respect this

809
00:40:52,359 --> 00:40:56,000
random one with probability I mean there

810
00:40:54,480 --> 00:40:58,040
exists one gate that's not respect

811
00:40:56,000 --> 00:41:00,280
probability one over poly

812
00:40:58,040 --> 00:41:03,359
okay Suppose there exist some GJ that

813
00:41:00,280 --> 00:41:03,359
this does not with

814
00:41:04,440 --> 00:41:10,000
probability one over

815
00:41:06,800 --> 00:41:15,040
poly now let's look at the bar what does

816
00:41:10,000 --> 00:41:16,920
the bar say the bar tells me that all

817
00:41:15,040 --> 00:41:19,760
the gates are

818
00:41:16,920 --> 00:41:24,160
respected so what I'm going to do in the

819
00:41:19,760 --> 00:41:27,680
bar I'm going to so remember in the bar

820
00:41:24,160 --> 00:41:30,280
a I have this somewhere now I'm to the

821
00:41:27,680 --> 00:41:33,560
Adaptive versus the why some more

822
00:41:30,280 --> 00:41:36,160
adaptive soundless of bar is enough why

823
00:41:33,560 --> 00:41:39,480
if there's some gay J that's not

824
00:41:36,160 --> 00:41:43,280
responsibility one over poly in the bar

825
00:41:39,480 --> 00:41:46,440
Construction in the CRS I'm going to

826
00:41:43,280 --> 00:41:48,119
hard why I'm so sorry I'm gonna okay let

827
00:41:46,440 --> 00:41:51,640
me construct a cheating prover for the

828
00:41:48,119 --> 00:41:51,640
bar okay so we're going to

829
00:41:52,839 --> 00:41:57,319
construct cheating prover

830
00:41:58,920 --> 00:42:01,280
for

831
00:42:01,440 --> 00:42:04,680
bar that

832
00:42:05,640 --> 00:42:10,040
cheats he's going to be somewhere

833
00:42:07,920 --> 00:42:13,119
adaptive sound is and he's going to

834
00:42:10,040 --> 00:42:15,839
cheat on

835
00:42:13,119 --> 00:42:18,079
J and this specific J I don't care about

836
00:42:15,839 --> 00:42:20,839
what the CRS is yet I'm going to be semi

837
00:42:18,079 --> 00:42:25,280
adaptive so I'm going to tell you my

838
00:42:20,839 --> 00:42:28,880
chover he may choose the X1 star of to x

839
00:42:25,280 --> 00:42:30,240
k star the actual instances later but

840
00:42:28,880 --> 00:42:31,359
which one he's going to choose he's

841
00:42:30,240 --> 00:42:34,359
going to cheat on I'm going to tell you

842
00:42:31,359 --> 00:42:35,800
now it's j so it's going to be S like

843
00:42:34,359 --> 00:42:36,960
it's going to be nonadaptive and where

844
00:42:35,800 --> 00:42:39,520
he's cheating that's kind of the

845
00:42:36,960 --> 00:42:39,520
semi-adaptive

846
00:42:39,800 --> 00:42:46,839
yeah loal consistency is a statement

847
00:42:43,680 --> 00:42:48,640
that the extractor out is that the same

848
00:42:46,839 --> 00:42:51,240
as the statement

849
00:42:48,640 --> 00:42:53,160
that okay so let me tell okay so let me

850
00:42:51,240 --> 00:42:55,520
so you're asking is there a match how do

851
00:42:53,160 --> 00:42:57,359
we match these two so let me okay so

852
00:42:55,520 --> 00:42:58,960
wait let me tell you the cheating prover

853
00:42:57,359 --> 00:43:02,280
so I'm going to construct a cheating

854
00:42:58,960 --> 00:43:04,640
prover let's say Pou star for the bar

855
00:43:02,280 --> 00:43:10,280
okay here's what my pble star does my

856
00:43:04,640 --> 00:43:10,280
pble star he gets CRS of

857
00:43:10,400 --> 00:43:18,960
bar what he's going to do he's gonna

858
00:43:15,040 --> 00:43:22,319
a uh run piece he's going to generate

859
00:43:18,960 --> 00:43:24,319
hash key on his own okay and he's going

860
00:43:22,319 --> 00:43:29,599
to

861
00:43:24,319 --> 00:43:29,599
run P star on the CRS

862
00:43:30,440 --> 00:43:35,240
bar and the hash key that he gives him

863
00:43:33,400 --> 00:43:39,119
he's going to get

864
00:43:35,240 --> 00:43:39,119
V and Pi

865
00:43:41,079 --> 00:43:46,160
Bar and now he's going to cheat pble

866
00:43:44,400 --> 00:43:48,599
star will

867
00:43:46,160 --> 00:43:49,920
cheat and here's the instances that he

868
00:43:48,599 --> 00:43:52,240
gives so he's going to give the

869
00:43:49,920 --> 00:43:56,040
instances adaptively the instances are

870
00:43:52,240 --> 00:44:01,240
going to be hash key V and

871
00:43:56,040 --> 00:44:02,400
J for J goes from one to uh K the number

872
00:44:01,240 --> 00:44:04,559
of

873
00:44:02,400 --> 00:44:08,040
gates these are going to be the instance

874
00:44:04,559 --> 00:44:14,000
so this is going to be XJ

875
00:44:08,040 --> 00:44:14,000
star or x i sorry that's a third go

876
00:44:16,280 --> 00:44:22,319
I so that's the XI star and the bar is

877
00:44:19,839 --> 00:44:22,319
going to be

878
00:44:24,720 --> 00:44:29,720
this so that time that time cheating

879
00:44:28,160 --> 00:44:34,880
okay I

880
00:44:29,720 --> 00:44:37,480
have K instances that I chose adaptively

881
00:44:34,880 --> 00:44:40,000
but I'm arguing that the J one which

882
00:44:37,480 --> 00:44:44,960
corresponds to gate

883
00:44:40,000 --> 00:44:48,280
J is actually it's false this XJ star is

884
00:44:44,960 --> 00:44:50,680
not in the language because I'm

885
00:44:48,280 --> 00:44:53,079
binding on this J and what's sitting

886
00:44:50,680 --> 00:44:57,440
there is false so even if you're just

887
00:44:53,079 --> 00:45:00,160
does not exist of an opening because I'm

888
00:44:57,440 --> 00:45:02,680
binding on these locations what I know

889
00:45:00,160 --> 00:45:06,000
from The Binding condition which

890
00:45:02,680 --> 00:45:08,359
is here what I know from The Binding

891
00:45:06,000 --> 00:45:11,000
condition there is no opening for the

892
00:45:08,359 --> 00:45:12,720
wrong value it just doesn't exist so

893
00:45:11,000 --> 00:45:18,079
there is no

894
00:45:12,720 --> 00:45:20,359
witness for x uh for XJ star but look I

895
00:45:18,079 --> 00:45:23,480
pble star managed to come up with a

896
00:45:20,359 --> 00:45:27,119
proof even though before in the semi

897
00:45:23,480 --> 00:45:29,000
adaptive way he gave me a j a gate

898
00:45:27,119 --> 00:45:32,319
before I got even the CRS he gave me a

899
00:45:29,000 --> 00:45:36,839
gate and nevertheless manages managed to

900
00:45:32,319 --> 00:45:38,880
produce a bar that all my xar and and a

901
00:45:36,839 --> 00:45:43,000
bunch of

902
00:45:38,880 --> 00:45:50,319
xstar and the bar is satisfied but the

903
00:45:43,000 --> 00:45:50,319
J A instance is does not have a witness

904
00:45:53,720 --> 00:45:58,760
contradiction so so the local

905
00:45:55,920 --> 00:46:02,079
consistency really follows from the

906
00:45:58,760 --> 00:46:05,839
soundness of the bar and all we need is

907
00:46:02,079 --> 00:46:08,359
is a a semi-adaptive soundness of the

908
00:46:05,839 --> 00:46:10,520
bar because if you're somewhere not

909
00:46:08,359 --> 00:46:12,520
local consistency not not local

910
00:46:10,520 --> 00:46:16,240
consistent even if there's you don't

911
00:46:12,520 --> 00:46:17,800
need to be even if there's one gate and

912
00:46:16,240 --> 00:46:20,319
which you're not local consistency only

913
00:46:17,800 --> 00:46:22,559
probility Epsilon Epson can be one overk

914
00:46:20,319 --> 00:46:26,200
can be very

915
00:46:22,559 --> 00:46:28,200
small i i i the the claim is on each and

916
00:46:26,200 --> 00:46:30,839
every gate local consisten hold this

917
00:46:28,200 --> 00:46:30,839
property one man is

918
00:46:31,079 --> 00:46:35,720
negligible because otherwise take that

919
00:46:33,319 --> 00:46:37,880
gate and then that gate we're gonna kind

920
00:46:35,720 --> 00:46:38,920
of cheat in the barg that's the instance

921
00:46:37,880 --> 00:46:41,040
that in which we're going to cheat on

922
00:46:38,920 --> 00:46:41,040
the

923
00:46:41,240 --> 00:46:47,319
bar so that's uh that's local

924
00:46:45,359 --> 00:46:49,880
consistency and now you can ask what

925
00:46:47,319 --> 00:46:53,680
about the non- signaling and the non

926
00:46:49,880 --> 00:46:55,680
signaling really follows from the fact

927
00:46:53,680 --> 00:46:58,680
from the index

928
00:46:55,680 --> 00:47:02,520
hiding and and so okay so let's go to

929
00:46:58,680 --> 00:47:02,520
the N so are we okay with local

930
00:47:02,680 --> 00:47:08,960
consistency okay any questions before I

931
00:47:05,920 --> 00:47:08,960
run actually

932
00:47:09,440 --> 00:47:15,680
yeah okay oh sorry I changed yeah sorry

933
00:47:12,440 --> 00:47:17,839
this is J thanks sorry about that this

934
00:47:15,680 --> 00:47:20,680
is yeah so I I give you all this is kind

935
00:47:17,839 --> 00:47:25,839
of an index uh language so I give the

936
00:47:20,680 --> 00:47:30,359
instances are oh ah sorry no these are

937
00:47:25,839 --> 00:47:32,800
all for all I I just J is a specific J

938
00:47:30,359 --> 00:47:35,119
so I don't want to J is the one that I'm

939
00:47:32,800 --> 00:47:39,119
binding on but I give

940
00:47:35,119 --> 00:47:42,800
you the the instances are yeah all of

941
00:47:39,119 --> 00:47:45,319
them are I sorry j is the specific one

942
00:47:42,800 --> 00:47:50,079
on which I'm G to be uh I'm G to cheat

943
00:47:45,319 --> 00:47:50,079
on all all them are sorry about the

944
00:47:53,000 --> 00:47:58,319
yeah any any other questions

945
00:47:59,040 --> 00:48:05,400
okay so so now the question is uh now

946
00:48:02,760 --> 00:48:07,920
what about non- signaling and non thing

947
00:48:05,400 --> 00:48:12,800
I don't want to go into a lot of depth

948
00:48:07,920 --> 00:48:16,040
but um let me be handwavy here uh the

949
00:48:12,800 --> 00:48:19,720
idea why we're non so we want to argue

950
00:48:16,040 --> 00:48:23,079
that the local assignment generator the

951
00:48:19,720 --> 00:48:27,400
the assignment values that he gives for

952
00:48:23,079 --> 00:48:30,680
any subset of wires do not depend on the

953
00:48:27,400 --> 00:48:33,359
other wires that is given to him okay so

954
00:48:30,680 --> 00:48:35,720
if we look if the extractor is given a

955
00:48:33,359 --> 00:48:37,480
bunch of wires and you look at the

956
00:48:35,720 --> 00:48:39,960
assignment on a

957
00:48:37,480 --> 00:48:43,520
subset the the distribution of the

958
00:48:39,960 --> 00:48:45,760
assignment that the that you get it it

959
00:48:43,520 --> 00:48:48,040
looks the same no matter what the other

960
00:48:45,760 --> 00:48:52,200
the rest of the the wires

961
00:48:48,040 --> 00:48:56,839
are and why is that it just follows from

962
00:48:52,200 --> 00:49:01,160
the fact that um did I I just erased it

963
00:48:56,839 --> 00:49:04,480
here uh so it follows from the fact

964
00:49:01,160 --> 00:49:07,799
that when we do a summer extractable

965
00:49:04,480 --> 00:49:10,040
hash with many when we uh construct a

966
00:49:07,799 --> 00:49:12,040
somewh extractable hash with many

967
00:49:10,040 --> 00:49:14,920
indices that were extractable on many

968
00:49:12,040 --> 00:49:17,839
indices we want to have the

969
00:49:14,920 --> 00:49:20,119
property that even if we extracted on

970
00:49:17,839 --> 00:49:20,119
some

971
00:49:21,119 --> 00:49:27,520
indices the the index hiding still holds

972
00:49:24,880 --> 00:49:28,960
for the other so in other words think of

973
00:49:27,520 --> 00:49:30,680
where the way we're going to construct

974
00:49:28,960 --> 00:49:32,599
the sum extractible hash is by

975
00:49:30,680 --> 00:49:35,640
repetition okay we're going to repeat it

976
00:49:32,599 --> 00:49:41,000
many many times so even if even if you

977
00:49:35,640 --> 00:49:44,079
saw if I extracted wire i1 wire I2 wire

978
00:49:41,000 --> 00:49:47,040
I3 the indexes indices behind the other

979
00:49:44,079 --> 00:49:52,359
wires are completely

980
00:49:47,040 --> 00:49:54,640
hidden okay so here when when uh when I

981
00:49:52,359 --> 00:49:56,440
when you look at extract and subset of

982
00:49:54,640 --> 00:49:57,440
witnesses how do you find extract on

983
00:49:56,440 --> 00:49:59,200
these

984
00:49:57,440 --> 00:50:02,160
how how does the how does the local

985
00:49:59,200 --> 00:50:04,319
assignment generator generate these

986
00:50:02,160 --> 00:50:05,839
these wires he gener these wires using

987
00:50:04,319 --> 00:50:09,400
the corresponding trap

988
00:50:05,839 --> 00:50:12,760
doors without the other trap doors so he

989
00:50:09,400 --> 00:50:12,760
actually has no

990
00:50:13,000 --> 00:50:17,960
idea this should not signal anything

991
00:50:15,480 --> 00:50:20,799
about the other the other the value of

992
00:50:17,960 --> 00:50:23,960
the other wires okay so again let me say

993
00:50:20,799 --> 00:50:27,559
it again the maybe I didn't say say it

994
00:50:23,960 --> 00:50:31,280
quite right but the local assignment

995
00:50:27,559 --> 00:50:35,319
generator when he he runs the cheating

996
00:50:31,280 --> 00:50:37,319
prover and the cheating prover he when

997
00:50:35,319 --> 00:50:40,359
you extract from the cheating

998
00:50:37,319 --> 00:50:42,200
prover the value of some of the wires

999
00:50:40,359 --> 00:50:44,000
you need only to do that using the trap

1000
00:50:42,200 --> 00:50:47,119
doors for these

1001
00:50:44,000 --> 00:50:49,040
wires the cheating Prov has no idea what

1002
00:50:47,119 --> 00:50:52,160
the other wires what the trap door of

1003
00:50:49,040 --> 00:50:55,599
the other wires are so these values

1004
00:50:52,160 --> 00:50:57,520
should not depend at all about the other

1005
00:50:55,599 --> 00:51:00,400
a indices

1006
00:50:57,520 --> 00:51:03,359
used in the other repetitions otherwise

1007
00:51:00,400 --> 00:51:07,200
you broke IND ex hiding for these

1008
00:51:03,359 --> 00:51:12,119
repetitions okay so so the point is the

1009
00:51:07,200 --> 00:51:13,720
the the a non signaling really follows

1010
00:51:12,119 --> 00:51:16,920
in a sense from the non- signaling in

1011
00:51:13,720 --> 00:51:18,480
the in in the summer extractable hash

1012
00:51:16,920 --> 00:51:21,440
the summer extractable hash when we

1013
00:51:18,480 --> 00:51:26,319
repeat when we do repetition what we can

1014
00:51:21,440 --> 00:51:27,160
argue is any cheating prover who given

1015
00:51:26,319 --> 00:51:30,400
uh

1016
00:51:27,160 --> 00:51:35,359
hash key generates a

1017
00:51:30,400 --> 00:51:39,200
value if you extract some of the

1018
00:51:35,359 --> 00:51:41,760
wir the value you get do not depend on

1019
00:51:39,200 --> 00:51:44,520
the other indices this is kind of a

1020
00:51:41,760 --> 00:51:47,559
property of the Su extractable hash so

1021
00:51:44,520 --> 00:51:50,200
non signaling here falls directly from

1022
00:51:47,559 --> 00:51:52,640
the non- signaling of the Su extractable

1023
00:51:50,200 --> 00:51:55,160
hash okay so I'm running out of time I

1024
00:51:52,640 --> 00:51:56,799
don't want to go too much in in depth

1025
00:51:55,160 --> 00:51:59,760
because I find I think it's not as

1026
00:51:56,799 --> 00:52:02,799
interesting I want to actually go and

1027
00:51:59,760 --> 00:52:04,359
talk about why is this not sufficient

1028
00:52:02,799 --> 00:52:08,599
and when is it

1029
00:52:04,359 --> 00:52:11,559
sufficient okay so let's so let's call

1030
00:52:08,599 --> 00:52:13,880
let's say okay so we have suppose we we

1031
00:52:11,559 --> 00:52:16,960
have a cheating prover we manag to to

1032
00:52:13,880 --> 00:52:19,440
construct from him this local assignment

1033
00:52:16,960 --> 00:52:21,920
generator so we have the

1034
00:52:19,440 --> 00:52:25,040
circuit we want to we we have a cheating

1035
00:52:21,920 --> 00:52:26,520
prover he gave me an X we want to argue

1036
00:52:25,040 --> 00:52:28,440
it's in the language it must if he

1037
00:52:26,520 --> 00:52:30,960
convinced me it must me the language

1038
00:52:28,440 --> 00:52:33,680
that's what soundness means what do we

1039
00:52:30,960 --> 00:52:35,280
know we know when we look at any window

1040
00:52:33,680 --> 00:52:37,040
everything looks good and when you look

1041
00:52:35,280 --> 00:52:38,839
at the window that contains the output

1042
00:52:37,040 --> 00:52:42,160
it's

1043
00:52:38,839 --> 00:52:45,079
one does that mean we can have like an

1044
00:52:42,160 --> 00:52:46,520
entire uh assignment to all the wires

1045
00:52:45,079 --> 00:52:49,160
that everything is consistent in which

1046
00:52:46,520 --> 00:52:53,280
case we can then

1047
00:52:49,160 --> 00:52:58,440
sound so can we piece these things

1048
00:52:53,280 --> 00:52:58,440
together okay so a

1049
00:53:02,640 --> 00:53:08,200
so the answer is yes and

1050
00:53:05,440 --> 00:53:10,559
no okay so in general for

1051
00:53:08,200 --> 00:53:12,720
NP the answer is no we don't know how to

1052
00:53:10,559 --> 00:53:15,280
piece it together moreover we believe

1053
00:53:12,720 --> 00:53:17,880
that you can't piece it together for any

1054
00:53:15,280 --> 00:53:20,079
NP language like we

1055
00:53:17,880 --> 00:53:23,599
believe

1056
00:53:20,079 --> 00:53:25,480
that it's just there exist very hard NP

1057
00:53:23,599 --> 00:53:27,880
languages that there's no way you can

1058
00:53:25,480 --> 00:53:30,559
piece it together but let me tell you

1059
00:53:27,880 --> 00:53:31,640
why why does why is it hard to piece

1060
00:53:30,559 --> 00:53:35,359
things

1061
00:53:31,640 --> 00:53:37,240
together and the reason is even you know

1062
00:53:35,359 --> 00:53:39,280
let's even think now for Simplicity I

1063
00:53:37,240 --> 00:53:42,720
think it would be easier to think let's

1064
00:53:39,280 --> 00:53:45,760
say even in the non-adaptive version X

1065
00:53:42,720 --> 00:53:51,160
is fixed can we argue that for this

1066
00:53:45,760 --> 00:53:53,799
fixed X we have a like we can we can uh

1067
00:53:51,160 --> 00:53:55,440
a piece everything together and the

1068
00:53:53,799 --> 00:53:57,880
reason why it's hard to piece everything

1069
00:53:55,440 --> 00:54:00,280
together is because because this local

1070
00:53:57,880 --> 00:54:01,480
assignment generator every time you give

1071
00:54:00,280 --> 00:54:05,000
him a bunch of

1072
00:54:01,480 --> 00:54:07,680
wires he even think think of a a even a

1073
00:54:05,000 --> 00:54:10,319
valid kind of approver okay this think

1074
00:54:07,680 --> 00:54:12,240
of a valid prover every time you run him

1075
00:54:10,319 --> 00:54:14,319
he uses different Witnesses maybe has

1076
00:54:12,240 --> 00:54:16,200
many many witnesses in his disposal

1077
00:54:14,319 --> 00:54:18,400
every time you run him he's honest but

1078
00:54:16,200 --> 00:54:19,799
with a different witness okay so it's

1079
00:54:18,400 --> 00:54:22,280
actually in the language but the

1080
00:54:19,799 --> 00:54:24,720
question is are we able to construct

1081
00:54:22,280 --> 00:54:27,359
kind of a satisfying assignment and the

1082
00:54:24,720 --> 00:54:28,160
reason why this is hard is or seems hard

1083
00:54:27,359 --> 00:54:30,839
is

1084
00:54:28,160 --> 00:54:32,720
because okay we have our local local

1085
00:54:30,839 --> 00:54:35,200
assignment generator we give him a bunch

1086
00:54:32,720 --> 00:54:36,280
of wires he chooses one of his Witnesses

1087
00:54:35,200 --> 00:54:37,799
at random because that's what the

1088
00:54:36,280 --> 00:54:39,880
cheating prover does and gives an

1089
00:54:37,799 --> 00:54:42,520
assignment with this the witness okay

1090
00:54:39,880 --> 00:54:44,400
local consistent we're fine we're happy

1091
00:54:42,520 --> 00:54:49,079
now we run him again he uses a different

1092
00:54:44,400 --> 00:54:51,640
witness it doesn't match things like you

1093
00:54:49,079 --> 00:54:53,520
know how do we match things together so

1094
00:54:51,640 --> 00:54:56,440
that's why in the non-deterministic case

1095
00:54:53,520 --> 00:54:57,799
things are really difficult okay and we

1096
00:54:56,440 --> 00:55:00,160
do have some results but for very

1097
00:54:57,799 --> 00:55:02,200
specific languages let me not go into

1098
00:55:00,160 --> 00:55:05,520
that let's talk about the teristic

1099
00:55:02,200 --> 00:55:07,599
languages that seems to be much easier

1100
00:55:05,520 --> 00:55:10,160
so let me first convince you that we can

1101
00:55:07,599 --> 00:55:15,680
do it and then I'll show you where I

1102
00:55:10,160 --> 00:55:17,760
cheated okay so let's first take a a

1103
00:55:15,680 --> 00:55:19,760
circuit we have a local assignment

1104
00:55:17,760 --> 00:55:22,480
generator so let me convince you that

1105
00:55:19,760 --> 00:55:27,520
that one must be one okay so we have an

1106
00:55:22,480 --> 00:55:27,520
input X1 up to xn

1107
00:55:27,720 --> 00:55:31,680
okay I'm going to call my local

1108
00:55:29,760 --> 00:55:33,280
assignment generator I'm going to tell

1109
00:55:31,680 --> 00:55:36,079
them give me the values

1110
00:55:33,280 --> 00:55:37,760
here or here let me I have L right so

1111
00:55:36,079 --> 00:55:41,319
let me use my L here here and here I

1112
00:55:37,760 --> 00:55:43,839
don't know he gives me values now this

1113
00:55:41,319 --> 00:55:46,240
must be consistent because I know local

1114
00:55:43,839 --> 00:55:49,160
consistency hold to one minus negligible

1115
00:55:46,240 --> 00:55:51,240
so and all of them are consistent okay

1116
00:55:49,160 --> 00:55:53,400
which means these are the correct values

1117
00:55:51,240 --> 00:55:56,400
now we're deterministic okay we're

1118
00:55:53,400 --> 00:55:58,599
talking about a deterministic circuit

1119
00:55:56,400 --> 00:55:59,799
so if this is locally consistent it

1120
00:55:58,599 --> 00:56:01,400
means this is the correct value I know

1121
00:55:59,799 --> 00:56:05,559
if it's an and it's an and whatever it

1122
00:56:01,400 --> 00:56:07,960
is so all these are correct I can argue

1123
00:56:05,559 --> 00:56:10,960
when I run the cheating the assignment J

1124
00:56:07,960 --> 00:56:14,400
so I want to argue essentially

1125
00:56:10,960 --> 00:56:16,920
any the local assignment generator every

1126
00:56:14,400 --> 00:56:18,039
wire he gives me must be the correct one

1127
00:56:16,920 --> 00:56:19,319
and then I'm done because the output is

1128
00:56:18,039 --> 00:56:21,880
the correct and if he gives me output

1129
00:56:19,319 --> 00:56:24,680
one voila it's the correct I'm

1130
00:56:21,880 --> 00:56:27,280
done so I'm going to argue kind of by

1131
00:56:24,680 --> 00:56:31,760
induction that every y or given me must

1132
00:56:27,280 --> 00:56:33,359
be the correct one why okay let's try

1133
00:56:31,760 --> 00:56:34,880
layer layer so I'm going to argue kind

1134
00:56:33,359 --> 00:56:37,359
of layer by the induction is going to be

1135
00:56:34,880 --> 00:56:39,480
by the think of the uh circuit as

1136
00:56:37,359 --> 00:56:42,760
layered and I'm going to argue this by

1137
00:56:39,480 --> 00:56:44,359
induction on the layers okay layer one

1138
00:56:42,760 --> 00:56:47,079
what does the cheating prover gives me

1139
00:56:44,359 --> 00:56:49,480
he gives me assignment now I know I

1140
00:56:47,079 --> 00:56:51,760
proved it's locally satisfiable which

1141
00:56:49,480 --> 00:56:55,520
means it satisfies the gate so it's

1142
00:56:51,760 --> 00:56:56,960
correct so layer one correct let's go to

1143
00:56:55,520 --> 00:56:59,079
Layer Two

1144
00:56:56,960 --> 00:57:01,240
Layer Two he G now I I'm going to ask

1145
00:56:59,079 --> 00:57:03,680
him this let's say I'm going to ask him

1146
00:57:01,240 --> 00:57:07,160
these I want to argue that this is

1147
00:57:03,680 --> 00:57:10,720
correct all I know is that it's locally

1148
00:57:07,160 --> 00:57:14,359
consistent but I know that these are

1149
00:57:10,720 --> 00:57:18,200
correct why are these correct because of

1150
00:57:14,359 --> 00:57:21,799
the non signaling I know if I asked give

1151
00:57:18,200 --> 00:57:24,960
me kind of these wires uh give me these

1152
00:57:21,799 --> 00:57:26,799
wires with kind of the input it was

1153
00:57:24,960 --> 00:57:30,160
correct I got the the correct

1154
00:57:26,799 --> 00:57:32,079
answer so now when I ask the extract the

1155
00:57:30,160 --> 00:57:33,480
local assignment generator give me these

1156
00:57:32,079 --> 00:57:36,480
wires with

1157
00:57:33,480 --> 00:57:39,240
these that we said the distribution is

1158
00:57:36,480 --> 00:57:42,400
the same up to computationally

1159
00:57:39,240 --> 00:57:46,079
distinguishable so when I asked him give

1160
00:57:42,400 --> 00:57:48,119
me kind of uh the value of this wire

1161
00:57:46,079 --> 00:57:50,079
when I asked with the kind of with the

1162
00:57:48,119 --> 00:57:52,839
inputs or and I asked give me these

1163
00:57:50,079 --> 00:57:54,640
wires with this it's the same

1164
00:57:52,839 --> 00:57:57,119
distribution was correct before it's

1165
00:57:54,640 --> 00:57:59,440
correct now so these are correct and

1166
00:57:57,119 --> 00:58:03,559
this is locally consistent so this is

1167
00:57:59,440 --> 00:58:05,559
also correct so these layers are correct

1168
00:58:03,559 --> 00:58:08,520
and and and again now let's look at

1169
00:58:05,559 --> 00:58:10,440
these is this correct yeah because this

1170
00:58:08,520 --> 00:58:12,480
these still need to be correct because

1171
00:58:10,440 --> 00:58:14,039
we argued it's correct and it doesn't

1172
00:58:12,480 --> 00:58:15,760
depend on the distribution it doesn't

1173
00:58:14,039 --> 00:58:17,760
depend on the every time I ask him this

1174
00:58:15,760 --> 00:58:19,599
I get corre one minus negligible so

1175
00:58:17,760 --> 00:58:22,039
correct so this is

1176
00:58:19,599 --> 00:58:25,640
correct by induction the output is

1177
00:58:22,039 --> 00:58:28,000
correct I know it's one that's what the

1178
00:58:25,640 --> 00:58:31,839
the local generator promised me so it's

1179
00:58:28,000 --> 00:58:31,839
one and correct I'm

1180
00:58:33,520 --> 00:58:38,319
done

1181
00:58:35,640 --> 00:58:40,319
okay that's the proof moreover let me

1182
00:58:38,319 --> 00:58:44,280
tell you something when we wrote this

1183
00:58:40,319 --> 00:58:46,880
proof we wrote it we were happy with it

1184
00:58:44,280 --> 00:58:48,319
we literally almost submitted this thing

1185
00:58:46,880 --> 00:58:51,039
a couple days before the deadline we

1186
00:58:48,319 --> 00:58:52,799
noticed there's a bug this is wrong this

1187
00:58:51,039 --> 00:58:55,559
does not

1188
00:58:52,799 --> 00:58:56,920
work okay I'll tell you why it doesn't

1189
00:58:55,559 --> 00:58:59,000
work as a suppos to asking because I

1190
00:58:56,920 --> 00:59:00,520
think it's so subtle but if does anybody

1191
00:58:59,000 --> 00:59:02,400
see why it doesn't it's very very hard

1192
00:59:00,520 --> 00:59:05,079
to see in my opinion but uh I mean

1193
00:59:02,400 --> 00:59:07,720
clearly I didn't see it but anybody see

1194
00:59:05,079 --> 00:59:09,640
why why I cheated

1195
00:59:07,720 --> 00:59:13,319
here

1196
00:59:09,640 --> 00:59:13,319
yeah restricted

1197
00:59:15,119 --> 00:59:20,480
deterministic inut yeah so what why yeah

1198
00:59:18,520 --> 00:59:21,680
there's only the input the actually the

1199
00:59:20,480 --> 00:59:23,760
fact that there's deterministic it's

1200
00:59:21,680 --> 00:59:26,280
helpful for us because now there's a

1201
00:59:23,760 --> 00:59:27,520
notion of correctness once there's a

1202
00:59:26,280 --> 00:59:29,720
there's no what do you mean correct

1203
00:59:27,520 --> 00:59:31,559
depends on the witness every wire has

1204
00:59:29,720 --> 00:59:34,400
like if use this witness it can be this

1205
00:59:31,559 --> 00:59:36,760
value here because it's deterministic

1206
00:59:34,400 --> 00:59:38,520
there's only one value for each wire and

1207
00:59:36,760 --> 00:59:41,280
so there's the notion of

1208
00:59:38,520 --> 00:59:43,839
correct

1209
00:59:41,280 --> 00:59:46,280
value and I can argue by induction that

1210
00:59:43,839 --> 00:59:46,280
everything is

1211
00:59:51,960 --> 01:00:01,440
correct okay I um a so I'll tell

1212
00:59:57,359 --> 01:00:04,640
you why I you know I I I suffered

1213
01:00:01,440 --> 01:00:06,680
through this I I have the like desire to

1214
01:00:04,640 --> 01:00:08,839
have you like to torture you a little

1215
01:00:06,680 --> 01:00:10,960
bit to see why and so like I like the

1216
01:00:08,839 --> 01:00:12,520
experience I had but I'll given that you

1217
01:00:10,960 --> 01:00:17,400
only have like 10 minutes left I'll tell

1218
01:00:12,520 --> 01:00:17,400
you so okay so here's

1219
01:00:17,799 --> 01:00:20,799
why

1220
01:00:21,240 --> 01:00:26,799
so local

1221
01:00:23,640 --> 01:00:31,039
consistency holds or or yeah everything

1222
01:00:26,799 --> 01:00:33,520
like local consistency holds with

1223
01:00:31,039 --> 01:00:35,799
probability or or the noning everything

1224
01:00:33,520 --> 01:00:38,400
holds with probability one minus

1225
01:00:35,799 --> 01:00:40,520
negligible not with probability one if

1226
01:00:38,400 --> 01:00:42,680
everything was with probability one one

1227
01:00:40,520 --> 01:00:45,520
you know local consistency this then

1228
01:00:42,680 --> 01:00:48,400
this cons probility one this then

1229
01:00:45,520 --> 01:00:51,200
everything would work out okay if if I

1230
01:00:48,400 --> 01:00:53,200
promised you local cons probability one

1231
01:00:51,200 --> 01:00:55,720
and non signability one like it's

1232
01:00:53,200 --> 01:00:57,400
exactly the same we're good then I can

1233
01:00:55,720 --> 01:00:59,520
Pro

1234
01:00:57,400 --> 01:01:02,720
now it's you in cryptography oh command

1235
01:00:59,520 --> 01:01:05,599
negligible it's zero okay here it's not

1236
01:01:02,720 --> 01:01:07,920
zero turns out negligible is a pain this

1237
01:01:05,599 --> 01:01:09,280
is the entire problem the negligible and

1238
01:01:07,920 --> 01:01:12,160
I'll tell you why it seems weird but

1239
01:01:09,280 --> 01:01:15,720
here is why the reason

1240
01:01:12,160 --> 01:01:18,599
is this is correct with all the ne

1241
01:01:15,720 --> 01:01:20,079
probability so this is correct except

1242
01:01:18,599 --> 01:01:22,720
probability

1243
01:01:20,079 --> 01:01:24,400
mu this is correct except with

1244
01:01:22,720 --> 01:01:26,559
probability

1245
01:01:24,400 --> 01:01:29,240
me but now

1246
01:01:26,559 --> 01:01:31,240
this is correct if this needs to be

1247
01:01:29,240 --> 01:01:33,640
correct and this needs to be correct if

1248
01:01:31,240 --> 01:01:37,160
one of them is incorrect you're not

1249
01:01:33,640 --> 01:01:40,319
correct so this is correct probity

1250
01:01:37,160 --> 01:01:44,599
correct exact probability to

1251
01:01:40,319 --> 01:01:46,720
Mu so here you have two mu now two mu is

1252
01:01:44,599 --> 01:01:49,400
also

1253
01:01:46,720 --> 01:01:53,119
negligible this is also corre except 2

1254
01:01:49,400 --> 01:01:55,079
mu but this for this to be correct both

1255
01:01:53,119 --> 01:01:59,200
of them need to be correct so here you

1256
01:01:55,079 --> 01:02:01,680
have four mu and then 8 mu you're going

1257
01:01:59,200 --> 01:02:05,920
to get two to the depth times

1258
01:02:01,680 --> 01:02:05,920
mu now if the depth is more than

1259
01:02:06,960 --> 01:02:10,799
log it's not negligible

1260
01:02:12,160 --> 01:02:18,240
anymore so the problem is two to depth

1261
01:02:14,799 --> 01:02:18,240
may be much bigger than one over

1262
01:02:18,279 --> 01:02:22,279
mu so it's this kind of there's this

1263
01:02:20,720 --> 01:02:26,680
exponential

1264
01:02:22,279 --> 01:02:29,839
curse of of of we carry kind of the air

1265
01:02:26,680 --> 01:02:31,640
Grows by factor of two each time and

1266
01:02:29,839 --> 01:02:35,680
eventually can kill

1267
01:02:31,640 --> 01:02:39,480
us that's the bug so this works if it's

1268
01:02:35,680 --> 01:02:42,640
bounded depth log depth yes more than

1269
01:02:39,480 --> 01:02:44,760
that not

1270
01:02:42,640 --> 01:02:49,599
clear

1271
01:02:44,760 --> 01:02:53,240
okay so what do we do so to fix

1272
01:02:49,599 --> 01:02:55,200
this there is two ways to fix this

1273
01:02:53,240 --> 01:02:56,359
option number one which is what we did

1274
01:02:55,200 --> 01:02:58,960
originally cuz we we didn't have a

1275
01:02:56,359 --> 01:03:01,160
better idea is we said you know what

1276
01:02:58,960 --> 01:03:03,640
let's assume that the circuit is very

1277
01:03:01,160 --> 01:03:06,480
narrow like think of bound depth

1278
01:03:03,640 --> 01:03:09,279
deterministic computations okay where

1279
01:03:06,480 --> 01:03:11,440
not sorry bounded space so think of DET

1280
01:03:09,279 --> 01:03:14,079
computation where each configuration is

1281
01:03:11,440 --> 01:03:17,559
like very small so like a TR machine you

1282
01:03:14,079 --> 01:03:20,680
know that has very uh it's kind of the

1283
01:03:17,559 --> 01:03:23,720
Tableau is very thin and long and then

1284
01:03:20,680 --> 01:03:26,960
we said you know what let's make L like

1285
01:03:23,720 --> 01:03:29,119
where you're statistically bound it on

1286
01:03:26,960 --> 01:03:31,880
let's make it an entire configuration so

1287
01:03:29,119 --> 01:03:34,799
yeah you pay with an entire kind of with

1288
01:03:31,880 --> 01:03:37,119
a space the snar the proof will grow

1289
01:03:34,799 --> 01:03:40,559
with the space but now we say you can

1290
01:03:37,119 --> 01:03:42,440
read the entire thing you can read so

1291
01:03:40,559 --> 01:03:44,160
here here is the Tableau you can read

1292
01:03:42,440 --> 01:03:47,000
the entire computation you can read the

1293
01:03:44,160 --> 01:03:49,000
entire configuration and now we say the

1294
01:03:47,000 --> 01:03:52,079
first configuration is correct probility

1295
01:03:49,000 --> 01:03:54,880
mu the second configuration if this was

1296
01:03:52,079 --> 01:03:57,200
correct it's this is two Mew three me

1297
01:03:54,880 --> 01:04:00,720
four me it doesn't grow exponential

1298
01:03:57,200 --> 01:04:01,839
anymore cuz you read the entire thing so

1299
01:04:00,720 --> 01:04:04,200
I'm going to read these two

1300
01:04:01,839 --> 01:04:06,000
configurations together if this was

1301
01:04:04,200 --> 01:04:07,640
consistent this is consistent there's

1302
01:04:06,000 --> 01:04:11,279
always an usability of error that I'm in

1303
01:04:07,640 --> 01:04:13,039
cran fine but it doesn't double because

1304
01:04:11,279 --> 01:04:15,200
I'm reading the entire thing I said if

1305
01:04:13,039 --> 01:04:17,400
this was a a correct

1306
01:04:15,200 --> 01:04:19,160
configuration then when I read this with

1307
01:04:17,400 --> 01:04:21,039
this this is going to be correct

1308
01:04:19,160 --> 01:04:23,160
configuration but I read the entire

1309
01:04:21,039 --> 01:04:28,520
thing so I don't double up

1310
01:04:23,160 --> 01:04:31,039
things so we get we get snark for any

1311
01:04:28,520 --> 01:04:33,520
computation that's bounded space where

1312
01:04:31,039 --> 01:04:36,119
the snar grows with the

1313
01:04:33,520 --> 01:04:37,359
space okay but let me tell you we can do

1314
01:04:36,119 --> 01:04:38,480
better we can actually we don't need to

1315
01:04:37,359 --> 01:04:41,000
grow with the

1316
01:04:38,480 --> 01:04:42,160
space so I'll just say a word because

1317
01:04:41,000 --> 01:04:45,799
I'm running out of time and I want to

1318
01:04:42,160 --> 01:04:48,119
kind of do a quick summary so but the

1319
01:04:45,799 --> 01:04:51,079
idea of not running into this

1320
01:04:48,119 --> 01:04:55,079
exponential curse idea is to say the

1321
01:04:51,079 --> 01:04:57,599
following you know let's do this hash

1322
01:04:55,079 --> 01:05:00,440
and Bar so what did we do this this snar

1323
01:04:57,599 --> 01:05:02,440
is like hash all the wires and then bar

1324
01:05:00,440 --> 01:05:05,160
the idea is don't do hash and Bar in the

1325
01:05:02,440 --> 01:05:08,000
original circuit don't just do hash and

1326
01:05:05,160 --> 01:05:11,240
Bar in the verification circuit do hash

1327
01:05:08,000 --> 01:05:14,240
and bar on an extended circuit change

1328
01:05:11,240 --> 01:05:17,119
the circuit do hash and a slightly more

1329
01:05:14,240 --> 01:05:18,559
elaborate circuit so what is the more

1330
01:05:17,119 --> 01:05:20,880
elaborate circuit let me give you an

1331
01:05:18,559 --> 01:05:27,079
example one example you can

1332
01:05:20,880 --> 01:05:29,000
do take each kind of um layer here and

1333
01:05:27,079 --> 01:05:31,599
add a miracle hash in the

1334
01:05:29,000 --> 01:05:33,359
circuit so now before you had a a

1335
01:05:31,599 --> 01:05:35,960
verification circuit change it a little

1336
01:05:33,359 --> 01:05:38,240
bit how how do you change it you compute

1337
01:05:35,960 --> 01:05:40,640
each one and then you compute kind of a

1338
01:05:38,240 --> 01:05:42,720
miracle hash compute the next layer and

1339
01:05:40,640 --> 01:05:44,920
compute a miracle hash compute the next

1340
01:05:42,720 --> 01:05:47,839
layer compute a mle hash it's weird like

1341
01:05:44,920 --> 01:05:50,400
why would you do that do that moreover

1342
01:05:47,839 --> 01:05:51,799
also compute for every wire like the

1343
01:05:50,400 --> 01:05:54,480
opening of the Merkel

1344
01:05:51,799 --> 01:05:55,640
hash add add all these Merkel hashes and

1345
01:05:54,480 --> 01:05:57,359
add all these opening to the circle

1346
01:05:55,640 --> 01:05:59,200
circuit now that seems a ridiculous

1347
01:05:57,359 --> 01:06:00,920
thing to do why would you add to the

1348
01:05:59,200 --> 01:06:04,000
Circuit that you're trying to verify

1349
01:06:00,920 --> 01:06:07,520
that it's correct for each wire Merle

1350
01:06:04,000 --> 01:06:11,079
has all the wires and add kind of wires

1351
01:06:07,520 --> 01:06:14,039
that check opening like what this sounds

1352
01:06:11,079 --> 01:06:16,799
really weird and not a very like a weird

1353
01:06:14,039 --> 01:06:18,359
thing to do or sorry you know you don't

1354
01:06:16,799 --> 01:06:20,599
need to check opening just add Merkel

1355
01:06:18,359 --> 01:06:22,520
hashes add for each wire add moral hash

1356
01:06:20,599 --> 01:06:26,119
to the wire for each layer add a miracle

1357
01:06:22,520 --> 01:06:28,240
hash so on so forth why is adding

1358
01:06:26,119 --> 01:06:31,319
hashes helpful at

1359
01:06:28,240 --> 01:06:35,440
all so I'll tell you why it's helpful

1360
01:06:31,319 --> 01:06:37,520
because now we have the local assignment

1361
01:06:35,440 --> 01:06:39,640
generator and now in the local

1362
01:06:37,520 --> 01:06:43,319
assignment generator what we can do we

1363
01:06:39,640 --> 01:06:45,920
said the first layer each one is

1364
01:06:43,319 --> 01:06:49,559
correct now we're going to argue this

1365
01:06:45,920 --> 01:06:53,039
implies that the meracle root is

1366
01:06:49,559 --> 01:06:55,799
correct that this must be correct now

1367
01:06:53,039 --> 01:06:58,279
when we argue it we do pay exponential

1368
01:06:55,799 --> 01:07:01,160
with the depth so this is a computation

1369
01:06:58,279 --> 01:07:03,760
and the air does grow but the depth is

1370
01:07:01,160 --> 01:07:06,760
long Miracle hash is a very low depth

1371
01:07:03,760 --> 01:07:11,559
computation so it grows but perally it's

1372
01:07:06,760 --> 01:07:13,640
okay now when we read things here we're

1373
01:07:11,559 --> 01:07:15,319
going to read them together with a root

1374
01:07:13,640 --> 01:07:18,920
we're not going to just we're going to

1375
01:07:15,319 --> 01:07:21,440
say the when we ask the local assignment

1376
01:07:18,920 --> 01:07:24,520
generator what is the value give me the

1377
01:07:21,440 --> 01:07:26,039
value here here here we're gonna also

1378
01:07:24,520 --> 01:07:28,880
say and

1379
01:07:26,039 --> 01:07:31,319
give me the value of the root and the

1380
01:07:28,880 --> 01:07:34,039
and the paths corresponding to this and

1381
01:07:31,319 --> 01:07:36,079
this and now the thing is the following

1382
01:07:34,039 --> 01:07:38,240
if the root was

1383
01:07:36,079 --> 01:07:39,960
correct both of them have to be correct

1384
01:07:38,240 --> 01:07:42,559
unless you broke the hash

1385
01:07:39,960 --> 01:07:45,319
function so you you don't need to get

1386
01:07:42,559 --> 01:07:47,680
this Independence before we were like oh

1387
01:07:45,319 --> 01:07:51,079
we needed this to be correct and this to

1388
01:07:47,680 --> 01:07:54,520
be correct and things doubl here we can

1389
01:07:51,079 --> 01:07:56,880
say if the root is correct we know that

1390
01:07:54,520 --> 01:07:58,640
both of them have to be correct

1391
01:07:56,880 --> 01:08:01,599
so it's enough to argue that the root is

1392
01:07:58,640 --> 01:08:03,880
correct so it's kind of a little bit

1393
01:08:01,599 --> 01:08:06,559
simulates the case of like reading the

1394
01:08:03,880 --> 01:08:08,799
entire config the entire configuration

1395
01:08:06,559 --> 01:08:10,119
or an entire layer which is what we did

1396
01:08:08,799 --> 01:08:12,920
in the bounded

1397
01:08:10,119 --> 01:08:15,640
space so I don't want to go I think

1398
01:08:12,920 --> 01:08:20,239
that's all I want to say but essentially

1399
01:08:15,640 --> 01:08:22,239
what I want to mention is this local

1400
01:08:20,239 --> 01:08:27,199
satisfiability or local soundness or

1401
01:08:22,239 --> 01:08:29,359
local uh uh a consistency

1402
01:08:27,199 --> 01:08:31,480
does not necessarily imply Global

1403
01:08:29,359 --> 01:08:33,920
correctness actually to use it to get

1404
01:08:31,480 --> 01:08:37,040
Global correctness often we need to kind

1405
01:08:33,920 --> 01:08:39,120
of change the circuit and kind of do

1406
01:08:37,040 --> 01:08:41,920
kind of circuit gymnastics in weird ways

1407
01:08:39,120 --> 01:08:43,880
to get it to work and this is still kind

1408
01:08:41,920 --> 01:08:46,799
of work in progress it's still kind of

1409
01:08:43,880 --> 01:08:48,600
uh us as a community are still uh

1410
01:08:46,799 --> 01:08:50,040
combating with this I see smiled because

1411
01:08:48,600 --> 01:08:52,839
my students have been suffering with me

1412
01:08:50,040 --> 01:08:54,319
through this L's like I don't know half

1413
01:08:52,839 --> 01:08:56,759
smiling half

1414
01:08:54,319 --> 01:08:59,920
crying but but

1415
01:08:56,759 --> 01:09:02,960
uh uh yeah so that's kind of uh where we

1416
01:08:59,920 --> 01:09:05,359
are today so let me use the last 3

1417
01:09:02,960 --> 01:09:07,920
minutes or so to do kind of a quick

1418
01:09:05,359 --> 01:09:12,440
summary so first of all before I

1419
01:09:07,920 --> 01:09:14,719
summarize there's um a if you have any

1420
01:09:12,440 --> 01:09:18,279
feedback there's feedback forms please

1421
01:09:14,719 --> 01:09:20,480
submit so I you know I'll improve uh uh

1422
01:09:18,279 --> 01:09:22,520
or I'll keep on doing things that worked

1423
01:09:20,480 --> 01:09:25,000
to try not to do things that didn't work

1424
01:09:22,520 --> 01:09:27,480
so uh it's it'll be great great great if

1425
01:09:25,000 --> 01:09:29,520
you if uh you can submit the feedback

1426
01:09:27,480 --> 01:09:32,120
form that would be really really helpful

1427
01:09:29,520 --> 01:09:35,120
uh and okay so with that uh let me just

1428
01:09:32,120 --> 01:09:40,279
I want to kind of reflect a couple

1429
01:09:35,120 --> 01:09:43,560
minutes on this journey and and where we

1430
01:09:40,279 --> 01:09:45,040
are and how you know so if you remember

1431
01:09:43,560 --> 01:09:47,120
you know we started by saying look

1432
01:09:45,040 --> 01:09:49,400
proofs has been has been something that

1433
01:09:47,120 --> 01:09:52,080
you know uh mathematicians have been

1434
01:09:49,400 --> 01:09:54,679
working with and uh thinking about for

1435
01:09:52,080 --> 01:09:57,960
thousands of years and proofs have

1436
01:09:54,679 --> 01:10:01,480
always been very specific form of like

1437
01:09:57,960 --> 01:10:04,040
logic deductions and this changed kind

1438
01:10:01,480 --> 01:10:06,560
of the cryptography changed this with

1439
01:10:04,040 --> 01:10:09,280
the introduction with the thinking about

1440
01:10:06,560 --> 01:10:11,520
zero knowledge proofs they defined this

1441
01:10:09,280 --> 01:10:15,239
notion of interactive proof a new proof

1442
01:10:11,520 --> 01:10:18,880
model and this new way of thinking about

1443
01:10:15,239 --> 01:10:23,280
proofs was kind of a a huge huge success

1444
01:10:18,880 --> 01:10:26,679
story for cryptography for complexity um

1445
01:10:23,280 --> 01:10:29,640
and it kind of we noticed that these

1446
01:10:26,679 --> 01:10:31,760
interactive proof systems turned out to

1447
01:10:29,640 --> 01:10:34,040
be very very powerful and this kind of

1448
01:10:31,760 --> 01:10:37,600
the main work that kind of uh

1449
01:10:34,040 --> 01:10:39,159
demonstrated that was the uh um sub Che

1450
01:10:37,600 --> 01:10:41,719
protocol that was kind of the first

1451
01:10:39,159 --> 01:10:43,760
protocol that wow you can do something

1452
01:10:41,719 --> 01:10:46,520
that we have no idea how to do

1453
01:10:43,760 --> 01:10:48,440
classically and that kind of gave birth

1454
01:10:46,520 --> 01:10:50,719
to the IP equals peace space theorem

1455
01:10:48,440 --> 01:10:54,920
once you had the the Su check from that

1456
01:10:50,719 --> 01:10:58,480
kind of uh with a little more work uh

1457
01:10:54,920 --> 01:11:00,560
you can do the IP equals uh P space uh

1458
01:10:58,480 --> 01:11:03,320
theorem and what we showed in this class

1459
01:11:00,560 --> 01:11:06,880
is actually we kind of went through uh

1460
01:11:03,320 --> 01:11:10,040
gkr so we we we showed that if you have

1461
01:11:06,880 --> 01:11:13,159
a su check you can get actually a just

1462
01:11:10,040 --> 01:11:17,360
by a very simple idea of kind of uh

1463
01:11:13,159 --> 01:11:20,280
doing snar H Su check layer by layer you

1464
01:11:17,360 --> 01:11:22,719
can get an interactive a succinct

1465
01:11:20,280 --> 01:11:24,560
interactive proof for any bound to depth

1466
01:11:22,719 --> 01:11:25,880
computation that's doubly efficient so

1467
01:11:24,560 --> 01:11:28,600
the pro is efficient

1468
01:11:25,880 --> 01:11:29,560
and the verifier is is uh succinct or

1469
01:11:28,600 --> 01:11:31,719
very

1470
01:11:29,560 --> 01:11:34,560
efficient and then we showed kind of the

1471
01:11:31,719 --> 01:11:37,199
IP equals P space as a quary showed that

1472
01:11:34,560 --> 01:11:39,719
you can get PCP from it uh and then we

1473
01:11:37,199 --> 01:11:41,760
moved to arguments said well okay that's

1474
01:11:39,719 --> 01:11:43,679
where we are with proofs uh with

1475
01:11:41,760 --> 01:11:46,520
statistical soundness and then we said

1476
01:11:43,679 --> 01:11:49,199
well if you're willing to rely to to

1477
01:11:46,520 --> 01:11:51,719
reduce soundness to computational

1478
01:11:49,199 --> 01:11:54,320
soundness then we saw the kilan mik you

1479
01:11:51,719 --> 01:11:58,239
can get everything like really efficient

1480
01:11:54,320 --> 01:12:00,480
uh Interactive arguments by T think PCP

1481
01:11:58,239 --> 01:12:02,760
and kind of hashing them

1482
01:12:00,480 --> 01:12:04,480
down and then there was a question okay

1483
01:12:02,760 --> 01:12:05,199
we can have intractive arguments can we

1484
01:12:04,480 --> 01:12:07,880
have

1485
01:12:05,199 --> 01:12:11,080
snars can we eliminate intraction and

1486
01:12:07,880 --> 01:12:12,320
then we talked about F uh kind of went

1487
01:12:11,080 --> 01:12:13,520
through kind of zero knowledge a little

1488
01:12:12,320 --> 01:12:17,040
bit because that's the first time where

1489
01:12:13,520 --> 01:12:18,960
F proved security of it was uh in the

1490
01:12:17,040 --> 01:12:23,040
context of zero

1491
01:12:18,960 --> 01:12:25,280
knowledge but then we showed or Jen Jang

1492
01:12:23,040 --> 01:12:28,480
showed that actually you can do F also

1493
01:12:25,280 --> 01:12:31,800
the context of bars so we have an

1494
01:12:28,480 --> 01:12:33,679
interactive uh batch argument and you

1495
01:12:31,800 --> 01:12:35,600
can or a constructed interractive batch

1496
01:12:33,679 --> 01:12:37,520
argument showed you can use I don't know

1497
01:12:35,600 --> 01:12:41,159
it didn't get into detail but turns out

1498
01:12:37,520 --> 01:12:45,760
you can use similar techniques to uh to

1499
01:12:41,159 --> 01:12:47,920
show F secure or these techniques Plus+

1500
01:12:45,760 --> 01:12:49,719
to show that F secure when apply to the

1501
01:12:47,920 --> 01:12:52,719
interactive batch argument and then you

1502
01:12:49,719 --> 01:12:55,920
get like a this non- interractive

1503
01:12:52,719 --> 01:12:58,639
bar and today kind of to close the this

1504
01:12:55,920 --> 01:13:01,600
entire Journey we showed how to get uh

1505
01:12:58,639 --> 01:13:04,560
snars from these bars and as I said we

1506
01:13:01,600 --> 01:13:06,480
have it for deterministic computation we

1507
01:13:04,560 --> 01:13:08,600
have it for some non-deterministic

1508
01:13:06,480 --> 01:13:12,560
computation constructing it for all of

1509
01:13:08,600 --> 01:13:14,960
NP is still a major open question uh so

1510
01:13:12,560 --> 01:13:16,600
you know I invite you all to work on it

1511
01:13:14,960 --> 01:13:19,280
with me but I want to say one more thing

1512
01:13:16,600 --> 01:13:21,560
about this area which is it's really

1513
01:13:19,280 --> 01:13:23,920
nice because this is one example where

1514
01:13:21,560 --> 01:13:26,239
this area has a beautiful beautiful math

1515
01:13:23,920 --> 01:13:30,320
in my opinion so it's very theoretical

1516
01:13:26,239 --> 01:13:32,960
with beautiful mathematical ideas and

1517
01:13:30,320 --> 01:13:35,880
applied so this is kind of this area has

1518
01:13:32,960 --> 01:13:37,840
been a really nice kind of bonding

1519
01:13:35,880 --> 01:13:40,520
between kind of theoreticians and

1520
01:13:37,840 --> 01:13:43,000
practitioners these things are used uh

1521
01:13:40,520 --> 01:13:44,239
in particular by a lot of bankers and uh

1522
01:13:43,000 --> 01:13:46,560
you know people started using

1523
01:13:44,239 --> 01:13:48,080
blockchains and now B Bank systems and

1524
01:13:46,560 --> 01:13:52,800
so on are interested in it so it's been

1525
01:13:48,080 --> 01:13:56,679
kind of um a really nice a example where

1526
01:13:52,800 --> 01:13:59,159
really beautiful theory is is used like

1527
01:13:56,679 --> 01:14:02,400
the theory itself is really uh deployed

1528
01:13:59,159 --> 01:14:03,880
and used so it's um it's kind of uh I

1529
01:14:02,400 --> 01:14:05,800
think this is an example of success

1530
01:14:03,880 --> 01:14:08,000
story for theoretical

1531
01:14:05,800 --> 01:14:12,560
cryptography okay thank you guys it was

1532
01:14:08,000 --> 01:14:12,560
really really fun teaching you thank you

