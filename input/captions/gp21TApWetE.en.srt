1
00:00:13,519 --> 00:00:16,920
okay um so what is

2
00:00:18,240 --> 00:00:23,119
gkr can you guys read this it's too big

3
00:00:20,400 --> 00:00:23,119
too small

4
00:00:26,840 --> 00:00:32,320
SL okay so the idea is given a circuit c

5
00:00:30,880 --> 00:00:34,000
um we're going to instead of having to

6
00:00:32,320 --> 00:00:36,360
complete the entire c c by yourself you

7
00:00:34,000 --> 00:00:38,040
can delegate it to a who do the comption

8
00:00:36,360 --> 00:00:41,360
for you and prove it the competion is

9
00:00:38,040 --> 00:00:43,360
correct in an interative protocol um and

10
00:00:41,360 --> 00:00:47,719
the main idea of how you can do it so

11
00:00:43,360 --> 00:00:47,719
let's say the depth sorry dep

12
00:00:48,199 --> 00:00:52,920
D and size s

13
00:00:50,800 --> 00:00:55,960
circuit um what you're going to do is

14
00:00:52,920 --> 00:00:58,120
you're going to take every single layer

15
00:00:55,960 --> 00:01:01,600
of the circuit um Extended to a low

16
00:00:58,120 --> 00:01:01,600
degree extension

17
00:01:02,879 --> 00:01:07,759
um so this is going to be

18
00:01:05,200 --> 00:01:10,600
the so basically take all the wire

19
00:01:07,759 --> 00:01:12,880
values on each layer find a LC extension

20
00:01:10,600 --> 00:01:15,759
of it um and then you're going to have

21
00:01:12,880 --> 00:01:18,000
some LC extension of each layer so layer

22
00:01:15,759 --> 00:01:19,720
is going to be v z then it's V1 second

23
00:01:18,000 --> 00:01:23,159
layer and so

24
00:01:19,720 --> 00:01:25,000
on the final layer is going to be and

25
00:01:23,159 --> 00:01:26,439
the way gkr works is essentially as

26
00:01:25,000 --> 00:01:28,759
follows you're going to reduce some

27
00:01:26,439 --> 00:01:30,439
claims about the top layer the out layer

28
00:01:28,759 --> 00:01:31,640
to claims about layers it and you're

29
00:01:30,439 --> 00:01:32,880
going to keep doing this until you reach

30
00:01:31,640 --> 00:01:35,640
the bottom layer at which point the

31
00:01:32,880 --> 00:01:38,439
verifier can check themselves um so at

32
00:01:35,640 --> 00:01:40,759
the beginning you might have that um the

33
00:01:38,439 --> 00:01:43,280
output gate you want this to be equal to

34
00:01:40,759 --> 00:01:46,759
zero um you're going to reduce this um

35
00:01:43,280 --> 00:01:48,920
via SL check protocol um to two claims

36
00:01:46,759 --> 00:01:53,920
um so let's call these

37
00:01:48,920 --> 00:01:57,560
z11 equals maybe the value V1 one um and

38
00:01:53,920 --> 00:02:02,240
also the claim that the L extension on a

39
00:01:57,560 --> 00:02:03,680
second point is also to be a different

40
00:02:02,240 --> 00:02:05,360
value if you want to and this is done

41
00:02:03,680 --> 00:02:07,240
sub

42
00:02:05,360 --> 00:02:09,399
protocol um and then you can do this

43
00:02:07,240 --> 00:02:11,400
again um so left show how to kind do

44
00:02:09,399 --> 00:02:15,160
this in a two to two fashion we're going

45
00:02:11,400 --> 00:02:15,160
reduce two claims to two CLS

46
00:02:22,879 --> 00:02:27,040
next I'm just going to keep going at the

47
00:02:25,120 --> 00:02:31,840
end you're going to reduce your to the

48
00:02:27,040 --> 00:02:31,840
claim about the out layer um so maybe

49
00:02:40,080 --> 00:02:44,239
zd1 okay and at this point in time um

50
00:02:42,760 --> 00:02:47,640
this is just a low deegree extension of

51
00:02:44,239 --> 00:02:49,239
all the input Gates which is size n um

52
00:02:47,640 --> 00:02:50,720
the verifier knows what all these inputs

53
00:02:49,239 --> 00:02:53,000
are so they can compute the low degree

54
00:02:50,720 --> 00:02:55,280
tension by themselves um and so alog

55
00:02:53,000 --> 00:02:59,120
together this is going to take the

56
00:02:55,280 --> 00:03:00,280
prover time polys to prove um the

57
00:02:59,120 --> 00:03:02,840
competition and correctly to the

58
00:03:00,280 --> 00:03:06,159
verifier and the verifier will

59
00:03:02,840 --> 00:03:09,599
run in time um let's see it's going to

60
00:03:06,159 --> 00:03:09,599
be D * poly log

61
00:03:09,959 --> 00:03:14,799
s um plus like n * main poly log s

62
00:03:15,120 --> 00:03:21,480
also okay is this is we did last time

63
00:03:17,599 --> 00:03:26,360
yeah can you go over how using the same

64
00:03:21,480 --> 00:03:28,159
Randomness you to just do the way down

65
00:03:26,360 --> 00:03:30,000
right so the idea is instead of having

66
00:03:28,159 --> 00:03:31,360
to run a different some protocol call

67
00:03:30,000 --> 00:03:33,280
with independent Randomness for each of

68
00:03:31,360 --> 00:03:35,280
these two claims what you can do is use

69
00:03:33,280 --> 00:03:37,760
the same Randomness for both um for both

70
00:03:35,280 --> 00:03:39,760
claims simultaneously and turns out that

71
00:03:37,760 --> 00:03:40,959
the um the G you have to check at the

72
00:03:39,760 --> 00:03:43,239
very bottom at the end of Thum check

73
00:03:40,959 --> 00:03:44,799
protocol will be based on um the

74
00:03:43,239 --> 00:03:46,599
randomness that was used during from the

75
00:03:44,799 --> 00:03:47,879
verifier point of view so as long as the

76
00:03:46,599 --> 00:03:49,439
same Randomness using both of these

77
00:03:47,879 --> 00:03:51,480
things then you'll have to reduce the

78
00:03:49,439 --> 00:03:54,040
same to like final checks at the very

79
00:03:51,480 --> 00:03:57,959
bottom of the S

80
00:03:54,040 --> 00:04:00,519
Check um yeah okay

81
00:03:57,959 --> 00:04:03,760
um cool um and maybe I should also just

82
00:04:00,519 --> 00:04:05,400
tell you um yeah I also wanted to write

83
00:04:03,760 --> 00:04:06,879
out like sort of sub check like equation

84
00:04:05,400 --> 00:04:09,360
just because we have it um for later

85
00:04:06,879 --> 00:04:10,599
because it's going to be important uh

86
00:04:09,360 --> 00:04:12,159
you have this entire board already which

87
00:04:10,599 --> 00:04:13,480
kind of awkward so maybe I'll put it

88
00:04:12,159 --> 00:04:18,320
somewhere

89
00:04:13,480 --> 00:04:19,759
else yeah oh there maybe okay I guess I

90
00:04:18,320 --> 00:04:21,639
told a camera man we wouldn't use that

91
00:04:19,759 --> 00:04:23,919
for but I'll just put it here because it

92
00:04:21,639 --> 00:04:25,120
shouldn't be important I guess um or

93
00:04:23,919 --> 00:04:26,320
like it would be important for us but

94
00:04:25,120 --> 00:04:30,880
like we did it last time so hopefully it

95
00:04:26,320 --> 00:04:30,880
won't be new um okay

96
00:04:31,800 --> 00:04:35,759
so you're checking a element of like the

97
00:04:34,400 --> 00:04:37,919
ice layer you want introduce it to two

98
00:04:35,759 --> 00:04:39,639
things in the previous layer um and so

99
00:04:37,919 --> 00:04:43,680
what you can do is you can take an

100
00:04:39,639 --> 00:04:46,039
output gate and two input

101
00:04:43,680 --> 00:04:48,520
Gates um and it's going to this giant

102
00:04:46,039 --> 00:04:48,520
thing

103
00:04:50,840 --> 00:04:57,160
so so whether or not it was um uh adgate

104
00:04:57,360 --> 00:05:03,720
times one

105
00:05:00,320 --> 00:05:03,720
times whether like times the sum of

106
00:05:17,040 --> 00:05:20,129
[Music]

107
00:05:27,600 --> 00:05:32,600
it and then you need to take the logic

108
00:05:29,720 --> 00:05:32,600
extension

109
00:05:33,039 --> 00:05:36,680
um okay and so as the equation what's

110
00:05:35,680 --> 00:05:38,600
going to happen is you're going to

111
00:05:36,680 --> 00:05:41,000
essentially do a sub check um with this

112
00:05:38,600 --> 00:05:43,120
entire thing here as a polinomial in

113
00:05:41,000 --> 00:05:44,560
your sub check so we'll come back to

114
00:05:43,120 --> 00:05:48,120
this later we'll just leave

115
00:05:44,560 --> 00:05:51,400
it yeah is a polinomial of

116
00:05:48,120 --> 00:05:53,880
degree um want to say it's like the size

117
00:05:51,400 --> 00:05:57,479
of H maybe in each variable so

118
00:05:53,880 --> 00:06:00,319
individual degree size um H minus one um

119
00:05:57,479 --> 00:06:02,600
or is just take it over

120
00:06:00,319 --> 00:06:05,360
which is the m um and it's going to

121
00:06:02,600 --> 00:06:08,599
basically test the quality of Z and P so

122
00:06:05,360 --> 00:06:10,080
if Z if p is in this like hyper Cube um

123
00:06:08,599 --> 00:06:14,080
then it should be one if and only if p

124
00:06:10,080 --> 00:06:14,080
is equal to Z and then L exension of

125
00:06:18,039 --> 00:06:21,680
that okay so today we're going to ask

126
00:06:20,280 --> 00:06:24,400
some questions okay so we show we knew

127
00:06:21,680 --> 00:06:26,639
how to do this um so last time show how

128
00:06:24,400 --> 00:06:28,199
to do this as long as we had Oracle

129
00:06:26,639 --> 00:06:30,120
access to the add in M

130
00:06:28,199 --> 00:06:31,759
Gates okay

131
00:06:30,120 --> 00:06:33,520
so the goal of the first part of today's

132
00:06:31,759 --> 00:06:34,960
class is to remove this Oracle axis

133
00:06:33,520 --> 00:06:37,120
we're going to show how to get these

134
00:06:34,960 --> 00:06:38,319
things um okay actually we have already

135
00:06:37,120 --> 00:06:42,960
a little bit more in this board so I

136
00:06:38,319 --> 00:06:47,800
guess like so question one is um how to

137
00:06:42,960 --> 00:06:47,800
get these um low degree tensions

138
00:06:49,800 --> 00:06:56,720
um okay um maybe you guys can tell me do

139
00:06:52,400 --> 00:06:56,720
you have any ideas how can we get these

140
00:07:00,639 --> 00:07:05,440
so I feel like onon is bouncing which

141
00:07:02,319 --> 00:07:05,440
clearly means he something to

142
00:07:06,599 --> 00:07:11,919
say

143
00:07:08,360 --> 00:07:13,280
circuit description okay good okay so

144
00:07:11,919 --> 00:07:14,720
maybe I'm saying something like maybe

145
00:07:13,280 --> 00:07:18,080
you can compute these things yourself

146
00:07:14,720 --> 00:07:19,479
somehow if you can artize it um um and

147
00:07:18,080 --> 00:07:21,400
we're going to see to do this in a sec

148
00:07:19,479 --> 00:07:23,080
um another way to do it is we already

149
00:07:21,400 --> 00:07:25,919
know how to do gkr like we already know

150
00:07:23,080 --> 00:07:28,639
how to sort of delegate a circuit right

151
00:07:25,919 --> 00:07:31,520
so let's red delegate the Adam mod Gates

152
00:07:28,639 --> 00:07:31,520
um so

153
00:07:33,319 --> 00:07:38,440
so we're going to Red delegate

154
00:07:36,319 --> 00:07:40,080
atote um and this is indeed what they do

155
00:07:38,440 --> 00:07:42,280
in the original gkr

156
00:07:40,080 --> 00:07:44,120
paper um but we're not going to do it

157
00:07:42,280 --> 00:07:45,360
today so this is another thing you could

158
00:07:44,120 --> 00:07:48,720
do but today we're going to show how to

159
00:07:45,360 --> 00:07:50,440
compute them um actually this is a bit

160
00:07:48,720 --> 00:07:51,840
weird because we're actually going to

161
00:07:50,440 --> 00:07:53,960
compute the low degree extensions of

162
00:07:51,840 --> 00:07:55,879
these added mode circuits we actually

163
00:07:53,960 --> 00:07:58,599
can compute like a different somewhat

164
00:07:55,879 --> 00:08:00,280
low degree polinomial on these that

165
00:07:58,599 --> 00:08:04,080
share the same values on like the hybrid

166
00:08:00,280 --> 00:08:08,400
Cube um so it's actually not going to

167
00:08:04,080 --> 00:08:11,639
be the conical

168
00:08:08,400 --> 00:08:13,319
LD um I think last time Leo had said

169
00:08:11,639 --> 00:08:15,520
something about like can you use a

170
00:08:13,319 --> 00:08:16,560
different like low degree polinomial and

171
00:08:15,520 --> 00:08:20,159
the answer here is yes and we're going

172
00:08:16,560 --> 00:08:22,919
to see application today so um

173
00:08:20,159 --> 00:08:25,120
Okay Okay cool so the idea is like okay

174
00:08:22,919 --> 00:08:26,599
so if you want to compute them okay so

175
00:08:25,120 --> 00:08:28,479
you can't compute the actual canonical

176
00:08:26,599 --> 00:08:30,360
low degree extension um so what can you

177
00:08:28,479 --> 00:08:32,440
do well

178
00:08:30,360 --> 00:08:34,880
so

179
00:08:32,440 --> 00:08:36,440
um Okay and like the reason is basically

180
00:08:34,880 --> 00:08:37,479
because like to compu the ad mod case

181
00:08:36,440 --> 00:08:39,959
like the surface is kind of just too

182
00:08:37,479 --> 00:08:42,560
complicated for you to compute yourself

183
00:08:39,959 --> 00:08:45,480
um so maybe here's an idea what if

184
00:08:42,560 --> 00:08:47,320
instead of computing um doing gkr in the

185
00:08:45,480 --> 00:08:49,120
OR circuit we do it on a much simpler

186
00:08:47,320 --> 00:08:50,680
circuit that comp the same functionality

187
00:08:49,120 --> 00:08:55,600
as a circuit you're trying to as you

188
00:08:50,680 --> 00:08:55,600
want um so

189
00:09:01,000 --> 00:09:08,120
so idea um

190
00:09:03,920 --> 00:09:08,120
replace C with a

191
00:09:08,760 --> 00:09:12,440
simpler to describe

192
00:09:12,780 --> 00:09:17,600
[Applause]

193
00:09:15,200 --> 00:09:19,399
circuit um and I guess by simpler to

194
00:09:17,600 --> 00:09:23,160
describe I just mean that Addam Mo

195
00:09:19,399 --> 00:09:23,160
should be easily computable

196
00:09:25,470 --> 00:09:28,830
[Applause]

197
00:09:31,079 --> 00:09:35,839
okay um okay and so let's use the

198
00:09:34,160 --> 00:09:37,480
universal circuit um so universal

199
00:09:35,839 --> 00:09:39,040
circuit is going to be a circuit that's

200
00:09:37,480 --> 00:09:41,440
going to take us inputs the circuit that

201
00:09:39,040 --> 00:09:43,120
you're trying to compute along with the

202
00:09:41,440 --> 00:09:44,720
input and it's going to Output it's

203
00:09:43,120 --> 00:09:47,320
going to simulate the computation of

204
00:09:44,720 --> 00:09:49,000
your circuit C on the input X and then

205
00:09:47,320 --> 00:09:51,959
compute C of

206
00:09:49,000 --> 00:09:53,200
X okay and the claim is going to be that

207
00:09:51,959 --> 00:09:54,680
this universal circuit is going to have

208
00:09:53,200 --> 00:09:56,760
a simpler description at least for the

209
00:09:54,680 --> 00:09:58,480
addom mod Gates than the original

210
00:09:56,760 --> 00:09:59,800
circuit right because it's going to take

211
00:09:58,480 --> 00:10:00,839
us input like the descript Des of the

212
00:09:59,800 --> 00:10:02,240
circuit and then it's going to kind of

213
00:10:00,839 --> 00:10:03,920
simulate description but all these sort

214
00:10:02,240 --> 00:10:06,680
of like simulation is easy to describe

215
00:10:03,920 --> 00:10:10,120
because it's very general and very

216
00:10:06,680 --> 00:10:11,959
easy okay um so maybe let's see how this

217
00:10:10,120 --> 00:10:14,360
will work um

218
00:10:11,959 --> 00:10:15,959
so okay so we have this universal

219
00:10:14,360 --> 00:10:19,399
circuit here it's going to look like

220
00:10:15,959 --> 00:10:21,320
this um and it's going to take us input

221
00:10:19,399 --> 00:10:22,839
a description of the circuit C along

222
00:10:21,320 --> 00:10:25,880
with your input

223
00:10:22,839 --> 00:10:28,760
X um and then it's going to run um The

224
00:10:25,880 --> 00:10:30,200
Hope is that this is going to be depth D

225
00:10:28,760 --> 00:10:32,000
* po

226
00:10:30,200 --> 00:10:34,440
log

227
00:10:32,000 --> 00:10:36,639
uh maybe it should be okay okay we'll

228
00:10:34,440 --> 00:10:37,760
talk about the depth later um so it

229
00:10:36,639 --> 00:10:38,720
should be hopefully not so much bigger

230
00:10:37,760 --> 00:10:41,399
than the circuit C because you're going

231
00:10:38,720 --> 00:10:43,320
to want to do do it efficiently what is

232
00:10:41,399 --> 00:10:47,200
this description C that over here um

233
00:10:43,320 --> 00:10:47,200
this is um yeah maybe I should okay

234
00:10:49,480 --> 00:10:53,440
so okay so what is the circuit C like

235
00:10:51,880 --> 00:10:55,600
how do you want to like like how what's

236
00:10:53,440 --> 00:10:57,160
the input to this be like um where it's

237
00:10:55,600 --> 00:11:01,240
going to take it's basically going to be

238
00:10:57,160 --> 00:11:01,240
a function that will tell you um

239
00:11:01,800 --> 00:11:05,760
yeah so I guess it would tell you um for

240
00:11:03,279 --> 00:11:07,720
every single like May should be an add

241
00:11:05,760 --> 00:11:10,399
one and a mod

242
00:11:07,720 --> 00:11:12,399
one so for both add a mode it tell you

243
00:11:10,399 --> 00:11:15,639
if at a single location in the original

244
00:11:12,399 --> 00:11:17,959
circuit C if there is

245
00:11:15,639 --> 00:11:19,959
a um if there is a gate of that form or

246
00:11:17,959 --> 00:11:21,560
not so it's going to be a pretty large

247
00:11:19,959 --> 00:11:23,880
description um it's going to be size two

248
00:11:21,560 --> 00:11:23,880
to the

249
00:11:25,320 --> 00:11:29,680
s that make sense

250
00:11:30,760 --> 00:11:38,680
yeah so the circuit we're a description

251
00:11:34,720 --> 00:11:39,959
size yes what that um and as said isn't

252
00:11:38,680 --> 00:11:41,160
alluding to so it would not be so good

253
00:11:39,959 --> 00:11:42,480
for us but we'll discuss how to do

254
00:11:41,160 --> 00:11:45,480
another

255
00:11:42,480 --> 00:11:47,600
way just literally just two bit

256
00:11:45,480 --> 00:11:48,800
strings yeah yeah yeah it's just be

257
00:11:47,600 --> 00:11:52,079
really long it's going to tell you what

258
00:11:48,800 --> 00:11:56,279
every gate of the circuit looks like

259
00:11:52,079 --> 00:12:00,240
okay P W1 and W2 range over kind of like

260
00:11:56,279 --> 00:12:03,120
the the horizontal

261
00:12:00,240 --> 00:12:05,160
yeah okay maybe we should um maybe we

262
00:12:03,120 --> 00:12:06,560
have pw1 W2 range over like all the

263
00:12:05,160 --> 00:12:10,040
possible grades say so you can change

264
00:12:06,560 --> 00:12:10,040
the notation a little bit that's

265
00:12:11,959 --> 00:12:18,920
okay okay um sorry yeah I guess this is

266
00:12:17,040 --> 00:12:21,480
a very small detail how you

267
00:12:18,920 --> 00:12:23,120
hand um so what you can do this also

268
00:12:21,480 --> 00:12:24,639
actually issue original GK protocol

269
00:12:23,120 --> 00:12:26,320
right because they only have ADD mode

270
00:12:24,639 --> 00:12:29,320
what you can do is you can have X and

271
00:12:26,320 --> 00:12:32,920
then also the flip of X or the not of x

272
00:12:29,320 --> 00:12:32,920
and then now you can simulate everything

273
00:12:33,240 --> 00:12:38,000
okay okay um okay so how do you so so my

274
00:12:36,680 --> 00:12:39,320
claim is basically that this universal

275
00:12:38,000 --> 00:12:41,160
circuit is going to be much simpler to

276
00:12:39,320 --> 00:12:42,720
describe than the origion of circuit C

277
00:12:41,160 --> 00:12:44,959
and maybe let's just see why is sort of

278
00:12:42,720 --> 00:12:47,160
a hopefully not too in detail um view

279
00:12:44,959 --> 00:12:48,880
but hopefully we can kind of get idea so

280
00:12:47,160 --> 00:12:51,680
the idea is like let's say this is your

281
00:12:48,880 --> 00:12:51,680
circuit C over

282
00:12:54,240 --> 00:12:57,760
here um and it's going to be a bunch of

283
00:12:56,240 --> 00:12:59,800
layers there's a bunch of gates in each

284
00:12:57,760 --> 00:13:02,120
of the layers and they're going to each

285
00:12:59,800 --> 00:13:02,120
have some

286
00:13:03,240 --> 00:13:07,480
functionality okay and so what the

287
00:13:05,880 --> 00:13:11,399
universal circuit is basically going to

288
00:13:07,480 --> 00:13:13,760
do is it's going to say um like I want

289
00:13:11,399 --> 00:13:16,079
to compute this value of the circuit C

290
00:13:13,760 --> 00:13:17,320
gate here let me look at all the

291
00:13:16,079 --> 00:13:19,440
previous ones because you don't know

292
00:13:17,320 --> 00:13:21,120
which which one this is attached to so

293
00:13:19,440 --> 00:13:23,079
you're going to look at all the possible

294
00:13:21,120 --> 00:13:24,800
like values and you're going to sort of

295
00:13:23,079 --> 00:13:26,680
then see what the circuit C saids and

296
00:13:24,800 --> 00:13:27,920
then compute the appropriate um function

297
00:13:26,680 --> 00:13:31,279
of the previous layer based on what the

298
00:13:27,920 --> 00:13:34,040
circuit C says um so in particular

299
00:13:31,279 --> 00:13:36,720
um yeah so in particular in the ice

300
00:13:34,040 --> 00:13:38,279
layer so the value of the of the circuit

301
00:13:36,720 --> 00:13:39,440
of this thing in the ice layer is going

302
00:13:38,279 --> 00:13:42,480
to

303
00:13:39,440 --> 00:13:45,440
be so maybe this is a

304
00:13:42,480 --> 00:13:50,040
layer and this is a

305
00:13:45,440 --> 00:13:52,720
gate um and it's going to be a sum of

306
00:13:50,040 --> 00:13:54,040
possible gates in the previous layer um

307
00:13:52,720 --> 00:13:57,920
of the following thing so it's going to

308
00:13:54,040 --> 00:13:57,920
be whether C

309
00:14:02,000 --> 00:14:05,120
so it's going whether a c has a add gate

310
00:14:03,839 --> 00:14:07,240
corresponding to the three gates you're

311
00:14:05,120 --> 00:14:08,800
picking picking so this is J and then

312
00:14:07,240 --> 00:14:14,759
maybe K and K

313
00:14:08,800 --> 00:14:14,759
Prime um and then times

314
00:14:15,360 --> 00:14:19,639
uh the sum of them so it's like it's

315
00:14:18,279 --> 00:14:21,160
similar thing as in the jpr thing we're

316
00:14:19,639 --> 00:14:24,000
going to have sort of like a add and

317
00:14:21,160 --> 00:14:25,199
like a m condition um and so okay so if

318
00:14:24,000 --> 00:14:26,880
it's add gaate you're going to compute

319
00:14:25,199 --> 00:14:29,240
the

320
00:14:26,880 --> 00:14:31,399
sum and if it's a m gaug you're going to

321
00:14:29,240 --> 00:14:31,399
the

322
00:14:40,240 --> 00:14:46,600
mode that okay um wait what is the what

323
00:14:44,199 --> 00:14:49,320
is said inside the parentheses on the ad

324
00:14:46,600 --> 00:14:52,199
gate yeah okay so this is going to be

325
00:14:49,320 --> 00:14:54,600
whether the circuit is an ad gate at

326
00:14:52,199 --> 00:14:57,480
this particular three gase JK and K

327
00:14:54,600 --> 00:15:01,360
Prime um and this is going to be the

328
00:14:57,480 --> 00:15:03,480
values v um i+ 1K so what this value is

329
00:15:01,360 --> 00:15:05,199
yeah sorry so maybe this is a little bit

330
00:15:03,480 --> 00:15:07,320
small

331
00:15:05,199 --> 00:15:10,199
um okay I don't really know how to make

332
00:15:07,320 --> 00:15:10,199
this bigger

333
00:15:11,279 --> 00:15:18,279
um um yeah the subscript on the C I

334
00:15:16,199 --> 00:15:20,120
think of it as an input to yeah exactly

335
00:15:18,279 --> 00:15:21,880
so these are both going to be given from

336
00:15:20,120 --> 00:15:24,839
the the description of the circuit C

337
00:15:21,880 --> 00:15:26,000
which is will also have to take um

338
00:15:24,839 --> 00:15:28,000
description circusy and it's also going

339
00:15:26,000 --> 00:15:30,959
to read into here and this the same

340
00:15:28,000 --> 00:15:30,959
thing that's written on the

341
00:15:37,839 --> 00:15:46,040
yeah yeah sorry still hung up on this C

342
00:15:43,079 --> 00:15:50,000
is defined over three inputs all which

343
00:15:46,040 --> 00:15:52,600
range from one to S right sure okay yeah

344
00:15:50,000 --> 00:15:55,759
so why is it of size so is a table size

345
00:15:52,600 --> 00:15:57,440
like s uh good yes yes so we're going to

346
00:15:55,759 --> 00:15:59,560
have to deal with that in a bit um so

347
00:15:57,440 --> 00:16:00,880
yeah saying that the circuit here is

348
00:15:59,560 --> 00:16:03,160
like the description of circuit C is too

349
00:16:00,880 --> 00:16:06,199
big we're going to have to do something

350
00:16:03,160 --> 00:16:08,519
for that wait so why is it two the S

351
00:16:06,199 --> 00:16:11,920
though because we have sorry it's just s

352
00:16:08,519 --> 00:16:11,920
just s you're right you're right just

353
00:16:13,279 --> 00:16:17,959
SB uh s cubed oh

354
00:16:20,519 --> 00:16:24,880
yes that makes sense like um Sor I feel

355
00:16:23,480 --> 00:16:27,000
like I explained the univers really

356
00:16:24,880 --> 00:16:29,160
badly but um you're basically trying to

357
00:16:27,000 --> 00:16:31,880
simulate the computation of c um and to

358
00:16:29,160 --> 00:16:34,319
do that you're going to introduce her

359
00:16:31,880 --> 00:16:37,319
like a new circuit like a new small

360
00:16:34,319 --> 00:16:38,759
circuit for every single um gate in your

361
00:16:37,319 --> 00:16:39,800
universal circuit I will look at the

362
00:16:38,759 --> 00:16:41,360
previous layer and then canus

363
00:16:39,800 --> 00:16:43,920
appropriate functionality based on let's

364
00:16:41,360 --> 00:16:49,360
see it's supposed to

365
00:16:43,920 --> 00:16:49,360
say okay umel yeah what

366
00:16:51,920 --> 00:16:57,120
the Yeah Yeah uh so yeah so these are

367
00:16:54,839 --> 00:16:58,959
all going to be an H to the m h to the m

368
00:16:57,120 --> 00:17:01,720
here is going to be the size of like

369
00:16:58,959 --> 00:17:04,079
layer okay okay so it's going to be so P

370
00:17:01,720 --> 00:17:06,000
you can think of as being in the I layer

371
00:17:04,079 --> 00:17:07,760
and then Omega 1 and Omega 2 are in the

372
00:17:06,000 --> 00:17:12,280
I plus one's

373
00:17:07,760 --> 00:17:12,280
layer oh like

374
00:17:14,520 --> 00:17:20,360
just so that summation there really

375
00:17:16,799 --> 00:17:21,760
represents like a a c like a you're

376
00:17:20,360 --> 00:17:23,959
trying to compute that summation with a

377
00:17:21,760 --> 00:17:25,799
bunch of GES yeah yeah yeah so this is

378
00:17:23,959 --> 00:17:27,439
going to this is going to correspond to

379
00:17:25,799 --> 00:17:29,559
I'm sorry this is really bad um yeah

380
00:17:27,439 --> 00:17:31,480
this correspond to like a sort of a

381
00:17:29,559 --> 00:17:33,400
pretty big circuit here that's going to

382
00:17:31,480 --> 00:17:36,799
look at the previous layer and yeah so

383
00:17:33,400 --> 00:17:40,440
the dep of be like dep of that Min Circ

384
00:17:36,799 --> 00:17:40,440
exactly yeah that's perfect um

385
00:17:47,880 --> 00:17:53,160
so yeah so so as um I don't know what

386
00:17:50,320 --> 00:17:55,360
your name is Gabe as Gabe said um the

387
00:17:53,160 --> 00:17:57,640
depth of the circuit is going to be um

388
00:17:55,360 --> 00:17:59,679
the depth of the original Circuit of c

389
00:17:57,640 --> 00:18:01,799
um times sort of like this like depth

390
00:17:59,679 --> 00:18:03,400
here um so the question is like what is

391
00:18:01,799 --> 00:18:05,039
a depth

392
00:18:03,400 --> 00:18:08,039
here

393
00:18:05,039 --> 00:18:08,039
um

394
00:18:10,480 --> 00:18:14,960
that's like roughly I don't know that

395
00:18:12,520 --> 00:18:14,960
might be very

396
00:18:16,320 --> 00:18:22,799
cck yeah okay something Times log gu

397
00:18:18,640 --> 00:18:22,799
like poly log maybe at worse

398
00:18:30,159 --> 00:18:33,600
yeah and like the reason is because you

399
00:18:31,360 --> 00:18:37,000
can sort of think of this big sum as

400
00:18:33,600 --> 00:18:37,000
like a binary tree of

401
00:18:37,080 --> 00:18:43,880
sums and then at the very bottom of this

402
00:18:39,440 --> 00:18:46,720
binary tree you have like hly as many um

403
00:18:43,880 --> 00:18:46,720
scen you're kind of looking

404
00:18:47,280 --> 00:18:50,520
at so this this entire depth because

405
00:18:49,400 --> 00:18:53,600
it's like a binary tree it's only going

406
00:18:50,520 --> 00:18:55,760
to be like depth like log s or

407
00:18:53,600 --> 00:18:56,720
something um the depths of the universes

408
00:18:55,760 --> 00:18:59,799
are

409
00:18:56,720 --> 00:19:01,400
good yeah

410
00:18:59,799 --> 00:19:03,840
okay and what about the size of this

411
00:19:01,400 --> 00:19:03,840
universal

412
00:19:11,880 --> 00:19:15,840
circuit yeah so it's going to be the

413
00:19:13,600 --> 00:19:18,960
size original circuit um times like

414
00:19:15,840 --> 00:19:18,960
polys it's going to be

415
00:19:19,280 --> 00:19:22,880
polys um and the reason for that is

416
00:19:21,600 --> 00:19:24,960
because the size of this universal

417
00:19:22,880 --> 00:19:26,520
circuit is basically going to be for

418
00:19:24,960 --> 00:19:28,720
every gate of the original circuit you

419
00:19:26,520 --> 00:19:30,679
have this like poly s- size like circuit

420
00:19:28,720 --> 00:19:32,799
get kind of replacing it so you get like

421
00:19:30,679 --> 00:19:36,000
polys size here and then times the side

422
00:19:32,799 --> 00:19:36,000
of toal circuit which is poly

423
00:19:36,039 --> 00:19:40,280
s okay so this is going to be like part

424
00:19:38,799 --> 00:19:42,360
of what the circuit we're going to end

425
00:19:40,280 --> 00:19:44,360
up using to delegate instead of using

426
00:19:42,360 --> 00:19:46,400
the original circuit c um I guess the

427
00:19:44,360 --> 00:19:48,679
last claim that I made is that this um

428
00:19:46,400 --> 00:19:51,240
circuit U is much simpler to describe

429
00:19:48,679 --> 00:19:53,960
than the circuit c um so particular the

430
00:19:51,240 --> 00:19:56,159
adom M Gates um are easily computable or

431
00:19:53,960 --> 00:19:59,520
like describable very

432
00:19:56,159 --> 00:20:02,799
simply um and maybe let's look at this

433
00:19:59,520 --> 00:20:02,799
and think about it for a

434
00:20:04,240 --> 00:20:09,960
minute so I guess like if you're trying

435
00:20:07,080 --> 00:20:11,320
to figure out you know I have sort of

436
00:20:09,960 --> 00:20:12,360
like I'm trying to look at a specific

437
00:20:11,320 --> 00:20:14,360
gate and I want to see if it's like an

438
00:20:12,360 --> 00:20:15,440
add orote gate what you kind of do is

439
00:20:14,360 --> 00:20:17,400
you kind of figure out where in this

440
00:20:15,440 --> 00:20:18,880
tree you are right and you can be like

441
00:20:17,400 --> 00:20:20,159
oh look I'm part of this binary tree it

442
00:20:18,880 --> 00:20:22,000
should be an ad gate right and you're

443
00:20:20,159 --> 00:20:23,520
like okay I'm an ad gate or you can sort

444
00:20:22,000 --> 00:20:25,200
of read maybe in the leaves like you're

445
00:20:23,520 --> 00:20:29,280
like oh this is this this a particular

446
00:20:25,200 --> 00:20:31,039
gate corresponds to you know like some

447
00:20:29,280 --> 00:20:32,360
some ad gate in the original circuit and

448
00:20:31,039 --> 00:20:33,440
sometime some values and you kind of

449
00:20:32,360 --> 00:20:36,440
figure out oh this is supposed to be a

450
00:20:33,440 --> 00:20:37,440
mate or ad gate or something the point

451
00:20:36,440 --> 00:20:39,400
is that this is like a pretty easy

452
00:20:37,440 --> 00:20:42,320
function to describe um in

453
00:20:39,400 --> 00:20:44,840
particular

454
00:20:42,320 --> 00:20:47,080
so there's going to be low depth booing

455
00:20:44,840 --> 00:20:51,000
formulas that compute both add and mod

456
00:20:47,080 --> 00:20:52,720
Gates um so there's going to be a buing

457
00:20:51,000 --> 00:20:55,880
formula

458
00:20:52,720 --> 00:21:00,600
of um let's see so it's going to

459
00:20:55,880 --> 00:21:00,600
be so it's a buing formula

460
00:21:00,799 --> 00:21:07,400
of size poly log

461
00:21:04,400 --> 00:21:07,400
s

462
00:21:08,960 --> 00:21:11,960
um

463
00:21:13,080 --> 00:21:17,400
that I computes to add in MTI

464
00:21:18,679 --> 00:21:23,600
functionalities so it tells you that

465
00:21:20,679 --> 00:21:26,120
whether within you these um like these

466
00:21:23,600 --> 00:21:28,279
are they're small formulas that tell you

467
00:21:26,120 --> 00:21:29,840
whether a particular gate in U is AD or

468
00:21:28,279 --> 00:21:31,760
mod

469
00:21:29,840 --> 00:21:35,720
that good

470
00:21:31,760 --> 00:21:35,720
okay cool

471
00:21:36,200 --> 00:21:40,880
um okay and so now like these formulat

472
00:21:38,760 --> 00:21:43,520
are much easier to compute than the

473
00:21:40,880 --> 00:21:45,679
previous adem mode um so accessibly the

474
00:21:43,520 --> 00:21:48,279
verifier can do it themselves

475
00:21:45,679 --> 00:21:50,919
now okay

476
00:21:48,279 --> 00:21:54,279
so

477
00:21:50,919 --> 00:21:56,440
yeah ah okay so I guess

478
00:21:54,279 --> 00:21:58,320
originally yeah originally so how do you

479
00:21:56,440 --> 00:22:00,000
compute ad a mode we're we're going to I

480
00:21:58,320 --> 00:22:02,600
didn't write it yet but um you're going

481
00:22:00,000 --> 00:22:05,400
to assume that c is a log SP a uniform

482
00:22:02,600 --> 00:22:07,159
um circuit which means that you can like

483
00:22:05,400 --> 00:22:09,039
you do like maybe up to like time like

484
00:22:07,159 --> 00:22:12,960
poly s computation to compute it which

485
00:22:09,039 --> 00:22:15,200
is too much um here since the cir the

486
00:22:12,960 --> 00:22:17,520
formula is only of size poly log you can

487
00:22:15,200 --> 00:22:18,640
kind of just Compu it yourself right so

488
00:22:17,520 --> 00:22:20,600
then when you're doing gkr in the

489
00:22:18,640 --> 00:22:21,919
universal circuit you just have to do

490
00:22:20,600 --> 00:22:23,080
the small computation as opposed to the

491
00:22:21,919 --> 00:22:27,000
big

492
00:22:23,080 --> 00:22:30,000
one yeah are these like Fiat log space

493
00:22:27,000 --> 00:22:34,480
uniform um I they be log log space

494
00:22:30,000 --> 00:22:37,919
uniform oh right is that how it

495
00:22:34,480 --> 00:22:39,919
works I mean there SI fly log right like

496
00:22:37,919 --> 00:22:42,919
the so basically what I mean by this is

497
00:22:39,919 --> 00:22:44,559
like you can feed in any like P Omega

498
00:22:42,919 --> 00:22:46,080
one and Omega 2 and then computer

499
00:22:44,559 --> 00:22:47,200
formula of the size and it'll tell you

500
00:22:46,080 --> 00:22:49,840
what the answer

501
00:22:47,200 --> 00:22:51,559
is right so it's only poly log size so

502
00:22:49,840 --> 00:22:54,159
you only have is there exist a formula

503
00:22:51,559 --> 00:22:56,880
such that for all P1 Omega 1 Omega 2

504
00:22:54,159 --> 00:22:59,200
yeah the for completes itct yeah

505
00:22:56,880 --> 00:23:00,720
yeah right but yeah the naive way I

506
00:22:59,200 --> 00:23:02,039
would do it is like advice of like P

507
00:23:00,720 --> 00:23:03,520
along sides but like I'm assuming

508
00:23:02,039 --> 00:23:06,360
there's a way to make it to get rid of

509
00:23:03,520 --> 00:23:09,520
this

510
00:23:06,360 --> 00:23:12,440
right yeah I think I think it's log log

511
00:23:09,520 --> 00:23:17,400
uniform I think it's just like

512
00:23:12,440 --> 00:23:17,400
Max figure out what level I

513
00:23:33,039 --> 00:23:39,159
oh

514
00:23:34,360 --> 00:23:41,799
the yeah okay okay

515
00:23:39,159 --> 00:23:43,480
understand yeah maybe just to summarize

516
00:23:41,799 --> 00:23:45,559
what we've done um we've essentially

517
00:23:43,480 --> 00:23:48,039
replaced this like C which has a sort of

518
00:23:45,559 --> 00:23:49,400
complicated adote gate description with

519
00:23:48,039 --> 00:23:51,559
a universal circuit which has a much

520
00:23:49,400 --> 00:23:52,559
simpler adote gate description and then

521
00:23:51,559 --> 00:23:54,120
now what we're going to do is we're

522
00:23:52,559 --> 00:23:55,880
going to run JKR on the universal

523
00:23:54,120 --> 00:23:57,960
circuit instead of the original circuit

524
00:23:55,880 --> 00:23:59,679
C the output is still the same because

525
00:23:57,960 --> 00:24:02,480
univers circuit will simulate C and

526
00:23:59,679 --> 00:24:06,240
compute C of X um but now like the

527
00:24:02,480 --> 00:24:06,240
verifier can themselves compute add

528
00:24:08,480 --> 00:24:15,039
ineut have WR descri good good good um

529
00:24:12,559 --> 00:24:15,039
yeah okay

530
00:24:18,520 --> 00:24:24,799
so so now we're going to run a gkr on U

531
00:24:23,159 --> 00:24:27,000
um you call U of C because it's on the

532
00:24:24,799 --> 00:24:29,279
circuit of it's just

533
00:24:27,000 --> 00:24:32,320
U instead of

534
00:24:29,279 --> 00:24:36,480
C okay so

535
00:24:32,320 --> 00:24:36,480
issues um okay maybe I should also write

536
00:24:53,559 --> 00:25:00,440
like okay so issues so one is that on on

537
00:24:58,080 --> 00:25:02,919
pointed out which is that the input is

538
00:25:00,440 --> 00:25:08,640
now really large

539
00:25:02,919 --> 00:25:08,640
so um so in issue one um input is

540
00:25:17,260 --> 00:25:22,720
[Music]

541
00:25:19,799 --> 00:25:24,760
large okay um and if you remember from

542
00:25:22,720 --> 00:25:26,559
the GPR protocol the proof the verifier

543
00:25:24,760 --> 00:25:27,720
at the very end has to compute some

544
00:25:26,559 --> 00:25:29,039
points in the low degree extension of

545
00:25:27,720 --> 00:25:31,200
the input

546
00:25:29,039 --> 00:25:33,080
right before we said okay the input is

547
00:25:31,200 --> 00:25:35,159
only size n so they can compute it by

548
00:25:33,080 --> 00:25:37,919
themselves it's only n * proba log time

549
00:25:35,159 --> 00:25:41,440
to compute it but now the input also has

550
00:25:37,919 --> 00:25:43,200
C which is size s so now you have to

551
00:25:41,440 --> 00:25:46,960
actually spend like you know time poly s

552
00:25:43,200 --> 00:25:49,000
to compute um the the final layer which

553
00:25:46,960 --> 00:25:50,760
is bad right like we wanted the verifi

554
00:25:49,000 --> 00:25:52,440
to be efficient now we're we kind back

555
00:25:50,760 --> 00:25:57,960
to square one okay so we're going to

556
00:25:52,440 --> 00:25:57,960
deal with this um any other issues

557
00:26:03,679 --> 00:26:09,559
sorry in the gkr protocol the end

558
00:26:06,880 --> 00:26:12,080
follow do I only need to comp a couple

559
00:26:09,559 --> 00:26:14,480
bits in theut Lay or do I need

560
00:26:12,080 --> 00:26:15,399
to uh you need to read it all because

561
00:26:14,480 --> 00:26:16,919
because what you're going to do is

562
00:26:15,399 --> 00:26:19,000
you're going to look at the input layer

563
00:26:16,919 --> 00:26:19,960
and then comp something load extension

564
00:26:19,000 --> 00:26:21,200
and the only way you can do something

565
00:26:19,960 --> 00:26:22,600
load extension if you you know

566
00:26:21,200 --> 00:26:26,320
everything sort of like in the coding

567
00:26:22,600 --> 00:26:26,320
otherwise yeah

568
00:26:29,520 --> 00:26:34,159
yeah sorry I just have a question before

569
00:26:31,120 --> 00:26:37,320
even issues is it obvious the verifier

570
00:26:34,159 --> 00:26:37,320
can compute like add or

571
00:26:38,120 --> 00:26:44,120
mlda good good good um yeah

572
00:26:51,600 --> 00:26:55,600
so yeah so Nikon's question is how do

573
00:26:54,080 --> 00:26:57,480
you compute like the low degree

574
00:26:55,600 --> 00:26:59,279
extensions that Addam mod right now I've

575
00:26:57,480 --> 00:27:01,000
only given you a Bo formula to compute

576
00:26:59,279 --> 00:27:02,840
them right so you can compute the values

577
00:27:01,000 --> 00:27:04,360
on the hyper Cube but you can't

578
00:27:02,840 --> 00:27:06,200
necessarily compute the low deges of

579
00:27:04,360 --> 00:27:08,840
them um so we're going to see how to fix

580
00:27:06,200 --> 00:27:10,360
those things um and hopefully if I'm not

581
00:27:08,840 --> 00:27:12,600
mistake these are the only two issues so

582
00:27:10,360 --> 00:27:12,600
we'll

583
00:27:12,960 --> 00:27:17,679
see is this okay so far

584
00:27:31,760 --> 00:27:37,440
okay so issue one the input is now all

585
00:27:35,240 --> 00:27:40,760
of the circuit plus the original input

586
00:27:37,440 --> 00:27:44,440
so it's very large um so right now this

587
00:27:40,760 --> 00:27:46,640
is what our circuit looks like is U um

588
00:27:44,440 --> 00:27:50,279
big part is C and like a small part is

589
00:27:46,640 --> 00:27:53,760
X okay um so here's when the log space

590
00:27:50,279 --> 00:27:53,760
uniformity of C is going to come

591
00:27:54,960 --> 00:28:00,240
in um so if you ever read like you know

592
00:27:57,559 --> 00:28:02,600
GK ments um the the the theorem only

593
00:28:00,240 --> 00:28:03,840
holds for when C is log space uniform

594
00:28:02,600 --> 00:28:06,640
which means that there's some small

595
00:28:03,840 --> 00:28:06,640
description of

596
00:28:07,919 --> 00:28:12,600
it so some small log S

597
00:28:12,799 --> 00:28:16,519
size description of

598
00:28:17,440 --> 00:28:24,600
c um and let maybe let's call this

599
00:28:20,880 --> 00:28:28,399
description this um and there exist a

600
00:28:24,600 --> 00:28:28,399
turing machine m

601
00:28:29,799 --> 00:28:33,840
that

602
00:28:31,279 --> 00:28:35,679
um basically if it reason this this

603
00:28:33,840 --> 00:28:38,080
description it can then output like the

604
00:28:35,679 --> 00:28:42,960
entire ciruit

605
00:28:38,080 --> 00:28:42,960
C and this turning machine should run

606
00:28:43,279 --> 00:28:49,519
in log space um but it can run for as

607
00:28:46,919 --> 00:28:49,519
much as s

608
00:28:51,600 --> 00:29:00,799
time okay um so okay so C is too big

609
00:28:57,120 --> 00:29:01,880
yeah so is like fixed yeah m is like a

610
00:29:00,799 --> 00:29:04,760
yeah it's just it's a fixed training

611
00:29:01,880 --> 00:29:04,760
machine

612
00:29:05,279 --> 00:29:16,399
yeah yeah just to make this

613
00:29:09,960 --> 00:29:19,840
matters structure it on different

614
00:29:16,399 --> 00:29:21,519
Umi oh I think one main thing is that

615
00:29:19,840 --> 00:29:23,559
the verifier needs to be able to like

616
00:29:21,519 --> 00:29:25,159
know what c is right because like in

617
00:29:23,559 --> 00:29:26,640
order to get sort of any hold on the on

618
00:29:25,159 --> 00:29:28,480
the circus C for the verifier that they

619
00:29:26,640 --> 00:29:30,159
need to kind of have some way of like

620
00:29:28,480 --> 00:29:31,880
describing the circuit in some sense

621
00:29:30,159 --> 00:29:34,159
this is like basically saying the

622
00:29:31,880 --> 00:29:35,600
circuit has to be like log size so that

623
00:29:34,159 --> 00:29:37,080
the verifier can hold it and like you

624
00:29:35,600 --> 00:29:40,000
know have some way of knowing what

625
00:29:37,080 --> 00:29:41,279
circuit he is I guess I'm trying to

626
00:29:40,000 --> 00:29:44,240
think about like what kinds of circuits

627
00:29:41,279 --> 00:29:46,039
are exed by this like C that basically

628
00:29:44,240 --> 00:29:47,679
have to write out all like the entire

629
00:29:46,039 --> 00:29:49,840
table to describe is that what we're

630
00:29:47,679 --> 00:29:55,000
trying to get rid of uh so I think um

631
00:29:49,840 --> 00:29:55,000
Ted is our local complexity theorist so

632
00:29:59,080 --> 00:30:02,399
okay you can't

633
00:30:03,080 --> 00:30:06,080
like

634
00:30:06,559 --> 00:30:09,559
right

635
00:30:12,799 --> 00:30:16,760
yeah so C is large um and the problem

636
00:30:15,600 --> 00:30:19,360
was that reading this entire thing is

637
00:30:16,760 --> 00:30:23,799
too much but we have a short description

638
00:30:19,360 --> 00:30:26,320
of C so let's also maybe have a circuit

639
00:30:23,799 --> 00:30:27,480
that compute c um maybe we'll call this

640
00:30:26,320 --> 00:30:28,600
m just because we have a Tre machine

641
00:30:27,480 --> 00:30:31,720
called M but it's not turing machine is

642
00:30:28,600 --> 00:30:35,000
a circuit um and this circuit will take

643
00:30:31,720 --> 00:30:36,720
us input the description C like with the

644
00:30:35,000 --> 00:30:39,679
things around it um and then it will

645
00:30:36,720 --> 00:30:41,039
output the entire circuit description

646
00:30:39,679 --> 00:30:43,240
and that'll feed into the university we

647
00:30:41,039 --> 00:30:46,600
just talked

648
00:30:43,240 --> 00:30:48,440
about okay so this circuit here is our

649
00:30:46,600 --> 00:30:50,880
circuit C Prime that we will actually be

650
00:30:48,440 --> 00:30:50,880
delegating

651
00:30:55,440 --> 00:31:00,919
on um and just to be clear which one are

652
00:30:58,240 --> 00:31:03,000
the inputs inputs are this um this

653
00:31:00,919 --> 00:31:04,240
description of c and also X like this

654
00:31:03,000 --> 00:31:07,799
entire C here is now kind of wrapped

655
00:31:04,240 --> 00:31:07,799
into the circuit right

656
00:31:13,200 --> 00:31:21,360
yeah description the circuit or say run

657
00:31:17,799 --> 00:31:23,600
the circuit any um so it will you know

658
00:31:21,360 --> 00:31:25,080
run and log as space and maybe up as

659
00:31:23,600 --> 00:31:26,880
time and then it can output like maybe

660
00:31:25,080 --> 00:31:28,919
any gate of the circuit you want any

661
00:31:26,880 --> 00:31:30,000
gate of yeah maybe like you know maybe

662
00:31:28,919 --> 00:31:31,840
if you have an output tape that's

663
00:31:30,000 --> 00:31:33,240
separate from like it's actual like

664
00:31:31,840 --> 00:31:34,880
space as all you comp on you can have

665
00:31:33,240 --> 00:31:37,320
like you can just like output the G by

666
00:31:34,880 --> 00:31:37,320
one sort

667
00:31:38,880 --> 00:31:44,600
of sure yeah out put the description of

668
00:31:41,760 --> 00:31:48,679
C so or like description of the gates of

669
00:31:44,600 --> 00:31:48,679
see so like output the

670
00:31:50,639 --> 00:31:56,919
gates yeah if you just unrolling m that

671
00:31:53,880 --> 00:31:59,840
like really deep good good good okay

672
00:31:56,919 --> 00:32:01,880
yeah so what's the depth of this um so

673
00:31:59,840 --> 00:32:03,639
okay M can run in time up TOS so this

674
00:32:01,880 --> 00:32:05,399
could offensively be depth s which is

675
00:32:03,639 --> 00:32:08,600
bad because her verifi run times depends

676
00:32:05,399 --> 00:32:10,880
on um the depth also

677
00:32:08,600 --> 00:32:13,600
um well it turns out you can do it in

678
00:32:10,880 --> 00:32:14,519
depths log gu um and I'm not going to

679
00:32:13,600 --> 00:32:16,919
tell you to do it you're going to tell

680
00:32:14,519 --> 00:32:18,120
me by the end of class so that's sort of

681
00:32:16,919 --> 00:32:22,440
the goal by

682
00:32:18,120 --> 00:32:22,440
3M um and this will also be size

683
00:32:25,159 --> 00:32:29,519
s so we'll get there but um but'll your

684
00:32:28,080 --> 00:32:32,760
job to convince me and not my job to

685
00:32:29,519 --> 00:32:32,760
convince you

686
00:32:32,960 --> 00:32:37,639
um well anything else yeah wait how do

687
00:32:35,480 --> 00:32:40,440
we turn this machine into a circuit good

688
00:32:37,639 --> 00:32:40,440
okay you tell

689
00:32:43,039 --> 00:32:46,679
me don't be hints don't be hints don't

690
00:32:45,039 --> 00:32:50,039
worry so won't be you like I think

691
00:32:46,679 --> 00:32:50,039
you'll be able to figure out what

692
00:32:53,720 --> 00:32:59,279
clost okay and then the other claim is

693
00:32:56,000 --> 00:33:01,880
this is um like has easy added M Gates

694
00:32:59,279 --> 00:33:04,279
um and well also you also tell me he

695
00:33:01,880 --> 00:33:05,240
that by the CL um so basically circuit

696
00:33:04,279 --> 00:33:06,919
is going to have all the nice properties

697
00:33:05,240 --> 00:33:09,440
you want it's going to be depth log S

698
00:33:06,919 --> 00:33:11,639
size s the whole C get now C Prime is

699
00:33:09,440 --> 00:33:13,039
going to be size poly s because you is

700
00:33:11,639 --> 00:33:15,200
also size poly

701
00:33:13,039 --> 00:33:18,120
s which should probably be poly s not

702
00:33:15,200 --> 00:33:20,200
just size s

703
00:33:18,120 --> 00:33:22,919
um yeah and the total depth is going to

704
00:33:20,200 --> 00:33:24,440
be like poly log s so yeah is the

705
00:33:22,919 --> 00:33:27,840
statement the statement is like true

706
00:33:24,440 --> 00:33:31,480
table of M on C equals c on bracket C

707
00:33:27,840 --> 00:33:33,559
equal C so do we need like size of C

708
00:33:31,480 --> 00:33:35,960
different copies of

709
00:33:33,559 --> 00:33:39,159
M

710
00:33:35,960 --> 00:33:40,399
yeah sure yeah or you can think maybe

711
00:33:39,159 --> 00:33:41,720
it's a thing in like you can have like

712
00:33:40,399 --> 00:33:42,919
an output tape right where you can just

713
00:33:41,720 --> 00:33:46,200
like output everything to or that

714
00:33:42,919 --> 00:33:47,799
another thing yeah yeah I just I want to

715
00:33:46,200 --> 00:33:51,320
make

716
00:33:47,799 --> 00:33:54,240
doesn't yeah no it

717
00:33:51,320 --> 00:33:55,159
doesn't okay yeah you might have just

718
00:33:54,240 --> 00:33:58,639
said

719
00:33:55,159 --> 00:34:01,080
this line there say log s description of

720
00:33:58,639 --> 00:34:04,000
C like C brackets like C in Brackets is

721
00:34:01,080 --> 00:34:07,200
a string it's not actually like it's

722
00:34:04,000 --> 00:34:09,919
like S no this is going to be this is

723
00:34:07,200 --> 00:34:09,919
going to be log S

724
00:34:11,440 --> 00:34:16,159
size so the circuit C is size s but

725
00:34:14,560 --> 00:34:18,159
there's like a short description that

726
00:34:16,159 --> 00:34:20,079
can sort of tell you what the C is going

727
00:34:18,159 --> 00:34:22,639
to look

728
00:34:20,079 --> 00:34:25,359
like I guess a family of circuits like

729
00:34:22,639 --> 00:34:29,720
C1 CN the description could be like the

730
00:34:25,359 --> 00:34:29,720
number n that you should something

731
00:34:29,879 --> 00:34:36,800
sure yeah why is that tree there

732
00:34:33,800 --> 00:34:36,800
like

733
00:34:38,280 --> 00:34:45,440
number um so this description is size

734
00:34:41,560 --> 00:34:45,440
log s so an entire sctu is log S

735
00:34:49,079 --> 00:34:54,960
size I guess it kind of goes like this

736
00:34:51,200 --> 00:34:54,960
more than like yes

737
00:35:10,040 --> 00:35:12,320
we don't know

738
00:35:21,280 --> 00:35:26,560
how um okay so the claim is given the

739
00:35:25,040 --> 00:35:27,760
circuit and CLA giving all these

740
00:35:26,560 --> 00:35:31,000
properties you're going to prove to me

741
00:35:27,760 --> 00:35:34,680
later about um then you can do

742
00:35:31,000 --> 00:35:37,240
gkr and okay so according to our let see

743
00:35:34,680 --> 00:35:39,040
be hi I should for okay the pro is going

744
00:35:37,240 --> 00:35:41,359
to run in time polys where s is the size

745
00:35:39,040 --> 00:35:43,160
of this like new circuit T Prime this is

746
00:35:41,359 --> 00:35:45,040
size polys this is size polys so

747
00:35:43,160 --> 00:35:48,680
everything is polys and poly of poly is

748
00:35:45,040 --> 00:35:50,240
poly so it's polys um for the frer um

749
00:35:48,680 --> 00:35:53,599
and the verifier is sort of the depths

750
00:35:50,240 --> 00:35:56,599
of the circuit um plus like the input

751
00:35:53,599 --> 00:35:58,599
lens deps here this is going to be like

752
00:35:56,599 --> 00:36:01,000
I think we said it was like

753
00:35:58,599 --> 00:36:02,400
basically dep original circuit Times log

754
00:36:01,000 --> 00:36:03,920
and this is going to be really small

755
00:36:02,400 --> 00:36:05,240
it's going to be like log s so it's

756
00:36:03,920 --> 00:36:07,599
going to be overall like the same depth

757
00:36:05,240 --> 00:36:09,800
as the original circuit um and then the

758
00:36:07,599 --> 00:36:12,520
input size is now log S Plus n so it's

759
00:36:09,800 --> 00:36:12,520
not so much bigger

760
00:36:21,920 --> 00:36:27,200
either okay input I maybe yeah okay

761
00:36:25,400 --> 00:36:29,359
whatever okay um okay so the second

762
00:36:27,200 --> 00:36:31,240
issue n pointed out how do you compute

763
00:36:29,359 --> 00:36:32,800
these like the low degree extensions of

764
00:36:31,240 --> 00:36:34,800
the added mod Gates whereas we only

765
00:36:32,800 --> 00:36:37,480
currently have buing formulas that

766
00:36:34,800 --> 00:36:38,680
compute them on the I guess in this case

767
00:36:37,480 --> 00:36:42,640
it's even a boing hyper Cube it's not

768
00:36:38,680 --> 00:36:44,800
even like the H hyper Cube

769
00:36:42,640 --> 00:36:46,800
yeah okay so the idea here was like you

770
00:36:44,800 --> 00:36:49,480
wanted to ultimately get like the bottom

771
00:36:46,800 --> 00:36:51,079
layer to be size that's small yeah like

772
00:36:49,480 --> 00:36:53,280
still like this middle layer that you

773
00:36:51,079 --> 00:36:55,640
get to that has like C like when you run

774
00:36:53,280 --> 00:36:57,880
the M like that's big so at some point

775
00:36:55,640 --> 00:37:00,160
you have to be able to like get

776
00:36:57,880 --> 00:37:04,800
valuations in mle there theover would do

777
00:37:00,160 --> 00:37:07,520
it you never have to do it I

778
00:37:04,800 --> 00:37:08,839
see gu I'm just because the G the

779
00:37:07,520 --> 00:37:12,720
protocol we did last time was like only

780
00:37:08,839 --> 00:37:15,760
first circuits exension smaller

781
00:37:12,720 --> 00:37:18,160
right better what what I did is she

782
00:37:15,760 --> 00:37:19,920
extended every every layer to size s

783
00:37:18,160 --> 00:37:22,880
anyway so even if it wasn't s originally

784
00:37:19,920 --> 00:37:24,040
she extended she'd be big so I think

785
00:37:22,880 --> 00:37:25,640
sometimes s can be viewed as like sort

786
00:37:24,040 --> 00:37:28,640
of upper bound of like each layer size

787
00:37:25,640 --> 00:37:28,640
also

788
00:37:32,400 --> 00:37:37,760
okay so second issue how do we compute

789
00:37:34,240 --> 00:37:39,280
at a mod um so we have let me just write

790
00:37:37,760 --> 00:37:40,800
down what I put there I can push this up

791
00:37:39,280 --> 00:37:45,560
so we

792
00:37:40,800 --> 00:37:45,560
have these two Boolean formulas

793
00:37:49,080 --> 00:37:52,739
[Applause]

794
00:38:02,480 --> 00:38:06,319
[Applause]

795
00:38:04,880 --> 00:38:07,560
it's going to compute at aote this

796
00:38:06,319 --> 00:38:08,599
doesn't have a scoll on top because not

797
00:38:07,560 --> 00:38:11,940
the

798
00:38:08,599 --> 00:38:15,059
extension so

799
00:38:11,940 --> 00:38:15,059
[Applause]

800
00:38:31,920 --> 00:38:35,839
okay right this is what um fee of ad

801
00:38:34,040 --> 00:38:38,000
looks like it's a booing formula so it's

802
00:38:35,839 --> 00:38:39,240
like you know big tree um not big

803
00:38:38,000 --> 00:38:43,319
actually it's very small tree it's like

804
00:38:39,240 --> 00:38:45,839
poly log size um and know output at the

805
00:38:43,319 --> 00:38:45,839
end

806
00:38:46,800 --> 00:38:54,079
um yeah what your like

807
00:38:50,240 --> 00:38:56,160
um yeah out of be one of she say um so

808
00:38:54,079 --> 00:39:00,680
here's the inputs are all

809
00:38:56,160 --> 00:39:03,280
bits so so it's going to be 0 one to

810
00:39:00,680 --> 00:39:04,920
the um I guess this should be taking as

811
00:39:03,280 --> 00:39:06,640
input the size of the circuit and

812
00:39:04,920 --> 00:39:08,040
telling you whether or not that

813
00:39:06,640 --> 00:39:11,040
particular game is add or mod G it

814
00:39:08,040 --> 00:39:13,200
should be like size of like log of the

815
00:39:11,040 --> 00:39:16,880
size of the C

816
00:39:13,200 --> 00:39:16,880
Prime so this should

817
00:39:24,599 --> 00:39:32,839
be okay um

818
00:39:29,079 --> 00:39:32,839
cool and our goal is to

819
00:39:37,359 --> 00:39:46,720
compute and so here we have H is going

820
00:39:42,280 --> 00:39:49,200
to be an H um and so here m is

821
00:39:46,720 --> 00:39:53,319
like log base

822
00:39:49,200 --> 00:39:55,680
h of S

823
00:39:53,319 --> 00:39:59,040
Prime this is what we want um and this

824
00:39:55,680 --> 00:39:59,040
what we have

825
00:40:00,119 --> 00:40:03,280
um I want you to repeat again this is

826
00:40:01,839 --> 00:40:04,800
not the low degree extension this is

827
00:40:03,280 --> 00:40:06,839
going to be a low degree

828
00:40:04,800 --> 00:40:11,400
extension

829
00:40:06,839 --> 00:40:12,680
um so what do we do for Sharp set or

830
00:40:11,400 --> 00:40:17,160
sharp

831
00:40:12,680 --> 00:40:19,160
P you guys remember Yeah question is a l

832
00:40:17,160 --> 00:40:22,280
degree extension but our L degree

833
00:40:19,160 --> 00:40:24,880
extension oh okay so it's a it's a

834
00:40:22,280 --> 00:40:26,200
extension that has low degree but it's

835
00:40:24,880 --> 00:40:28,440
not that low it's like somewhat low

836
00:40:26,200 --> 00:40:29,280
maybe low to degree talking about like

837
00:40:28,440 --> 00:40:31,160
just

838
00:40:29,280 --> 00:40:32,599
extension the low and it's not going to

839
00:40:31,160 --> 00:40:34,960
be the lowest degree but it will have

840
00:40:32,599 --> 00:40:36,800
okay like low enough degree we call it

841
00:40:34,960 --> 00:40:41,040
low

842
00:40:36,800 --> 00:40:41,040
enough low enough degree

843
00:40:42,800 --> 00:40:50,000
extension

844
00:40:44,480 --> 00:40:50,000
okay so you can call this like the l e i

845
00:40:56,040 --> 00:41:00,240
d okay that okay so it's not going to be

846
00:40:58,880 --> 00:41:02,040
the low degree extension but it'll be

847
00:41:00,240 --> 00:41:05,480
like kind of it'll be

848
00:41:02,040 --> 00:41:07,079
okay okay so what do we do for Sharp P

849
00:41:05,480 --> 00:41:08,680
the other like the first class this is

850
00:41:07,079 --> 00:41:11,480
like going like three weeks

851
00:41:08,680 --> 00:41:13,800
ago um the idea there we took like a

852
00:41:11,480 --> 00:41:15,960
Boolean formula or like a like a formula

853
00:41:13,800 --> 00:41:18,640
right we like we okay let me maybe Dr

854
00:41:15,960 --> 00:41:20,079
your memory so the idea was um you want

855
00:41:18,640 --> 00:41:22,760
to count the number of satisfying

856
00:41:20,079 --> 00:41:25,359
equations to some sort of like know CSP

857
00:41:22,760 --> 00:41:28,640
you first turn this into some Boolean

858
00:41:25,359 --> 00:41:29,880
formula right and then you

859
00:41:28,640 --> 00:41:31,640
do something to it and then you can

860
00:41:29,880 --> 00:41:34,599
apply the sub check protocol so what do

861
00:41:31,640 --> 00:41:36,680
you do in the middle artize let's artize

862
00:41:34,599 --> 00:41:38,160
this thing um okay so maybe first before

863
00:41:36,680 --> 00:41:40,079
we ariti we should change the input

864
00:41:38,160 --> 00:41:42,640
formats so over here we have H here we

865
00:41:40,079 --> 00:41:44,440
have bling like the one um but what you

866
00:41:42,640 --> 00:41:47,599
can do is you can just take like maybe a

867
00:41:44,440 --> 00:41:49,319
chunk of size like this is sorry this is

868
00:41:47,599 --> 00:41:51,520
a really like Minor Detail I think

869
00:41:49,319 --> 00:41:54,359
whatever it's fine let's do it anyway um

870
00:41:51,520 --> 00:41:57,800
so this is going to be

871
00:41:54,359 --> 00:41:59,079
size um log of size of H and and then so

872
00:41:57,800 --> 00:42:01,200
this this is how many bits are going to

873
00:41:59,079 --> 00:42:03,720
be here and you're going to take H and

874
00:42:01,200 --> 00:42:08,079
you can convert it via some like

875
00:42:03,720 --> 00:42:08,079
polinomial um it's going to be a

876
00:42:08,119 --> 00:42:14,400
degree H minus one poly is going to

877
00:42:11,599 --> 00:42:19,920
convert any element h of your like you

878
00:42:14,400 --> 00:42:21,640
know your bigger set Capital H to a 01

879
00:42:19,920 --> 00:42:24,760
string and they can do this like a bunch

880
00:42:21,640 --> 00:42:24,760
of times

881
00:42:31,240 --> 00:42:35,960
okay so now we have like this like weird

882
00:42:33,440 --> 00:42:39,040
thing where you're feeding in

883
00:42:35,960 --> 00:42:41,880
h and then you get um you use a degree

884
00:42:39,040 --> 00:42:43,280
like H polinomial to convert it to like

885
00:42:41,880 --> 00:42:45,359
you know zero ones and then now you can

886
00:42:43,280 --> 00:42:46,280
feed it up through this bling formula

887
00:42:45,359 --> 00:42:47,680
and for this part we're going to just

888
00:42:46,280 --> 00:42:50,720
Aris matize

889
00:42:47,680 --> 00:42:53,280
it so what is aris matiz um just to

890
00:42:50,720 --> 00:42:53,280
recall so

891
00:42:58,319 --> 00:43:05,240
and replace it with the the polinomial a

892
00:43:00,839 --> 00:43:07,760
plus B minus a * b um and then sorry

893
00:43:05,240 --> 00:43:10,079
this this should be and not add and then

894
00:43:07,760 --> 00:43:13,400
or of a is

895
00:43:10,079 --> 00:43:16,520
just is this right is this no other way

896
00:43:13,400 --> 00:43:18,200
right this is a plus B minus a b and

897
00:43:16,520 --> 00:43:20,559
this is a *

898
00:43:18,200 --> 00:43:22,400
B right so every time there a or gate

899
00:43:20,559 --> 00:43:25,800
here you can like yeah replace it by

900
00:43:22,400 --> 00:43:29,119
this polinomial anate replace by this

901
00:43:25,800 --> 00:43:29,119
polinomial um

902
00:43:29,839 --> 00:43:33,520
okay so maybe this another Lemo that

903
00:43:31,720 --> 00:43:34,599
like y proved during the first class

904
00:43:33,520 --> 00:43:35,839
that maybe it's been too long to

905
00:43:34,599 --> 00:43:37,960
remember but maybe you can try to

906
00:43:35,839 --> 00:43:40,359
rethink about it um so the question is

907
00:43:37,960 --> 00:43:42,119
like what is the degree of the final

908
00:43:40,359 --> 00:43:45,760
polinomial you get here when you've

909
00:43:42,119 --> 00:43:45,760
arith matized it

910
00:44:00,359 --> 00:44:04,680
like yeah yeah yeah exactly so it's a

911
00:44:02,880 --> 00:44:05,920
number of sort of input Gates here I

912
00:44:04,680 --> 00:44:07,359
think that's the way she said it is a

913
00:44:05,920 --> 00:44:09,079
birth class it just number of input

914
00:44:07,359 --> 00:44:10,680
Gates times like I guess here you have

915
00:44:09,079 --> 00:44:11,599
to Times by the degree of each like sort

916
00:44:10,680 --> 00:44:14,040
of thing you're feeding in which is

917
00:44:11,599 --> 00:44:18,319
going to be H minus one um so it's going

918
00:44:14,040 --> 00:44:21,760
to be um log S Prime which is the number

919
00:44:18,319 --> 00:44:23,160
of gates on the bottom um times this is

920
00:44:21,760 --> 00:44:25,280
say h instead of hus one because it's a

921
00:44:23,160 --> 00:44:25,280
little

922
00:44:25,880 --> 00:44:29,480
shorter okay

923
00:44:27,640 --> 00:44:32,760
so this is going to be the polinomial

924
00:44:29,480 --> 00:44:35,160
that we're going to use um for adod and

925
00:44:32,760 --> 00:44:37,680
Moda so it's not the low degree tension

926
00:44:35,160 --> 00:44:40,559
but it's a good

927
00:44:37,680 --> 00:44:43,640
thing yeah over

928
00:44:40,559 --> 00:44:45,640
F2 over is right or is

929
00:44:43,640 --> 00:44:49,160
over yeah so I guess what's happening is

930
00:44:45,640 --> 00:44:53,079
you're first converting your H um over

931
00:44:49,160 --> 00:44:54,240
larger L yeah sorry yeah the way you've

932
00:44:53,079 --> 00:44:58,359
drawn it it makes it seem like you're

933
00:44:54,240 --> 00:45:00,720
converting H into log H bits but

934
00:44:58,359 --> 00:45:03,720
single ah so H is Big right H is like

935
00:45:00,720 --> 00:45:05,040
two chose a log H sort of information or

936
00:45:03,720 --> 00:45:07,319
like okay maybe it's wrong with the

937
00:45:05,040 --> 00:45:10,280
information but like like guess say like

938
00:45:07,319 --> 00:45:11,800
the H comes from um this bigger set H so

939
00:45:10,280 --> 00:45:12,800
you want to convert it to like 0er one

940
00:45:11,800 --> 00:45:14,200
so you can feed it into the boiling

941
00:45:12,800 --> 00:45:16,480
formula otherwise it's not like type

942
00:45:14,200 --> 00:45:19,720
compatible but the Boolean formula only

943
00:45:16,480 --> 00:45:22,040
takes in like like when you fix the

944
00:45:19,720 --> 00:45:27,160
Boolean formula it has a bunch of input

945
00:45:22,040 --> 00:45:30,640
that are but each you

946
00:45:27,160 --> 00:45:32,720
um so like how do you plug in log H bits

947
00:45:30,640 --> 00:45:35,079
into like an input that only have one

948
00:45:32,720 --> 00:45:37,680
bit oh okay yeah so you can convert this

949
00:45:35,079 --> 00:45:40,480
into like a number of bits it's going to

950
00:45:37,680 --> 00:45:40,480
be log H

951
00:45:50,319 --> 00:45:55,079
many yeah so the conversion isn't from

952
00:45:52,880 --> 00:45:58,760
one h symbol to one bit it's going to be

953
00:45:55,079 --> 00:46:01,119
one h symbol to many bits many but many

954
00:45:58,760 --> 00:46:01,119
it's going to be

955
00:46:01,359 --> 00:46:07,440
L I thought we just wanted to find like

956
00:46:05,000 --> 00:46:10,359
big arithmetic circuit that when you

957
00:46:07,440 --> 00:46:12,280
evaluate it when the ages are Z one it's

958
00:46:10,359 --> 00:46:13,880
equivalent to okay yeah sure so if you

959
00:46:12,280 --> 00:46:16,599
want to keep this this in 01 so you can

960
00:46:13,880 --> 00:46:17,839
have big big set here H just be 01 then

961
00:46:16,599 --> 00:46:19,800
this is just identity you can just plug

962
00:46:17,839 --> 00:46:22,800
it straight in I guess this conversion

963
00:46:19,800 --> 00:46:24,960
is sort of like a I don't know yeah

964
00:46:22,800 --> 00:46:26,599
called the thing based on whether H is

965
00:46:24,960 --> 00:46:28,319
like a bigger set so I've just been

966
00:46:26,599 --> 00:46:32,520
covering it to H is to mat that

967
00:46:28,319 --> 00:46:35,520
basically oh okay H is different than F

968
00:46:32,520 --> 00:46:35,520
okay

969
00:46:41,440 --> 00:46:48,960
okay lit just say I'm

970
00:46:45,319 --> 00:46:51,119
Ling yeah it's it's still a determin

971
00:46:48,960 --> 00:46:53,160
procedure so you'll get to like some

972
00:46:51,119 --> 00:46:53,920
unique Point given the same point it's

973
00:46:53,160 --> 00:46:57,400
just

974
00:46:53,920 --> 00:46:59,000
not y yeah yeah but it's low enough

975
00:46:57,400 --> 00:47:01,240
degree um which is going to be this

976
00:46:59,000 --> 00:47:03,440
number here right because it it's a

977
00:47:01,240 --> 00:47:06,280
really low degree it would just be H

978
00:47:03,440 --> 00:47:07,520
degree but this is a log Factor bigger

979
00:47:06,280 --> 00:47:10,559
but that's going to be okay for us

980
00:47:07,520 --> 00:47:12,160
because I guess the verifier that's fine

981
00:47:10,559 --> 00:47:15,160
I guess

982
00:47:12,160 --> 00:47:19,960
yeah yeah I'm still a little bit

983
00:47:15,160 --> 00:47:23,119
confused about like so V is um like

984
00:47:19,960 --> 00:47:25,040
basically computes for one gate right

985
00:47:23,119 --> 00:47:27,960
like that's essentially like comput like

986
00:47:25,040 --> 00:47:30,720
given one gate um SES the circuit for

987
00:47:27,960 --> 00:47:32,640
one particular G right ah no so the this

988
00:47:30,720 --> 00:47:35,359
formula yeah so the the input is going

989
00:47:32,640 --> 00:47:37,079
to be any particular like location in

990
00:47:35,359 --> 00:47:39,000
your entire circuit and it's going to

991
00:47:37,079 --> 00:47:40,880
compute in this log depths like this

992
00:47:39,000 --> 00:47:42,559
proba log size formula to tell you what

993
00:47:40,880 --> 00:47:44,440
that gug should be like whether that

994
00:47:42,559 --> 00:47:45,720
with the add gate or not so the input is

995
00:47:44,440 --> 00:47:48,960
not like the specific gate it's going to

996
00:47:45,720 --> 00:47:52,880
be like any of the gates in the entire

997
00:47:48,960 --> 00:47:54,760
c yeah so so it's okay so it's one

998
00:47:52,880 --> 00:47:57,839
formula for the entire CC yeah one

999
00:47:54,760 --> 00:48:00,240
formul for circuit um but then why are

1000
00:47:57,839 --> 00:48:03,720
you but

1001
00:48:00,240 --> 00:48:05,880
like and then so we exactly what but

1002
00:48:03,720 --> 00:48:07,960
like we have these hes that means that

1003
00:48:05,880 --> 00:48:09,920
we have technically like I guess the

1004
00:48:07,960 --> 00:48:12,880
same number of inputs but like we have

1005
00:48:09,920 --> 00:48:14,520
like blocks of inputs now and like how

1006
00:48:12,880 --> 00:48:18,200
exactly does that change because that

1007
00:48:14,520 --> 00:48:21,760
means that we have like

1008
00:48:18,200 --> 00:48:21,760
technically we we're

1009
00:48:22,640 --> 00:48:27,440
combining information it just feels

1010
00:48:25,040 --> 00:48:29,160
weird because like

1011
00:48:27,440 --> 00:48:31,200
feels like we're mixing up information

1012
00:48:29,160 --> 00:48:34,280
because we're saying like we're

1013
00:48:31,200 --> 00:48:36,440
assigning one thing one like like one

1014
00:48:34,280 --> 00:48:39,839
thing in a large space to like a bunch

1015
00:48:36,440 --> 00:48:39,839
of things the

1016
00:48:40,520 --> 00:48:46,359
the in the large field H is in the

1017
00:48:42,839 --> 00:48:49,160
larger right and we're saying that just

1018
00:48:46,359 --> 00:48:51,839
one to this sprad

1019
00:48:49,160 --> 00:48:56,440
of

1020
00:48:51,839 --> 00:48:58,480
feels not I'm not falling okay yeah so

1021
00:48:56,440 --> 00:49:00,440
you confusion is like this part is like

1022
00:48:58,480 --> 00:49:02,000
01 it's really just bullying and then

1023
00:49:00,440 --> 00:49:04,079
over here we have this weird H going

1024
00:49:02,000 --> 00:49:05,400
into it which is like not bullying so

1025
00:49:04,079 --> 00:49:06,760
like what is this polom kind of doing

1026
00:49:05,400 --> 00:49:08,359
with all this like bullying stuff that's

1027
00:49:06,760 --> 00:49:10,040
part of the question yeah so maybe we

1028
00:49:08,359 --> 00:49:12,599
should think about it as in like let's

1029
00:49:10,040 --> 00:49:13,680
first Aris matize this um circuit here

1030
00:49:12,599 --> 00:49:15,839
so we're going to get something over a

1031
00:49:13,680 --> 00:49:17,440
large fod already and then now for we're

1032
00:49:15,839 --> 00:49:18,839
going to plug in these like pols into

1033
00:49:17,440 --> 00:49:20,079
this already arith matized thing which

1034
00:49:18,839 --> 00:49:22,160
is already going to be polinomial so we

1035
00:49:20,079 --> 00:49:25,079
kind of like like poog

1036
00:49:22,160 --> 00:49:28,119
composition but you're but the thing is

1037
00:49:25,079 --> 00:49:30,119
you're not doing one to one you're doing

1038
00:49:28,119 --> 00:49:31,720
um if you think about the amount of

1039
00:49:30,119 --> 00:49:33,799
information kind of conserved because

1040
00:49:31,720 --> 00:49:35,920
here this's h options capital h options

1041
00:49:33,799 --> 00:49:38,000
for this H1 and then when you pluck it

1042
00:49:35,920 --> 00:49:42,359
up here you now still have only h

1043
00:49:38,000 --> 00:49:47,200
options for the resulting like 01

1044
00:49:42,359 --> 00:49:51,359
string well I mean yes but it also it it

1045
00:49:47,200 --> 00:49:53,680
felt that yes but like the but like in

1046
00:49:51,359 --> 00:49:57,079
the higher field we only have like now

1047
00:49:53,680 --> 00:49:59,319
we only have um you know log log s uh

1048
00:49:57,079 --> 00:50:03,359
different inputs from the larger field

1049
00:49:59,319 --> 00:50:08,000
now we're jamming them into this

1050
00:50:03,359 --> 00:50:11,319
like we only have like a few we have

1051
00:50:08,000 --> 00:50:13,440
much less um things from the larger

1052
00:50:11,319 --> 00:50:15,760
field and we're ging that in and it's

1053
00:50:13,440 --> 00:50:18,599
just kind of like um like each each

1054
00:50:15,760 --> 00:50:20,760
element is getting um you know is

1055
00:50:18,599 --> 00:50:22,960
covering a bunch of bits in

1056
00:50:20,760 --> 00:50:25,480
those so it turns out that there's a

1057
00:50:22,960 --> 00:50:29,599
unique mapping from the string of H1 up

1058
00:50:25,480 --> 00:50:32,200
to um hm and then this zero one to the

1059
00:50:29,599 --> 00:50:33,480
log S Prime string and so it's a

1060
00:50:32,200 --> 00:50:34,960
bijection you can go back and forth

1061
00:50:33,480 --> 00:50:37,079
between them so there actually there no

1062
00:50:34,960 --> 00:50:38,520
like clashing it's going to be just one

1063
00:50:37,079 --> 00:50:42,160
to

1064
00:50:38,520 --> 00:50:46,119
one I'm I'm sorry I'm just not

1065
00:50:42,160 --> 00:50:49,240
following sure okay um yeah I guess

1066
00:50:46,119 --> 00:50:51,200
that's sure okay so what's going to

1067
00:50:49,240 --> 00:50:53,040
happen is you're maybe let me zoom out

1068
00:50:51,200 --> 00:50:54,799
of that it's a little messy so let's say

1069
00:50:53,040 --> 00:50:57,000
you have this is going to be

1070
00:50:54,799 --> 00:50:59,280
just so this is going to be our Z 0 one

1071
00:50:57,000 --> 00:51:00,880
layer over here I'm sorry again yeah no

1072
00:50:59,280 --> 00:51:03,160
you're fine it's good to ask questions

1073
00:51:00,880 --> 00:51:04,640
um so this is going to be log H number

1074
00:51:03,160 --> 00:51:06,799
of

1075
00:51:04,640 --> 00:51:08,480
bits and the idea is we're going to take

1076
00:51:06,799 --> 00:51:12,400
some

1077
00:51:08,480 --> 00:51:16,119
H and we're going to map it here

1078
00:51:12,400 --> 00:51:18,040
to um to log H many different bits right

1079
00:51:16,119 --> 00:51:20,400
so here like one way you can do this you

1080
00:51:18,040 --> 00:51:22,799
write this in binary right so maybe this

1081
00:51:20,400 --> 00:51:24,880
maybe H here is like size eight so this

1082
00:51:22,799 --> 00:51:27,160
will correspond to like a binary string

1083
00:51:24,880 --> 00:51:29,960
I get you can do that but like

1084
00:51:27,160 --> 00:51:32,079
why is why are we allowed to do that and

1085
00:51:29,960 --> 00:51:34,480
how how exactly why exactly is this

1086
00:51:32,079 --> 00:51:37,240
helping us I understand that you can

1087
00:51:34,480 --> 00:51:39,720
write it in binary oning that like how

1088
00:51:37,240 --> 00:51:43,079
exactly is this helping us again because

1089
00:51:39,720 --> 00:51:45,520
it feels like now um each element each

1090
00:51:43,079 --> 00:51:47,079
big element in the extension like before

1091
00:51:45,520 --> 00:51:50,559
we were just saying that like we're

1092
00:51:47,079 --> 00:51:53,000
going to extend um each individual like

1093
00:51:50,559 --> 00:51:55,799
like we're going to assume that like 01

1094
00:51:53,000 --> 00:51:58,319
values are actually now extended values

1095
00:51:55,799 --> 00:52:01,799
but then we're doing it in such a way

1096
00:51:58,319 --> 00:52:05,640
that um like before we wereing these

1097
00:52:01,799 --> 00:52:07,319
values from the large circuit are um

1098
00:52:05,640 --> 00:52:10,839
going

1099
00:52:07,319 --> 00:52:14,000
to like we're going to say like um like

1100
00:52:10,839 --> 00:52:16,359
if we have an we have say an hand G then

1101
00:52:14,000 --> 00:52:19,079
we're GNA have like PL one big value and

1102
00:52:16,359 --> 00:52:20,839
another big value and multiply them

1103
00:52:19,079 --> 00:52:22,119
together how about do we take a break

1104
00:52:20,839 --> 00:52:23,000
now and then we'll come back in five

1105
00:52:22,119 --> 00:52:24,440
minutes and then we'll do the second

1106
00:52:23,000 --> 00:52:25,520
half of the class I think that's all for

1107
00:52:24,440 --> 00:52:27,760
this part and then maybe we can talk

1108
00:52:25,520 --> 00:52:29,680
offline sor you're totally fun let's

1109
00:52:27,760 --> 00:52:32,799
talk about it

1110
00:52:29,680 --> 00:52:35,240
okay okay so how many of you guys know

1111
00:52:32,799 --> 00:52:37,480
the theorem like exists or what it says

1112
00:52:35,240 --> 00:52:37,480
or

1113
00:52:38,400 --> 00:52:42,319
anything okay it's fine we talk about it

1114
00:52:40,760 --> 00:52:44,760
again so this is a really famous theorem

1115
00:52:42,319 --> 00:52:46,440
it's a great theorem it's very good um

1116
00:52:44,760 --> 00:52:49,200
yeah so we should talk about what these

1117
00:52:46,440 --> 00:52:50,520
things are so can one of the local

1118
00:52:49,200 --> 00:52:52,720
complexity theorist people tell me what

1119
00:52:50,520 --> 00:52:54,880
IP

1120
00:52:52,720 --> 00:52:56,240
is it doesn't have to be the local

1121
00:52:54,880 --> 00:52:58,440
complexity theorist it could be any of

1122
00:52:56,240 --> 00:52:58,440
you

1123
00:52:59,799 --> 00:53:07,030
stat that proven

1124
00:53:03,670 --> 00:53:07,030
[Applause]

1125
00:53:08,200 --> 00:53:11,200
interactive

1126
00:53:13,640 --> 00:53:20,559
um oh

1127
00:53:15,900 --> 00:53:23,260
[Applause]

1128
00:53:20,559 --> 00:53:38,400
did see

1129
00:53:23,260 --> 00:53:40,839
[Applause]

1130
00:53:38,400 --> 00:53:43,119
okay yeah so okay so IP is a CLA of all

1131
00:53:40,839 --> 00:53:45,760
statement that have interactive proofs

1132
00:53:43,119 --> 00:53:48,160
um interactive that's right okay yeah so

1133
00:53:45,760 --> 00:53:50,000
and the rer can be unbounded time um and

1134
00:53:48,160 --> 00:53:51,160
then the verify should run po time this

1135
00:53:50,000 --> 00:53:53,040
mean interactive proof should also be

1136
00:53:51,160 --> 00:53:56,360
poly size right otherwise ver I can't

1137
00:53:53,040 --> 00:53:59,519
read it okay and then what is ppace

1138
00:53:56,360 --> 00:53:59,519
[Applause]

1139
00:54:04,160 --> 00:54:12,450
TM languages great okay poly space

1140
00:54:08,400 --> 00:54:14,400
computations yay um

1141
00:54:12,450 --> 00:54:17,720
[Applause]

1142
00:54:14,400 --> 00:54:19,599
okay okay um and so the easier Direction

1143
00:54:17,720 --> 00:54:22,400
so like okay so it was shown 1992 these

1144
00:54:19,599 --> 00:54:24,720
two things are actually equal um so the

1145
00:54:22,400 --> 00:54:27,079
easier direction to show is that IP is

1146
00:54:24,720 --> 00:54:28,720
in ppace um the way you kind of do that

1147
00:54:27,079 --> 00:54:29,880
is by sort of simulating all possible

1148
00:54:28,720 --> 00:54:31,799
like transcripts and then you can do

1149
00:54:29,880 --> 00:54:34,520
some counting stuff we won't go into

1150
00:54:31,799 --> 00:54:36,280
details um but in 1992 it was shown the

1151
00:54:34,520 --> 00:54:38,330
other direction also held so this is by

1152
00:54:36,280 --> 00:54:40,160
Shamir in

1153
00:54:38,330 --> 00:54:44,200
[Applause]

1154
00:54:40,160 --> 00:54:46,640
1992 so in fact ppace is also in IP

1155
00:54:44,200 --> 00:54:50,000
which means that um these two classes

1156
00:54:46,640 --> 00:54:52,799
are actually equal um and to do this he

1157
00:54:50,000 --> 00:54:55,839
constructed a like a interactive proof

1158
00:54:52,799 --> 00:54:57,920
for all any pbas computation um and that

1159
00:54:55,839 --> 00:55:00,000
would give you the

1160
00:54:57,920 --> 00:55:01,839
inclusion okay so in particular this

1161
00:55:00,000 --> 00:55:05,319
means that

1162
00:55:01,839 --> 00:55:08,000
um any

1163
00:55:05,319 --> 00:55:11,680
pspace

1164
00:55:08,000 --> 00:55:11,680
computation has interactive

1165
00:55:12,240 --> 00:55:15,760
[Applause]

1166
00:55:13,760 --> 00:55:17,200
proof okay so going back to like the

1167
00:55:15,760 --> 00:55:18,720
concept of Delegation which is what this

1168
00:55:17,200 --> 00:55:20,799
class is entirely about right like how

1169
00:55:18,720 --> 00:55:22,599
do you you know delegate a computation

1170
00:55:20,799 --> 00:55:25,160
to like a bigger approver while you can

1171
00:55:22,599 --> 00:55:27,880
run very quickly well this is delegation

1172
00:55:25,160 --> 00:55:29,440
right okay um like it's basically like

1173
00:55:27,880 --> 00:55:31,839
you know I want to compute some like

1174
00:55:29,440 --> 00:55:33,280
small space computation like PO space

1175
00:55:31,839 --> 00:55:34,760
you know and I can like ask the cloud

1176
00:55:33,280 --> 00:55:36,079
hey can you run like awesome like should

1177
00:55:34,760 --> 00:55:38,079
your interactive proof for me and just

1178
00:55:36,079 --> 00:55:39,359
tell me you know like prove to me that

1179
00:55:38,079 --> 00:55:42,400
you know you did it correctly and

1180
00:55:39,359 --> 00:55:43,920
they're good right okay um so what's the

1181
00:55:42,400 --> 00:55:46,160
issue like why why aren't we done like

1182
00:55:43,920 --> 00:55:48,480
why did why are all the why did DKR at

1183
00:55:46,160 --> 00:55:50,839
all um the reason is because here the

1184
00:55:48,480 --> 00:55:50,839
pro a

1185
00:55:51,880 --> 00:55:57,039
runtime is 2 to the s

1186
00:55:54,319 --> 00:55:59,720
s right so like

1187
00:55:57,039 --> 00:56:01,680
um so in ppace like any competion is

1188
00:55:59,720 --> 00:56:03,520
doable in time two to the S but here's

1189
00:56:01,680 --> 00:56:06,520
this additional like so this is like s

1190
00:56:03,520 --> 00:56:08,240
to squar this like is like basically the

1191
00:56:06,520 --> 00:56:10,640
time to prove is much more than the time

1192
00:56:08,240 --> 00:56:11,880
necessary to Simply compute um which is

1193
00:56:10,640 --> 00:56:12,920
why there's all these follow-ups works

1194
00:56:11,880 --> 00:56:15,839
and why this is actually so an

1195
00:56:12,920 --> 00:56:17,400
interesting question today um okay and

1196
00:56:15,839 --> 00:56:19,240
there's some follow-up work U I don't

1197
00:56:17,400 --> 00:56:20,559
know the reference and Y didn't either

1198
00:56:19,240 --> 00:56:21,839
and I don't know if her memory is wrong

1199
00:56:20,559 --> 00:56:26,839
either so it could be wrong it could be

1200
00:56:21,839 --> 00:56:28,000
true so it's a possible statement um

1201
00:56:26,839 --> 00:56:29,720
okay so it's possible that there's a

1202
00:56:28,000 --> 00:56:32,680
followup work that showed how to have a

1203
00:56:29,720 --> 00:56:34,440
Prov a runtime of 2 to the S log s which

1204
00:56:32,680 --> 00:56:36,359
is like significantly better than 2 to S

1205
00:56:34,440 --> 00:56:38,240
squ but it's you know it's still not two

1206
00:56:36,359 --> 00:56:39,440
to the S which would be kind of the best

1207
00:56:38,240 --> 00:56:40,359
you could hope for for any arbitrary

1208
00:56:39,440 --> 00:56:42,400
pbas

1209
00:56:40,359 --> 00:56:45,240
computation um so today what we're going

1210
00:56:42,400 --> 00:56:45,240
to show

1211
00:56:45,839 --> 00:56:51,720
is okay so today the theorem is going to

1212
00:56:48,880 --> 00:56:52,880
be as follows um so assuming gkr which

1213
00:56:51,720 --> 00:56:54,079
is an unconditional statement so it's

1214
00:56:52,880 --> 00:56:56,319
not an assumption it's just this is what

1215
00:56:54,079 --> 00:56:59,839
we're going to use in the proof um so

1216
00:56:56,319 --> 00:57:01,790
since we have gkr um we can get

1217
00:56:59,839 --> 00:57:03,079
IP equals

1218
00:57:01,790 --> 00:57:07,480
[Applause]

1219
00:57:03,079 --> 00:57:09,880
pspace um with uh

1220
00:57:07,480 --> 00:57:10,620
time 2 to the I should probably write

1221
00:57:09,880 --> 00:57:13,200
poly 2 to the

1222
00:57:10,620 --> 00:57:16,200
[Applause]

1223
00:57:13,200 --> 00:57:16,200
S

1224
00:57:18,680 --> 00:57:24,599
pro right so okay so what this means is

1225
00:57:22,520 --> 00:57:26,680
like so for like maybe the hardest P

1226
00:57:24,599 --> 00:57:27,880
computations um assuming that I guess

1227
00:57:26,680 --> 00:57:29,480
the hardest things you can do is time CH

1228
00:57:27,880 --> 00:57:31,760
to the S then we do have actually

1229
00:57:29,480 --> 00:57:33,200
efficient um delegation protocols for

1230
00:57:31,760 --> 00:57:34,240
these things and they're in fact also

1231
00:57:33,200 --> 00:57:38,559
proof systems so they are like

1232
00:57:34,240 --> 00:57:40,079
information theoretically secure um and

1233
00:57:38,559 --> 00:57:43,000
maybe I just mentioned like one open

1234
00:57:40,079 --> 00:57:47,000
question is what about General time t

1235
00:57:43,000 --> 00:57:47,000
space um space computation

1236
00:57:47,880 --> 00:57:53,760
so where T is not necess cly s um can

1237
00:57:51,920 --> 00:57:57,280
you

1238
00:57:53,760 --> 00:58:02,240
do an interactive proof um um a

1239
00:57:57,280 --> 00:58:04,599
[Applause]

1240
00:58:02,240 --> 00:58:07,440
sufficient I think this is not

1241
00:58:04,599 --> 00:58:08,760
known so if you want to think about some

1242
00:58:07,440 --> 00:58:11,960
proof systems this is a question you

1243
00:58:08,760 --> 00:58:11,960
think about

1244
00:58:13,319 --> 00:58:18,240
um let's see are you guys okay about

1245
00:58:16,559 --> 00:58:21,000
races this is probably fine right okay

1246
00:58:18,240 --> 00:58:22,599
here efficient just like poly yeah poity

1247
00:58:21,000 --> 00:58:23,760
yeah and you definitely ask more like

1248
00:58:22,599 --> 00:58:25,280
even like stronger questions like can

1249
00:58:23,760 --> 00:58:27,520
you do it with like you know linear time

1250
00:58:25,280 --> 00:58:32,880
overhead like you know additive whatever

1251
00:58:27,520 --> 00:58:32,880
overhead um yeah there's many

1252
00:58:50,440 --> 00:58:55,720
questions okay so how do we describe a

1253
00:58:53,319 --> 00:58:57,079
uh peace based computation um someone

1254
00:58:55,720 --> 00:58:58,920
said that it's a space of all

1255
00:58:57,079 --> 00:59:01,319
computations that are doable by like a

1256
00:58:58,920 --> 00:59:02,319
touring machine with founded space so

1257
00:59:01,319 --> 00:59:04,640
let's say that we have our touring

1258
00:59:02,319 --> 00:59:04,640
machine

1259
00:59:05,200 --> 00:59:09,359
M and let say it runs in space

1260
00:59:09,839 --> 00:59:16,799
s

1261
00:59:12,640 --> 00:59:16,799
um and maybe could they on

1262
00:59:17,280 --> 00:59:26,240
input 01 to the N okay and maybe that's

1263
00:59:23,200 --> 00:59:29,119
the thing we want is

1264
00:59:26,240 --> 00:59:30,000
um and maybe we can just say time um and

1265
00:59:29,119 --> 00:59:33,039
also

1266
00:59:30,000 --> 00:59:35,280
time T unless I just St 2 to the S just

1267
00:59:33,039 --> 00:59:36,599
for now okay so let's say that maybe we

1268
00:59:35,280 --> 00:59:38,520
have a turning machine and we want to

1269
00:59:36,599 --> 00:59:40,400
see that within time T which is two to

1270
00:59:38,520 --> 00:59:42,000
the s that eventually it will get to the

1271
00:59:40,400 --> 00:59:44,880
like output like the accepting

1272
00:59:42,000 --> 00:59:48,680
configuration or not um

1273
00:59:44,880 --> 00:59:52,400
so so by this point I

1274
00:59:48,680 --> 00:59:52,400
should um get

1275
00:59:53,400 --> 00:59:57,880
to accepting configuration

1276
01:00:01,680 --> 01:00:03,960
okay

1277
01:00:04,359 --> 01:00:08,960
so so here's sort of the trick the idea

1278
01:00:07,119 --> 01:00:10,680
here we're going to use GK gkr to prove

1279
01:00:08,960 --> 01:00:13,039
the theorem so we're going to have to

1280
01:00:10,680 --> 01:00:16,720
construct some circuit to delegate you

1281
01:00:13,039 --> 01:00:19,359
know some habitation with gkr with

1282
01:00:16,720 --> 01:00:21,799
um so this training machine here it runs

1283
01:00:19,359 --> 01:00:25,039
in space s can run timing up to 2 to the

1284
01:00:21,799 --> 01:00:26,880
S right so if you notely do this it get

1285
01:00:25,039 --> 01:00:29,039
depth 2 to the s c good that's not so

1286
01:00:26,880 --> 01:00:33,760
good we want to really be

1287
01:00:29,039 --> 01:00:36,480
deps okay so okay so think that down so

1288
01:00:33,760 --> 01:00:37,680
the goal is to

1289
01:00:36,480 --> 01:00:40,240
[Applause]

1290
01:00:37,680 --> 01:00:42,290
convert um to

1291
01:00:40,240 --> 01:00:48,409
depths

1292
01:00:42,290 --> 01:00:48,409
[Applause]

1293
01:00:48,559 --> 01:00:53,599
s has a goal um so here's a trick um the

1294
01:00:52,319 --> 01:00:56,319
trick is as follows we're going to look

1295
01:00:53,599 --> 01:01:00,559
at the transition Matrix of all the

1296
01:00:56,319 --> 01:01:03,960
possible um states of the of the CH tape

1297
01:01:00,559 --> 01:01:05,559
basically so um so we're going to have a

1298
01:01:03,960 --> 01:01:06,920
bunch of different possible States here

1299
01:01:05,559 --> 01:01:11,960
and a bunch of different possible States

1300
01:01:06,920 --> 01:01:16,119
here um so how many possible states are

1301
01:01:11,960 --> 01:01:17,039
there well there is 0 one to the S

1302
01:01:16,119 --> 01:01:19,039
because that's what the state could

1303
01:01:17,039 --> 01:01:20,480
actually say on the tape right but

1304
01:01:19,039 --> 01:01:23,760
that's also where the cheering machine

1305
01:01:20,480 --> 01:01:26,160
is right now so

1306
01:01:23,760 --> 01:01:28,480
maybe times the index and S2 to say

1307
01:01:26,160 --> 01:01:30,440
where the cheering machine is right now

1308
01:01:28,480 --> 01:01:31,799
and then you know it'll do like one

1309
01:01:30,440 --> 01:01:33,160
computation move somewhere and then

1310
01:01:31,799 --> 01:01:35,039
it'll be like an adjacent place at a

1311
01:01:33,160 --> 01:01:36,200
different state and then now the new

1312
01:01:35,039 --> 01:01:38,520
state will be like a slightly different

1313
01:01:36,200 --> 01:01:39,720
string and it'll be the ter like pointer

1314
01:01:38,520 --> 01:01:44,559
will be at different

1315
01:01:39,720 --> 01:01:44,559
location so so here's also be the same

1316
01:01:45,730 --> 01:01:50,839
[Applause]

1317
01:01:48,599 --> 01:01:52,920
States okay and the point is we're going

1318
01:01:50,839 --> 01:01:56,319
to

1319
01:01:52,920 --> 01:01:58,079
put a one at a location if there a way

1320
01:01:56,319 --> 01:02:01,240
to get from this state here to this

1321
01:01:58,079 --> 01:02:01,240
state here in one time

1322
01:02:01,640 --> 01:02:06,760
step um and zero everywhere else yeah

1323
01:02:04,279 --> 01:02:08,680
does the state include like the internal

1324
01:02:06,760 --> 01:02:11,599
like

1325
01:02:08,680 --> 01:02:13,279
automaton um yes that's a good point

1326
01:02:11,599 --> 01:02:16,200
it's actually very good yeah there

1327
01:02:13,279 --> 01:02:18,160
should only be like one one in each

1328
01:02:16,200 --> 01:02:20,119
row yeah there should be one one in

1329
01:02:18,160 --> 01:02:21,520
every row because the the thing you are

1330
01:02:20,119 --> 01:02:23,240
going to do after one time step should

1331
01:02:21,520 --> 01:02:24,599
be deterministic based on your current

1332
01:02:23,240 --> 01:02:27,039
like sort of location or your state

1333
01:02:24,599 --> 01:02:28,760
based on your Turing like so your

1334
01:02:27,039 --> 01:02:31,000
internal state of your touring machine

1335
01:02:28,760 --> 01:02:33,640
as well as what you see around

1336
01:02:31,000 --> 01:02:35,720
you so I'm using this as just like those

1337
01:02:33,640 --> 01:02:36,839
number of states in the touring machine

1338
01:02:35,720 --> 01:02:38,240
um anything else I'm forgetting was in

1339
01:02:36,839 --> 01:02:41,319
these states there's just like a bunch

1340
01:02:38,240 --> 01:02:41,319
of information that I don't

1341
01:02:43,000 --> 01:02:48,359
remember okay so anyway so I guess like

1342
01:02:45,559 --> 01:02:50,839
the the key Point here is that this

1343
01:02:48,359 --> 01:02:53,440
Matrix is actually very easy to compute

1344
01:02:50,839 --> 01:02:55,279
right because given like like maybe a

1345
01:02:53,440 --> 01:02:57,680
state here and like a state here you can

1346
01:02:55,279 --> 01:02:59,599
like sort of compare very in very low

1347
01:02:57,680 --> 01:03:01,640
depth very efficiently so this a very

1348
01:02:59,599 --> 01:03:02,920
uniform description of this check that

1349
01:03:01,640 --> 01:03:04,760
or the circuit that will generate

1350
01:03:02,920 --> 01:03:08,440
whether or not um the particular

1351
01:03:04,760 --> 01:03:08,440
corresponding Matrix value is zero or

1352
01:03:08,880 --> 01:03:12,799
one that would be important for us

1353
01:03:10,920 --> 01:03:15,440
because we want this like add a like we

1354
01:03:12,799 --> 01:03:17,079
want we want a uniform circuit I guess

1355
01:03:15,440 --> 01:03:22,079
point and this will make it

1356
01:03:17,079 --> 01:03:24,279
uniform PR St yeah okay so the Matrix

1357
01:03:22,079 --> 01:03:26,400
here is easy to compute is my claim the

1358
01:03:24,279 --> 01:03:29,720
reason is you can take any St here any

1359
01:03:26,400 --> 01:03:31,839
state here you can do some checks it's a

1360
01:03:29,720 --> 01:03:33,200
very a small like formula you can kind

1361
01:03:31,839 --> 01:03:34,440
of just check it very easily by knowing

1362
01:03:33,200 --> 01:03:36,440
what m is by knowing what you kind of

1363
01:03:34,440 --> 01:03:38,720
see you can tell if there's a transition

1364
01:03:36,440 --> 01:03:40,680
from that to the next state so the

1365
01:03:38,720 --> 01:03:43,680
Matrix here is easy to compute is my

1366
01:03:40,680 --> 01:03:43,680
claim

1367
01:03:44,620 --> 01:03:51,390
[Applause]

1368
01:03:53,039 --> 01:03:59,559
yeah um

1369
01:03:56,000 --> 01:04:03,520
okay so maybe let's call this Matrix

1370
01:03:59,559 --> 01:04:05,799
a so what I just said is that a i j this

1371
01:04:03,520 --> 01:04:08,559
is going to be like the I row and the

1372
01:04:05,799 --> 01:04:12,200
J's column and tree of a this is going

1373
01:04:08,559 --> 01:04:16,240
to be uh one if theate I goes to AJ in

1374
01:04:12,200 --> 01:04:16,240
one time step so

1375
01:04:16,860 --> 01:04:23,540
[Applause]

1376
01:04:29,599 --> 01:04:34,319
okay and so that's good right um what we

1377
01:04:32,559 --> 01:04:37,079
really want to know

1378
01:04:34,319 --> 01:04:38,319
is whether I will go to J or like the

1379
01:04:37,079 --> 01:04:41,440
starting configuration will go to the

1380
01:04:38,319 --> 01:04:43,079
accepting configuration in t time steps

1381
01:04:41,440 --> 01:04:46,079
that's what we

1382
01:04:43,079 --> 01:04:46,079
want

1383
01:04:54,640 --> 01:04:58,680
um for

1384
01:05:26,279 --> 01:05:30,839
okay so here we have a copy of a so okay

1385
01:05:28,319 --> 01:05:32,839
so okay yeah so we okay so we want to

1386
01:05:30,839 --> 01:05:33,920
find what um yeah okay so we want to

1387
01:05:32,839 --> 01:05:35,160
let's look maybe let's just do some

1388
01:05:33,920 --> 01:05:37,039
computations just for it fun and see

1389
01:05:35,160 --> 01:05:39,720
what happens so you have a copy of

1390
01:05:37,039 --> 01:05:41,559
Matrix a here copy of Matrix a here

1391
01:05:39,720 --> 01:05:45,920
let's multiply them VI have matrix

1392
01:05:41,559 --> 01:05:45,920
multiplication um so we have a squ

1393
01:05:46,039 --> 01:05:53,440
um what is the value of the entry in the

1394
01:05:49,799 --> 01:05:53,440
I row and the J's column of a

1395
01:05:53,480 --> 01:05:59,440
squ yeah so I guess right here actually

1396
01:05:57,180 --> 01:06:06,119
[Applause]

1397
01:05:59,440 --> 01:06:09,680
so so a s um the IJ entry of a squ

1398
01:06:06,119 --> 01:06:11,839
is whether I goes to J in two

1399
01:06:09,680 --> 01:06:12,960
steps um and maybe for those of you who

1400
01:06:11,839 --> 01:06:16,079
haven't seen this before let's just do

1401
01:06:12,960 --> 01:06:16,079
it um so you see

1402
01:06:17,319 --> 01:06:22,440
why so if you want to look at the ice St

1403
01:06:21,000 --> 01:06:24,240
entry of this product of these two

1404
01:06:22,440 --> 01:06:26,160
matrices what you want to do is you want

1405
01:06:24,240 --> 01:06:28,760
to take the ice row look at all the

1406
01:06:26,160 --> 01:06:31,200
entries across it take the J's column

1407
01:06:28,760 --> 01:06:32,599
look at all the entries down it and you

1408
01:06:31,200 --> 01:06:33,720
want to take like sort of the pair wise

1409
01:06:32,599 --> 01:06:35,039
like you want to take the product and

1410
01:06:33,720 --> 01:06:36,799
sum so you want to take like this entry

1411
01:06:35,039 --> 01:06:39,359
times this entry this entry time this

1412
01:06:36,799 --> 01:06:41,640
entry and so on so what's essentially

1413
01:06:39,359 --> 01:06:43,200
happening is here you want to take like

1414
01:06:41,640 --> 01:06:44,880
U you want to look at the entry um

1415
01:06:43,200 --> 01:06:47,720
corresponding you're going from I to K

1416
01:06:44,880 --> 01:06:50,720
and then you go from K to l k to

1417
01:06:47,720 --> 01:06:52,440
J um and then you do this for k equal 2

1418
01:06:50,720 --> 01:06:55,599
also you do it like can you go from I to

1419
01:06:52,440 --> 01:06:57,720
K and then you'll do it um from K to J

1420
01:06:55,599 --> 01:06:59,359
and so the final entry will some of all

1421
01:06:57,720 --> 01:07:01,359
of this these products will be one if

1422
01:06:59,359 --> 01:07:05,559
and only if there is a way to go from I

1423
01:07:01,359 --> 01:07:10,039
to sum K to J and two types

1424
01:07:05,559 --> 01:07:12,720
of okay or I don't know

1425
01:07:10,039 --> 01:07:15,400
okay okay so in general then if we want

1426
01:07:12,720 --> 01:07:18,359
to look at the transition Matrix of

1427
01:07:15,400 --> 01:07:20,160
having after going for T time steps you

1428
01:07:18,359 --> 01:07:23,799
kind of keep doing this right and you

1429
01:07:20,160 --> 01:07:26,799
get that the 's entry of a to the t's

1430
01:07:23,799 --> 01:07:26,799
power

1431
01:07:27,760 --> 01:07:35,519
is whether I goes to

1432
01:07:29,170 --> 01:07:35,519
[Applause]

1433
01:07:36,599 --> 01:07:46,000
J yeah so here H give you like whether I

1434
01:07:43,440 --> 01:07:48,400
exactly ke step like no more no less

1435
01:07:46,000 --> 01:07:50,279
yeah okay that's a good point um so

1436
01:07:48,400 --> 01:07:51,920
maybe we can say this should be an

1437
01:07:50,279 --> 01:07:53,599
exactly T time steps and maybe you can

1438
01:07:51,920 --> 01:07:55,039
have your touring machine like kind of

1439
01:07:53,599 --> 01:07:57,279
stay as accepting configuration already

1440
01:07:55,039 --> 01:07:58,440
reached it maybe for instance that's one

1441
01:07:57,279 --> 01:08:00,200
thing you could do another way you could

1442
01:07:58,440 --> 01:08:01,400
do it is you could have you could change

1443
01:08:00,200 --> 01:08:02,559
this Matrix as it's a one along the

1444
01:08:01,400 --> 01:08:04,240
diagonal so that you can always like

1445
01:08:02,559 --> 01:08:05,960
kind of waste time if you want okay but

1446
01:08:04,240 --> 01:08:07,960
whatever version you want is fine just

1447
01:08:05,960 --> 01:08:09,799
yeah maybe let's say for now after

1448
01:08:07,960 --> 01:08:11,119
exactly T time steps I should reach the

1449
01:08:09,799 --> 01:08:14,000
accepting configuration and just have it

1450
01:08:11,119 --> 01:08:14,000
Sol accepting

1451
01:08:16,880 --> 01:08:21,040
place

1452
01:08:18,560 --> 01:08:23,480
okay yeah okay so the point is if we can

1453
01:08:21,040 --> 01:08:25,120
compute what a of the input

1454
01:08:23,480 --> 01:08:27,880
configuration comma the accepting

1455
01:08:25,120 --> 01:08:30,839
configur ation is we'll know if um this

1456
01:08:27,880 --> 01:08:32,279
pbas computation is accepting or not

1457
01:08:30,839 --> 01:08:35,279
that

1458
01:08:32,279 --> 01:08:35,279
good

1459
01:08:35,640 --> 01:08:39,960
so so what we want

1460
01:08:45,470 --> 01:08:52,400
[Applause]

1461
01:08:50,560 --> 01:08:56,239
is okay so we're going to write a

1462
01:08:52,400 --> 01:08:56,239
circuit to compute this

1463
01:09:01,520 --> 01:09:06,600
um is it okay if I'm very like loose

1464
01:09:04,080 --> 01:09:07,920
about this I like I just feel like all

1465
01:09:06,600 --> 01:09:09,560
these things about like exactly how

1466
01:09:07,920 --> 01:09:12,839
everything Changs up is just terrible

1467
01:09:09,560 --> 01:09:14,960
like it's I don't know

1468
01:09:12,839 --> 01:09:16,600
um okay so I guess like one thing you

1469
01:09:14,960 --> 01:09:19,960
could do is you could just compute a and

1470
01:09:16,600 --> 01:09:21,040
then a squ then a cubed and a to the 4th

1471
01:09:19,960 --> 01:09:22,359
this is not so good right you're going

1472
01:09:21,040 --> 01:09:25,040
to do it for T times your cir speed

1473
01:09:22,359 --> 01:09:27,359
depth T okay so what should we do

1474
01:09:25,040 --> 01:09:27,359
instead

1475
01:09:27,480 --> 01:09:34,600
squaring great okay yay

1476
01:09:31,899 --> 01:09:36,960
[Applause]

1477
01:09:34,600 --> 01:09:39,000
um okay so the idea is we can compute

1478
01:09:36,960 --> 01:09:41,679
this Matrix

1479
01:09:39,000 --> 01:09:43,560
a so this is going to be like very easy

1480
01:09:41,679 --> 01:09:45,359
to compute because we I we talked a

1481
01:09:43,560 --> 01:09:46,920
little bit about how every like entry of

1482
01:09:45,359 --> 01:09:48,560
this Matrix is like you can compute it

1483
01:09:46,920 --> 01:09:49,679
very easily kind of just by looking at

1484
01:09:48,560 --> 01:09:52,159
what the two configurations are that

1485
01:09:49,679 --> 01:09:52,159
you're interested

1486
01:09:53,239 --> 01:09:58,600
in and then you can compute a squ

1487
01:09:55,840 --> 01:10:01,199
from this I just like I guess you

1488
01:09:58,600 --> 01:10:01,199
doation

1489
01:10:01,640 --> 01:10:06,719
multiplication and then we can do H to

1490
01:10:03,480 --> 01:10:08,679
the fourth a to the E and so on um

1491
01:10:06,719 --> 01:10:11,600
eventually we'll get to a to the T which

1492
01:10:08,679 --> 01:10:11,600
I don't have room

1493
01:10:18,400 --> 01:10:22,960
for so this is going to be our Matrix or

1494
01:10:20,800 --> 01:10:22,960
our

1495
01:10:23,080 --> 01:10:28,239
circuit okay let's look at the depths um

1496
01:10:25,600 --> 01:10:28,239
what's the depth of the

1497
01:10:32,719 --> 01:10:39,320
circuit okay so it's like log T is wait

1498
01:10:36,520 --> 01:10:41,000
but each like thing yeah okay times

1499
01:10:39,320 --> 01:10:44,920
something

1500
01:10:41,000 --> 01:10:44,920
um like don't you have to

1501
01:10:45,560 --> 01:10:49,480
do if like you have to add

1502
01:10:50,520 --> 01:10:56,560
up but you can make it a binary tree so

1503
01:10:53,320 --> 01:10:56,560
that will have

1504
01:10:59,880 --> 01:11:06,159
okay you can say po s it's probably like

1505
01:11:02,560 --> 01:11:06,159
log T times like polys

1506
01:11:06,960 --> 01:11:12,199
anyway okay so that's pretty good um

1507
01:11:10,080 --> 01:11:14,199
means that a verifier when running this

1508
01:11:12,199 --> 01:11:15,960
computation with theover in gkr the

1509
01:11:14,199 --> 01:11:20,760
scales of the depth depth is not only

1510
01:11:15,960 --> 01:11:20,760
polys right what's the size of circuit

1511
01:11:21,840 --> 01:11:28,810
[Applause]

1512
01:11:41,159 --> 01:11:44,480
yeah so I guess the Matrix itself is

1513
01:11:42,639 --> 01:11:47,639
going to be size two to S right or

1514
01:11:44,480 --> 01:11:49,520
something time two s yeah two s two to

1515
01:11:47,639 --> 01:11:56,520
the

1516
01:11:49,520 --> 01:11:56,520
s s 2s so yeah um

1517
01:11:56,800 --> 01:12:02,199
yeah

1518
01:11:59,280 --> 01:12:05,440
okay okay so if we apply gkr to this um

1519
01:12:02,199 --> 01:12:07,320
would be good so let's um let's run

1520
01:12:05,440 --> 01:12:08,960
gkr oh and I should proba also say at

1521
01:12:07,320 --> 01:12:10,639
the very top we need to then like look

1522
01:12:08,960 --> 01:12:12,560
at the input State and then check the

1523
01:12:10,639 --> 01:12:15,120
corresponding entry so you want to read

1524
01:12:12,560 --> 01:12:16,600
like this particular entry maybe but you

1525
01:12:15,120 --> 01:12:20,120
can sort of read it by doing some sort

1526
01:12:16,600 --> 01:12:21,639
of like pretty small like computation on

1527
01:12:20,120 --> 01:12:26,199
what the input in accepting comparations

1528
01:12:21,639 --> 01:12:26,199
are okay so let's run gkr

1529
01:12:26,560 --> 01:12:29,719
uh okay so prove a run

1530
01:12:30,900 --> 01:12:34,040
[Applause]

1531
01:12:38,960 --> 01:12:41,960
time

1532
01:12:43,800 --> 01:12:46,800
y

1533
01:12:50,239 --> 01:12:54,400
verify yay

1534
01:12:52,480 --> 01:12:59,880
okay I guess that's what we wanted to

1535
01:12:54,400 --> 01:13:00,920
prove huh okay nice good work um are

1536
01:12:59,880 --> 01:13:02,440
there any questions about this or do

1537
01:13:00,920 --> 01:13:04,320
this like make sense yeah sorry I might

1538
01:13:02,440 --> 01:13:06,520
have missed an important point but like

1539
01:13:04,320 --> 01:13:08,239
where is the cost of like actually doing

1540
01:13:06,520 --> 01:13:10,600
the

1541
01:13:08,239 --> 01:13:11,880
squaring um I guess sort of like the

1542
01:13:10,600 --> 01:13:13,320
depth of circuit is sort of like each

1543
01:13:11,880 --> 01:13:15,080
Square you do is going to take some more

1544
01:13:13,320 --> 01:13:17,120
depths to your circuit yeah that what

1545
01:13:15,080 --> 01:13:19,199
you're saying yeah yeah that's the

1546
01:13:17,120 --> 01:13:21,480
question oh maybe I didn't understand

1547
01:13:19,199 --> 01:13:23,960
the question oh as in like what is the

1548
01:13:21,480 --> 01:13:25,960
cost of squaring a like just going from

1549
01:13:23,960 --> 01:13:28,639
a to a squ what's the cost sure yeah so

1550
01:13:25,960 --> 01:13:30,840
how do you compute a

1551
01:13:28,639 --> 01:13:33,719
square you can kind of do every row and

1552
01:13:30,840 --> 01:13:35,880
every column and then like mly and add

1553
01:13:33,719 --> 01:13:39,280
them so oh in like you're just doing

1554
01:13:35,880 --> 01:13:41,880
like you're doing compation I see um so

1555
01:13:39,280 --> 01:13:41,880
maybe you can tell me

1556
01:13:47,960 --> 01:13:52,440
how supposed to know how that um thing

1557
01:13:50,800 --> 01:13:53,800
that you said we need to prove to you

1558
01:13:52,440 --> 01:13:56,239
are we supposed to know oh yeah that's a

1559
01:13:53,800 --> 01:13:59,520
great question oh yeah so so okay

1560
01:13:56,239 --> 01:14:01,560
earlier I already it I

1561
01:13:59,520 --> 01:14:04,199
think are any questions about this

1562
01:14:01,560 --> 01:14:04,199
before we go to

1563
01:14:11,520 --> 01:14:18,440
that um you can't use

1564
01:14:14,800 --> 01:14:21,199
IP um or you're allow to use a logic we

1565
01:14:18,440 --> 01:14:24,760
just had okay yeah so how do we how do

1566
01:14:21,199 --> 01:14:24,760
we construct this

1567
01:14:39,320 --> 01:14:42,800
oh so that's reason need

1568
01:14:51,400 --> 01:14:56,520
L yeah okay so this is basically a scale

1569
01:14:54,520 --> 01:14:58,360
down version of that right this is log

1570
01:14:56,520 --> 01:15:00,440
space usern form so you're running in

1571
01:14:58,360 --> 01:15:02,760
log space there you're running in times

1572
01:15:00,440 --> 01:15:04,719
like space s so this is a exponentially

1573
01:15:02,760 --> 01:15:06,159
smaller version of that take all the

1574
01:15:04,719 --> 01:15:08,880
parameters over there and you scale them

1575
01:15:06,159 --> 01:15:13,040
down so we had a depth over here was po

1576
01:15:08,880 --> 01:15:15,840
s the log of that is like log s right

1577
01:15:13,040 --> 01:15:18,159
the log of the size here is s so we have

1578
01:15:15,840 --> 01:15:21,120
all the things we

1579
01:15:18,159 --> 01:15:25,800
wanted

1580
01:15:21,120 --> 01:15:27,040
do how do you incorporate the input into

1581
01:15:25,800 --> 01:15:30,080
like you need to know what the starting

1582
01:15:27,040 --> 01:15:34,000
state is uh was this one or was the

1583
01:15:30,080 --> 01:15:36,520
IP um the input State yeah yeah so I

1584
01:15:34,000 --> 01:15:38,800
think the way I normally think or I like

1585
01:15:36,520 --> 01:15:40,320
to think about it is you only check the

1586
01:15:38,800 --> 01:15:42,719
input configuration at the very end once

1587
01:15:40,320 --> 01:15:44,040
you competed entire thing so then you

1588
01:15:42,719 --> 01:15:46,520
only have to read like the input comma

1589
01:15:44,040 --> 01:15:48,760
accepting configurations entry and there

1590
01:15:46,520 --> 01:15:50,760
you can just kind of like do like a a

1591
01:15:48,760 --> 01:15:52,560
formula like read off what it says and

1592
01:15:50,760 --> 01:15:55,040
then look at the corresponding

1593
01:15:52,560 --> 01:15:57,360
value that's great so like almost the

1594
01:15:55,040 --> 01:16:01,000
entire circuit is just like doesn't even

1595
01:15:57,360 --> 01:16:01,000
read the yeah it's only the very

1596
01:16:07,960 --> 01:16:13,960
end but I mean this is for accepting

1597
01:16:11,760 --> 01:16:17,480
that

1598
01:16:13,960 --> 01:16:21,480
accept yeah

1599
01:16:17,480 --> 01:16:21,480
um yeah yeah okay so

1600
01:16:22,080 --> 01:16:26,400
maybe yeah so I guess like each each

1601
01:16:24,239 --> 01:16:28,080
configuration corresponds to like it's a

1602
01:16:26,400 --> 01:16:29,600
configuration right so there's like some

1603
01:16:28,080 --> 01:16:31,920
like data about like what the gates

1604
01:16:29,600 --> 01:16:36,320
output like gate value is or something

1605
01:16:31,920 --> 01:16:36,320
andbe you can read off the the value

1606
01:16:37,880 --> 01:16:42,760
there each like input comma

1607
01:16:47,960 --> 01:16:55,880
is this like an easy situation

1608
01:16:53,199 --> 01:16:57,639
right yeah important Point here is that

1609
01:16:55,880 --> 01:16:59,800
check like Computing The Matrix a is

1610
01:16:57,639 --> 01:17:02,679
very easy that's really the key thing

1611
01:16:59,800 --> 01:17:05,320
here um and that's also why um when we

1612
01:17:02,679 --> 01:17:08,360
said what we were put behind but when we

1613
01:17:05,320 --> 01:17:10,239
said what um a looks like it really had

1614
01:17:08,360 --> 01:17:12,120
to be like also where the touring like

1615
01:17:10,239 --> 01:17:13,639
pointer was right if you didn't know

1616
01:17:12,120 --> 01:17:16,280
where the pointer was you it could be

1617
01:17:13,639 --> 01:17:16,280
very large

1618
01:17:22,080 --> 01:17:28,960
yeah okay uh so

1619
01:17:26,440 --> 01:17:30,400
wa you can like factor out uh what

1620
01:17:28,960 --> 01:17:32,440
you're saying into the form of like if

1621
01:17:30,400 --> 01:17:34,360
you have a low space computation you can

1622
01:17:32,440 --> 01:17:36,639
turn into a low dead circuit is that a

1623
01:17:34,360 --> 01:17:38,840
is that a fair you

1624
01:17:36,639 --> 01:17:41,120
used yeah it's actually a kind of

1625
01:17:38,840 --> 01:17:42,480
interesting statement huh I don't know I

1626
01:17:41,120 --> 01:17:45,159
didn't know that this you could do this

1627
01:17:42,480 --> 01:17:45,159
in recently

1628
01:17:46,120 --> 01:17:49,520
either um so I guess like the the

1629
01:17:48,120 --> 01:17:51,239
interesting thing here is instead of

1630
01:17:49,520 --> 01:17:52,920
being like a really tall and skinny

1631
01:17:51,239 --> 01:17:54,280
computation you can turn it into a

1632
01:17:52,920 --> 01:17:55,480
circuit that's really fat and like kind

1633
01:17:54,280 --> 01:17:58,040
of short

1634
01:17:55,480 --> 01:17:58,040
that's why we're getting

1635
01:18:03,679 --> 01:18:08,639
qu wait sorry okay just in terms of like

1636
01:18:06,639 --> 01:18:11,440
where we're at in class so we just

1637
01:18:08,639 --> 01:18:14,760
proved this theem and is this like the

1638
01:18:11,440 --> 01:18:17,199
same reasoning for why the law toity

1639
01:18:14,760 --> 01:18:19,679
thing works out too why this thing works

1640
01:18:17,199 --> 01:18:19,679
oh you tell

1641
01:18:19,920 --> 01:18:27,440
me you tell me I'm delegating the

1642
01:18:26,000 --> 01:18:29,400
it's kind of weird right because you you

1643
01:18:27,440 --> 01:18:31,679
don't actually take a as input a is like

1644
01:18:29,400 --> 01:18:33,400
kind of like hardcoded into the circuit

1645
01:18:31,679 --> 01:18:34,600
right like that's why like the input can

1646
01:18:33,400 --> 01:18:37,320
still be like the small thing that's

1647
01:18:34,600 --> 01:18:39,360
just describing the stting state yeah

1648
01:18:37,320 --> 01:18:40,800
like the the turning machine m is sort

1649
01:18:39,360 --> 01:18:42,320
of what the term of the circuit actually

1650
01:18:40,800 --> 01:18:43,400
looks like so maybe as part of the input

1651
01:18:42,320 --> 01:18:45,080
of this you're also going to have a

1652
01:18:43,400 --> 01:18:46,679
description like the turning machine

1653
01:18:45,080 --> 01:18:49,120
entirety turning machines are like you

1654
01:18:46,679 --> 01:18:50,719
know finite size so it doesn't matter

1655
01:18:49,120 --> 01:18:52,480
and then

1656
01:18:50,719 --> 01:18:55,440
you and that's why we don't need to

1657
01:18:52,480 --> 01:18:58,239
worry about complicated

1658
01:18:55,440 --> 01:18:58,239
actually just looks like

1659
01:19:06,679 --> 01:19:13,000
this I'm still kind of weirded out by

1660
01:19:08,960 --> 01:19:15,080
the fact that like all of that up until

1661
01:19:13,000 --> 01:19:17,159
the star at the top all of this is like

1662
01:19:15,080 --> 01:19:19,440
not even dependent on the input so it's

1663
01:19:17,159 --> 01:19:21,960
like in this case it's just going to be

1664
01:19:19,440 --> 01:19:23,880
constants like zero than one so then

1665
01:19:21,960 --> 01:19:26,400
like why are we go through the trouble

1666
01:19:23,880 --> 01:19:28,320
of like Computing all layers instead of

1667
01:19:26,400 --> 01:19:29,400
just like using the top layer we like

1668
01:19:28,320 --> 01:19:31,159
yeah I mean how do you how do you hold

1669
01:19:29,400 --> 01:19:33,719
the top

1670
01:19:31,159 --> 01:19:36,440
layer so you're saying that like it's

1671
01:19:33,719 --> 01:19:38,760
easier to encode the entire computation

1672
01:19:36,440 --> 01:19:40,120
thing than just the result it's easy to

1673
01:19:38,760 --> 01:19:43,520
say what you have to do to compute it

1674
01:19:40,120 --> 01:19:43,520
than to actually computed

1675
01:19:59,159 --> 01:20:04,400
representation but I'm thinking like why

1676
01:20:01,080 --> 01:20:04,400
don't you death hard cod in the top

1677
01:20:10,360 --> 01:20:16,040
layer well it's just I mean it's just a

1678
01:20:12,679 --> 01:20:19,159
string of like size

1679
01:20:16,040 --> 01:20:19,159
of you

1680
01:20:19,520 --> 01:20:24,199
can't weird I

1681
01:20:25,560 --> 01:20:27,800
so we basically went through this

1682
01:20:26,679 --> 01:20:29,280
trouble and we're able to go through

1683
01:20:27,800 --> 01:20:31,760
this trouble because we assume that c

1684
01:20:29,280 --> 01:20:34,080
can be described succinctly like long

1685
01:20:31,760 --> 01:20:34,080
space

1686
01:20:36,000 --> 01:20:40,159
suly yeah is po

1687
01:20:40,639 --> 01:20:46,080
uni I'm going to delate like question

1688
01:20:42,840 --> 01:20:47,400
somebody else I don't know how like log

1689
01:20:46,080 --> 01:20:50,120
blows

1690
01:20:47,400 --> 01:20:52,320
up probably not right because if you if

1691
01:20:50,120 --> 01:20:53,840
you take like the transition Matrix a

1692
01:20:52,320 --> 01:20:55,199
you have is going to be two to the

1693
01:20:53,840 --> 01:20:57,679
description size or whatever like the

1694
01:20:55,199 --> 01:21:00,360
space right so if you have like larger

1695
01:20:57,679 --> 01:21:00,360
Space is really

1696
01:21:00,800 --> 01:21:04,199
bad but like

1697
01:21:06,320 --> 01:21:13,920
space um yeah so we

1698
01:21:10,920 --> 01:21:13,920
have

1699
01:21:14,760 --> 01:21:19,440
um yeah but then the question is the pro

1700
01:21:16,920 --> 01:21:21,280
a runtime

1701
01:21:19,440 --> 01:21:22,360
right the reason why we're doing any of

1702
01:21:21,280 --> 01:21:23,320
this is because of prove a run time you

1703
01:21:22,360 --> 01:21:26,560
get you actually get an advantage in the

1704
01:21:23,320 --> 01:21:26,560
prove a run time

1705
01:21:35,000 --> 01:21:42,239
uh so we're done early um so maybe we

1706
01:21:37,159 --> 01:21:42,239
can all go get some corn and

1707
01:21:42,680 --> 01:21:47,789
[Applause]

