1
00:00:02,080 --> 00:00:06,000
Good morning everyone. My name is Siang

2
00:00:03,919 --> 00:00:08,400
Cha from Soul National University in

3
00:00:06,000 --> 00:00:11,280
Korea and working under the supervision

4
00:00:08,400 --> 00:00:12,960
of professor Martin Siner and it's a

5
00:00:11,280 --> 00:00:16,240
pleasure to be here today to give this

6
00:00:12,960 --> 00:00:18,640
primer. Um before professor Steiner's

7
00:00:16,240 --> 00:00:21,279
talk on exploring the predictive prod

8
00:00:18,640 --> 00:00:22,800
universe using computational methods. I

9
00:00:21,279 --> 00:00:24,400
would like to briefly introduce some

10
00:00:22,800 --> 00:00:26,800
concepts of product sequence and

11
00:00:24,400 --> 00:00:28,480
structure analysis which is which will

12
00:00:26,800 --> 00:00:30,160
provide a foundation for today's

13
00:00:28,480 --> 00:00:32,320
discussion.

14
00:00:30,160 --> 00:00:35,120
Let me first introduce our lab. Our

15
00:00:32,320 --> 00:00:37,360
group's goal is to accelerate biological

16
00:00:35,120 --> 00:00:40,000
science by developing fast and easy to

17
00:00:37,360 --> 00:00:41,600
use open source computational tools. And

18
00:00:40,000 --> 00:00:44,399
we believe that by lowering the

19
00:00:41,600 --> 00:00:46,079
technical barriers to powerful analysis,

20
00:00:44,399 --> 00:00:48,160
um researchers around the world can ask

21
00:00:46,079 --> 00:00:50,399
and answer bigger questions in biology

22
00:00:48,160 --> 00:00:53,520
more efficiently.

23
00:00:50,399 --> 00:00:55,840
In short, we develop tools for biology.

24
00:00:53,520 --> 00:00:58,079
Now, let me start with a question. Um

25
00:00:55,840 --> 00:00:59,920
why do we compare proteins? If you open

26
00:00:58,079 --> 00:01:02,399
a protein database, you will often see

27
00:00:59,920 --> 00:01:04,239
entries labeled as hypothetical protein,

28
00:01:02,399 --> 00:01:06,640
uncharacterized protein or unknown

29
00:01:04,239 --> 00:01:08,880
function. And in fact, a huge fraction

30
00:01:06,640 --> 00:01:12,000
of protein sequences fall into this

31
00:01:08,880 --> 00:01:14,159
category. In uniro, more than 30% of

32
00:01:12,000 --> 00:01:16,560
entries are annotated as hypothetical

33
00:01:14,159 --> 00:01:18,560
proteins. And in some metagenomic data

34
00:01:16,560 --> 00:01:21,439
sets, the proportion can be even higher,

35
00:01:18,560 --> 00:01:23,280
reaching up to 50%. And this highlights

36
00:01:21,439 --> 00:01:25,840
how little we know about the functional

37
00:01:23,280 --> 00:01:28,479
landscape of proteins. But science is

38
00:01:25,840 --> 00:01:30,799
driven by curiosity. Um what are these

39
00:01:28,479 --> 00:01:32,880
proteins and what do they do? The most

40
00:01:30,799 --> 00:01:35,200
straightforward way to answer that is

41
00:01:32,880 --> 00:01:37,200
through comparison. If these unknown

42
00:01:35,200 --> 00:01:39,439
proteins resemble other proteins whose

43
00:01:37,200 --> 00:01:41,520
function we already know then we can

44
00:01:39,439 --> 00:01:44,400
gain a clue about their function. For

45
00:01:41,520 --> 00:01:47,280
example, if you find that a lizooal

46
00:01:44,400 --> 00:01:50,079
asperic proteosis looks very similar to

47
00:01:47,280 --> 00:01:51,840
an orange colored hypothetical protein,

48
00:01:50,079 --> 00:01:53,520
we can assume that the hypothetical

49
00:01:51,840 --> 00:01:56,720
protein may also share a similar

50
00:01:53,520 --> 00:01:58,640
function. So protein comparism forms the

51
00:01:56,720 --> 00:02:00,079
basis of function prediction and

52
00:01:58,640 --> 00:02:01,840
understanding evolutionary

53
00:02:00,079 --> 00:02:04,479
relationships.

54
00:02:01,840 --> 00:02:07,280
So um and let's begin with the basics.

55
00:02:04,479 --> 00:02:09,440
What exactly is a protein? And you all

56
00:02:07,280 --> 00:02:11,520
might know but proteins are polymers of

57
00:02:09,440 --> 00:02:14,239
amino acids linked together through

58
00:02:11,520 --> 00:02:16,000
peptide bones. And proteins can be very

59
00:02:14,239 --> 00:02:17,920
long with hundreds or even thousands of

60
00:02:16,000 --> 00:02:20,640
amino acids and their corresponding

61
00:02:17,920 --> 00:02:22,400
nucleotide sequences are even longer. So

62
00:02:20,640 --> 00:02:24,800
given this long change the question

63
00:02:22,400 --> 00:02:27,200
becomes how can we compare two protein

64
00:02:24,800 --> 00:02:29,200
sequences or even how can we compare two

65
00:02:27,200 --> 00:02:31,040
protein structures

66
00:02:29,200 --> 00:02:33,280
I'll start with sequence alignments

67
00:02:31,040 --> 00:02:36,480
sequence searches form the basis of most

68
00:02:33,280 --> 00:02:38,480
of protein binformatics task tasks such

69
00:02:36,480 --> 00:02:40,720
as identifying disease associated

70
00:02:38,480 --> 00:02:43,120
phenotypes or predicting protein protein

71
00:02:40,720 --> 00:02:45,040
interaction or performing denovo

72
00:02:43,120 --> 00:02:46,879
structural prediction and studying

73
00:02:45,040 --> 00:02:49,120
evolutionary relationships all begin

74
00:02:46,879 --> 00:02:50,800
with sequence comparison

75
00:02:49,120 --> 00:02:52,560
and broadly speaking There are two main

76
00:02:50,800 --> 00:02:55,200
categories of sequence alignments,

77
00:02:52,560 --> 00:02:57,440
global and local. Global alignment

78
00:02:55,200 --> 00:02:59,680
compares entire sequences end to end

79
00:02:57,440 --> 00:03:01,680
while local alignment fi focuses on

80
00:02:59,680 --> 00:03:03,519
finding the best matching regions within

81
00:03:01,680 --> 00:03:05,680
the sequences.

82
00:03:03,519 --> 00:03:08,080
Um local alignment is particularly

83
00:03:05,680 --> 00:03:10,000
important in biology because proteins

84
00:03:08,080 --> 00:03:13,280
often share only a single domain or a

85
00:03:10,000 --> 00:03:15,519
short motive. For instance, um these

86
00:03:13,280 --> 00:03:18,239
structures share conserved regions shown

87
00:03:15,519 --> 00:03:19,920
here in green. It can be critical for

88
00:03:18,239 --> 00:03:22,720
function or can simply reflect

89
00:03:19,920 --> 00:03:24,239
evolutionary history. And therefore when

90
00:03:22,720 --> 00:03:26,080
we are interested in functional

91
00:03:24,239 --> 00:03:28,480
similarity or evolutionary

92
00:03:26,080 --> 00:03:30,400
relationships, local alignment methods

93
00:03:28,480 --> 00:03:31,920
could be more appropriate than global

94
00:03:30,400 --> 00:03:33,680
alignment.

95
00:03:31,920 --> 00:03:35,440
Um one of the earliest and most

96
00:03:33,680 --> 00:03:38,319
classical approaches is the Smith

97
00:03:35,440 --> 00:03:40,720
Waterman algorithm. It finds the optimal

98
00:03:38,319 --> 00:03:45,599
local alignment between two sequences

99
00:03:40,720 --> 00:03:48,599
based on the dynamic programming and it

100
00:03:45,599 --> 00:03:48,599
captalates

101
00:03:59,840 --> 00:04:05,280
all possible local alignments by fing a

102
00:04:02,560 --> 00:04:07,360
scoring matrix and the algorithm begins

103
00:04:05,280 --> 00:04:09,920
by initializing the metric mat with

104
00:04:07,360 --> 00:04:13,120
zeros and then filled it according to a

105
00:04:09,920 --> 00:04:15,120
substitution matrix and gap penalties.

106
00:04:13,120 --> 00:04:17,440
Um for example to calculate the score

107
00:04:15,120 --> 00:04:19,040
for the yellow cell we consider three

108
00:04:17,440 --> 00:04:20,959
candidate

109
00:04:19,040 --> 00:04:23,840
um scores derived from the three green

110
00:04:20,959 --> 00:04:27,280
cells from the diagonal green cell since

111
00:04:23,840 --> 00:04:29,440
the letters in both sequence match as t.

112
00:04:27,280 --> 00:04:33,280
The sufficitution matrix gives a score

113
00:04:29,440 --> 00:04:35,520
of four which is 1 + 3 and from the top

114
00:04:33,280 --> 00:04:39,120
green cell a vertical move indicates a

115
00:04:35,520 --> 00:04:42,160
gap. So applying a gap penalty of minus2

116
00:04:39,120 --> 00:04:44,639
it's minus2 and from the left green cell

117
00:04:42,160 --> 00:04:47,759
applying the gap penalty of minus2 gives

118
00:04:44,639 --> 00:04:49,919
6 - 2 equals 4 and the value for the

119
00:04:47,759 --> 00:04:53,120
yellow cell is the maximum of these

120
00:04:49,919 --> 00:04:56,479
three candidates four zero and four. So

121
00:04:53,120 --> 00:04:58,160
it becomes four because this maximum can

122
00:04:56,479 --> 00:05:00,639
be obtained in two ways from the

123
00:04:58,160 --> 00:05:03,280
diagonal and the and from the left two

124
00:05:00,639 --> 00:05:05,759
red arrows are drawn to indicate both

125
00:05:03,280 --> 00:05:09,440
trace back options. So there are arrows

126
00:05:05,759 --> 00:05:11,680
from 1 to 4 and 6 to 4. After filling

127
00:05:09,440 --> 00:05:15,520
the scoring matrix, the algorithm finds

128
00:05:11,680 --> 00:05:17,840
the highest value. So here 13 and it it

129
00:05:15,520 --> 00:05:20,720
traces back from that cell until it

130
00:05:17,840 --> 00:05:22,639
reaches a cell with value zero. The

131
00:05:20,720 --> 00:05:24,479
trace path is the optimal local

132
00:05:22,639 --> 00:05:26,400
alignment.

133
00:05:24,479 --> 00:05:28,320
Computing all possible alignments makes

134
00:05:26,400 --> 00:05:31,120
Smith Woman extremely sensitive.

135
00:05:28,320 --> 00:05:33,039
However, it is also very slow with time

136
00:05:31,120 --> 00:05:35,680
complexity proportional to the product

137
00:05:33,039 --> 00:05:37,840
of the sequence length. As a result,

138
00:05:35,680 --> 00:05:41,039
searching against large databases using

139
00:05:37,840 --> 00:05:43,039
Smith Waterman alone is invisible. So,

140
00:05:41,039 --> 00:05:44,880
in summary, Smith Waterman provides the

141
00:05:43,039 --> 00:05:47,120
gold standard for local sequence

142
00:05:44,880 --> 00:05:49,600
alignment in terms of sensitivity and

143
00:05:47,120 --> 00:05:51,520
accuracy, but its computational cost

144
00:05:49,600 --> 00:05:53,520
makes it impractical for large scale

145
00:05:51,520 --> 00:05:55,199
database searches.

146
00:05:53,520 --> 00:05:58,160
So, the field needed something faster

147
00:05:55,199 --> 00:06:00,000
and that's why blast was developed. Last

148
00:05:58,160 --> 00:06:02,639
makes it possible to search a sequence

149
00:06:00,000 --> 00:06:06,400
against a large database such as refig

150
00:06:02,639 --> 00:06:08,720
gem bank or Swiss proud and pdbid

151
00:06:06,400 --> 00:06:10,639
uses short words or cers to see the

152
00:06:08,720 --> 00:06:12,479
alignments

153
00:06:10,639 --> 00:06:14,880
and [clears throat] then extends them.

154
00:06:12,479 --> 00:06:17,680
These initial matches shown as dots in a

155
00:06:14,880 --> 00:06:20,319
dot plot serve as seas that are extended

156
00:06:17,680 --> 00:06:22,400
into alignments. So if the sequences are

157
00:06:20,319 --> 00:06:25,360
homologous you will see a diagonal line

158
00:06:22,400 --> 00:06:28,080
of dots as in the figure on the left and

159
00:06:25,360 --> 00:06:30,400
if not only a few scatter dots appear as

160
00:06:28,080 --> 00:06:33,199
in the figure on the right. And this

161
00:06:30,400 --> 00:06:35,600
heristic approach is much faster and it

162
00:06:33,199 --> 00:06:37,759
revolutionized sequence searching but as

163
00:06:35,600 --> 00:06:40,240
databases grew from thousands to

164
00:06:37,759 --> 00:06:43,199
millions of sequences even blast began

165
00:06:40,240 --> 00:06:46,880
to feel slow. So to overcome this

166
00:06:43,199 --> 00:06:49,840
limitation MF6 was introduced. Um the

167
00:06:46,880 --> 00:06:51,840
main idea is to filter sequences

168
00:06:49,840 --> 00:06:53,759
as quickly as possible so that more

169
00:06:51,840 --> 00:06:56,479
computation time can be spent on

170
00:06:53,759 --> 00:06:58,400
meaningful true positives. For this it

171
00:06:56,479 --> 00:07:01,520
needs a pref filter which is fast and

172
00:06:58,400 --> 00:07:03,759
sensitive. The mm6 process work like

173
00:07:01,520 --> 00:07:06,080
this. First it finds the double kr

174
00:07:03,759 --> 00:07:08,639
matches on the diagonal then runs

175
00:07:06,080 --> 00:07:10,880
ungapped alignment and if the score is

176
00:07:08,639 --> 00:07:12,479
high enough it runs gapped alignment.

177
00:07:10,880 --> 00:07:14,960
the the data size is reduced

178
00:07:12,479 --> 00:07:18,319
dramatically at each stage from 10 to

179
00:07:14,960 --> 00:07:20,720
the^ of 8 to 10 to the^ of five and then

180
00:07:18,319 --> 00:07:23,120
three and so on so that the algorithm

181
00:07:20,720 --> 00:07:26,800
can focus only for the subset of the

182
00:07:23,120 --> 00:07:29,520
targets and the final gap alignments.

183
00:07:26,800 --> 00:07:32,400
Um aides from being optimized for modern

184
00:07:29,520 --> 00:07:34,240
hardware also incorporates al

185
00:07:32,400 --> 00:07:36,800
algorithmmetrics that make it both

186
00:07:34,240 --> 00:07:40,319
sensitive and fast. It combines space

187
00:07:36,800 --> 00:07:42,080
cam indexing and optimize Smith waterman

188
00:07:40,319 --> 00:07:44,000
extensions.

189
00:07:42,080 --> 00:07:46,240
It uses space cameras for the curry

190
00:07:44,000 --> 00:07:48,000
sequences which makes it less strict and

191
00:07:46,240 --> 00:07:51,039
allows it to catch alignments with

192
00:07:48,000 --> 00:07:52,880
subtle mutations. For example, from this

193
00:07:51,039 --> 00:07:55,120
curry sequence, it doesn't use

194
00:07:52,880 --> 00:07:58,639
sequential sequential amino acids as

195
00:07:55,120 --> 00:08:00,560
cameras but it uses space. And moreover,

196
00:07:58,639 --> 00:08:03,120
while searching the speech camer against

197
00:08:00,560 --> 00:08:06,240
the target database, it considers not

198
00:08:03,120 --> 00:08:09,120
only the exact cam but also the similar

199
00:08:06,240 --> 00:08:11,440
gamers for the same reason.

200
00:08:09,120 --> 00:08:13,199
And as a result, MM6 is hundreds of

201
00:08:11,440 --> 00:08:15,360
times faster than blast enabling

202
00:08:13,199 --> 00:08:17,680
practical large scale large scale

203
00:08:15,360 --> 00:08:19,520
searches across today's massive sequence

204
00:08:17,680 --> 00:08:22,560
databases.

205
00:08:19,520 --> 00:08:24,479
But sequence similarity has its limits.

206
00:08:22,560 --> 00:08:26,720
Um sometimes two proteins have very

207
00:08:24,479 --> 00:08:29,120
different sequences yet they fold into

208
00:08:26,720 --> 00:08:31,440
nearly identical 3D structures and

209
00:08:29,120 --> 00:08:33,200
perform the same function. Consider

210
00:08:31,440 --> 00:08:36,880
these two proteins. Both remove

211
00:08:33,200 --> 00:08:38,880
miscellated amino acids from tRNA and

212
00:08:36,880 --> 00:08:41,519
thus share functional similarity and

213
00:08:38,880 --> 00:08:43,599
also the structural similarity. But

214
00:08:41,519 --> 00:08:46,160
their sequences are so different. Um

215
00:08:43,599 --> 00:08:48,880
each sequence is longer than 130 amino

216
00:08:46,160 --> 00:08:52,480
acids. But when aligned with Smith

217
00:08:48,880 --> 00:08:54,720
Waterman um only 16 amino acid was

218
00:08:52,480 --> 00:08:58,080
aligned with eight matches and eight

219
00:08:54,720 --> 00:08:59,920
mismatches. So when aligned with blast P

220
00:08:58,080 --> 00:09:03,040
the protein version of blast no

221
00:08:59,920 --> 00:09:04,880
alignment is detected at all. Proteins

222
00:09:03,040 --> 00:09:07,040
with similar structures can often carry

223
00:09:04,880 --> 00:09:08,720
out similar functions even if their

224
00:09:07,040 --> 00:09:11,600
sequences have diverged beyond

225
00:09:08,720 --> 00:09:14,320
recognition. So recognizing such cases

226
00:09:11,600 --> 00:09:17,519
provides evolutionary insights and

227
00:09:14,320 --> 00:09:20,399
informs protein structure prediction

228
00:09:17,519 --> 00:09:21,920
um um protein structure prediction and

229
00:09:20,399 --> 00:09:25,120
um function prediction and even

230
00:09:21,920 --> 00:09:28,000
pathogenic city studies. This brings us

231
00:09:25,120 --> 00:09:30,480
to structure alignment. The idea here is

232
00:09:28,000 --> 00:09:33,200
that structure is more conserved during

233
00:09:30,480 --> 00:09:35,200
evolution and as with sequences there

234
00:09:33,200 --> 00:09:38,320
are both global and local alignment

235
00:09:35,200 --> 00:09:40,399
methods. Um, global alignment finds the

236
00:09:38,320 --> 00:09:42,320
best end to end match while local

237
00:09:40,399 --> 00:09:44,000
alignment identifies similar

238
00:09:42,320 --> 00:09:45,279
substructures.

239
00:09:44,000 --> 00:09:46,959
And because sequences are

240
00:09:45,279 --> 00:09:48,720
one-dimensional and structures are

241
00:09:46,959 --> 00:09:51,839
three-dimensional, there are several

242
00:09:48,720 --> 00:09:54,480
ways to present the um represent

243
00:09:51,839 --> 00:09:56,959
structural similarity. First as 30

244
00:09:54,480 --> 00:10:00,560
structure and second as 2D distance

245
00:09:56,959 --> 00:10:02,480
matrix and third as um 1D secondary

246
00:10:00,560 --> 00:10:04,560
structure strings.

247
00:10:02,480 --> 00:10:07,040
For example, in the 2D distance matrix

248
00:10:04,560 --> 00:10:09,440
approach for a protein of length N, you

249
00:10:07,040 --> 00:10:12,720
can build an N byN distance matrix where

250
00:10:09,440 --> 00:10:15,760
entry J is the distance between C alpha

251
00:10:12,720 --> 00:10:18,160
atoms of the residue Y and residue J.

252
00:10:15,760 --> 00:10:21,440
Um, so today I'll talk about three

253
00:10:18,160 --> 00:10:24,079
methods, one for each category. First,

254
00:10:21,440 --> 00:10:26,480
TML is a state-of-the-art global

255
00:10:24,079 --> 00:10:29,200
alignment tool that works directly in

256
00:10:26,480 --> 00:10:31,680
3D. Its goal is to produce a global

257
00:10:29,200 --> 00:10:34,880
alignments and an optimal superposition

258
00:10:31,680 --> 00:10:37,200
that maximize the structural similarity.

259
00:10:34,880 --> 00:10:40,320
First, it introduced its own similarity

260
00:10:37,200 --> 00:10:42,800
score called TM score. And unlike RMSD,

261
00:10:40,320 --> 00:10:44,959
which is very sensitive to outliers, the

262
00:10:42,800 --> 00:10:48,079
TM score is a length normalized measure

263
00:10:44,959 --> 00:10:51,120
that rewards many close residue pairs

264
00:10:48,079 --> 00:10:53,839
while discounting far apart mismatches.

265
00:10:51,120 --> 00:10:56,560
um the TM score ranges from 0 to one and

266
00:10:53,839 --> 00:10:58,640
generally a TM score higher than 0.5

267
00:10:56,560 --> 00:11:01,519
indicates the two proteins adopt a

268
00:10:58,640 --> 00:11:03,920
similar fold. So it begins with an

269
00:11:01,519 --> 00:11:06,720
initial rough alignment and given a set

270
00:11:03,920 --> 00:11:09,279
of aligned residue pairs it computes an

271
00:11:06,720 --> 00:11:12,480
optimal rigid body superposition

272
00:11:09,279 --> 00:11:14,800
and by using dynamic programming it's um

273
00:11:12,480 --> 00:11:17,440
update the align updates the alignments

274
00:11:14,800 --> 00:11:20,079
under the current transformation. So the

275
00:11:17,440 --> 00:11:22,399
cycle of superposition and scoring and

276
00:11:20,079 --> 00:11:24,160
realignment repeats until the

277
00:11:22,399 --> 00:11:26,640
convergence

278
00:11:24,160 --> 00:11:29,120
and because of its iterative refinement

279
00:11:26,640 --> 00:11:30,640
CML is both robust and efficient. It

280
00:11:29,120 --> 00:11:32,160
avoids getting trapped by local

281
00:11:30,640 --> 00:11:35,040
mismatches

282
00:11:32,160 --> 00:11:37,519
um but and and instead it converges on

283
00:11:35,040 --> 00:11:41,040
the best overall structural alignment

284
00:11:37,519 --> 00:11:43,600
but um it's less suited for identifying

285
00:11:41,040 --> 00:11:46,000
small local similarities.

286
00:11:43,600 --> 00:11:47,920
Dali on the other hand is a local

287
00:11:46,000 --> 00:11:50,240
alignment algorithm based on distance

288
00:11:47,920 --> 00:11:52,480
matrices. Instead of directly

289
00:11:50,240 --> 00:11:54,399
superimposing the coordinates, Dolly

290
00:11:52,480 --> 00:11:57,120
compares the internal distance patterns

291
00:11:54,399 --> 00:11:59,519
of products. Um here's a general

292
00:11:57,120 --> 00:12:01,440
workflow. Darly first computes the

293
00:11:59,519 --> 00:12:04,240
distance map for each structure and

294
00:12:01,440 --> 00:12:06,240
these large matrices are then split into

295
00:12:04,240 --> 00:12:08,639
smaller submatrices.

296
00:12:06,240 --> 00:12:10,959
The algorithm then scans for similar

297
00:12:08,639 --> 00:12:14,240
submatrices between the curry and the

298
00:12:10,959 --> 00:12:16,480
target proteins here A and B. And if a

299
00:12:14,240 --> 00:12:19,120
sub matrices from protein A matches one

300
00:12:16,480 --> 00:12:21,040
from protein B, it this indicates that

301
00:12:19,120 --> 00:12:24,959
the two regions may share a conserved

302
00:12:21,040 --> 00:12:27,600
structural motive. Next um the matches

303
00:12:24,959 --> 00:12:29,760
are concatenated into longer alignments

304
00:12:27,600 --> 00:12:33,279
often using Monte Carlo optimization

305
00:12:29,760 --> 00:12:37,839
procedure and it's it does it like

306
00:12:33,279 --> 00:12:39,839
iteratively until it reaches convergence

307
00:12:37,839 --> 00:12:42,480
because Dolly operates at the level of

308
00:12:39,839 --> 00:12:44,560
distance patterns not absolute not the

309
00:12:42,480 --> 00:12:47,040
absolute coordinates. It is very good at

310
00:12:44,560 --> 00:12:48,880
detecting recurrent local motives even

311
00:12:47,040 --> 00:12:50,399
if the proteins are proteins defer

312
00:12:48,880 --> 00:12:52,480
globally.

313
00:12:50,399 --> 00:12:54,880
In short, while TML excels at

314
00:12:52,480 --> 00:12:56,959
recognizing entire fold similarities,

315
00:12:54,880 --> 00:12:58,639
Dolly shines at finding local structural

316
00:12:56,959 --> 00:13:00,560
motives and conserved domains of

317
00:12:58,639 --> 00:13:02,639
proteins.

318
00:13:00,560 --> 00:13:04,639
With such structural alignment methods,

319
00:13:02,639 --> 00:13:06,800
we can detect proteins with very low

320
00:13:04,639 --> 00:13:09,040
sequence identity but strikingly similar

321
00:13:06,800 --> 00:13:11,680
folds. For example, these are the

322
00:13:09,040 --> 00:13:14,399
structures I showed a few slides ago.

323
00:13:11,680 --> 00:13:17,120
And TM line can give this proteins a TM

324
00:13:14,399 --> 00:13:19,600
score higher than 0.7.

325
00:13:17,120 --> 00:13:21,839
Since a TM score above 0.5 generally

326
00:13:19,600 --> 00:13:24,480
indicates structural similarity, this

327
00:13:21,839 --> 00:13:26,160
reveals relationships missed by sequence

328
00:13:24,480 --> 00:13:28,560
alone.

329
00:13:26,160 --> 00:13:30,240
Both tools are powerful, but how long

330
00:13:28,560 --> 00:13:33,920
would it take to search one sequence

331
00:13:30,240 --> 00:13:36,720
against Alpha Flow DB? Powered by Alpha

332
00:13:33,920 --> 00:13:40,240
2, AFDB contains nearly every predicted

333
00:13:36,720 --> 00:13:43,360
uniroin with over 200 million entries.

334
00:13:40,240 --> 00:13:46,000
So um but even for smaller databases

335
00:13:43,360 --> 00:13:49,040
like Swiss prod which has about 800,000

336
00:13:46,000 --> 00:13:51,519
entries deli may take a week and TMLI

337
00:13:49,040 --> 00:13:54,560
may take more than a day and for the

338
00:13:51,519 --> 00:13:56,639
whole alpha DB tali would need about a

339
00:13:54,560 --> 00:13:59,199
year to search a single sequence against

340
00:13:56,639 --> 00:14:02,000
the entire database and Dolly would need

341
00:13:59,199 --> 00:14:04,079
about seven years. If searching a single

342
00:14:02,000 --> 00:14:06,240
sequence takes this amount of time it is

343
00:14:04,079 --> 00:14:09,120
nearly impossible to conduct meaningful

344
00:14:06,240 --> 00:14:11,199
research on such large databases.

345
00:14:09,120 --> 00:14:15,120
Thus, despite their accuracy, these

346
00:14:11,199 --> 00:14:16,959
tools face a scalability problem. And to

347
00:14:15,120 --> 00:14:19,040
overcome this bottleneck, our lab

348
00:14:16,959 --> 00:14:20,800
developed full

349
00:14:19,040 --> 00:14:22,639
transforms protein structure into

350
00:14:20,800 --> 00:14:25,440
one-dimensional sequences and then

351
00:14:22,639 --> 00:14:27,600
applies MM62 and it combines the speed

352
00:14:25,440 --> 00:14:30,320
of sequence alignment with the depths of

353
00:14:27,600 --> 00:14:32,480
structural information. As a result,

354
00:14:30,320 --> 00:14:34,800
tasks that would take days or weeks with

355
00:14:32,480 --> 00:14:37,920
traditional tools can be performed in

356
00:14:34,800 --> 00:14:40,560
seconds with full. The key idea of old

357
00:14:37,920 --> 00:14:44,959
sig is reducing the dimensionality from

358
00:14:40,560 --> 00:14:46,959
3D to 1d. And here is how it works.

359
00:14:44,959 --> 00:14:49,360
Assuming found the nearest blue residue

360
00:14:46,959 --> 00:14:51,040
for the given red residue by also

361
00:14:49,360 --> 00:14:53,760
considering the preceding and the

362
00:14:51,040 --> 00:14:55,839
following residues. Fig extracts

363
00:14:53,760 --> 00:14:58,079
geometric features such as angles and

364
00:14:55,839 --> 00:14:59,360
distances. So how does full stick

365
00:14:58,079 --> 00:15:02,560
retrieve the nearest neighboring

366
00:14:59,360 --> 00:15:06,160
residue? It uses virtual centers defined

367
00:15:02,560 --> 00:15:08,240
by C alpha, C beta and N and C atoms. So

368
00:15:06,160 --> 00:15:10,720
each residue thus has one virtual

369
00:15:08,240 --> 00:15:13,360
center. For example, from these

370
00:15:10,720 --> 00:15:16,160
structures, this structure, it retrieves

371
00:15:13,360 --> 00:15:18,160
a virtual center for every residue and

372
00:15:16,160 --> 00:15:22,720
then finds the nearest residue for each

373
00:15:18,160 --> 00:15:24,959
one using those virtual centers. Um

374
00:15:22,720 --> 00:15:26,399
for this red virtual center, um the

375
00:15:24,959 --> 00:15:28,880
nearest neighbor would be this green

376
00:15:26,399 --> 00:15:31,040
one. To sum up, it finds neighboring

377
00:15:28,880 --> 00:15:33,519
residues using virtual centers and

378
00:15:31,040 --> 00:15:37,199
extract the 30 descriptors and then

379
00:15:33,519 --> 00:15:39,199
encodes this features using a VQV model.

380
00:15:37,199 --> 00:15:41,519
Finally, a single letter is assigned to

381
00:15:39,199 --> 00:15:43,440
each residue and as a result, similar

382
00:15:41,519 --> 00:15:45,600
structures are encoded into similar

383
00:15:43,440 --> 00:15:47,760
letter sequences as you can see in the

384
00:15:45,600 --> 00:15:50,480
figures on the right and these letters

385
00:15:47,760 --> 00:15:53,199
are called 30i letters. Because the

386
00:15:50,480 --> 00:15:55,120
resulted alphabet consists of 20 letters

387
00:15:53,199 --> 00:15:57,199
the same as the number of amino acid

388
00:15:55,120 --> 00:16:00,079
types. The encoded structures can be

389
00:15:57,199 --> 00:16:02,720
directly input into MM62 which is

390
00:16:00,079 --> 00:16:04,639
sequence alignment software.

391
00:16:02,720 --> 00:16:06,720
And for example consider two structures

392
00:16:04,639 --> 00:16:10,399
that diverged more than a billion years

393
00:16:06,720 --> 00:16:12,720
ago. Their sequence identity is only 16%

394
00:16:10,399 --> 00:16:17,120
but after converting them into 3DI

395
00:16:12,720 --> 00:16:18,880
sequences their identity rises to 54%.

396
00:16:17,120 --> 00:16:20,639
And this makes it possible to capture

397
00:16:18,880 --> 00:16:22,639
their similarity using sequence

398
00:16:20,639 --> 00:16:24,880
alignment methods.

399
00:16:22,639 --> 00:16:27,519
In summary, unfolic bridges the gap

400
00:16:24,880 --> 00:16:29,360
between accuracy and scalability. It

401
00:16:27,519 --> 00:16:31,759
achieves structural sensitivity

402
00:16:29,360 --> 00:16:33,920
comparable to classical tools like Dali

403
00:16:31,759 --> 00:16:36,800
and TM online while maintaining the

404
00:16:33,920 --> 00:16:39,519
speed of sequence-based methods. Then

405
00:16:36,800 --> 00:16:42,079
what is the next bottleneck? Even with

406
00:16:39,519 --> 00:16:44,959
full sick databases continue to grow.

407
00:16:42,079 --> 00:16:47,759
The ESM metagenomic database contains

408
00:16:44,959 --> 00:16:49,839
more than 600 million entries. And in

409
00:16:47,759 --> 00:16:52,240
the future, if metagenomic resources

410
00:16:49,839 --> 00:16:54,240
such as login or magnify structures are

411
00:16:52,240 --> 00:16:56,800
predicted, there could be billions of

412
00:16:54,240 --> 00:16:58,560
prod entries waiting to be analyzed. And

413
00:16:56,800 --> 00:17:01,920
conducting meaningful searches at these

414
00:16:58,560 --> 00:17:03,759
scale will be extremely challenging.

415
00:17:01,920 --> 00:17:06,000
So how can we make a meaningful but

416
00:17:03,759 --> 00:17:08,319
smaller database? Imagine we have 12

417
00:17:06,000 --> 00:17:10,559
structures and by clustering them by

418
00:17:08,319 --> 00:17:13,280
similarity, we can reduce them to three

419
00:17:10,559 --> 00:17:15,120
clusters. So we can reduce the size of

420
00:17:13,280 --> 00:17:17,679
the database with little information

421
00:17:15,120 --> 00:17:20,400
loss. In practice, clustering can be

422
00:17:17,679 --> 00:17:22,240
framed as great graph clustering. Each

423
00:17:20,400 --> 00:17:25,439
sequence is a node and significant

424
00:17:22,240 --> 00:17:28,400
alignments form edges. There are several

425
00:17:25,439 --> 00:17:31,440
approaches and I'll um the first one is

426
00:17:28,400 --> 00:17:34,240
the set cover algorithm and set cover

427
00:17:31,440 --> 00:17:35,919
picks representative node and form a

428
00:17:34,240 --> 00:17:37,919
cluster with all its neighbors and

429
00:17:35,919 --> 00:17:39,600
removes those nodes. And then it picks

430
00:17:37,919 --> 00:17:41,919
another representative and forms a

431
00:17:39,600 --> 00:17:44,640
cluster and remove and it repeats until

432
00:17:41,919 --> 00:17:47,120
this until every node is assigned.

433
00:17:44,640 --> 00:17:49,039
Second connected component algorithm

434
00:17:47,120 --> 00:17:51,520
form clusters by taking connected

435
00:17:49,039 --> 00:17:53,679
components of one of the graph. So every

436
00:17:51,520 --> 00:17:56,400
node in a connected component belongs to

437
00:17:53,679 --> 00:17:58,400
the same cluster. This often produces a

438
00:17:56,400 --> 00:18:01,120
small number of clusters but can include

439
00:17:58,400 --> 00:18:03,440
noisy members. And for example that

440
00:18:01,120 --> 00:18:06,799
these two yellow sequences may not have

441
00:18:03,440 --> 00:18:09,200
sequence similarity at all. Third grid

442
00:18:06,799 --> 00:18:11,760
incremental algorithm sorts sequences by

443
00:18:09,200 --> 00:18:14,720
length. It picks the longest remaining

444
00:18:11,760 --> 00:18:17,280
sequence and as a cluster center and

445
00:18:14,720 --> 00:18:19,919
assigns all neighbors to it and remove

446
00:18:17,280 --> 00:18:22,559
the assigned sequences and repeats it.

447
00:18:19,919 --> 00:18:25,919
This helps keep full length sequences

448
00:18:22,559 --> 00:18:28,400
and their fragments clustered together.

449
00:18:25,919 --> 00:18:30,799
And how long would cluster take? A knife

450
00:18:28,400 --> 00:18:34,799
clustering method has quadratic

451
00:18:30,799 --> 00:18:37,120
quadratic time complexity. Imagine dots

452
00:18:34,799 --> 00:18:40,480
representing sequences or structures and

453
00:18:37,120 --> 00:18:42,640
k clusters initially empty. You take the

454
00:18:40,480 --> 00:18:45,039
first blue dot and then assign it to the

455
00:18:42,640 --> 00:18:47,120
first cluster. For each subsequent dot,

456
00:18:45,039 --> 00:18:49,280
you compare it to existing cluster

457
00:18:47,120 --> 00:18:51,360
representatives and if it is similar

458
00:18:49,280 --> 00:18:54,240
enough, it joins that cluster and

459
00:18:51,360 --> 00:18:56,640
otherwise it becomes a new cluster. For

460
00:18:54,240 --> 00:18:59,600
example, the second dot may not match

461
00:18:56,640 --> 00:19:02,720
the first and so starts the new cluster

462
00:18:59,600 --> 00:19:05,280
and the third dot may match the second

463
00:19:02,720 --> 00:19:07,280
cluster. So join that cluster and

464
00:19:05,280 --> 00:19:10,559
repeating this process yields K

465
00:19:07,280 --> 00:19:13,760
clusters. But if K grows up to N, the

466
00:19:10,559 --> 00:19:16,160
algorithm requires quadratic runtime.

467
00:19:13,760 --> 00:19:18,720
Most clustering algorithms scale near

468
00:19:16,160 --> 00:19:20,320
quadratically because assigning it new

469
00:19:18,720 --> 00:19:23,280
new sequence can require many

470
00:19:20,320 --> 00:19:26,080
comparisons. So clustering a billion

471
00:19:23,280 --> 00:19:27,760
sequences requires almost 10 to 18

472
00:19:26,080 --> 00:19:30,080
comparisons.

473
00:19:27,760 --> 00:19:32,400
Linklas was developed to achieve linear

474
00:19:30,080 --> 00:19:34,240
scaling. Clustering only requires 20

475
00:19:32,400 --> 00:19:36,960
times of the number of the sequences.

476
00:19:34,240 --> 00:19:39,440
And how does it do that? It uses

477
00:19:36,960 --> 00:19:41,840
cameras. Linklas first selects 20

478
00:19:39,440 --> 00:19:46,799
cameras per sequence and group sequences

479
00:19:41,840 --> 00:19:48,640
to share a cam. Um for each camera group

480
00:19:46,799 --> 00:19:51,360
the longest sequence is chosen as a

481
00:19:48,640 --> 00:19:54,960
center and each other sequence in the

482
00:19:51,360 --> 00:19:57,360
group is aligned to that center because

483
00:19:54,960 --> 00:19:59,440
link avoids this kind of all VSSL

484
00:19:57,360 --> 00:20:02,480
comparison within groups it dramatically

485
00:19:59,440 --> 00:20:04,799
reduces runtime. If the alignment meets

486
00:20:02,480 --> 00:20:06,799
the clustering criteria an is thrown and

487
00:20:04,799 --> 00:20:09,280
they are clustered based on grid

488
00:20:06,799 --> 00:20:12,000
incremental algorithm.

489
00:20:09,280 --> 00:20:15,679
When we clustered alpha 4 DB sequences

490
00:20:12,000 --> 00:20:20,000
with MM6 by sequence identity 50% the

491
00:20:15,679 --> 00:20:21,919
size was reduced from 214 million to 53

492
00:20:20,000 --> 00:20:25,200
million and it makes a large scale

493
00:20:21,919 --> 00:20:27,600
analysis much more manageable.

494
00:20:25,200 --> 00:20:29,679
And in summary, we have seen how

495
00:20:27,600 --> 00:20:32,240
sequence and structure structure

496
00:20:29,679 --> 00:20:34,480
alignment methods allow us to explore

497
00:20:32,240 --> 00:20:37,360
protein similarities at different scales

498
00:20:34,480 --> 00:20:40,799
and sensitivities from Smith waterman to

499
00:20:37,360 --> 00:20:43,200
blast mm style tmine and fseek. Each

500
00:20:40,799 --> 00:20:45,600
tool addresses the specific need and

501
00:20:43,200 --> 00:20:48,240
bottleneck together with clustering

502
00:20:45,600 --> 00:20:50,320
strategies especially with link clust

503
00:20:48,240 --> 00:20:52,799
methods make it possible to work with

504
00:20:50,320 --> 00:20:54,720
unprecedentedly large biological

505
00:20:52,799 --> 00:20:56,080
databases.

506
00:20:54,720 --> 00:20:58,240
So we started with the fact that

507
00:20:56,080 --> 00:21:01,520
sequence searches form the basis of most

508
00:20:58,240 --> 00:21:04,159
of bioinformatics. Now with structures

509
00:21:01,520 --> 00:21:07,120
we can supercharge the analysis tools

510
00:21:04,159 --> 00:21:09,280
enables enable us to ask new questions

511
00:21:07,120 --> 00:21:11,840
and make discoveries that would have

512
00:21:09,280 --> 00:21:13,520
been impossible just a few years ago and

513
00:21:11,840 --> 00:21:15,440
they set the stage for professor

514
00:21:13,520 --> 00:21:17,440
Steiner's talk where you will see how

515
00:21:15,440 --> 00:21:20,240
these methods are applied to truly

516
00:21:17,440 --> 00:21:22,960
massive databases in practice. Thank you

517
00:21:20,240 --> 00:21:25,039
very much for your attention. So before

518
00:21:22,960 --> 00:21:26,880
we continue with the seminar with Martin

519
00:21:25,039 --> 00:21:29,440
Steiner, are there any questions you

520
00:21:26,880 --> 00:21:31,520
want to ask in um regards to the first

521
00:21:29,440 --> 00:21:35,520
session?

522
00:21:31,520 --> 00:21:37,840
field question is um whether uh whether

523
00:21:35,520 --> 00:21:40,559
you're using you know the 214 million

524
00:21:37,840 --> 00:21:43,520
alpha fold sequences somebody must have

525
00:21:40,559 --> 00:21:46,080
gone back and compared those 214 million

526
00:21:43,520 --> 00:21:48,720
sequences to properties of the the

527
00:21:46,080 --> 00:21:51,039
actual PTB database to understand

528
00:21:48,720 --> 00:21:53,919
whether there's biases in that in the

529
00:21:51,039 --> 00:21:56,400
alphafold uh database that would impact

530
00:21:53,919 --> 00:21:57,120
your results and our you know what we

531
00:21:56,400 --> 00:21:59,440
look at.

532
00:21:57,120 --> 00:22:01,039
>> Yeah. So you you're you're asking the

533
00:21:59,440 --> 00:22:02,400
quality of the models in some way. So

534
00:22:01,039 --> 00:22:03,360
can we really trust the models on the

535
00:22:02,400 --> 00:22:05,679
alpha fold structure?

536
00:22:03,360 --> 00:22:07,679
>> Subtle flaws in AlphaFold by direct

537
00:22:05,679 --> 00:22:08,320
comparison between AlphaFold and the

538
00:22:07,679 --> 00:22:11,039
PDB.

539
00:22:08,320 --> 00:22:13,280
>> Yeah, I mean the Yeah, that's a good

540
00:22:11,039 --> 00:22:15,360
question. I mean PDB has 200,000 entries

541
00:22:13,280 --> 00:22:17,360
and we have now 214 million entries in

542
00:22:15,360 --> 00:22:19,120
the Alphaold database. So I guess there

543
00:22:17,360 --> 00:22:21,440
will be quite a big disconnect where

544
00:22:19,120 --> 00:22:22,240
many will not align very well or at all

545
00:22:21,440 --> 00:22:24,159
to the PDB.

546
00:22:22,240 --> 00:22:25,120
>> Oh, I was thinking more even even local

547
00:22:24,159 --> 00:22:28,559
properties. Yeah,

548
00:22:25,120 --> 00:22:29,520
>> too many too many alpha helyses, uh,

549
00:22:28,559 --> 00:22:30,799
patterns, etc.

550
00:22:29,520 --> 00:22:32,960
>> Yeah, I'm not aware that somebody has

551
00:22:30,799 --> 00:22:34,320
done this like systematically at that at

552
00:22:32,960 --> 00:22:35,760
the scale of like really trying to

553
00:22:34,320 --> 00:22:37,120
figure out if there is something

554
00:22:35,760 --> 00:22:38,640
completely odd about some of these

555
00:22:37,120 --> 00:22:40,799
structures or like property wise. It's a

556
00:22:38,640 --> 00:22:42,400
very interesting um um idea. I think

557
00:22:40,799 --> 00:22:44,480
many of the faults should be pretty much

558
00:22:42,400 --> 00:22:46,000
conserved, right? We should find similar

559
00:22:44,480 --> 00:22:47,679
domains and so on and they are also in

560
00:22:46,000 --> 00:22:49,520
the PDB. So, we can check their quality

561
00:22:47,679 --> 00:22:51,360
and there is a work from TED um um

562
00:22:49,520 --> 00:22:53,840
Christine Orango's group and um David

563
00:22:51,360 --> 00:22:55,120
Jones's group. Um so that gives you can

564
00:22:53,840 --> 00:22:56,480
see how much coverage you have through

565
00:22:55,120 --> 00:22:59,600
that. I think that gives some kind of

566
00:22:56,480 --> 00:23:01,600
level of of of um um um guarantees. Um

567
00:22:59,600 --> 00:23:03,039
but for the other ones where we do not

568
00:23:01,600 --> 00:23:04,400
where we cannot map them back I don't

569
00:23:03,039 --> 00:23:05,840
think we have really systematically look

570
00:23:04,400 --> 00:23:07,120
into this and understand what that

571
00:23:05,840 --> 00:23:09,120
really is. Yeah.

572
00:23:07,120 --> 00:23:12,000
>> I think Christine has also looked at how

573
00:23:09,120 --> 00:23:14,640
many folds how many new folds are in yes

574
00:23:12,000 --> 00:23:16,240
>> alpha fault database compared to BDB

575
00:23:14,640 --> 00:23:17,679
>> right? But then there's many things that

576
00:23:16,240 --> 00:23:19,520
do not have something that are not

577
00:23:17,679 --> 00:23:20,720
annotated as a folder as a domain. And

578
00:23:19,520 --> 00:23:22,240
then the question is what are these

579
00:23:20,720 --> 00:23:23,360
pieces right? Like what are all of the

580
00:23:22,240 --> 00:23:27,640
missing pieces where we actually don't

581
00:23:23,360 --> 00:23:27,640
know what that is right? Yeah.

582
00:23:28,159 --> 00:23:32,559
>> Any other question?

583
00:23:30,720 --> 00:23:33,440
Great. Then we can just continue. Thank

584
00:23:32,559 --> 00:23:35,600
you Martin.

585
00:23:33,440 --> 00:23:37,440
>> Okay. Um thank you so much for the

586
00:23:35,600 --> 00:23:39,520
introduction and also um giving me the

587
00:23:37,440 --> 00:23:40,880
chance to present here and it's a very

588
00:23:39,520 --> 00:23:42,960
interesting format. It's the first time

589
00:23:40,880 --> 00:23:44,559
I have this like precursor and um thank

590
00:23:42,960 --> 00:23:47,120
you Suang really to set up so many

591
00:23:44,559 --> 00:23:49,039
things up for me so I can skip many

592
00:23:47,120 --> 00:23:52,559
topics um and can get over them very

593
00:23:49,039 --> 00:23:54,080
very fast. Um so before getting started

594
00:23:52,559 --> 00:23:56,400
um the most important things we have

595
00:23:54,080 --> 00:23:58,640
stickers with me with us. Um so if you

596
00:23:56,400 --> 00:24:00,559
if you like our software and you you you

597
00:23:58,640 --> 00:24:03,360
want some stickers please come to us um

598
00:24:00,559 --> 00:24:04,720
um get them because like we really don't

599
00:24:03,360 --> 00:24:06,799
want to bring them back to South Korea.

600
00:24:04,720 --> 00:24:10,080
Um so it would be nice if you can just

601
00:24:06,799 --> 00:24:11,600
come up and um yeah uh pick them up.

602
00:24:10,080 --> 00:24:14,400
Okay. So I'm pretty much interested in

603
00:24:11,600 --> 00:24:16,960
exploring the global proteomic diversity

604
00:24:14,400 --> 00:24:19,039
already started from my from my PhD like

605
00:24:16,960 --> 00:24:21,120
an analyzing really big protein sets and

606
00:24:19,039 --> 00:24:22,400
I think this really it motivates me

607
00:24:21,120 --> 00:24:23,919
because I feel like there are many

608
00:24:22,400 --> 00:24:25,919
pressing problems that we have these

609
00:24:23,919 --> 00:24:27,840
days you know like plastic pollution for

610
00:24:25,919 --> 00:24:30,000
example but then if you go out there you

611
00:24:27,840 --> 00:24:31,600
can find peptases you can find enzymes

612
00:24:30,000 --> 00:24:33,120
that can break them apart we have

613
00:24:31,600 --> 00:24:34,799
carbonization of the planet we have

614
00:24:33,120 --> 00:24:37,520
organisms that capture and put them down

615
00:24:34,799 --> 00:24:39,440
to the the oceans right um we have

616
00:24:37,520 --> 00:24:41,360
antibiotic resistance but then we have

617
00:24:39,440 --> 00:24:43,200
medicine out that is just developed by

618
00:24:41,360 --> 00:24:45,760
in nature from bacteria to attack other

619
00:24:43,200 --> 00:24:47,200
bacteria. And one project that we do

620
00:24:45,760 --> 00:24:49,039
together with the Novon Nordisk

621
00:24:47,200 --> 00:24:50,799
Foundation um funded by No Foundation

622
00:24:49,039 --> 00:24:53,039
and researchers in Copenhagen is the

623
00:24:50,799 --> 00:24:55,200
idea to go back to ancient proteomic

624
00:24:53,039 --> 00:24:57,919
diversity and drill into the into the

625
00:24:55,200 --> 00:25:00,000
core and like sequence it to revive

626
00:24:57,919 --> 00:25:02,559
ancient mutation of plants to make

627
00:25:00,000 --> 00:25:04,080
plants growable under changed climate.

628
00:25:02,559 --> 00:25:06,240
You know we the planet is getting

629
00:25:04,080 --> 00:25:07,760
hotter. So what mutations do we have to

630
00:25:06,240 --> 00:25:09,840
put into plants in order to make them

631
00:25:07,760 --> 00:25:11,600
growable um under these conditions? So

632
00:25:09,840 --> 00:25:13,440
learning from ancient data I think

633
00:25:11,600 --> 00:25:15,520
that's really all yeah just like a small

634
00:25:13,440 --> 00:25:17,520
glimpse of what is possible but really

635
00:25:15,520 --> 00:25:19,919
the technique how to do that is using

636
00:25:17,520 --> 00:25:23,039
metagenomics right so you go out there

637
00:25:19,919 --> 00:25:25,200
you sequence oceans you sequence um um

638
00:25:23,039 --> 00:25:27,200
soil whatever you want to sequence and

639
00:25:25,200 --> 00:25:28,559
you do it by sampling that and put into

640
00:25:27,200 --> 00:25:30,400
sequencing machine and what you get out

641
00:25:28,559 --> 00:25:32,000
is like these short reads like terabytes

642
00:25:30,400 --> 00:25:33,679
of reads and then once you have these

643
00:25:32,000 --> 00:25:35,840
reads you can start asking questions

644
00:25:33,679 --> 00:25:37,200
right so you can take these reads and

645
00:25:35,840 --> 00:25:38,880
you can search them against reference

646
00:25:37,200 --> 00:25:40,400
genomic databases right and then you

647
00:25:38,880 --> 00:25:42,320
know that This read is for example from

648
00:25:40,400 --> 00:25:43,440
an E.coli and therefore that's an E.oli

649
00:25:42,320 --> 00:25:45,840
and so you can kind of assign

650
00:25:43,440 --> 00:25:47,919
taxonomical labels. You can also take

651
00:25:45,840 --> 00:25:50,159
these reads take the six frame

652
00:25:47,919 --> 00:25:51,760
translated version of it and search it

653
00:25:50,159 --> 00:25:52,720
back against protein databases and then

654
00:25:51,760 --> 00:25:53,760
you can figure out what are these

655
00:25:52,720 --> 00:25:54,960
functions and I think that's really

656
00:25:53,760 --> 00:25:57,360
critical to understand what these

657
00:25:54,960 --> 00:25:58,960
microbes can do or you can take the

658
00:25:57,360 --> 00:26:00,960
whole bag of reads and try to

659
00:25:58,960 --> 00:26:02,480
reconstruct metabolic pathways. So what

660
00:26:00,960 --> 00:26:05,600
kind of communication patterns might be

661
00:26:02,480 --> 00:26:07,200
existing in these microbes? Um and I

662
00:26:05,600 --> 00:26:08,720
think all of these is really dependent

663
00:26:07,200 --> 00:26:10,799
on search right. So your initial search

664
00:26:08,720 --> 00:26:12,559
is important. The problem is that 50 to

665
00:26:10,799 --> 00:26:14,000
90% of these proteins remains

666
00:26:12,559 --> 00:26:16,000
unanotated. Especially if you work on

667
00:26:14,000 --> 00:26:17,360
soil or like environmental samples, many

668
00:26:16,000 --> 00:26:18,880
of these things you cannot map to

669
00:26:17,360 --> 00:26:20,240
anything. We don't know. That means we

670
00:26:18,880 --> 00:26:21,760
don't even use these data. We often

671
00:26:20,240 --> 00:26:24,000
throw it away. We discard it and we work

672
00:26:21,760 --> 00:26:25,679
on the 10% that we can annotate and can

673
00:26:24,000 --> 00:26:28,880
um make statements about it. I think

674
00:26:25,679 --> 00:26:32,480
this is a really big problem. Um before

675
00:26:28,880 --> 00:26:34,080
going into into um into how to solve

676
00:26:32,480 --> 00:26:36,480
this problem, I want to just show an

677
00:26:34,080 --> 00:26:38,799
example where we use proteomic diversity

678
00:26:36,480 --> 00:26:41,919
for finding enzymes for imunotherapy in

679
00:26:38,799 --> 00:26:43,360
huge protein databases. Um and so here

680
00:26:41,919 --> 00:26:45,120
what you have you have a cellular

681
00:26:43,360 --> 00:26:47,120
system, you have a cancer cell and you

682
00:26:45,120 --> 00:26:48,799
have a T- cell. So cancer cells try to

683
00:26:47,120 --> 00:26:50,480
somehow evade the immune system, right?

684
00:26:48,799 --> 00:26:52,000
So they try to get around it. Um so what

685
00:26:50,480 --> 00:26:53,840
they do is one mechanism that they use

686
00:26:52,000 --> 00:26:56,799
is this like alkine mechanism the small

687
00:26:53,840 --> 00:26:58,480
molecule they um secrete and they block

688
00:26:56,799 --> 00:27:00,000
tea cells so tea cells are not

689
00:26:58,480 --> 00:27:02,960
functioning in these environments big

690
00:27:00,000 --> 00:27:04,159
problem so in humans we do have um

691
00:27:02,960 --> 00:27:06,080
solutions for that we have these

692
00:27:04,159 --> 00:27:08,080
curinases these are enzyme that breaks

693
00:27:06,080 --> 00:27:09,360
these small molecules apart and

694
00:27:08,080 --> 00:27:10,880
therefore then have a chance to

695
00:27:09,360 --> 00:27:12,880
reactivate the tea cells and from

696
00:27:10,880 --> 00:27:16,000
working against this cancer again and

697
00:27:12,880 --> 00:27:17,679
there's a study by triplet all in 2018

698
00:27:16,000 --> 00:27:20,400
where they asked a question could we

699
00:27:17,679 --> 00:27:23,039
somehow find an efficant curing

700
00:27:20,400 --> 00:27:24,880
a more efficient enzyme and um combine

701
00:27:23,039 --> 00:27:26,400
it with a cancer vaccine and see if you

702
00:27:24,880 --> 00:27:30,000
could increase the survivability in

703
00:27:26,400 --> 00:27:34,000
mice. And they did go and find um some

704
00:27:30,000 --> 00:27:36,720
bacteria um by doing um like very old

705
00:27:34,000 --> 00:27:40,240
brow tricks um to find something that

706
00:27:36,720 --> 00:27:43,279
seemed to be efficant um to to um um and

707
00:27:40,240 --> 00:27:44,480
increase the the lifespan of mice. So I

708
00:27:43,279 --> 00:27:46,240
thought that was a very interesting

709
00:27:44,480 --> 00:27:48,240
study and I thought somehow can we do

710
00:27:46,240 --> 00:27:50,159
that now in a different way in a more

711
00:27:48,240 --> 00:27:54,000
maybe systematic way with the techniques

712
00:27:50,159 --> 00:27:55,600
that we have at hand at these days. Um

713
00:27:54,000 --> 00:27:57,520
so

714
00:27:55,600 --> 00:27:58,960
um so here that's example right we have

715
00:27:57,520 --> 00:28:01,440
the control we have the mouse with um

716
00:27:58,960 --> 00:28:03,039
this PFK enzyme and the cancer shrink so

717
00:28:01,440 --> 00:28:05,039
the question is can we find an enzyme

718
00:28:03,039 --> 00:28:06,399
that shrinks it even further um can we

719
00:28:05,039 --> 00:28:08,240
find a more efficient enzyme in

720
00:28:06,399 --> 00:28:10,480
databases so my question to you how

721
00:28:08,240 --> 00:28:12,960
would you do it somebody would ask you

722
00:28:10,480 --> 00:28:15,120
how would you go for that um so you have

723
00:28:12,960 --> 00:28:17,679
heard from Suyong some tricks and one

724
00:28:15,120 --> 00:28:20,080
trick that we use is MM6 so just take

725
00:28:17,679 --> 00:28:22,000
the best the PFK um enzyme and search it

726
00:28:20,080 --> 00:28:24,080
against a protein database so you take

727
00:28:22,000 --> 00:28:25,200
the protein with the highest efficacy.

728
00:28:24,080 --> 00:28:27,840
You search it against a protein

729
00:28:25,200 --> 00:28:30,480
database. Now you find around 10,000

730
00:28:27,840 --> 00:28:32,000
candidates. Um and um now my problem is

731
00:28:30,480 --> 00:28:33,440
solved as a bathematician. I'm done. Now

732
00:28:32,000 --> 00:28:34,880
I'm handing it over to the vet lab and

733
00:28:33,440 --> 00:28:36,640
the vet lab can just do all of these

734
00:28:34,880 --> 00:28:38,159
experiments. Um wouldn't you would tell

735
00:28:36,640 --> 00:28:39,919
me you're crazy. Um she wouldn't because

736
00:28:38,159 --> 00:28:41,760
she's very polite. But so would you tell

737
00:28:39,919 --> 00:28:43,600
me we can maybe do three, right? So that

738
00:28:41,760 --> 00:28:45,520
means we have to be somehow reranking

739
00:28:43,600 --> 00:28:48,480
these things in order to increase the

740
00:28:45,520 --> 00:28:50,559
chances of success. Um so this order is

741
00:28:48,480 --> 00:28:51,919
mostly defined by similarity, right? the

742
00:28:50,559 --> 00:28:54,320
most similar ones are on top and the

743
00:28:51,919 --> 00:28:56,640
most dissimilar ones are at the bottom.

744
00:28:54,320 --> 00:28:58,240
But maybe an enzyme the most similar one

745
00:28:56,640 --> 00:29:02,320
doesn't need to be necessarily the best

746
00:28:58,240 --> 00:29:05,279
one. Okay, so how do we go with that?

747
00:29:02,320 --> 00:29:08,159
The good thing is that we had some data

748
00:29:05,279 --> 00:29:09,600
points. So we have 159 measurements from

749
00:29:08,159 --> 00:29:11,679
this triplet at all study. They have

750
00:29:09,600 --> 00:29:13,520
tried quite a lot um of of proteins and

751
00:29:11,679 --> 00:29:15,600
they did get KMK CAT measures and we

752
00:29:13,520 --> 00:29:17,440
have associations with protein sequences

753
00:29:15,600 --> 00:29:18,880
for that. So okay, now it becomes a

754
00:29:17,440 --> 00:29:20,480
machine learning problem, right? So now

755
00:29:18,880 --> 00:29:23,200
we can somehow learn something on top of

756
00:29:20,480 --> 00:29:25,520
this to um to yeah learn something from

757
00:29:23,200 --> 00:29:27,520
this 159 data points. I think the

758
00:29:25,520 --> 00:29:28,799
problem here is that with 159 data

759
00:29:27,520 --> 00:29:30,559
points you can't really train deep

760
00:29:28,799 --> 00:29:32,080
neural networks. You need way more data,

761
00:29:30,559 --> 00:29:34,960
right? Like you can't have billions of

762
00:29:32,080 --> 00:29:36,480
parameters. But here's really where

763
00:29:34,960 --> 00:29:38,320
language the power of language models

764
00:29:36,480 --> 00:29:40,399
comes in. Similar to like a GPT like

765
00:29:38,320 --> 00:29:43,600
system, we have um language models like

766
00:29:40,399 --> 00:29:44,960
ESM1B for example for proteins. And what

767
00:29:43,600 --> 00:29:46,720
they can do is you can take protein

768
00:29:44,960 --> 00:29:48,480
sequences and you can embed them. And

769
00:29:46,720 --> 00:29:50,880
the embedding is at the end you can get

770
00:29:48,480 --> 00:29:52,640
generate um a floatingoint vector, a

771
00:29:50,880 --> 00:29:54,640
vector of like numbers and that

772
00:29:52,640 --> 00:29:56,720
describes that protein somehow. And you

773
00:29:54,640 --> 00:29:58,640
can associate these vectors with um

774
00:29:56,720 --> 00:29:59,840
these experimental measures and then on

775
00:29:58,640 --> 00:30:01,679
top of that you train something fairly

776
00:29:59,840 --> 00:30:03,200
simple like a random forest for that is

777
00:30:01,679 --> 00:30:05,600
very data efficient doesn't need too

778
00:30:03,200 --> 00:30:07,360
much um data to be trained on and by

779
00:30:05,600 --> 00:30:09,600
doing so you can get a regressor that

780
00:30:07,360 --> 00:30:11,520
has an 0.81 spear correlation. So it's a

781
00:30:09,600 --> 00:30:13,679
quite decent um regressor to somehow

782
00:30:11,520 --> 00:30:15,360
rerank these hits. So with this together

783
00:30:13,679 --> 00:30:17,520
we have now a pipeline right we are

784
00:30:15,360 --> 00:30:19,600
somehow ready to to put that together.

785
00:30:17,520 --> 00:30:21,600
So we search these proteins we find this

786
00:30:19,600 --> 00:30:23,200
10,000 hits and we have our regressor

787
00:30:21,600 --> 00:30:25,600
model that we have pre-trained on this

788
00:30:23,200 --> 00:30:28,320
159 data points and then we rerank these

789
00:30:25,600 --> 00:30:29,520
hits and the ranking changed quite a

790
00:30:28,320 --> 00:30:30,960
lot. This is actually a ranking that

791
00:30:29,520 --> 00:30:33,600
really happened for for what we have

792
00:30:30,960 --> 00:30:35,679
seen in the paper or for this Q&A. Um so

793
00:30:33,600 --> 00:30:38,000
something that was before at position

794
00:30:35,679 --> 00:30:39,919
143 is now at position one. So it has

795
00:30:38,000 --> 00:30:41,760
shuffled the list quite a lot. And for

796
00:30:39,919 --> 00:30:43,520
the top three then we we we started to

797
00:30:41,760 --> 00:30:46,240
do experiments right? So we wanted to

798
00:30:43,520 --> 00:30:48,799
see is one of them more efficient. So

799
00:30:46,240 --> 00:30:50,559
would you help with this? And um we did

800
00:30:48,799 --> 00:30:51,840
find out that majority of them are very

801
00:30:50,559 --> 00:30:54,480
similar to the best previously

802
00:30:51,840 --> 00:30:56,240
performing one while the third one um is

803
00:30:54,480 --> 00:30:57,840
substantially better in the catalytic

804
00:30:56,240 --> 00:31:00,960
efficacy

805
00:30:57,840 --> 00:31:02,640
and with this um mongle group went into

806
00:31:00,960 --> 00:31:04,960
the mouse models and actually showed

807
00:31:02,640 --> 00:31:07,039
that if you would administer this enzyme

808
00:31:04,960 --> 00:31:08,799
you could shrink cancer. code um even

809
00:31:07,039 --> 00:31:10,240
further. So meaning this afficant enzyme

810
00:31:08,799 --> 00:31:13,520
also helps for this for this kind of

811
00:31:10,240 --> 00:31:15,679
therapy. And this works not just with

812
00:31:13,520 --> 00:31:17,919
KMK cut, it also work for luminescence

813
00:31:15,679 --> 00:31:19,840
stability. So you can assign all kinds

814
00:31:17,919 --> 00:31:22,080
of properties and and and and use them

815
00:31:19,840 --> 00:31:24,480
to make predictors on it. So we make a a

816
00:31:22,080 --> 00:31:26,320
kind of notebook where you go to um um

817
00:31:24,480 --> 00:31:28,159
seek rank.ab.com

818
00:31:26,320 --> 00:31:29,600
where you can upload a faster file with

819
00:31:28,159 --> 00:31:30,960
measurements. So experimental

820
00:31:29,600 --> 00:31:33,200
measurements that you associate with a

821
00:31:30,960 --> 00:31:35,120
sequence. we on the fly will generate a

822
00:31:33,200 --> 00:31:37,760
regressor for you um search through a

823
00:31:35,120 --> 00:31:39,120
protein database and then um rerank

824
00:31:37,760 --> 00:31:40,640
these hits for you and you get you a

825
00:31:39,120 --> 00:31:43,840
reranked list that you might be able to

826
00:31:40,640 --> 00:31:46,000
use for doing experiments on them okay

827
00:31:43,840 --> 00:31:49,039
so what if you don't find any homologus

828
00:31:46,000 --> 00:31:51,519
sequences um I think um Su answered that

829
00:31:49,039 --> 00:31:53,279
question already um but I like this

830
00:31:51,519 --> 00:31:54,320
question here to show you a pair wise

831
00:31:53,279 --> 00:31:56,240
alignment now you have learned what a

832
00:31:54,320 --> 00:31:58,080
pair wise alignment is right now we can

833
00:31:56,240 --> 00:31:59,120
all judge it so there's a pair wise

834
00:31:58,080 --> 00:32:01,519
alignment do you think this is a

835
00:31:59,120 --> 00:32:05,200
homologous pair and raise Raise your

836
00:32:01,519 --> 00:32:06,320
hand if it's a homologous pair.

837
00:32:05,200 --> 00:32:08,720
Raise your hands if it's not a

838
00:32:06,320 --> 00:32:12,000
homologous pair.

839
00:32:08,720 --> 00:32:13,840
Raise your hand if it's maybe.

840
00:32:12,000 --> 00:32:15,760
Okay.

841
00:32:13,840 --> 00:32:17,519
So maybe is right. We often cannot see

842
00:32:15,760 --> 00:32:19,120
it from the amino acids alone, right? Um

843
00:32:17,519 --> 00:32:20,240
but then now we can use structures,

844
00:32:19,120 --> 00:32:22,000
right? That's really what we have seen

845
00:32:20,240 --> 00:32:23,360
in in the precursor. And structurally

846
00:32:22,000 --> 00:32:25,039
this is very similar. So I could you ask

847
00:32:23,360 --> 00:32:26,640
the same question. Does it look similar?

848
00:32:25,039 --> 00:32:29,679
And now this looks fairly similar

849
00:32:26,640 --> 00:32:31,120
hopefully. And yeah and through the

850
00:32:29,679 --> 00:32:33,519
emergence of alpha fold right we have

851
00:32:31,120 --> 00:32:34,880
now a tool that can um with high

852
00:32:33,519 --> 00:32:37,360
accuracy actually predict these

853
00:32:34,880 --> 00:32:39,279
structures um and so we can somehow

854
00:32:37,360 --> 00:32:40,559
really generate models and as suing

855
00:32:39,279 --> 00:32:44,720
mentioned we already have done that for

856
00:32:40,559 --> 00:32:46,320
many of these big databases um so just a

857
00:32:44,720 --> 00:32:48,240
basic question um who knows how

858
00:32:46,320 --> 00:32:51,120
alphafold works if yes I can skip that

859
00:32:48,240 --> 00:32:53,600
do you know how alphafold works

860
00:32:51,120 --> 00:32:56,080
1 2 3 4 5

861
00:32:53,600 --> 00:32:58,240
who wants to hear how alphafold works

862
00:32:56,080 --> 00:33:01,840
okay more people want to hear it. Okay.

863
00:32:58,240 --> 00:33:04,080
Um so this is a um an an um slide I took

864
00:33:01,840 --> 00:33:05,919
from from Sergio Hinikov um here at MIT.

865
00:33:04,080 --> 00:33:08,320
Um he has a very simplified version or

866
00:33:05,919 --> 00:33:09,919
like a view on alpha fold um which I

867
00:33:08,320 --> 00:33:11,679
really like. You start off with a

868
00:33:09,919 --> 00:33:13,679
sequence and you search a sequence

869
00:33:11,679 --> 00:33:15,760
against a database and what you generate

870
00:33:13,679 --> 00:33:17,200
is a multiple sequence alignment and

871
00:33:15,760 --> 00:33:18,720
from that multiple sequence alignment

872
00:33:17,200 --> 00:33:20,559
you make a prediction that is actually

873
00:33:18,720 --> 00:33:23,039
given to that neural network that um

874
00:33:20,559 --> 00:33:25,279
that first an EV former block or an MSA

875
00:33:23,039 --> 00:33:26,960
module that extracts evolutionary

876
00:33:25,279 --> 00:33:28,880
information and then it's given to the

877
00:33:26,960 --> 00:33:30,480
structural module which turns it into

878
00:33:28,880 --> 00:33:31,840
coordinates or something that looks like

879
00:33:30,480 --> 00:33:33,760
a structure in the end and then you

880
00:33:31,840 --> 00:33:35,760
recycle this information back into the

881
00:33:33,760 --> 00:33:37,200
network and you can over time improve

882
00:33:35,760 --> 00:33:38,399
the prediction. So initially you have an

883
00:33:37,200 --> 00:33:40,080
initial guess and then that guess

884
00:33:38,399 --> 00:33:41,919
becomes better and better over time with

885
00:33:40,080 --> 00:33:44,399
more recycles.

886
00:33:41,919 --> 00:33:46,399
So how how does that work? How can a

887
00:33:44,399 --> 00:33:48,240
network do that? Um because it's kind of

888
00:33:46,399 --> 00:33:50,080
cheating, right? It's not really um

889
00:33:48,240 --> 00:33:51,840
playing the game really fair. It doesn't

890
00:33:50,080 --> 00:33:53,440
use just a single sequence, but rather

891
00:33:51,840 --> 00:33:54,960
use a multiple sequence alignment. And

892
00:33:53,440 --> 00:33:56,240
that mult multiple sequence alignment

893
00:33:54,960 --> 00:33:58,080
actually tells you a lot about

894
00:33:56,240 --> 00:33:59,519
evolution. So you have these columns

895
00:33:58,080 --> 00:34:01,679
that are for example this like a green

896
00:33:59,519 --> 00:34:03,279
column here um on the left. That's a

897
00:34:01,679 --> 00:34:04,720
column where you do want to change the

898
00:34:03,279 --> 00:34:06,000
amino acid. If you change it, you might

899
00:34:04,720 --> 00:34:08,240
change a functional site. it might be

900
00:34:06,000 --> 00:34:09,760
really bad for for for this for this um

901
00:34:08,240 --> 00:34:12,240
protein. Then you have these regions

902
00:34:09,760 --> 00:34:14,240
where you have like um yellow, red and

903
00:34:12,240 --> 00:34:15,839
green. These seem to be like a a column

904
00:34:14,240 --> 00:34:17,919
where you can change the amides amino

905
00:34:15,839 --> 00:34:19,599
acids fairly easily. And so meaning that

906
00:34:17,919 --> 00:34:20,560
might be a disordered region or

907
00:34:19,599 --> 00:34:22,079
something that might be not very

908
00:34:20,560 --> 00:34:24,159
structured. And then you have this like

909
00:34:22,079 --> 00:34:25,760
blue yellow blue pattern that you see

910
00:34:24,159 --> 00:34:27,520
here in the middle that are like somehow

911
00:34:25,760 --> 00:34:29,760
alternating and it's like co-evolving

912
00:34:27,520 --> 00:34:31,679
residues. Co-evolving residues means to

913
00:34:29,760 --> 00:34:33,280
have somehow often physical contact in

914
00:34:31,679 --> 00:34:35,119
the structure. If you find enough of

915
00:34:33,280 --> 00:34:36,800
these co-evolving residues, you actually

916
00:34:35,119 --> 00:34:38,639
the the folding problem becomes kind of

917
00:34:36,800 --> 00:34:40,159
constrained and then you get an initial

918
00:34:38,639 --> 00:34:41,839
guess in the energy landscape of the

919
00:34:40,159 --> 00:34:43,839
protein and then with the structural

920
00:34:41,839 --> 00:34:45,040
model you can take that guess and refine

921
00:34:43,839 --> 00:34:46,800
it and turn it more into what a

922
00:34:45,040 --> 00:34:48,879
structure actually looks like. Just a

923
00:34:46,800 --> 00:34:50,800
gut feeling how that how that model

924
00:34:48,879 --> 00:34:54,240
works if how it's exactly work we don't

925
00:34:50,800 --> 00:34:57,040
know um but um just an intuition.

926
00:34:54,240 --> 00:34:58,560
So but the MSA is important. So if you

927
00:34:57,040 --> 00:35:01,359
don't have a proper MSA, you don't get a

928
00:34:58,560 --> 00:35:02,960
proper structure prediction. And so uh

929
00:35:01,359 --> 00:35:05,599
yeah, the DeepMind team put a lot of

930
00:35:02,960 --> 00:35:07,359
effort into making these um um MSAs

931
00:35:05,599 --> 00:35:09,119
really really well um using a lot of

932
00:35:07,359 --> 00:35:10,480
these big protein databases that are out

933
00:35:09,119 --> 00:35:12,160
there and searching through them to

934
00:35:10,480 --> 00:35:14,240
generate like a really really diverse

935
00:35:12,160 --> 00:35:16,240
multiple sequence alignment. The problem

936
00:35:14,240 --> 00:35:18,560
is that these searches become actually

937
00:35:16,240 --> 00:35:19,839
fairly slow. So it can take 20 to 30

938
00:35:18,560 --> 00:35:22,240
minutes sometimes to generate one of

939
00:35:19,839 --> 00:35:23,520
these MSAs and that is um really like

940
00:35:22,240 --> 00:35:24,720
much slower than actually doing the

941
00:35:23,520 --> 00:35:26,480
prediction in the end with the neural

942
00:35:24,720 --> 00:35:29,280
network. So generating the MSAs is a

943
00:35:26,480 --> 00:35:31,920
hard task. But we have heard something

944
00:35:29,280 --> 00:35:33,200
there's mms. So we thought okay why

945
00:35:31,920 --> 00:35:34,720
don't we replace these methods

946
00:35:33,200 --> 00:35:36,960
jackhammer and hex blitz that are used

947
00:35:34,720 --> 00:35:38,720
in the alpha system and just use mms to

948
00:35:36,960 --> 00:35:41,920
do fast searches and because it's um

949
00:35:38,720 --> 00:35:44,480
it's fairly efficient. So um we did that

950
00:35:41,920 --> 00:35:46,240
and we can can generate um MSAs much

951
00:35:44,480 --> 00:35:48,480
faster and we can generate it so fast

952
00:35:46,240 --> 00:35:50,240
that we were able to set up server um a

953
00:35:48,480 --> 00:35:52,160
small server that is just one server

954
00:35:50,240 --> 00:35:53,440
that is currently providing these MSAs

955
00:35:52,160 --> 00:35:54,960
to the community. So you don't actually

956
00:35:53,440 --> 00:35:56,560
need to generate MSAs on your own. You

957
00:35:54,960 --> 00:36:00,480
just send a request to our server and we

958
00:35:56,560 --> 00:36:01,760
generate an MSA back for you. Um and

959
00:36:00,480 --> 00:36:03,119
yeah, you can do that through web

960
00:36:01,760 --> 00:36:04,480
interface. You can use that or you can

961
00:36:03,119 --> 00:36:06,240
use it through terminal. You can somehow

962
00:36:04,480 --> 00:36:07,599
access our server and we generate a

963
00:36:06,240 --> 00:36:09,280
multiple sequence alignment for you for

964
00:36:07,599 --> 00:36:10,720
monomer prediction or multiple sequence

965
00:36:09,280 --> 00:36:12,480
alignments for complex prediction where

966
00:36:10,720 --> 00:36:15,520
we actually pair up the sequences based

967
00:36:12,480 --> 00:36:18,960
on um trying to maximize the orthology

968
00:36:15,520 --> 00:36:21,200
in the in these pairs. And um we worked

969
00:36:18,960 --> 00:36:23,760
um with with Nvidia and um you know

970
00:36:21,200 --> 00:36:26,160
their minds um to make that even faster

971
00:36:23,760 --> 00:36:28,160
making MM6 ported to the GPU. So you can

972
00:36:26,160 --> 00:36:30,960
actually now generate MSAs in the ranges

973
00:36:28,160 --> 00:36:32,960
of seconds. Um um just using the GPUs

974
00:36:30,960 --> 00:36:34,640
you have around even gaming GPUs you can

975
00:36:32,960 --> 00:36:37,680
use for this kind of purpose. Um yeah

976
00:36:34,640 --> 00:36:38,880
and one of the persons here Chris um so

977
00:36:37,680 --> 00:36:40,640
I'm very happy that you come to the

978
00:36:38,880 --> 00:36:42,800
talk.

979
00:36:40,640 --> 00:36:44,160
Okay, with this this is what then like

980
00:36:42,800 --> 00:36:46,240
we have that server. We wanted to

981
00:36:44,160 --> 00:36:48,240
initially wanted to make somehow alpha

982
00:36:46,240 --> 00:36:49,839
fold accessible to the community. One

983
00:36:48,240 --> 00:36:51,440
way of us to do it was to have that

984
00:36:49,839 --> 00:36:54,240
server but then also together with

985
00:36:51,440 --> 00:36:56,079
Sergey and and Milo and Yoshitaka Lim

986
00:36:54,240 --> 00:36:57,760
and Constantine we started to build like

987
00:36:56,079 --> 00:37:00,160
a call-up notebook that people could use

988
00:36:57,760 --> 00:37:02,800
to just make these predictions somehow

989
00:37:00,160 --> 00:37:04,880
um um in the web.

990
00:37:02,800 --> 00:37:06,079
Okay. Um and you just run all and you

991
00:37:04,880 --> 00:37:08,720
can make a prediction which is really

992
00:37:06,079 --> 00:37:12,079
great. But this thing has grown quite a

993
00:37:08,720 --> 00:37:13,839
lot. Now this server is not just just

994
00:37:12,079 --> 00:37:15,440
alpha fold and the back end for color

995
00:37:13,839 --> 00:37:17,839
fold but it becomes like the backbone

996
00:37:15,440 --> 00:37:20,240
for all of these methods um bolts one

997
00:37:17,839 --> 00:37:21,760
chai bio emo and so on. They all are

998
00:37:20,240 --> 00:37:24,240
pretty much using the server to try to

999
00:37:21,760 --> 00:37:26,240
generate MSAs or using um mmcs to

1000
00:37:24,240 --> 00:37:28,160
somehow do it. So this is obviously like

1001
00:37:26,240 --> 00:37:31,680
a big responsibility for us to not

1002
00:37:28,160 --> 00:37:33,680
really um um ruin their services um uh

1003
00:37:31,680 --> 00:37:36,079
which we try and sometimes fail but we

1004
00:37:33,680 --> 00:37:37,520
try our best and um yeah we have not

1005
00:37:36,079 --> 00:37:39,119
just call but you can also run these

1006
00:37:37,520 --> 00:37:41,040
things in Linux and Mac OS. So we can

1007
00:37:39,119 --> 00:37:44,720
install our call-up fold locally and run

1008
00:37:41,040 --> 00:37:46,560
it there. And this thing here is like

1009
00:37:44,720 --> 00:37:48,960
really like an I would say an overnight

1010
00:37:46,560 --> 00:37:51,520
success that was built on a Sunday on a

1011
00:37:48,960 --> 00:37:53,359
Sunday on a couch and um it ended up

1012
00:37:51,520 --> 00:37:54,640
being released at midnight or so. So

1013
00:37:53,359 --> 00:37:56,079
this is what we have done as a first

1014
00:37:54,640 --> 00:37:58,079
system and we had thousands of users

1015
00:37:56,079 --> 00:38:00,320
from the first day and I measured the

1016
00:37:58,079 --> 00:38:02,640
success because I'm from Korea. Um I

1017
00:38:00,320 --> 00:38:04,880
measured the success in in K-pop views,

1018
00:38:02,640 --> 00:38:06,320
K-pop video views, right? So you can say

1019
00:38:04,880 --> 00:38:08,160
how many million views would you need to

1020
00:38:06,320 --> 00:38:10,640
have a successful K-pop video? So,

1021
00:38:08,160 --> 00:38:12,240
Colorfold has generated over 80 million

1022
00:38:10,640 --> 00:38:14,720
um MSAs, I would say it's a medium

1023
00:38:12,240 --> 00:38:17,280
successful K-pop video. So, but for but

1024
00:38:14,720 --> 00:38:19,520
but for um for a bionatics resource is

1025
00:38:17,280 --> 00:38:20,960
pretty good, I think. Um it's it's not

1026
00:38:19,520 --> 00:38:22,480
often that you see these big numbers for

1027
00:38:20,960 --> 00:38:26,400
bionformatics.

1028
00:38:22,480 --> 00:38:28,400
Okay. So with Alphaold um um emergence

1029
00:38:26,400 --> 00:38:31,839
also the the database came as Suing

1030
00:38:28,400 --> 00:38:34,240
mentioned and we have 214 million models

1031
00:38:31,839 --> 00:38:36,880
right out there that we can um um use

1032
00:38:34,240 --> 00:38:39,520
for um yeah to to explore really models

1033
00:38:36,880 --> 00:38:42,640
of structures for nearly every um

1034
00:38:39,520 --> 00:38:44,560
sequence in the uniro but no viruses

1035
00:38:42,640 --> 00:38:45,760
viruses were excluded from the uniro. So

1036
00:38:44,560 --> 00:38:47,359
if you want to find them, you don't find

1037
00:38:45,760 --> 00:38:49,520
them. You might find proofages because

1038
00:38:47,359 --> 00:38:51,119
they might be incredib

1039
00:38:49,520 --> 00:38:53,440
and they're just labeled as bacteria,

1040
00:38:51,119 --> 00:38:55,520
but you do not find like RNA viruses and

1041
00:38:53,440 --> 00:38:57,359
so on. So we thought that's a great

1042
00:38:55,520 --> 00:39:00,000
opportunity. So why don't we generate

1043
00:38:57,359 --> 00:39:03,040
that? Um it's a is a easy publication,

1044
00:39:00,000 --> 00:39:05,040
right? You just take 347,000

1045
00:39:03,040 --> 00:39:06,560
um um um proteins and then you put them

1046
00:39:05,040 --> 00:39:08,160
into color fold and colorful gives you

1047
00:39:06,560 --> 00:39:11,359
structures and you have a paper. So

1048
00:39:08,160 --> 00:39:13,040
that's great. Um so we we did that and

1049
00:39:11,359 --> 00:39:14,960
um started with this. But the problem is

1050
00:39:13,040 --> 00:39:16,880
we realized very fast that many of these

1051
00:39:14,960 --> 00:39:17,920
predictions are pretty bad. So and the

1052
00:39:16,880 --> 00:39:19,280
reason for that is that multiple

1053
00:39:17,920 --> 00:39:21,839
sequence alignments of many of these

1054
00:39:19,280 --> 00:39:23,920
viral proteins become very shallow and

1055
00:39:21,839 --> 00:39:25,200
so you don't really do good structure

1056
00:39:23,920 --> 00:39:27,520
predictions. So you have to do better

1057
00:39:25,200 --> 00:39:29,280
here, right? Um otherwise um you're just

1058
00:39:27,520 --> 00:39:32,560
delivering a database that hasn't much

1059
00:39:29,280 --> 00:39:34,560
quality in the end.

1060
00:39:32,560 --> 00:39:37,839
So one thing that we have done before

1061
00:39:34,560 --> 00:39:40,240
that um Simon and Yuri in my lab started

1062
00:39:37,839 --> 00:39:42,800
it is to just show how much power is in

1063
00:39:40,240 --> 00:39:45,520
the MSAs for for structure prediction.

1064
00:39:42,800 --> 00:39:47,280
So we went to cusp 15 and we searched

1065
00:39:45,520 --> 00:39:48,880
the cusp 15 targets. This is like

1066
00:39:47,280 --> 00:39:50,960
structure prediction um um challenge

1067
00:39:48,880 --> 00:39:53,599
that happens every two year two years

1068
00:39:50,960 --> 00:39:55,520
and we we took these cusp 15 targets and

1069
00:39:53,599 --> 00:39:57,760
we searched against 22 pabytes of

1070
00:39:55,520 --> 00:39:59,440
sequence reads. Um it's just as a

1071
00:39:57,760 --> 00:40:01,599
sentence on a slide that is a lot of

1072
00:39:59,440 --> 00:40:03,760
work that is not easy. Um, so it's not

1073
00:40:01,599 --> 00:40:05,760
easy to search against 22 pabytes of of

1074
00:40:03,760 --> 00:40:07,920
of data. But that's where really Ryan

1075
00:40:05,760 --> 00:40:10,480
cheeky at all helped us with having set

1076
00:40:07,920 --> 00:40:12,160
up an AWS pipeline that can really

1077
00:40:10,480 --> 00:40:14,079
parallel go through all of these samples

1078
00:40:12,160 --> 00:40:17,119
and search. And by doing so, you go from

1079
00:40:14,079 --> 00:40:19,440
a very shallow MSA to a deep MSA

1080
00:40:17,119 --> 00:40:21,200
and from a ranking perspective in a

1081
00:40:19,440 --> 00:40:23,440
competition going from rank 11 to rank

1082
00:40:21,200 --> 00:40:26,240
three and by effectively just changing

1083
00:40:23,440 --> 00:40:27,599
the MSA and do not not much more. Okay,

1084
00:40:26,240 --> 00:40:29,040
we thought okay, why don't we do the

1085
00:40:27,599 --> 00:40:30,800
same thing for viruses, right? we just

1086
00:40:29,040 --> 00:40:32,720
have seen that works for cusp. Maybe we

1087
00:40:30,800 --> 00:40:34,480
can also do better in viruses. So we

1088
00:40:32,720 --> 00:40:36,400
start off with about 50% of the

1089
00:40:34,480 --> 00:40:39,040
prediction being about um um high

1090
00:40:36,400 --> 00:40:41,520
quality and the rest are low quality or

1091
00:40:39,040 --> 00:40:43,359
very low quality. Just to show you what

1092
00:40:41,520 --> 00:40:44,800
a very low quality structure look like.

1093
00:40:43,359 --> 00:40:46,160
You can see here in white this is the

1094
00:40:44,800 --> 00:40:48,079
experimental structure. In orange you

1095
00:40:46,160 --> 00:40:50,000
can see the yeah lowquality prediction

1096
00:40:48,079 --> 00:40:52,320
on top is pretty useless. There you

1097
00:40:50,000 --> 00:40:53,839
can't really find much similarities but

1098
00:40:52,320 --> 00:40:55,440
by searching it against a resource

1099
00:40:53,839 --> 00:40:57,520
called Logan which is an assembled

1100
00:40:55,440 --> 00:40:59,280
version of the SR. Orion cheeky at all

1101
00:40:57,520 --> 00:41:01,040
went on and they just didn't want to

1102
00:40:59,280 --> 00:41:03,040
make the SR searchable but rather wanted

1103
00:41:01,040 --> 00:41:04,079
to assemble it into context. So you

1104
00:41:03,040 --> 00:41:05,920
cannot now search through these

1105
00:41:04,079 --> 00:41:09,920
contexts. Now you'd have one pabytes

1106
00:41:05,920 --> 00:41:11,760
instead of like 22 pabytes. Um you can

1107
00:41:09,920 --> 00:41:14,480
still increase your MSA quite a lot with

1108
00:41:11,760 --> 00:41:17,520
this and and you can um improve the

1109
00:41:14,480 --> 00:41:19,520
predictions um also by by a big big

1110
00:41:17,520 --> 00:41:21,040
fraction. And then you can also use the

1111
00:41:19,520 --> 00:41:22,640
tricks of recycles right I've mentioned

1112
00:41:21,040 --> 00:41:24,560
the alpha fold system has recycles. you

1113
00:41:22,640 --> 00:41:26,319
can just increase the recycles to 12 and

1114
00:41:24,560 --> 00:41:27,680
then you can even rescue a few more

1115
00:41:26,319 --> 00:41:30,560
predictions and then if you take the

1116
00:41:27,680 --> 00:41:32,800
best out of it you can um get over 60%

1117
00:41:30,560 --> 00:41:34,640
of these structures to um a high quality

1118
00:41:32,800 --> 00:41:37,040
level and meaning now you have a quite

1119
00:41:34,640 --> 00:41:38,400
good viral structural database. So

1120
00:41:37,040 --> 00:41:40,160
normally this is the point where I will

1121
00:41:38,400 --> 00:41:41,599
talk about foldsek but I don't have to

1122
00:41:40,160 --> 00:41:43,839
because su has explained to you what

1123
00:41:41,599 --> 00:41:45,680
fseek is and so I can save a lot of time

1124
00:41:43,839 --> 00:41:48,640
here so I can go directly into the

1125
00:41:45,680 --> 00:41:51,359
applications of it. Um there is this

1126
00:41:48,640 --> 00:41:53,359
work by Greg Lor's group at um Western

1127
00:41:51,359 --> 00:41:56,640
UN University in Canada. They did

1128
00:41:53,359 --> 00:41:57,760
metagenomics on um on on on wastewater

1129
00:41:56,640 --> 00:41:59,839
and they were pretty much interested in

1130
00:41:57,760 --> 00:42:02,079
the phages wastewater phages that are

1131
00:41:59,839 --> 00:42:03,440
that are that are there. Um and they

1132
00:42:02,079 --> 00:42:06,400
wanted to annotate these wastewater

1133
00:42:03,440 --> 00:42:07,760
phages. So they did the or calls and so

1134
00:42:06,400 --> 00:42:09,359
on and then at the end they use a

1135
00:42:07,760 --> 00:42:11,200
software called Baka which uses amino

1136
00:42:09,359 --> 00:42:12,800
acid alignments and HMMs to map back

1137
00:42:11,200 --> 00:42:15,440
against the protein databases and by

1138
00:42:12,800 --> 00:42:17,359
doing so about 15% of these open reading

1139
00:42:15,440 --> 00:42:18,800
frames could be mapped back. But by

1140
00:42:17,359 --> 00:42:20,480
using colup fold and predicting the

1141
00:42:18,800 --> 00:42:22,960
structure of these um using obviously

1142
00:42:20,480 --> 00:42:24,800
also environmental data to build an MSA

1143
00:42:22,960 --> 00:42:26,160
um you get like a good structural model.

1144
00:42:24,800 --> 00:42:28,079
You can then map these structural models

1145
00:42:26,160 --> 00:42:30,000
back to the alpha database and you reach

1146
00:42:28,079 --> 00:42:31,839
now 60% or so that you can map from

1147
00:42:30,000 --> 00:42:34,800
these open reading frames to the to the

1148
00:42:31,839 --> 00:42:37,920
alpha database. So significantly more.

1149
00:42:34,800 --> 00:42:39,680
Um and another great study that I wanted

1150
00:42:37,920 --> 00:42:42,560
to highlight is by the Benfield group

1151
00:42:39,680 --> 00:42:44,960
that looks at these like giant ors with

1152
00:42:42,560 --> 00:42:46,000
80,000 amino acids. Um um really big

1153
00:42:44,960 --> 00:42:47,920
machines that are out there. The

1154
00:42:46,000 --> 00:42:49,839
question is why why does bacteria need

1155
00:42:47,920 --> 00:42:51,359
something that is bigger than Titan? Um

1156
00:42:49,839 --> 00:42:52,800
and so what they have done is they

1157
00:42:51,359 --> 00:42:54,800
thought okay maybe there are many non

1158
00:42:52,800 --> 00:42:56,960
many non-cononical function in this one.

1159
00:42:54,800 --> 00:42:58,960
So they wanted to slice up these huge

1160
00:42:56,960 --> 00:43:00,640
open reading frame into small pieces and

1161
00:42:58,960 --> 00:43:02,720
map them back to databases to see what

1162
00:43:00,640 --> 00:43:04,319
these regions are. And for many you can

1163
00:43:02,720 --> 00:43:06,960
just use classical amino acids works

1164
00:43:04,319 --> 00:43:08,640
pretty well. Um amino acid searches. Um

1165
00:43:06,960 --> 00:43:10,319
but whenever you see this donut here

1166
00:43:08,640 --> 00:43:11,680
there's a points where you need colorful

1167
00:43:10,319 --> 00:43:15,040
fold and full signal conjunction to

1168
00:43:11,680 --> 00:43:16,800
actually map it back to the database.

1169
00:43:15,040 --> 00:43:18,720
Okay. So I think there's a lot of

1170
00:43:16,800 --> 00:43:20,160
opportunity for using structures in

1171
00:43:18,720 --> 00:43:23,119
metagenomics. But there's a big

1172
00:43:20,160 --> 00:43:26,240
roadblock. If you if you want to predict

1173
00:43:23,119 --> 00:43:29,280
1,700 structures um with alpha 2 you

1174
00:43:26,240 --> 00:43:31,040
need about 4,200 hours um prediction

1175
00:43:29,280 --> 00:43:32,720
time. Right? In metagenomes, we work in

1176
00:43:31,040 --> 00:43:34,720
a million or billion scales. So that

1177
00:43:32,720 --> 00:43:36,480
doesn't really work. With Colop fold, we

1178
00:43:34,720 --> 00:43:39,359
bring that down by a factor of 100

1179
00:43:36,480 --> 00:43:41,760
approximately. Um, so you need 48 hours,

1180
00:43:39,359 --> 00:43:44,880
but that's still not fast enough to to

1181
00:43:41,760 --> 00:43:46,160
do it. Um, you have now MMC uh GPU that

1182
00:43:44,880 --> 00:43:47,520
brings it down a little bit more, but

1183
00:43:46,160 --> 00:43:48,560
it's still not in the same range where

1184
00:43:47,520 --> 00:43:50,960
you have to be to be really in a

1185
00:43:48,560 --> 00:43:52,640
metagenomic level.

1186
00:43:50,960 --> 00:43:54,400
But this is where Michel Heing and

1187
00:43:52,640 --> 00:43:55,920
Booker Rust helped us out. So together

1188
00:43:54,400 --> 00:43:57,839
with them we trained a translation

1189
00:43:55,920 --> 00:44:00,240
system a translation system very similar

1190
00:43:57,839 --> 00:44:02,319
to like German to English um or um

1191
00:44:00,240 --> 00:44:04,800
English to Korean. Um you can train

1192
00:44:02,319 --> 00:44:06,400
between amino acids and 3DI right these

1193
00:44:04,800 --> 00:44:09,200
are two different languages. One is the

1194
00:44:06,400 --> 00:44:11,680
language of of of the protein itself and

1195
00:44:09,200 --> 00:44:13,760
3DI is our alphabet that describes the

1196
00:44:11,680 --> 00:44:15,119
structure and if you would get these 3DI

1197
00:44:13,760 --> 00:44:16,880
strings and they would be high quality

1198
00:44:15,119 --> 00:44:18,560
enough then we would actually not need

1199
00:44:16,880 --> 00:44:21,040
the structure for search. We could just

1200
00:44:18,560 --> 00:44:23,599
use the string in itself.

1201
00:44:21,040 --> 00:44:26,480
And it seems to be the case that um we

1202
00:44:23,599 --> 00:44:28,480
actually can um um shortcut this quite a

1203
00:44:26,480 --> 00:44:31,200
lot with this with this prost 5 language

1204
00:44:28,480 --> 00:44:33,680
model um this transformer and the

1205
00:44:31,200 --> 00:44:35,760
performance of the search is comparable

1206
00:44:33,680 --> 00:44:37,599
to actually using reals real structures

1207
00:44:35,760 --> 00:44:39,760
in the end.

1208
00:44:37,599 --> 00:44:42,079
And so from a practical application you

1209
00:44:39,760 --> 00:44:44,000
can just now easily download these prost

1210
00:44:42,079 --> 00:44:45,599
5 weights. you can download a PDB

1211
00:44:44,000 --> 00:44:47,040
database or an alpha fold database or

1212
00:44:45,599 --> 00:44:48,880
fold system and now you can give it a

1213
00:44:47,040 --> 00:44:50,800
faster file like just a normal faster

1214
00:44:48,880 --> 00:44:52,240
file um and you can search against these

1215
00:44:50,800 --> 00:44:54,160
structures without needing structures

1216
00:44:52,240 --> 00:44:56,160
right um but still maintaining the

1217
00:44:54,160 --> 00:44:59,839
sensitivity that you could get with um

1218
00:44:56,160 --> 00:45:02,720
regular structural searches

1219
00:44:59,839 --> 00:45:04,720
okay and that is faster that is about

1220
00:45:02,720 --> 00:45:08,400
300,000 times faster than the alpha fold

1221
00:45:04,720 --> 00:45:10,800
base system and about um 3,500 times

1222
00:45:08,400 --> 00:45:12,480
faster than colup fold so now we're

1223
00:45:10,800 --> 00:45:13,920
getting into a range where it is faster

1224
00:45:12,480 --> 00:45:15,440
fast enough that you can do like a few

1225
00:45:13,920 --> 00:45:17,280
million proteins or maybe tens of

1226
00:45:15,440 --> 00:45:19,119
millions of proteins. Maybe billions are

1227
00:45:17,280 --> 00:45:20,960
still very expensive, but you can at

1228
00:45:19,119 --> 00:45:22,319
least do it at a larger scale, right? So

1229
00:45:20,960 --> 00:45:24,240
for some things that you cannot map

1230
00:45:22,319 --> 00:45:27,040
back, you can go and using this approach

1231
00:45:24,240 --> 00:45:29,040
now to to see what the thing might be

1232
00:45:27,040 --> 00:45:31,280
from the metagenoms that you um looking

1233
00:45:29,040 --> 00:45:34,079
that you're looking at. And we're trying

1234
00:45:31,280 --> 00:45:35,280
to make these things even faster. And

1235
00:45:34,079 --> 00:45:36,960
recently we have more and more of this

1236
00:45:35,280 --> 00:45:39,040
realization and also more data that

1237
00:45:36,960 --> 00:45:40,319
confirms it that these language models

1238
00:45:39,040 --> 00:45:42,000
that are really really big. They often

1239
00:45:40,319 --> 00:45:44,000
have like billions of parameters don't

1240
00:45:42,000 --> 00:45:46,400
need to be that big necessarily for the

1241
00:45:44,000 --> 00:45:48,800
tasks. So we saw already that you get

1242
00:45:46,400 --> 00:45:50,640
quite decent performance for the prost 5

1243
00:45:48,800 --> 00:45:52,800
model using only 20 million weights

1244
00:45:50,640 --> 00:45:55,280
instead of like 1.5 billion weights. And

1245
00:45:52,800 --> 00:45:57,040
that makes obviously the the the the the

1246
00:45:55,280 --> 00:45:59,200
inference much much faster and and

1247
00:45:57,040 --> 00:46:02,000
hopefully makes it then even easier to

1248
00:45:59,200 --> 00:46:04,480
do larger scale metagenomic analysis

1249
00:46:02,000 --> 00:46:07,760
with fault.

1250
00:46:04,480 --> 00:46:09,760
Okay. Um once we had fault we wanted to

1251
00:46:07,760 --> 00:46:12,640
use it to somehow organize the alphault

1252
00:46:09,760 --> 00:46:15,920
database. Um and this really goes into

1253
00:46:12,640 --> 00:46:17,760
this problem of clustering. Um so and

1254
00:46:15,920 --> 00:46:19,440
you have heard from from Suong that

1255
00:46:17,760 --> 00:46:21,440
clustering in a default is actually

1256
00:46:19,440 --> 00:46:25,040
something that is quadratic right and if

1257
00:46:21,440 --> 00:46:27,680
you have a quadratic of 214 million

1258
00:46:25,040 --> 00:46:30,240
that's a really big number um and even

1259
00:46:27,680 --> 00:46:34,960
full isn't fast enough to search 214

1260
00:46:30,240 --> 00:46:37,760
million against 214 million but since we

1261
00:46:34,960 --> 00:46:40,160
we um somehow have now a structural

1262
00:46:37,760 --> 00:46:41,839
representation that is a string right um

1263
00:46:40,160 --> 00:46:43,760
we can use every kind of algorithm that

1264
00:46:41,839 --> 00:46:46,319
we have developed before for for

1265
00:46:43,760 --> 00:46:49,359
clustering or for biogeimemetics in

1266
00:46:46,319 --> 00:46:51,520
general and [snorts] so we can cluster

1267
00:46:49,359 --> 00:46:53,040
in linear time using lintclass. So why

1268
00:46:51,520 --> 00:46:54,720
do we actually want to cluster the the

1269
00:46:53,040 --> 00:46:57,680
alpha database? Why would it be

1270
00:46:54,720 --> 00:46:59,599
interesting to cluster it? Um I find it

1271
00:46:57,680 --> 00:47:01,440
just interesting to know how much you

1272
00:46:59,599 --> 00:47:03,280
can compress the database without

1273
00:47:01,440 --> 00:47:04,880
actually losing too much information,

1274
00:47:03,280 --> 00:47:07,040
right? Like how much redundancy is

1275
00:47:04,880 --> 00:47:08,880
there? I mean you can imagine redundancy

1276
00:47:07,040 --> 00:47:11,119
being like the same multi-dommain

1277
00:47:08,880 --> 00:47:13,200
composition like a globally alignable um

1278
00:47:11,119 --> 00:47:14,400
sequence um or structure in that point

1279
00:47:13,200 --> 00:47:15,920
and you want to put them together and

1280
00:47:14,400 --> 00:47:18,240
ask the question how many bins would I

1281
00:47:15,920 --> 00:47:21,240
need to to to cover the whole alpha

1282
00:47:18,240 --> 00:47:21,240
database.

1283
00:47:22,079 --> 00:47:26,720
So we went on and we take this 214

1284
00:47:24,720 --> 00:47:29,119
million proteins and we clustered them

1285
00:47:26,720 --> 00:47:31,839
first with MM6 um on amino acid level at

1286
00:47:29,119 --> 00:47:33,520
50% sequence identity at a 90% sequence

1287
00:47:31,839 --> 00:47:36,000
overlap meaning that they are nearly

1288
00:47:33,520 --> 00:47:39,440
full length alignable at 50% sequence

1289
00:47:36,000 --> 00:47:41,760
identity and we end up with 52 million

1290
00:47:39,440 --> 00:47:44,079
about 52 million clusters per clusters

1291
00:47:41,760 --> 00:47:45,760
we pick the best predicted

1292
00:47:44,079 --> 00:47:48,000
representative where alphafold has

1293
00:47:45,760 --> 00:47:50,800
generated the best um structural model

1294
00:47:48,000 --> 00:47:53,119
and we use falsy clusters to cluster um

1295
00:47:50,800 --> 00:47:55,040
um down by structural similarity at a

1296
00:47:53,119 --> 00:47:57,680
90% overlap meaning again you want them

1297
00:47:55,040 --> 00:47:59,200
to be um end to end nearly alignable and

1298
00:47:57,680 --> 00:48:01,040
what you end up with once you remove

1299
00:47:59,200 --> 00:48:04,240
singletons and fragments with you end up

1300
00:48:01,040 --> 00:48:05,920
with 2.3 million clusters so that number

1301
00:48:04,240 --> 00:48:08,880
in itself is already interesting so you

1302
00:48:05,920 --> 00:48:13,200
get from 214 million to 2.3 million

1303
00:48:08,880 --> 00:48:15,839
right um so it's near 100 um um fold

1304
00:48:13,200 --> 00:48:18,000
reduction in in in size right so um that

1305
00:48:15,839 --> 00:48:19,920
already means something about how

1306
00:48:18,000 --> 00:48:21,520
redundant is the protein structure

1307
00:48:19,920 --> 00:48:23,920
universe

1308
00:48:21,520 --> 00:48:26,079
And then with um with Petro's group at

1309
00:48:23,920 --> 00:48:28,480
the ETH, we went on and we we analyzed

1310
00:48:26,079 --> 00:48:29,920
this this clusters more in detail. I

1311
00:48:28,480 --> 00:48:32,480
want to I don't want to go too much into

1312
00:48:29,920 --> 00:48:34,160
it. Um if you're interested, we looked

1313
00:48:32,480 --> 00:48:36,720
at the dark clusters like how many of

1314
00:48:34,160 --> 00:48:38,160
these clusters are dark. A summary 35%

1315
00:48:36,720 --> 00:48:40,480
of them are dark, meaning we have no

1316
00:48:38,160 --> 00:48:42,160
experimental um information about them.

1317
00:48:40,480 --> 00:48:44,559
We cannot structurally map them back to

1318
00:48:42,160 --> 00:48:46,160
the PDB. We can really not gain much

1319
00:48:44,559 --> 00:48:47,920
information about them. Also with

1320
00:48:46,160 --> 00:48:49,920
computational tools to predict the

1321
00:48:47,920 --> 00:48:51,440
functions, we kind of fail. And we

1322
00:48:49,920 --> 00:48:52,960
looked at these um clusters from the

1323
00:48:51,440 --> 00:48:54,880
perspective of evolution. Like how do

1324
00:48:52,960 --> 00:48:56,240
these clusters distribute in in in the

1325
00:48:54,880 --> 00:48:58,400
tree of life? Like how many of these

1326
00:48:56,240 --> 00:49:00,559
clusters are essential to all life? Like

1327
00:48:58,400 --> 00:49:02,000
how many machinery are essential? And

1328
00:49:00,559 --> 00:49:05,119
how many machineries are for example

1329
00:49:02,000 --> 00:49:09,200
essential to only bacteria or ukariots?

1330
00:49:05,119 --> 00:49:12,000
And we tried to find um new domains.

1331
00:49:09,200 --> 00:49:15,200
Okay. Um we wanted to scale this

1332
00:49:12,000 --> 00:49:17,280
analysis up you know um we wanted to um

1333
00:49:15,200 --> 00:49:19,280
include more metagenomic structures to

1334
00:49:17,280 --> 00:49:21,680
this kind of analysis to cluster not

1335
00:49:19,280 --> 00:49:24,480
just the alphaold database but also go

1336
00:49:21,680 --> 00:49:27,599
to this uncultured world right

1337
00:49:24,480 --> 00:49:29,760
unculturable world um there's this ESM

1338
00:49:27,599 --> 00:49:31,280
Atlas which is predicted by ESM fold

1339
00:49:29,760 --> 00:49:33,839
it's not alpha fold it's a language

1340
00:49:31,280 --> 00:49:37,680
model based structure pred predictor but

1341
00:49:33,839 --> 00:49:39,680
they have predicted um 617 million um

1342
00:49:37,680 --> 00:49:42,319
structures and so we have done against

1343
00:49:39,680 --> 00:49:43,760
these 214 million of the uniro. So we

1344
00:49:42,319 --> 00:49:45,040
wanted to combine the set and somehow

1345
00:49:43,760 --> 00:49:47,200
learn something from this you know like

1346
00:49:45,040 --> 00:49:49,760
how many structures are environmental

1347
00:49:47,200 --> 00:49:51,200
specific and um how many are shared with

1348
00:49:49,760 --> 00:49:53,440
the with the uni pro what can you what

1349
00:49:51,200 --> 00:49:56,079
can you just see from from um um looking

1350
00:49:53,440 --> 00:49:57,520
at these environmental data. So

1351
00:49:56,079 --> 00:50:00,400
understand the whole metagenomic

1352
00:49:57,520 --> 00:50:03,599
structural universe in some way

1353
00:50:00,400 --> 00:50:07,119
and we use the same pipeline um slightly

1354
00:50:03,599 --> 00:50:09,119
tweaked. So um since we talk about

1355
00:50:07,119 --> 00:50:10,880
clustering here we clustered a bit

1356
00:50:09,119 --> 00:50:12,800
differently. So we combined the alpha

1357
00:50:10,880 --> 00:50:14,960
database with the ESM artas and we also

1358
00:50:12,800 --> 00:50:17,119
used MMC the first step to cluster but

1359
00:50:14,960 --> 00:50:18,640
we cluster at 30% sequence identity

1360
00:50:17,119 --> 00:50:22,720
means lower than before and before we

1361
00:50:18,640 --> 00:50:24,400
had 50 and we cluster using the

1362
00:50:22,720 --> 00:50:27,040
clustering mode that Zong explains where

1363
00:50:24,400 --> 00:50:29,040
you keep the longer ones um and we merge

1364
00:50:27,040 --> 00:50:30,400
fragments into this. So why do we do

1365
00:50:29,040 --> 00:50:32,240
this? Why? Because many of these

1366
00:50:30,400 --> 00:50:34,160
metagenomic sequences when you look at

1367
00:50:32,240 --> 00:50:36,000
them in the ESM atlas are fragments.

1368
00:50:34,160 --> 00:50:37,839
they're not just complete open reading

1369
00:50:36,000 --> 00:50:40,000
frames and they are really a pain for

1370
00:50:37,839 --> 00:50:42,720
the analysis in general. So we wanted to

1371
00:50:40,000 --> 00:50:44,559
somehow keep the longest the longest one

1372
00:50:42,720 --> 00:50:48,400
as a representative. So that's what we

1373
00:50:44,559 --> 00:50:51,760
did. We end up with um 187 million um um

1374
00:50:48,400 --> 00:50:55,119
clusters and then we use our full seek

1375
00:50:51,760 --> 00:50:57,440
clustering um same criteria as before um

1376
00:50:55,119 --> 00:51:00,240
and we end up with like 5.2 million

1377
00:50:57,440 --> 00:51:04,079
non-zingleton clusters. So it's like a

1378
00:51:00,240 --> 00:51:05,680
about 2x bit more than 2x um um increase

1379
00:51:04,079 --> 00:51:09,760
in clusters over the alpha fold

1380
00:51:05,680 --> 00:51:11,839
database. Um but we have more than 4x

1381
00:51:09,760 --> 00:51:13,280
more um structures or sequences in the

1382
00:51:11,839 --> 00:51:14,800
beginning. Right? So that's already also

1383
00:51:13,280 --> 00:51:19,520
tells you it's compresses still fairly

1384
00:51:14,800 --> 00:51:21,040
well. Um but you have 3 um 5 million ESM

1385
00:51:19,520 --> 00:51:23,440
only clusters. These are clusters that

1386
00:51:21,040 --> 00:51:26,160
only contains members from the ESM but

1387
00:51:23,440 --> 00:51:28,240
nothing from the from the um uniro at

1388
00:51:26,160 --> 00:51:31,359
all. So we wanted to kind of understand

1389
00:51:28,240 --> 00:51:32,640
what is there. Um one big obvious

1390
00:51:31,359 --> 00:51:34,720
question is the question is how many

1391
00:51:32,640 --> 00:51:36,240
more novel folds do you have right? Do

1392
00:51:34,720 --> 00:51:39,280
these actually fold in something very

1393
00:51:36,240 --> 00:51:42,160
very unique and um and if it does um how

1394
00:51:39,280 --> 00:51:44,800
many units out there so we we teamed up

1395
00:51:42,160 --> 00:51:47,599
with Christine Orango and David Jones um

1396
00:51:44,800 --> 00:51:49,680
which in this um have recently processed

1397
00:51:47,599 --> 00:51:52,240
the whole Alphault database and cut them

1398
00:51:49,680 --> 00:51:53,599
into domains this resource and they

1399
00:51:52,240 --> 00:51:54,720
search for novel folds in this one. I

1400
00:51:53,599 --> 00:51:57,599
said okay let's just do the same

1401
00:51:54,720 --> 00:52:01,599
analysis but do it on this like um 3.5

1402
00:51:57,599 --> 00:52:03,680
million clusters here okay

1403
00:52:01,599 --> 00:52:05,200
the pipeline is like um there's a lot of

1404
00:52:03,680 --> 00:52:06,960
filtering steps in it but effectively it

1405
00:52:05,200 --> 00:52:10,319
is t pipeline so you start off with this

1406
00:52:06,960 --> 00:52:12,079
ESM only clusters um then you have that

1407
00:52:10,319 --> 00:52:14,960
many um domains that you can actually

1408
00:52:12,079 --> 00:52:17,520
extract from it so 5 million domains um

1409
00:52:14,960 --> 00:52:19,599
you check if they're in cast um so many

1410
00:52:17,520 --> 00:52:21,280
of them are not in cast you check if

1411
00:52:19,599 --> 00:52:22,559
them are high quality so many of them

1412
00:52:21,280 --> 00:52:24,079
fall out because they do not fulfill

1413
00:52:22,559 --> 00:52:27,119
their quality criteria of the t

1414
00:52:24,079 --> 00:52:29,760
pipeline. And then my big question is

1415
00:52:27,119 --> 00:52:32,960
how many novel domains did we find?

1416
00:52:29,760 --> 00:52:36,359
Never folds. Do you have a guess? More

1417
00:52:32,960 --> 00:52:36,359
than 10,000.

1418
00:52:36,400 --> 00:52:44,079
More than a thousand.

1419
00:52:39,040 --> 00:52:46,160
Okay. More than 100.

1420
00:52:44,079 --> 00:52:49,280
Okay. Um the answer is we found

1421
00:52:46,160 --> 00:52:51,546
initially zero.

1422
00:52:49,280 --> 00:52:52,160
Um so that's a surprisingly low number.

1423
00:52:51,546 --> 00:52:54,880
[laughter]

1424
00:52:52,160 --> 00:52:57,280
Um so we thought okay maybe it's quality

1425
00:52:54,880 --> 00:53:00,160
right so this database was generated

1426
00:52:57,280 --> 00:53:01,680
using ESM fold and we know that ESM fold

1427
00:53:00,160 --> 00:53:03,680
might have some shortcomings especially

1428
00:53:01,680 --> 00:53:05,440
if you go out of distribution and many

1429
00:53:03,680 --> 00:53:08,400
of these metagenomic proteins might be

1430
00:53:05,440 --> 00:53:10,400
out of distribution so we thought um

1431
00:53:08,400 --> 00:53:13,040
let's see if we could repredict some of

1432
00:53:10,400 --> 00:53:15,119
them so we took 25% of these ESM only

1433
00:53:13,040 --> 00:53:19,520
clusters and repredicted them with alpha

1434
00:53:15,119 --> 00:53:20,880
fold um to be precise colup fold um and

1435
00:53:19,520 --> 00:53:23,200
then asked the question how many noble

1436
00:53:20,880 --> 00:53:25,680
folds can find um so how many did we

1437
00:53:23,200 --> 00:53:27,599
find I think I already okay that was not

1438
00:53:25,680 --> 00:53:31,280
smart it's already in the title um we

1439
00:53:27,599 --> 00:53:33,680
found exactly one um and so what is

1440
00:53:31,280 --> 00:53:36,640
great I can show you all the folds this

1441
00:53:33,680 --> 00:53:38,880
is how the novel fold looks like um and

1442
00:53:36,640 --> 00:53:41,280
so it's a bit surprising I think so even

1443
00:53:38,880 --> 00:53:43,520
after repredicting and and so on I would

1444
00:53:41,280 --> 00:53:45,599
expected to find more right um but it is

1445
00:53:43,520 --> 00:53:48,000
somehow limiting so maybe one hypothesis

1446
00:53:45,599 --> 00:53:49,680
is that there is some in inherent bias

1447
00:53:48,000 --> 00:53:52,319
in the in the prediction methods in

1448
00:53:49,680 --> 00:53:54,559
itself or it It could be really that we

1449
00:53:52,319 --> 00:53:58,079
are we are narrowing like the fold space

1450
00:53:54,559 --> 00:54:00,960
and pretty much in comparison in the TAD

1451
00:53:58,079 --> 00:54:02,480
they found around 7,600 novel folds just

1452
00:54:00,960 --> 00:54:03,839
that means in the up database so

1453
00:54:02,480 --> 00:54:07,040
substantially more than we have found in

1454
00:54:03,839 --> 00:54:09,119
these metagenomes but um if we wouldn't

1455
00:54:07,040 --> 00:54:10,800
have t we would found way more novel

1456
00:54:09,119 --> 00:54:12,319
folds in the set but since we had TAD

1457
00:54:10,800 --> 00:54:15,640
and we mapped against TED many of them

1458
00:54:12,319 --> 00:54:15,640
fall out

1459
00:54:16,720 --> 00:54:20,720
but there is a lot of variability in

1460
00:54:19,040 --> 00:54:22,319
these environments we're curious what

1461
00:54:20,720 --> 00:54:25,200
could be another reason for this

1462
00:54:22,319 --> 00:54:27,200
variability and we looked at the domain

1463
00:54:25,200 --> 00:54:28,960
composition asked the question can we

1464
00:54:27,200 --> 00:54:31,200
find Cath combination like domain

1465
00:54:28,960 --> 00:54:34,480
combinations that we do not find in the

1466
00:54:31,200 --> 00:54:37,520
alpha database like completely unseen um

1467
00:54:34,480 --> 00:54:40,000
um combinations of of of domains and

1468
00:54:37,520 --> 00:54:42,240
there is quite a lot of novelty in

1469
00:54:40,000 --> 00:54:44,160
multi-dommains combinations so it seems

1470
00:54:42,240 --> 00:54:46,000
like a lot of combinations driving the

1471
00:54:44,160 --> 00:54:48,319
diversity and we see that especially

1472
00:54:46,000 --> 00:54:49,680
enriched in transporters so we see in

1473
00:54:48,319 --> 00:54:52,000
more and more functions that are somehow

1474
00:54:49,680 --> 00:54:53,280
fused onto a transporter um that are out

1475
00:54:52,000 --> 00:54:57,079
there in the metagenomes but they are

1476
00:54:53,280 --> 00:54:57,079
not in the alpha database.

1477
00:54:57,599 --> 00:55:02,640
Okay, with this I want to go to the next

1478
00:55:00,480 --> 00:55:04,240
thing that I believe is probably the

1479
00:55:02,640 --> 00:55:06,160
next biggest modality of structures that

1480
00:55:04,240 --> 00:55:08,240
we will have in the in the in the near

1481
00:55:06,160 --> 00:55:10,319
future and these are complexes um

1482
00:55:08,240 --> 00:55:12,720
structural complexes.

1483
00:55:10,319 --> 00:55:14,240
So with the emergence of alpha 2 people

1484
00:55:12,720 --> 00:55:15,839
realized you can do monomers but then

1485
00:55:14,240 --> 00:55:17,280
also very fast with some tricks people

1486
00:55:15,839 --> 00:55:19,040
realized you can do complexes. You can

1487
00:55:17,280 --> 00:55:21,920
actually see how how how these um

1488
00:55:19,040 --> 00:55:24,160
quartinary states are are built and and

1489
00:55:21,920 --> 00:55:26,800
we thought we just somehow need a tool

1490
00:55:24,160 --> 00:55:28,559
that can compare um these quartinary

1491
00:55:26,800 --> 00:55:30,480
databases efficiently. This is false

1492
00:55:28,559 --> 00:55:33,119
multimeir.

1493
00:55:30,480 --> 00:55:35,680
Okay. So what does it mean to compare

1494
00:55:33,119 --> 00:55:36,880
complexes? So here you have a complex on

1495
00:55:35,680 --> 00:55:38,160
the left and on the right. The one is

1496
00:55:36,880 --> 00:55:40,319
left is on the query and the other one

1497
00:55:38,160 --> 00:55:42,240
is the target. And the one on left has

1498
00:55:40,319 --> 00:55:44,880
three chains A, B and C and the other

1499
00:55:42,240 --> 00:55:46,559
one is X, Y and Z. And the problem of a

1500
00:55:44,880 --> 00:55:48,640
complex alignment is you want to find

1501
00:55:46,559 --> 00:55:51,680
like a good match between these between

1502
00:55:48,640 --> 00:55:54,559
these two um units. So a good answer is

1503
00:55:51,680 --> 00:55:56,000
you match a tox b to y and c to set

1504
00:55:54,559 --> 00:55:58,160
right and if you do so then you have a

1505
00:55:56,000 --> 00:56:01,440
perfect overlap between these two units.

1506
00:55:58,160 --> 00:56:03,040
Um so now computationally how long does

1507
00:56:01,440 --> 00:56:05,040
how long would it take you to do that?

1508
00:56:03,040 --> 00:56:07,119
So you say you have n chains here right

1509
00:56:05,040 --> 00:56:09,920
um on each each side. Do you have an

1510
00:56:07,119 --> 00:56:11,520
idea how long it would take to do that

1511
00:56:09,920 --> 00:56:15,960
to find an optimal matching between

1512
00:56:11,520 --> 00:56:15,960
these two um um complexes?

1513
00:56:19,599 --> 00:56:26,240
Yeah, just your thoughts I guess. Um

1514
00:56:23,359 --> 00:56:28,640
it's n factorial. So it is actually

1515
00:56:26,240 --> 00:56:30,480
quite quite quite complicated because

1516
00:56:28,640 --> 00:56:32,319
you you match A, right? And you have the

1517
00:56:30,480 --> 00:56:33,839
chance to match B or C, but they can be

1518
00:56:32,319 --> 00:56:35,839
matched in either way. And then you

1519
00:56:33,839 --> 00:56:37,520
could move that and you can check match

1520
00:56:35,839 --> 00:56:39,760
again. So you end up with an n factorial

1521
00:56:37,520 --> 00:56:41,599
comparisons to really find the best

1522
00:56:39,760 --> 00:56:43,280
possible way to superpose these two

1523
00:56:41,599 --> 00:56:44,880
complexes. And this is obviously not

1524
00:56:43,280 --> 00:56:47,040
great. That doesn't scale really well,

1525
00:56:44,880 --> 00:56:49,760
especially for big complexes and make

1526
00:56:47,040 --> 00:56:51,040
things um um quite inefficient. So we

1527
00:56:49,760 --> 00:56:54,079
thought about how can you make that

1528
00:56:51,040 --> 00:56:56,079
faster. Um so what does it mean to um do

1529
00:56:54,079 --> 00:56:57,359
a complex to complex alignment? What you

1530
00:56:56,079 --> 00:57:00,880
actually want to find is you want to

1531
00:56:57,359 --> 00:57:04,079
find a translation and you want to find

1532
00:57:00,880 --> 00:57:06,240
a rotation that matches these two chains

1533
00:57:04,079 --> 00:57:07,839
together. Right? Um so this is then if

1534
00:57:06,240 --> 00:57:09,760
you would have the translation and the

1535
00:57:07,839 --> 00:57:11,920
rotation then you would find your your

1536
00:57:09,760 --> 00:57:13,839
chain matching in some way. And one

1537
00:57:11,920 --> 00:57:17,119
observation is that you could take each

1538
00:57:13,839 --> 00:57:18,559
chain one by one and you can apply the

1539
00:57:17,119 --> 00:57:21,359
translation rotation completely

1540
00:57:18,559 --> 00:57:23,040
independent um of the other chains onto

1541
00:57:21,359 --> 00:57:24,880
it and you would still end up in the

1542
00:57:23,040 --> 00:57:26,319
same solution. So what does that mean?

1543
00:57:24,880 --> 00:57:28,240
That means we don't need to care about

1544
00:57:26,319 --> 00:57:30,880
the complex in the beginning. We can

1545
00:57:28,240 --> 00:57:32,640
just care about single chains and find

1546
00:57:30,880 --> 00:57:35,119
superpositions and then somehow cluster

1547
00:57:32,640 --> 00:57:36,960
them. So how does it work? You just

1548
00:57:35,119 --> 00:57:38,400
compute the superp positions from all

1549
00:57:36,960 --> 00:57:41,680
the chains in the query against the

1550
00:57:38,400 --> 00:57:44,000
target. So then you get your rotation

1551
00:57:41,680 --> 00:57:45,680
and translations and you see there's one

1552
00:57:44,000 --> 00:57:46,960
solution that emerges, right? And this

1553
00:57:45,680 --> 00:57:48,240
is the solution that will actually tell

1554
00:57:46,960 --> 00:57:51,200
you what the chain matching is at the

1555
00:57:48,240 --> 00:57:52,880
end and this is you can do an n square.

1556
00:57:51,200 --> 00:57:54,480
So now you don't need n factorial to do

1557
00:57:52,880 --> 00:57:56,400
that anymore. So that's substantially

1558
00:57:54,480 --> 00:57:59,280
faster.

1559
00:57:56,400 --> 00:58:01,440
So we wanted to somehow yeah use that

1560
00:57:59,280 --> 00:58:05,200
and so there is this work here um from

1561
00:58:01,440 --> 00:58:07,359
fangs group um from ultra at all where

1562
00:58:05,200 --> 00:58:08,720
they look at this um crisper systems we

1563
00:58:07,359 --> 00:58:10,000
wanted to somehow take this gene

1564
00:58:08,720 --> 00:58:11,839
neighborhood that they have discovered

1565
00:58:10,000 --> 00:58:13,920
like a crisper a new type of crystal

1566
00:58:11,839 --> 00:58:15,599
system and predicted this alphafold

1567
00:58:13,920 --> 00:58:17,680
multimeir because I think there will be

1568
00:58:15,599 --> 00:58:19,839
more and more discovery in these like

1569
00:58:17,680 --> 00:58:20,880
neighborhoods based on like complex

1570
00:58:19,839 --> 00:58:22,400
predictions because often this like

1571
00:58:20,880 --> 00:58:24,400
operons right so there is a lot of like

1572
00:58:22,400 --> 00:58:27,440
protein protein actions within them and

1573
00:58:24,400 --> 00:58:28,799
if you give these chains to um a fold

1574
00:58:27,440 --> 00:58:31,760
multimeter. You get this prediction here

1575
00:58:28,799 --> 00:58:33,839
on the left. It has a PTM score of 0.5.

1576
00:58:31,760 --> 00:58:36,640
That means the prediction is so so it's

1577
00:58:33,839 --> 00:58:37,920
not amazing, but it's also not bad. But

1578
00:58:36,640 --> 00:58:40,000
you would like to have the tool now to

1579
00:58:37,920 --> 00:58:41,359
search against this um the PDB for

1580
00:58:40,000 --> 00:58:44,319
example to see if you find similar

1581
00:58:41,359 --> 00:58:46,480
complexes in the databases. And with um

1582
00:58:44,319 --> 00:58:47,599
full multime, you can align this in less

1583
00:58:46,480 --> 00:58:49,119
than a minute. So you can take this

1584
00:58:47,599 --> 00:58:52,400
complex and search through the whole PDB

1585
00:58:49,119 --> 00:58:54,720
and identify um complexes that have a

1586
00:58:52,400 --> 00:58:55,680
similar chain um confirmation. And you

1587
00:58:54,720 --> 00:58:57,760
can even find [clears throat] hits that

1588
00:58:55,680 --> 00:59:00,799
are lower than 20% sequence identity,

1589
00:58:57,760 --> 00:59:02,720
you know, really really distant things.

1590
00:59:00,799 --> 00:59:04,640
Um, so we can do in less than a minute.

1591
00:59:02,720 --> 00:59:07,280
There's a software called us align which

1592
00:59:04,640 --> 00:59:10,480
does it pairwise. It would take 13 uh 13

1593
00:59:07,280 --> 00:59:12,960
days um to to really complete this task.

1594
00:59:10,480 --> 00:59:14,960
So this searchfor.com is a web server

1595
00:59:12,960 --> 00:59:17,119
where you can just put in a complex. You

1596
00:59:14,960 --> 00:59:20,079
can push search. It will now search this

1597
00:59:17,119 --> 00:59:21,599
complex against um the PDB. And now you

1598
00:59:20,079 --> 00:59:23,359
see all of these things that it matches

1599
00:59:21,599 --> 00:59:24,640
the chain matching as well. And this

1600
00:59:23,359 --> 00:59:27,599
takes a bit to load because they're

1601
00:59:24,640 --> 00:59:29,200
quite big complex. And you can see um

1602
00:59:27,599 --> 00:59:30,880
yeah, you can see how these chains are

1603
00:59:29,200 --> 00:59:32,559
are similar to the experimentally

1604
00:59:30,880 --> 00:59:34,720
determined structure. And you can

1605
00:59:32,559 --> 00:59:36,720
highlight regions. You can see um where

1606
00:59:34,720 --> 00:59:38,880
they are in the complex and you can see

1607
00:59:36,720 --> 00:59:40,319
the yeah thing in full screen can take

1608
00:59:38,880 --> 00:59:43,559
pictures and so on and put them into

1609
00:59:40,319 --> 00:59:43,559
your publications.

1610
00:59:44,000 --> 00:59:50,960
Okay. Um next is the idea of fully

1611
00:59:48,240 --> 00:59:53,200
interfaces. Um so this is unpublished

1612
00:59:50,960 --> 00:59:56,480
work that we do together with um Katya

1613
00:59:53,200 --> 00:59:59,920
look at the IMB um it's the idea to

1614
00:59:56,480 --> 01:00:02,480
somehow compare interfaces um instead of

1615
00:59:59,920 --> 01:00:04,000
whole chains full seek multime

1616
01:00:02,480 --> 01:00:06,000
effectively just take chains and find

1617
01:00:04,000 --> 01:00:07,520
these chain matchings but we often

1618
01:00:06,000 --> 01:00:09,040
interested not in the chains but rather

1619
01:00:07,520 --> 01:00:11,920
in the interface that describes the

1620
01:00:09,040 --> 01:00:14,400
interactions on like a smaller level. So

1621
01:00:11,920 --> 01:00:16,720
I think from an alpha fold kind of

1622
01:00:14,400 --> 01:00:19,359
perspective just imagine you do alpha

1623
01:00:16,720 --> 01:00:21,680
fold predictions of multimemerse you

1624
01:00:19,359 --> 01:00:23,599
it's actually hard to know currently if

1625
01:00:21,680 --> 01:00:25,599
you have really done like a a novel

1626
01:00:23,599 --> 01:00:27,280
prediction or not so if it's a novel

1627
01:00:25,599 --> 01:00:28,559
interface or not we have no tool that

1628
01:00:27,280 --> 01:00:30,000
actually tells us okay for that

1629
01:00:28,559 --> 01:00:31,440
interface that I've just predicted how

1630
01:00:30,000 --> 01:00:33,280
novel is that is it something that we

1631
01:00:31,440 --> 01:00:35,040
have observed before or is it something

1632
01:00:33,280 --> 01:00:38,640
that is really really really new and for

1633
01:00:35,040 --> 01:00:40,400
that we wanted to build this tool

1634
01:00:38,640 --> 01:00:42,240
so

1635
01:00:40,400 --> 01:00:45,200
the idea is actually fairly similar to

1636
01:00:42,240 --> 01:00:47,680
what we just do in in in in fals. We

1637
01:00:45,200 --> 01:00:49,839
just extract effectively the region

1638
01:00:47,680 --> 01:00:52,000
where between two chains like in was it

1639
01:00:49,839 --> 01:00:54,480
in a 10 amstrong distance from the C

1640
01:00:52,000 --> 01:00:56,559
alphas and just take that neighborhood

1641
01:00:54,480 --> 01:00:58,799
and for this neighborhood we convert it

1642
01:00:56,559 --> 01:01:01,040
into 3DI string. So we will have two

1643
01:00:58,799 --> 01:01:04,559
strings for the interface of the chain A

1644
01:01:01,040 --> 01:01:07,119
and for the interface of the chain B and

1645
01:01:04,559 --> 01:01:09,119
then we try we do that for the database

1646
01:01:07,119 --> 01:01:10,880
as well. We do it for like the PDB,

1647
01:01:09,119 --> 01:01:12,559
extract all of the interfaces from from

1648
01:01:10,880 --> 01:01:14,240
the PDB

1649
01:01:12,559 --> 01:01:16,079
and then we can do an alignment task. We

1650
01:01:14,240 --> 01:01:17,839
just align the chains independently and

1651
01:01:16,079 --> 01:01:20,640
we use full seek multimeter in the end

1652
01:01:17,839 --> 01:01:22,960
to do the chain matching. Um and with

1653
01:01:20,640 --> 01:01:26,720
this we then can figure out what

1654
01:01:22,960 --> 01:01:28,319
interfaces are similar to each other

1655
01:01:26,720 --> 01:01:30,960
and there is software that can already

1656
01:01:28,319 --> 01:01:33,520
do it. Um there's a software called iine

1657
01:01:30,960 --> 01:01:35,760
and we benchmarked um fseek interface

1658
01:01:33,520 --> 01:01:39,760
against iine on a domain domain

1659
01:01:35,760 --> 01:01:42,319
interface benchmark um based on proc cid

1660
01:01:39,760 --> 01:01:43,920
um and on this benchmark fse slightly

1661
01:01:42,319 --> 01:01:46,799
outperforms iline while they were

1662
01:01:43,920 --> 01:01:49,839
comparable in performance. However, um

1663
01:01:46,799 --> 01:01:51,599
FIC is substantially faster. Um I do not

1664
01:01:49,839 --> 01:01:53,520
have the exact number. I think we in a

1665
01:01:51,599 --> 01:01:55,119
range of like a few seconds to do this

1666
01:01:53,520 --> 01:01:57,599
comparison and benchmark while if you do

1667
01:01:55,119 --> 01:02:00,839
it with line it takes um um a few hours

1668
01:01:57,599 --> 01:02:00,839
in general.

1669
01:02:02,559 --> 01:02:07,119
Okay. Having now like a really fast tool

1670
01:02:04,799 --> 01:02:09,599
to compare interfaces, we're curious to

1671
01:02:07,119 --> 01:02:12,079
cluster these interfaces.

1672
01:02:09,599 --> 01:02:14,960
um starting off from the P PDB take

1673
01:02:12,079 --> 01:02:17,520
these biological assemblies um extract

1674
01:02:14,960 --> 01:02:19,760
um just interfaces but only the ones

1675
01:02:17,520 --> 01:02:22,720
that have at least four residues. Then

1676
01:02:19,760 --> 01:02:25,119
we have about 3 million DR like dmer

1677
01:02:22,720 --> 01:02:27,119
interfaces and we use um full seek

1678
01:02:25,119 --> 01:02:30,079
interface clustering to to somehow

1679
01:02:27,119 --> 01:02:32,319
cluster these groups together

1680
01:02:30,079 --> 01:02:35,359
and what we ended up with is about

1681
01:02:32,319 --> 01:02:37,280
43,000 clusters while um 11,000 of them

1682
01:02:35,359 --> 01:02:39,280
are singletons. So it's a big reduction.

1683
01:02:37,280 --> 01:02:41,280
So means like um interface space is much

1684
01:02:39,280 --> 01:02:43,680
much much smaller than um the the the

1685
01:02:41,280 --> 01:02:45,040
dimemer space in general. Um and now

1686
01:02:43,680 --> 01:02:46,480
with this we really have a lot of

1687
01:02:45,040 --> 01:02:47,920
questions in mind. We have not done so

1688
01:02:46,480 --> 01:02:50,160
much analysis. This is really work in

1689
01:02:47,920 --> 01:02:51,599
progress heavily. But we were curious to

1690
01:02:50,160 --> 01:02:53,599
annotate these. We want to figure out

1691
01:02:51,599 --> 01:02:56,960
how ancient are these interfaces like

1692
01:02:53,599 --> 01:02:59,760
are they um specific to certain

1693
01:02:56,960 --> 01:03:01,680
organisms um and and and really

1694
01:02:59,760 --> 01:03:02,880
understand what these clusters are. In

1695
01:03:01,680 --> 01:03:05,440
addition of this, we were pretty

1696
01:03:02,880 --> 01:03:07,040
interested in predicted alpha fold

1697
01:03:05,440 --> 01:03:09,119
complexes and asked the question in

1698
01:03:07,040 --> 01:03:10,880
these alpha fold complexes. How many of

1699
01:03:09,119 --> 01:03:13,359
the interfaces in the PDB are actually

1700
01:03:10,880 --> 01:03:15,039
covered um through alpha predictions?

1701
01:03:13,359 --> 01:03:17,839
Are they all covered? Do we have some

1702
01:03:15,039 --> 01:03:19,839
problems for some of them or not? Um we

1703
01:03:17,839 --> 01:03:21,920
started off with some analysis. Um this

1704
01:03:19,839 --> 01:03:24,799
is our flying spaghetti monster. And

1705
01:03:21,920 --> 01:03:28,400
this is the biggest non-coil coil BFMD

1706
01:03:24,799 --> 01:03:31,440
which is a a database of predicted um um

1707
01:03:28,400 --> 01:03:33,680
uh complexes from AlphaFold. Um, and we

1708
01:03:31,440 --> 01:03:37,680
compared the interfaces like of this

1709
01:03:33,680 --> 01:03:39,680
BFMD against the PDB. And this one is

1710
01:03:37,680 --> 01:03:41,280
the one that has nothing in the PDB, but

1711
01:03:39,680 --> 01:03:43,839
it's like a big cluster that is somehow

1712
01:03:41,280 --> 01:03:45,520
occurred in the in the um in the alpha

1713
01:03:43,839 --> 01:03:49,119
fold one. So, it might be a novel

1714
01:03:45,520 --> 01:03:50,799
interface. Um, novel interface or wrong

1715
01:03:49,119 --> 01:03:52,480
prediction. We are not sure and we have

1716
01:03:50,799 --> 01:03:53,920
to now kind of understand if this is

1717
01:03:52,480 --> 01:03:55,680
really like a novel interface that Alpha

1718
01:03:53,920 --> 01:03:58,079
was able to predict or if this is

1719
01:03:55,680 --> 01:04:01,440
something um where something really went

1720
01:03:58,079 --> 01:04:04,000
terribly wrong. Okay, the last thing

1721
01:04:01,440 --> 01:04:07,200
just I want to talk very briefly about

1722
01:04:04,000 --> 01:04:08,880
um is 3D motives. So we we method

1723
01:04:07,200 --> 01:04:10,400
developers we put out fullse seek and

1724
01:04:08,880 --> 01:04:11,520
then you know a few days later when you

1725
01:04:10,400 --> 01:04:12,880
put out full you're very proud of

1726
01:04:11,520 --> 01:04:14,240
yourself you think you have generated a

1727
01:04:12,880 --> 01:04:15,520
good software but then the community

1728
01:04:14,240 --> 01:04:18,319
asked the question how can I find

1729
01:04:15,520 --> 01:04:19,920
binding pockets um and then how can I

1730
01:04:18,319 --> 01:04:22,079
find these custom motives and your

1731
01:04:19,920 --> 01:04:24,400
answer is you cannot and that is really

1732
01:04:22,079 --> 01:04:26,319
frustrating as a method developer um uh

1733
01:04:24,400 --> 01:04:28,079
and so we wanted to have a solution for

1734
01:04:26,319 --> 01:04:30,000
this so why are these things really

1735
01:04:28,079 --> 01:04:31,760
important you know these ensematic sites

1736
01:04:30,000 --> 01:04:33,680
are very conserved you have these like

1737
01:04:31,760 --> 01:04:35,280
these ensematic triads that really

1738
01:04:33,680 --> 01:04:37,280
causes the enzyatic reaction and you

1739
01:04:35,280 --> 01:04:39,839
want to be able to somehow find that. So

1740
01:04:37,280 --> 01:04:41,760
why is it hard to find it? And Su

1741
01:04:39,839 --> 01:04:44,160
introduced dynamic programming to you.

1742
01:04:41,760 --> 01:04:45,920
Dynamic programming actually means that

1743
01:04:44,160 --> 01:04:47,760
you can align from left to right because

1744
01:04:45,920 --> 01:04:49,280
you fill up the cells from left to right

1745
01:04:47,760 --> 01:04:50,960
and you have always the property that

1746
01:04:49,280 --> 01:04:52,559
you look back to what was previously

1747
01:04:50,960 --> 01:04:54,160
aligned and you compute the score to

1748
01:04:52,559 --> 01:04:57,119
what is previously aligned. And this is

1749
01:04:54,160 --> 01:04:58,880
what fseek and mm sensor can do. They

1750
01:04:57,119 --> 01:05:00,079
can find really like a stretch that you

1751
01:04:58,880 --> 01:05:03,119
can align really well from left to

1752
01:05:00,079 --> 01:05:05,039
right. But these motive like the sync

1753
01:05:03,119 --> 01:05:07,119
finger for example here doesn't need to

1754
01:05:05,039 --> 01:05:09,440
be following this rule. So it can

1755
01:05:07,119 --> 01:05:11,119
completely shuffle the order of the

1756
01:05:09,440 --> 01:05:12,880
letters. Right? And that makes the

1757
01:05:11,119 --> 01:05:14,480
problem much much harder. So it's much

1758
01:05:12,880 --> 01:05:18,359
harder to find something that you cannot

1759
01:05:14,480 --> 01:05:18,359
align from left to right.

1760
01:05:18,880 --> 01:05:23,920
So how can you find that? So we have

1761
01:05:21,599 --> 01:05:26,319
developed a f full disco um especially

1762
01:05:23,920 --> 01:05:28,400
for this purpose. So if you have a

1763
01:05:26,319 --> 01:05:29,920
structural motive for example um so here

1764
01:05:28,400 --> 01:05:33,039
a sync finger with this like four

1765
01:05:29,920 --> 01:05:35,200
residues the way how you would find it

1766
01:05:33,039 --> 01:05:36,799
is actually very tedious and what you

1767
01:05:35,200 --> 01:05:39,119
have to do is you have to compare all

1768
01:05:36,799 --> 01:05:42,160
pair wise interactions. So you have to

1769
01:05:39,119 --> 01:05:43,200
cut cut this piece into into pair wise

1770
01:05:42,160 --> 01:05:44,480
interactions. You have to ask the

1771
01:05:43,200 --> 01:05:46,640
question is this pair wise interaction

1772
01:05:44,480 --> 01:05:48,240
somehow compatible to something in your

1773
01:05:46,640 --> 01:05:50,000
structure in the end and you have to do

1774
01:05:48,240 --> 01:05:53,599
it for all. So you're checking all of

1775
01:05:50,000 --> 01:05:56,559
these pair wise interactions. Um and in

1776
01:05:53,599 --> 01:05:58,079
order to be fast and we want to be fast

1777
01:05:56,559 --> 01:05:59,680
we have to actually store all of these

1778
01:05:58,079 --> 01:06:02,720
pair wise interactions. So for the

1779
01:05:59,680 --> 01:06:04,559
upfold database we have to store um a

1780
01:06:02,720 --> 01:06:06,400
big set of these paractions and this is

1781
01:06:04,559 --> 01:06:09,440
really a big problem. So there is a

1782
01:06:06,400 --> 01:06:11,200
software that called um RCSB. They use

1783
01:06:09,440 --> 01:06:13,119
this pair feature representation where

1784
01:06:11,200 --> 01:06:15,200
they take the C alpha distances, C beta

1785
01:06:13,119 --> 01:06:18,000
distances and an insect intersecting

1786
01:06:15,200 --> 01:06:20,960
angle between two amino acids

1787
01:06:18,000 --> 01:06:23,280
and um then they store the identifier

1788
01:06:20,960 --> 01:06:25,520
for the structure where this um pair is

1789
01:06:23,280 --> 01:06:27,599
from as well as the position of where

1790
01:06:25,520 --> 01:06:30,240
where does the pair is anchored in the

1791
01:06:27,599 --> 01:06:32,160
structure. And if you would store that

1792
01:06:30,240 --> 01:06:35,280
it for 214 million structures you would

1793
01:06:32,160 --> 01:06:37,280
like need 73 terabytes of of disk space

1794
01:06:35,280 --> 01:06:38,640
which is not really handable for many of

1795
01:06:37,280 --> 01:06:40,480
the groups and many people do not have

1796
01:06:38,640 --> 01:06:41,760
that much space and also obviously it

1797
01:06:40,480 --> 01:06:43,520
makes search slower because you have to

1798
01:06:41,760 --> 01:06:47,200
go through this big big data set in the

1799
01:06:43,520 --> 01:06:49,039
end. Um so we thought about in disco how

1800
01:06:47,200 --> 01:06:50,720
can we make that smaller and um also

1801
01:06:49,039 --> 01:06:53,200
maybe include some more features that

1802
01:06:50,720 --> 01:06:55,760
might be important to identify um these

1803
01:06:53,200 --> 01:06:58,480
these motives um a bit more sensitive.

1804
01:06:55,760 --> 01:07:00,960
So we take the same features as the RCSB

1805
01:06:58,480 --> 01:07:02,640
um um idea but we add the side chains

1806
01:07:00,960 --> 01:07:04,000
you know the side chain orientations and

1807
01:07:02,640 --> 01:07:05,599
I think that's very important for

1808
01:07:04,000 --> 01:07:07,760
ensematic pockets because the side chain

1809
01:07:05,599 --> 01:07:10,640
orientation really contributes a lot in

1810
01:07:07,760 --> 01:07:13,359
the end to the geometric pattern right

1811
01:07:10,640 --> 01:07:15,200
and we also decided to not store the

1812
01:07:13,359 --> 01:07:17,520
position but we only store the

1813
01:07:15,200 --> 01:07:19,280
identifier. So now our algorithm what it

1814
01:07:17,520 --> 01:07:20,880
does is it takes a motive it breaks it

1815
01:07:19,280 --> 01:07:22,720
up into this pair wise interactions and

1816
01:07:20,880 --> 01:07:25,359
it searches them in in an index that is

1817
01:07:22,720 --> 01:07:29,119
10 terabytes big um through an inverse

1818
01:07:25,359 --> 01:07:30,720
lookup table and it finds where in what

1819
01:07:29,119 --> 01:07:32,640
identifier can I find all of these pair

1820
01:07:30,720 --> 01:07:34,400
wise features and if I found it I can

1821
01:07:32,640 --> 01:07:35,920
take a slower algorithm afterwards to

1822
01:07:34,400 --> 01:07:37,359
find more precisely where are the

1823
01:07:35,920 --> 01:07:39,119
positions of this one. So you can see

1824
01:07:37,359 --> 01:07:40,559
that like as a fast pre-f filter, you

1825
01:07:39,119 --> 01:07:42,240
know, similar to the pre-f filter you

1826
01:07:40,559 --> 01:07:43,920
have seen in MM62. This is a pre-f

1827
01:07:42,240 --> 01:07:45,280
filter that somehow narrow down the

1828
01:07:43,920 --> 01:07:46,799
space of structures. And when you found

1829
01:07:45,280 --> 01:07:48,559
the set of structures that have a chance

1830
01:07:46,799 --> 01:07:50,640
to have that motive, use something more

1831
01:07:48,559 --> 01:07:52,160
thoroughly to find really where does the

1832
01:07:50,640 --> 01:07:54,480
um where is the motive really occurring

1833
01:07:52,160 --> 01:07:56,240
in it. And yeah, full disco

1834
01:07:54,480 --> 01:07:57,920
substantially faster than pi score

1835
01:07:56,240 --> 01:08:00,880
motive which is ani python

1836
01:07:57,920 --> 01:08:03,039
implementation of the RCSB. um you can

1837
01:08:00,880 --> 01:08:05,119
search a motive without pre-f filter

1838
01:08:03,039 --> 01:08:06,319
alone in in seconds. When you really

1839
01:08:05,119 --> 01:08:08,160
want to need to know the position where

1840
01:08:06,319 --> 01:08:09,760
it occurs, you need about a minute or so

1841
01:08:08,160 --> 01:08:12,079
um to search a motive against the A4

1842
01:08:09,760 --> 01:08:14,720
database. So why is it useful? So for

1843
01:08:12,079 --> 01:08:16,480
example, you can take a sync finger

1844
01:08:14,720 --> 01:08:18,560
and you can search the sync finger

1845
01:08:16,480 --> 01:08:19,839
against the database. So what you find

1846
01:08:18,560 --> 01:08:21,600
if you search a sync finger against the

1847
01:08:19,839 --> 01:08:23,199
alpha database is this uncharacterized

1848
01:08:21,600 --> 01:08:25,520
protein here on the right side which is

1849
01:08:23,199 --> 01:08:27,199
a Pacific oyster. Um we don't know what

1850
01:08:25,520 --> 01:08:29,120
it is but it seemed to have the sync

1851
01:08:27,199 --> 01:08:30,799
fingers quite a lot. And you can also

1852
01:08:29,120 --> 01:08:32,880
find sync fingers in unanotated

1853
01:08:30,799 --> 01:08:34,719
metagenomic sequences. So you can kind

1854
01:08:32,880 --> 01:08:36,799
of get an idea of what the thing might

1855
01:08:34,719 --> 01:08:38,640
be able to do.

1856
01:08:36,799 --> 01:08:40,400
Or something to play with with your

1857
01:08:38,640 --> 01:08:42,640
imagination is you can actually start

1858
01:08:40,400 --> 01:08:45,199
looking at states. So you can take a

1859
01:08:42,640 --> 01:08:47,120
here's a GPCR in an active and an

1860
01:08:45,199 --> 01:08:49,279
inactive state. And you see highlighted

1861
01:08:47,120 --> 01:08:52,719
are certain hinge points that describe

1862
01:08:49,279 --> 01:08:55,520
the state um um of this of this GPCRs.

1863
01:08:52,719 --> 01:08:57,440
So you now you can take the left motive

1864
01:08:55,520 --> 01:08:58,799
and search it against the alpha database

1865
01:08:57,440 --> 01:09:01,359
and the right motive and search against

1866
01:08:58,799 --> 01:09:02,880
the alpha alpha database. The left one

1867
01:09:01,359 --> 01:09:04,239
should find everything that is in an

1868
01:09:02,880 --> 01:09:06,000
active state and the other one should

1869
01:09:04,239 --> 01:09:08,000
find everything that is in an inactive

1870
01:09:06,000 --> 01:09:10,159
state. So now my question is how often

1871
01:09:08,000 --> 01:09:12,000
do you believe in the alpha database

1872
01:09:10,159 --> 01:09:13,839
that you have an active versus an

1873
01:09:12,000 --> 01:09:15,199
inactive state? When you make a

1874
01:09:13,839 --> 01:09:16,960
prediction alpha for would you always

1875
01:09:15,199 --> 01:09:19,440
believe it always generates everything

1876
01:09:16,960 --> 01:09:23,080
as an active one or everything always as

1877
01:09:19,440 --> 01:09:23,080
an inactive one.

1878
01:09:25,199 --> 01:09:29,440
So what we have seen is when you search

1879
01:09:26,719 --> 01:09:31,839
against the PDB you find 50% active and

1880
01:09:29,440 --> 01:09:33,600
50% inactive. If you do the same search

1881
01:09:31,839 --> 01:09:36,000
in the alpha database you find 50%

1882
01:09:33,600 --> 01:09:37,600
active and 50% inactive. So maybe alpha

1883
01:09:36,000 --> 01:09:39,120
is kind of sampling you know what it has

1884
01:09:37,600 --> 01:09:40,239
seen. So you I think there's a lot of

1885
01:09:39,120 --> 01:09:43,359
structural diversity probably in the

1886
01:09:40,239 --> 01:09:44,719
alpha falls um DB um um out there

1887
01:09:43,359 --> 01:09:47,440
already and you can probably explore

1888
01:09:44,719 --> 01:09:49,759
different states. So you can easily use

1889
01:09:47,440 --> 01:09:52,239
full disco um through our web server

1890
01:09:49,759 --> 01:09:55,600
upload um a structure then define your

1891
01:09:52,239 --> 01:09:58,000
motive that you want to um search

1892
01:09:55,600 --> 01:10:00,000
you can click search and then after some

1893
01:09:58,000 --> 01:10:01,840
time you will see the hits in the um in

1894
01:10:00,000 --> 01:10:04,159
in all of these databases alpha database

1895
01:10:01,840 --> 01:10:05,440
included um and then yeah this is how

1896
01:10:04,159 --> 01:10:06,880
the motive looks like this is how it's

1897
01:10:05,440 --> 01:10:08,000
in the query look how how it look in the

1898
01:10:06,880 --> 01:10:09,840
query and this is how it looks like in

1899
01:10:08,000 --> 01:10:11,840
the target

1900
01:10:09,840 --> 01:10:13,920
and so yeah we keep on developing this

1901
01:10:11,840 --> 01:10:15,679
um so if you try that out and you have

1902
01:10:13,920 --> 01:10:18,560
any problems please let us know um we

1903
01:10:15,679 --> 01:10:21,120
happy to to help and and fix things. In

1904
01:10:18,560 --> 01:10:23,600
conclusion, um Su has taken my

1905
01:10:21,120 --> 01:10:25,840
conclusion. Um so I had to have a

1906
01:10:23,600 --> 01:10:28,320
different conclusion and and this

1907
01:10:25,840 --> 01:10:31,679
conclusion is that I I I see so there's

1908
01:10:28,320 --> 01:10:34,800
this um um tweet by um Seaming Lin that

1909
01:10:31,679 --> 01:10:37,840
sees us somehow as this like small stone

1910
01:10:34,800 --> 01:10:39,199
here um that holds up that that big

1911
01:10:37,840 --> 01:10:41,360
thing on top which is like protein

1912
01:10:39,199 --> 01:10:43,760
design I would say like um AI bio in

1913
01:10:41,360 --> 01:10:45,600
some way. Um so I I see we are building

1914
01:10:43,760 --> 01:10:48,159
these like fundamental units right

1915
01:10:45,600 --> 01:10:50,560
somehow that helps others um to to make

1916
01:10:48,159 --> 01:10:52,719
their work and life um easier is really

1917
01:10:50,560 --> 01:10:54,800
nice was really really motivating and I

1918
01:10:52,719 --> 01:10:56,719
also see our work like this but I want

1919
01:10:54,800 --> 01:10:58,480
to at this point really thank everybody

1920
01:10:56,719 --> 01:11:00,159
that contributes open source software

1921
01:10:58,480 --> 01:11:01,760
right because our software would be

1922
01:11:00,159 --> 01:11:04,159
possible because we are standing also on

1923
01:11:01,760 --> 01:11:05,840
somebody's stone right so um many many

1924
01:11:04,159 --> 01:11:07,920
of you have contributed code have

1925
01:11:05,840 --> 01:11:09,679
contributed ideas um and put them out

1926
01:11:07,920 --> 01:11:11,040
there and let other people use it for

1927
01:11:09,679 --> 01:11:12,480
free I think that's really the great

1928
01:11:11,040 --> 01:11:14,480
thing about academia here we can do that

1929
01:11:12,480 --> 01:11:16,159
right we can really live idealistic give

1930
01:11:14,480 --> 01:11:19,040
our code for free and let other people

1931
01:11:16,159 --> 01:11:20,560
use it and so um if your face is not on

1932
01:11:19,040 --> 01:11:22,080
here but you have contributed then

1933
01:11:20,560 --> 01:11:23,840
anyway thank you so much for for doing

1934
01:11:22,080 --> 01:11:25,360
this this is really really critical and

1935
01:11:23,840 --> 01:11:27,120
with this I want to thank everybody that

1936
01:11:25,360 --> 01:11:30,440
helped make this work possible and yeah

1937
01:11:27,120 --> 01:11:30,440
thank you for listening

1938
01:11:36,719 --> 01:11:41,840
let's see if it's working now yes it is

1939
01:11:39,280 --> 01:11:41,840
any questions

1940
01:11:45,199 --> 01:11:51,440
A wonderful talk. I really love seeing

1941
01:11:47,920 --> 01:11:53,199
all the tools your lab's creating and um

1942
01:11:51,440 --> 01:11:55,120
it's become apparent to me that you know

1943
01:11:53,199 --> 01:11:58,640
so many of these tools are depending on

1944
01:11:55,120 --> 01:12:02,800
the fold seek 3DI alphabet. And I think

1945
01:11:58,640 --> 01:12:05,520
from the primer we we sort of got a um

1946
01:12:02,800 --> 01:12:10,320
an understanding of why it's 20 because

1947
01:12:05,520 --> 01:12:12,480
it it feeds directly into MMX 2. Um, so

1948
01:12:10,320 --> 01:12:15,199
that was sort of a logical choice I

1949
01:12:12,480 --> 01:12:17,199
think technically. Um, I'm just curious

1950
01:12:15,199 --> 01:12:19,600
to know if you and others are thinking

1951
01:12:17,199 --> 01:12:22,320
about that choice and how that's

1952
01:12:19,600 --> 01:12:25,199
impacting all these future tools that we

1953
01:12:22,320 --> 01:12:27,440
sort of kept it at uh 20 for the

1954
01:12:25,199 --> 01:12:31,040
alphabet size. Is that a problem with

1955
01:12:27,440 --> 01:12:34,080
the coarseness of those um of that

1956
01:12:31,040 --> 01:12:36,159
alphabet or you know should we go for um

1957
01:12:34,080 --> 01:12:37,679
a more descriptive alphabet?

1958
01:12:36,159 --> 01:12:40,000
>> I think it really depends on the use

1959
01:12:37,679 --> 01:12:41,520
case. So if you want to use an alphabet

1960
01:12:40,000 --> 01:12:42,719
to reconstruct a structure from it, you

1961
01:12:41,520 --> 01:12:44,640
know, you want to really have something

1962
01:12:42,719 --> 01:12:46,400
that contains a lot of information, then

1963
01:12:44,640 --> 01:12:48,560
our alphabet isn't great. So you would

1964
01:12:46,400 --> 01:12:50,560
not be able to use the 3D string and

1965
01:12:48,560 --> 01:12:52,480
then go back to cartisians and you would

1966
01:12:50,560 --> 01:12:56,320
lose quite a lot. For us, this

1967
01:12:52,480 --> 01:12:58,320
representation um was useful in that

1968
01:12:56,320 --> 01:13:00,560
coarse crane level because in the end it

1969
01:12:58,320 --> 01:13:02,560
it captures enough for the alignments to

1970
01:13:00,560 --> 01:13:04,159
find the folds that we want to find. And

1971
01:13:02,560 --> 01:13:06,719
and yeah, as you mentioned, 20 is nice

1972
01:13:04,159 --> 01:13:08,560
for MM6. And in the evalation studies,

1973
01:13:06,719 --> 01:13:10,320
we showed that with 24, you're a bit

1974
01:13:08,560 --> 01:13:12,560
better. If you go higher, you don't you

1975
01:13:10,320 --> 01:13:14,080
don't gain very much anymore. Um but

1976
01:13:12,560 --> 01:13:15,679
there is more to gain. So you can

1977
01:13:14,080 --> 01:13:17,360
probably do a better alignment if you

1978
01:13:15,679 --> 01:13:18,560
would not just have one structural

1979
01:13:17,360 --> 01:13:21,199
alphabet, but multiple structural

1980
01:13:18,560 --> 01:13:23,120
alphabets. And we also have um

1981
01:13:21,199 --> 01:13:25,520
Johannes's group has work on a

1982
01:13:23,120 --> 01:13:27,120
complimentary 3DI alphabet that takes

1983
01:13:25,520 --> 01:13:28,719
this virtual center and just places it

1984
01:13:27,120 --> 01:13:30,000
in the other direction kind of and um

1985
01:13:28,719 --> 01:13:31,280
optimize it to be maximally

1986
01:13:30,000 --> 01:13:33,120
complimentary and you can just stack

1987
01:13:31,280 --> 01:13:36,080
these two alphabets together and you

1988
01:13:33,120 --> 01:13:38,400
would get a better alignment out. Um so

1989
01:13:36,080 --> 01:13:42,719
yeah there is a lot you can consider for

1990
01:13:38,400 --> 01:13:44,480
these alphabets. Um but I think yeah

1991
01:13:42,719 --> 01:13:45,920
for us for the alignment purpose you can

1992
01:13:44,480 --> 01:13:47,280
just not really use a really high

1993
01:13:45,920 --> 01:13:48,960
dimensional one right that's definitely

1994
01:13:47,280 --> 01:13:50,000
a problem. Um, so we need to be somehow

1995
01:13:48,960 --> 01:13:51,120
low dimensional otherwise our

1996
01:13:50,000 --> 01:13:53,440
substitution matrix would not be

1997
01:13:51,120 --> 01:13:55,120
trainable and so on. So yeah, I think

1998
01:13:53,440 --> 01:13:56,640
that trade-off that we have made is a

1999
01:13:55,120 --> 01:13:58,480
good technical trade-off, right? It's

2000
01:13:56,640 --> 01:14:00,000
not obviously the best solution and it's

2001
01:13:58,480 --> 01:14:02,480
probably like best from the perspective

2002
01:14:00,000 --> 01:14:04,880
of like finding more um um structures,

2003
01:14:02,480 --> 01:14:06,640
but um it was good enough or I think it

2004
01:14:04,880 --> 01:14:10,080
is good enough to find the majority that

2005
01:14:06,640 --> 01:14:11,840
you care about. Yeah. And I just wanted

2006
01:14:10,080 --> 01:14:14,400
to ask a question about your uh your

2007
01:14:11,840 --> 01:14:16,080
clustering. Whether you think whether

2008
01:14:14,400 --> 01:14:18,239
you think you could infer whether

2009
01:14:16,080 --> 01:14:21,360
something was a product of convergent or

2010
01:14:18,239 --> 01:14:23,280
divergent evolution and whether your own

2011
01:14:21,360 --> 01:14:24,480
system biases toward divergent

2012
01:14:23,280 --> 01:14:27,600
evolution.

2013
01:14:24,480 --> 01:14:29,520
>> Yeah, it's I get this question a lot and

2014
01:14:27,600 --> 01:14:31,280
I never have like an amazing answer um

2015
01:14:29,520 --> 01:14:33,360
because I don't even know how to really

2016
01:14:31,280 --> 01:14:34,719
know if it's convergent or not. It's um

2017
01:14:33,360 --> 01:14:38,560
how would you measure that? It's a bit

2018
01:14:34,719 --> 01:14:40,400
hard. There is one database um from from

2019
01:14:38,560 --> 01:14:44,159
Nick Gishian's group um I think it's

2020
01:14:40,400 --> 01:14:47,360
called Mali Malisam Mali um I forgot the

2021
01:14:44,159 --> 01:14:48,640
exact name but they um handcreated some

2022
01:14:47,360 --> 01:14:50,640
cases where they really believe these

2023
01:14:48,640 --> 01:14:51,840
are convergent evolution cases. You can

2024
01:14:50,640 --> 01:14:53,440
actually look at the structures you can

2025
01:14:51,840 --> 01:14:54,719
see they are somehow super poseable. So

2026
01:14:53,440 --> 01:14:56,480
if you put them over each other you

2027
01:14:54,719 --> 01:14:59,040
would probably see that they look

2028
01:14:56,480 --> 01:15:01,440
somehow similar but the sheets are

2029
01:14:59,040 --> 01:15:03,280
shifted you know and and and sometimes

2030
01:15:01,440 --> 01:15:05,440
the other direction and and so on. So

2031
01:15:03,280 --> 01:15:06,560
it's there are differences and if we

2032
01:15:05,440 --> 01:15:08,400
cluster that with our clustering

2033
01:15:06,560 --> 01:15:10,640
algorithm we cluster zero. So we don't

2034
01:15:08,400 --> 01:15:12,560
cluster them together at all. So I would

2035
01:15:10,640 --> 01:15:14,480
rather indicate that I would this would

2036
01:15:12,560 --> 01:15:16,719
indicate that we have probably more

2037
01:15:14,480 --> 01:15:18,320
non-convergent cases in these clusters

2038
01:15:16,719 --> 01:15:19,840
than we have convergent cases in the

2039
01:15:18,320 --> 01:15:21,440
cluster. Yeah.

2040
01:15:19,840 --> 01:15:22,960
>> So there might be a bias.

2041
01:15:21,440 --> 01:15:24,640
>> Yeah. Yeah. There might be a bias there.

2042
01:15:22,960 --> 01:15:26,080
Yeah. You need probably to find these

2043
01:15:24,640 --> 01:15:27,679
convergent cases, you probably probably

2044
01:15:26,080 --> 01:15:30,000
want something that is like superposing

2045
01:15:27,679 --> 01:15:32,560
really strongly, right? because the it's

2046
01:15:30,000 --> 01:15:34,800
hard to align because the 3DI alphabet

2047
01:15:32,560 --> 01:15:36,719
will be quite screwed if you start

2048
01:15:34,800 --> 01:15:39,600
turning the sheets completely around or

2049
01:15:36,719 --> 01:15:41,440
do something quite um aggressive to the

2050
01:15:39,600 --> 01:15:42,560
to the structure somehow. And so you

2051
01:15:41,440 --> 01:15:44,719
would probably need a different type of

2052
01:15:42,560 --> 01:15:45,840
algorithm to really um align these um

2053
01:15:44,719 --> 01:15:48,000
cases. Then yeah

2054
01:15:45,840 --> 01:15:50,400
>> subcluster the cluster

2055
01:15:48,000 --> 01:15:51,760
>> subclusters to clusters. Um yeah

2056
01:15:50,400 --> 01:15:53,120
something like that I guess you could do

2057
01:15:51,760 --> 01:15:55,120
with some other method for example then

2058
01:15:53,120 --> 01:15:56,880
and see if you can do it. Also in Fzig

2059
01:15:55,120 --> 01:15:58,960
we have TML line as a module in it

2060
01:15:56,880 --> 01:16:00,960
right? So you could say you just first

2061
01:15:58,960 --> 01:16:03,840
try find somehow some similarities in a

2062
01:16:00,960 --> 01:16:06,000
fast way and use TML line to try to find

2063
01:16:03,840 --> 01:16:07,760
some convergent cases but then once you

2064
01:16:06,000 --> 01:16:09,600
have it how do you really show that it

2065
01:16:07,760 --> 01:16:12,000
is that's another problem and I don't

2066
01:16:09,600 --> 01:16:13,920
know I have no no strong feeling how to

2067
01:16:12,000 --> 01:16:15,440
make like a really objective measure of

2068
01:16:13,920 --> 01:16:18,000
this is really convergent or this isn't

2069
01:16:15,440 --> 01:16:20,480
really convergent. Yeah,

2070
01:16:18,000 --> 01:16:23,840
>> maybe one last question from the chat.

2071
01:16:20,480 --> 01:16:25,520
Um, Anthony asked, "Alpha 3 seems to

2072
01:16:23,840 --> 01:16:28,000
reduce the importance of the

2073
01:16:25,520 --> 01:16:30,480
multisequence alignment as there is no

2074
01:16:28,000 --> 01:16:32,560
dedicated specific attention block for

2075
01:16:30,480 --> 01:16:34,960
the alignments. Do you think this

2076
01:16:32,560 --> 01:16:36,560
changes the cases when collab fold is

2077
01:16:34,960 --> 01:16:38,640
beneficial?

2078
01:16:36,560 --> 01:16:40,239
>> Alphault 3 has still has the MSA block."

2079
01:16:38,640 --> 01:16:43,280
So they it still has it. So what they

2080
01:16:40,239 --> 01:16:45,199
have done is the the alpha 2 model has

2081
01:16:43,280 --> 01:16:46,880
uh an MSA block then a performer block

2082
01:16:45,199 --> 01:16:48,800
an MSA block a parapformer block and

2083
01:16:46,880 --> 01:16:50,480
they're somehow talking to each other.

2084
01:16:48,800 --> 01:16:53,120
So that's how the network architecture

2085
01:16:50,480 --> 01:16:54,719
of alpha 2 is. Alpha 3 took these MSA

2086
01:16:53,120 --> 01:16:56,640
blocks and it moves it in the beginning.

2087
01:16:54,719 --> 01:16:58,880
So you have four blocks for extracting

2088
01:16:56,640 --> 01:17:01,840
MSA information and then you have 48

2089
01:16:58,880 --> 01:17:03,360
blocks of pair pair representation. So

2090
01:17:01,840 --> 01:17:05,280
they still extracting knowledge from the

2091
01:17:03,360 --> 01:17:07,920
MSA. So I don't think you lose the

2092
01:17:05,280 --> 01:17:10,960
dependency on the MSA um completely.

2093
01:17:07,920 --> 01:17:13,120
they changed even the MSA block to allow

2094
01:17:10,960 --> 01:17:15,280
more sequences to be in the to be

2095
01:17:13,120 --> 01:17:16,719
considered in the MSA block. So they

2096
01:17:15,280 --> 01:17:19,199
they want to actually extract more

2097
01:17:16,719 --> 01:17:22,560
knowledge from bigger MSA. So I don't

2098
01:17:19,199 --> 01:17:24,719
think it makes MSAs obsolete in any way.

2099
01:17:22,560 --> 01:17:27,280
>> Thank you so much Martin and Suang. This

2100
01:17:24,719 --> 01:17:31,880
was fantastic, very instructive and

2101
01:17:27,280 --> 01:17:31,880
thank you all for joining today.

