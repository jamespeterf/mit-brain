1
00:00:05,359 --> 00:00:12,800
Okay, continuing with this segment, our

2
00:00:08,320 --> 00:00:16,400
next speaker will uh be Armando Solar

3
00:00:12,800 --> 00:00:19,199
Lzama. He is a distinguished professor

4
00:00:16,400 --> 00:00:21,840
at the Schwarzman College of Computing

5
00:00:19,199 --> 00:00:24,480
and also the chief operating officer of

6
00:00:21,840 --> 00:00:27,359
the computer science and AI lab, CESAL,

7
00:00:24,480 --> 00:00:31,039
at MIT. Armando is going to speak to you

8
00:00:27,359 --> 00:00:33,440
about how AI is transforming uh so

9
00:00:31,039 --> 00:00:35,600
software engineering. Thank you. Thanks

10
00:00:33,440 --> 00:00:35,600
a

11
00:00:36,810 --> 00:00:40,719
[Music]

12
00:00:37,960 --> 00:00:44,719
lot. Very glad to uh very glad to be

13
00:00:40,719 --> 00:00:46,320
here. And in my research lab and uh you

14
00:00:44,719 --> 00:00:47,239
know generally myself we have been

15
00:00:46,320 --> 00:00:50,239
working

16
00:00:47,239 --> 00:00:53,920
for about 20 years now on this problem

17
00:00:50,239 --> 00:00:55,440
of how to bring more automation into

18
00:00:53,920 --> 00:00:57,360
software construction. and how to

19
00:00:55,440 --> 00:00:59,840
leverage computing power to help people

20
00:00:57,360 --> 00:01:02,960
deal with tricky problems that arise

21
00:00:59,840 --> 00:01:04,720
when you're writing uh software. And I

22
00:01:02,960 --> 00:01:07,040
have to say it's been quite a ride. Uh

23
00:01:04,720 --> 00:01:09,520
when we started working in this area,

24
00:01:07,040 --> 00:01:11,439
the dominant question was why are you

25
00:01:09,520 --> 00:01:13,760
working on this? This is never going to

26
00:01:11,439 --> 00:01:15,600
work. It's too hard. You need too much

27
00:01:13,760 --> 00:01:17,600
cleverness to write software. How is a

28
00:01:15,600 --> 00:01:19,840
machine going to help you? And suddenly

29
00:01:17,600 --> 00:01:22,560
about three years ago, it switched very

30
00:01:19,840 --> 00:01:24,560
abruptly to why are you working this on

31
00:01:22,560 --> 00:01:25,840
this? This is a solved problem. uh

32
00:01:24,560 --> 00:01:29,119
there's already all these companies

33
00:01:25,840 --> 00:01:32,960
doing this. Um there is really no need

34
00:01:29,119 --> 00:01:34,479
to uh uh to be doing this in in academia

35
00:01:32,960 --> 00:01:36,640
and it certainly has been quite a

36
00:01:34,479 --> 00:01:38,799
change. You know the very first paper we

37
00:01:36,640 --> 00:01:40,640
published in this topic uh you know

38
00:01:38,799 --> 00:01:43,040
trying to get machines to help us write

39
00:01:40,640 --> 00:01:44,799
programs. A running example was well

40
00:01:43,040 --> 00:01:47,040
what if you want to drop every third bit

41
00:01:44,799 --> 00:01:49,759
of a stream of bits which is you know

42
00:01:47,040 --> 00:01:52,479
not the most ambitious of targets but at

43
00:01:49,759 --> 00:01:54,960
least it worked. uh to today where

44
00:01:52,479 --> 00:01:57,040
people are actually seriously wondering

45
00:01:54,960 --> 00:01:59,119
do we actually need to learn how to

46
00:01:57,040 --> 00:02:02,960
program? Does anybody need to learn how

47
00:01:59,119 --> 00:02:06,640
to program? Um are we just about to make

48
00:02:02,960 --> 00:02:10,360
programmers obsolete? Right? And um we

49
00:02:06,640 --> 00:02:13,040
have this enormous gamut of production

50
00:02:10,360 --> 00:02:16,080
quality fully deployed tools and

51
00:02:13,040 --> 00:02:18,720
widespread use across industry. And it

52
00:02:16,080 --> 00:02:22,879
raises the question so what is there

53
00:02:18,720 --> 00:02:25,760
left to do for academic research in in

54
00:02:22,879 --> 00:02:27,760
this uh in this space. So this is a

55
00:02:25,760 --> 00:02:30,959
question that we've been fielding a lot

56
00:02:27,760 --> 00:02:34,400
in the last few years and as it happens

57
00:02:30,959 --> 00:02:37,920
uh just last week we released um a

58
00:02:34,400 --> 00:02:39,920
report on the challenges and paths

59
00:02:37,920 --> 00:02:42,720
towards AI and software engineering. try

60
00:02:39,920 --> 00:02:44,319
to give a summary about what are some of

61
00:02:42,720 --> 00:02:47,040
these open problems and what are some of

62
00:02:44,319 --> 00:02:50,160
these directions where current tools and

63
00:02:47,040 --> 00:02:52,959
current models still have problems. Why

64
00:02:50,160 --> 00:02:55,280
do you still need uh humans helping you

65
00:02:52,959 --> 00:02:57,440
write uh helping you write software? If

66
00:02:55,280 --> 00:03:01,280
you're interested uh definitely a lot

67
00:02:57,440 --> 00:03:02,760
more detail there than in the 18minute

68
00:03:01,280 --> 00:03:05,680
talk,

69
00:03:02,760 --> 00:03:08,720
but very broadly speaking, what are some

70
00:03:05,680 --> 00:03:10,959
of these uh open challenges? One really

71
00:03:08,720 --> 00:03:12,560
important one comes with out of

72
00:03:10,959 --> 00:03:15,040
distribution domains. What does that

73
00:03:12,560 --> 00:03:17,760
mean? Uh programming that doesn't look

74
00:03:15,040 --> 00:03:21,040
like the bulk of code that you can find

75
00:03:17,760 --> 00:03:23,599
in GitHub or you know out on the

76
00:03:21,040 --> 00:03:25,120
internet in general, right? Turns out

77
00:03:23,599 --> 00:03:27,840
everybody's code looks different

78
00:03:25,120 --> 00:03:31,120
especially when you go inside companies

79
00:03:27,840 --> 00:03:33,360
that uh you know as a rule tend not to

80
00:03:31,120 --> 00:03:35,360
like to uh open source all the code

81
00:03:33,360 --> 00:03:37,200
they're writing. You know, oftentimes

82
00:03:35,360 --> 00:03:39,360
you end up with code that looks very

83
00:03:37,200 --> 00:03:42,080
different from the code that these

84
00:03:39,360 --> 00:03:44,400
models have been trained on. Program

85
00:03:42,080 --> 00:03:48,720
understanding especially at scale turns

86
00:03:44,400 --> 00:03:50,720
out to be quite u quite a challenge. Uh

87
00:03:48,720 --> 00:03:54,560
these models have become quite good at

88
00:03:50,720 --> 00:03:57,599
reasoning about code locally. And uh in

89
00:03:54,560 --> 00:03:59,920
fact uh just two years ago we released a

90
00:03:57,599 --> 00:04:02,400
benchmark showing that models were

91
00:03:59,920 --> 00:04:05,280
really not very good at reasoning about

92
00:04:02,400 --> 00:04:07,519
the behavior even of small fragments of

93
00:04:05,280 --> 00:04:10,000
code and basically it took a few more

94
00:04:07,519 --> 00:04:12,000
months for industry to catch up and

95
00:04:10,000 --> 00:04:16,239
actually um essentially make this

96
00:04:12,000 --> 00:04:19,199
benchmark obsolete. Um but when it comes

97
00:04:16,239 --> 00:04:21,880
to uh reasoning about software at scale

98
00:04:19,199 --> 00:04:24,400
that is still very much an open uh

99
00:04:21,880 --> 00:04:26,560
problem. Similarly along that vein is

100
00:04:24,400 --> 00:04:28,800
this question of software design. Right?

101
00:04:26,560 --> 00:04:31,840
Software is often designed with a wide

102
00:04:28,800 --> 00:04:34,800
range of goals. Not just does it produce

103
00:04:31,840 --> 00:04:36,960
a right answer uh but keeping in mind

104
00:04:34,800 --> 00:04:40,320
how you expect the code to evolve

105
00:04:36,960 --> 00:04:42,400
possibly over decades into the future.

106
00:04:40,320 --> 00:04:44,639
And good software design is something

107
00:04:42,400 --> 00:04:46,160
that is really critical for good

108
00:04:44,639 --> 00:04:50,560
software engineering. It's something

109
00:04:46,160 --> 00:04:53,840
that uh is uh is not uh specifically one

110
00:04:50,560 --> 00:04:55,680
of the goals for many of these uh many

111
00:04:53,840 --> 00:04:58,320
of these tools. Similarly, when it comes

112
00:04:55,680 --> 00:05:00,720
to reusing code, there's a very basic

113
00:04:58,320 --> 00:05:03,840
mode of reuse where you have a function

114
00:05:00,720 --> 00:05:06,240
that does X and somewhere else you need

115
00:05:03,840 --> 00:05:07,919
to do X and the model tells you, yep,

116
00:05:06,240 --> 00:05:10,479
here's the function that does X. That's

117
00:05:07,919 --> 00:05:12,320
the simple case of reuse. But the real

118
00:05:10,479 --> 00:05:15,039
sophisticated case of reuse, the kind of

119
00:05:12,320 --> 00:05:17,639
reuse that you would expect from a

120
00:05:15,039 --> 00:05:20,320
skilled programmer is the kind of reuse

121
00:05:17,639 --> 00:05:22,240
where you know that this new

122
00:05:20,320 --> 00:05:26,560
functionality that you try to implement

123
00:05:22,240 --> 00:05:28,560
can be um assembled by you know taking

124
00:05:26,560 --> 00:05:29,840
this little bit of code here that was

125
00:05:28,560 --> 00:05:31,680
actually written for a completely

126
00:05:29,840 --> 00:05:33,759
different purpose and this other little

127
00:05:31,680 --> 00:05:35,759
bit of code over there that was written

128
00:05:33,759 --> 00:05:37,280
for a completely different purpose. And

129
00:05:35,759 --> 00:05:39,840
that if you take this routine over here

130
00:05:37,280 --> 00:05:41,280
and you generalize it in just the right

131
00:05:39,840 --> 00:05:43,520
way, then you can bring all of those

132
00:05:41,280 --> 00:05:45,360
together and get your new functionality

133
00:05:43,520 --> 00:05:47,360
writing very little code. Right? That's

134
00:05:45,360 --> 00:05:50,000
the kind of sophisticated reuse and

135
00:05:47,360 --> 00:05:53,120
sophisticated reasoning that is really

136
00:05:50,000 --> 00:05:55,680
today still beyond the scope of many of

137
00:05:53,120 --> 00:05:58,800
these tools. And the big one and really

138
00:05:55,680 --> 00:06:01,039
the crucial one is the specification

139
00:05:58,800 --> 00:06:03,919
challenge. How in the world do you

140
00:06:01,039 --> 00:06:07,039
actually tell the machine what it is

141
00:06:03,919 --> 00:06:08,319
that you're trying to uh what it is that

142
00:06:07,039 --> 00:06:13,039
you're trying to do? What is this

143
00:06:08,319 --> 00:06:15,600
software supposed to uh to do? And um

144
00:06:13,039 --> 00:06:18,960
you know it is a little bit of common

145
00:06:15,600 --> 00:06:21,360
knowledge in uh you know the broader

146
00:06:18,960 --> 00:06:24,080
community that everything changed with

147
00:06:21,360 --> 00:06:26,880
the advent of LLMs. There is very

148
00:06:24,080 --> 00:06:30,000
clearly a before and after in the world

149
00:06:26,880 --> 00:06:32,400
of program synthesis and uh machine

150
00:06:30,000 --> 00:06:35,440
learning for software engineering right

151
00:06:32,400 --> 00:06:37,520
when uh you know GPT3 came out and it

152
00:06:35,440 --> 00:06:40,240
became very clear that this was going to

153
00:06:37,520 --> 00:06:42,560
be a very powerful technology for

154
00:06:40,240 --> 00:06:44,880
working with code but there's actually a

155
00:06:42,560 --> 00:06:47,840
lot of really compelling ideas that come

156
00:06:44,880 --> 00:06:49,919
from the research community even before

157
00:06:47,840 --> 00:06:53,680
then that still have a lot of relevance

158
00:06:49,919 --> 00:06:57,120
in this period for example Um, you know,

159
00:06:53,680 --> 00:07:00,000
back in 2017, we were actually working

160
00:06:57,120 --> 00:07:03,120
on this problem of how do you deal with

161
00:07:00,000 --> 00:07:05,599
code that has complex functionality

162
00:07:03,120 --> 00:07:08,400
where it might actually be difficult to

163
00:07:05,599 --> 00:07:10,720
describe exactly what you want it to to

164
00:07:08,400 --> 00:07:12,880
do, right? And you know, today we live

165
00:07:10,720 --> 00:07:14,319
in a world where there's lots of code

166
00:07:12,880 --> 00:07:17,120
out there, lots of code that is ready

167
00:07:14,319 --> 00:07:19,280
for you to reuse it. uh so that you can

168
00:07:17,120 --> 00:07:22,319
implement very rich functionality

169
00:07:19,280 --> 00:07:25,919
without actually having to write a lot

170
00:07:22,319 --> 00:07:28,479
of code. Uh and this is great until you

171
00:07:25,919 --> 00:07:30,479
actually try to find this code and then

172
00:07:28,479 --> 00:07:34,240
until you actually try to go and figure

173
00:07:30,479 --> 00:07:36,080
out how to reuse it and when you

174
00:07:34,240 --> 00:07:38,160
actually realize that it kind of almost

175
00:07:36,080 --> 00:07:40,720
does what you want but not uh not

176
00:07:38,160 --> 00:07:42,720
really. And when you're dealing with

177
00:07:40,720 --> 00:07:45,360
relatively complicated functionality

178
00:07:42,720 --> 00:07:47,759
that can be hard to describe, you know,

179
00:07:45,360 --> 00:07:50,000
today we can use natural language. But

180
00:07:47,759 --> 00:07:53,199
even natural language is not often

181
00:07:50,000 --> 00:07:55,759
sufficient to convey what uh what we

182
00:07:53,199 --> 00:07:57,759
want. Uh uh you know as a simple example

183
00:07:55,759 --> 00:07:59,599
we used the case where we had a code

184
00:07:57,759 --> 00:08:02,440
editor and this code editor had this

185
00:07:59,599 --> 00:08:07,120
plug-in system that allowed you

186
00:08:02,440 --> 00:08:09,360
to do very simple uh with very little

187
00:08:07,120 --> 00:08:12,080
extra code uh implement things like

188
00:08:09,360 --> 00:08:13,520
syntax highlighting for new languages,

189
00:08:12,080 --> 00:08:15,599
new programming languages that you

190
00:08:13,520 --> 00:08:17,759
created, right? Very powerful uh

191
00:08:15,599 --> 00:08:22,319
framework, very powerful functionality

192
00:08:17,759 --> 00:08:26,479
until you actually try to uh reuse it.

193
00:08:22,319 --> 00:08:29,599
And so what we found was that well uh

194
00:08:26,479 --> 00:08:32,159
something as simple as I want to reuse

195
00:08:29,599 --> 00:08:35,200
uh the syntax highlighting functionality

196
00:08:32,159 --> 00:08:36,719
requires you to know that there's

197
00:08:35,200 --> 00:08:38,880
something called the rulebased scanner

198
00:08:36,719 --> 00:08:40,880
that you have to extend with your own

199
00:08:38,880 --> 00:08:43,360
scanner. But then you have to go to

200
00:08:40,880 --> 00:08:45,279
something called the source viewer

201
00:08:43,360 --> 00:08:48,000
configuration and override it with your

202
00:08:45,279 --> 00:08:50,080
own source viewer configuration that

203
00:08:48,000 --> 00:08:52,399
internally has to instantiate something

204
00:08:50,080 --> 00:08:53,680
called a presentation reconciler.

205
00:08:52,399 --> 00:08:55,600
There's actually something called a

206
00:08:53,680 --> 00:08:57,360
damage repairer. And suddenly you're

207
00:08:55,600 --> 00:09:00,080
wondering like what do these things have

208
00:08:57,360 --> 00:09:04,560
to do with the syntax highlighting,

209
00:09:00,080 --> 00:09:06,399
right? Um it's uh it turns out that the

210
00:09:04,560 --> 00:09:09,200
whole framework has its own internal

211
00:09:06,399 --> 00:09:11,040
language and its own internal logic and

212
00:09:09,200 --> 00:09:12,720
once you understand the logic everything

213
00:09:11,040 --> 00:09:14,320
makes perfect sense. For example, in

214
00:09:12,720 --> 00:09:17,600
this case the editor has this view of

215
00:09:14,320 --> 00:09:20,880
the world where there's a very nice data

216
00:09:17,600 --> 00:09:23,440
structure that reflects the state of the

217
00:09:20,880 --> 00:09:25,360
code. Every time you type new code,

218
00:09:23,440 --> 00:09:28,080
you're damaging the relationship between

219
00:09:25,360 --> 00:09:30,320
the view and the data structure. So you

220
00:09:28,080 --> 00:09:32,399
have to repair that damage to

221
00:09:30,320 --> 00:09:34,160
rehighlight things. Oh, okay. That makes

222
00:09:32,399 --> 00:09:35,519
sense. If you didn't know that before,

223
00:09:34,160 --> 00:09:36,880
how would you know that? How would you

224
00:09:35,519 --> 00:09:39,120
know what to search? How would you know

225
00:09:36,880 --> 00:09:40,640
what the right uh keywords are? How

226
00:09:39,120 --> 00:09:42,959
would you know what the right classes

227
00:09:40,640 --> 00:09:45,519
are? And it goes back to this problem of

228
00:09:42,959 --> 00:09:48,640
yes, all the code is there. How do you

229
00:09:45,519 --> 00:09:50,399
find it? Right? And LLMs are supposed to

230
00:09:48,640 --> 00:09:53,680
be the solution to this. You can go and

231
00:09:50,399 --> 00:09:56,000
describe what it is that you want to do.

232
00:09:53,680 --> 00:09:57,839
And you know out comes a very nice

233
00:09:56,000 --> 00:09:59,920
tutorial together with all the code

234
00:09:57,839 --> 00:10:04,399
together with all the information that

235
00:09:59,920 --> 00:10:06,240
you need about how to uh how to do this.

236
00:10:04,399 --> 00:10:08,080
Uh you know sort of because it's a lot

237
00:10:06,240 --> 00:10:10,000
of code and very quickly you run out of

238
00:10:08,080 --> 00:10:14,640
buffer space and it cuts off in the

239
00:10:10,000 --> 00:10:16,880
middle. Um, but even more problematic,

240
00:10:14,640 --> 00:10:19,200
you still have to have a very specific

241
00:10:16,880 --> 00:10:21,640
prompt describing very precisely what

242
00:10:19,200 --> 00:10:24,880
you want, using the right uh class

243
00:10:21,640 --> 00:10:27,200
names. And you know, here we're talking

244
00:10:24,880 --> 00:10:29,040
about a very well doumented API. This

245
00:10:27,200 --> 00:10:30,959
was a framework that lots of people

246
00:10:29,040 --> 00:10:33,200
used. There were blog posts. There were

247
00:10:30,959 --> 00:10:35,040
tutorials. It's an ideal case scenario

248
00:10:33,200 --> 00:10:37,200
for this kind of tool, right? What

249
00:10:35,040 --> 00:10:41,440
happens when you have to do the same

250
00:10:37,200 --> 00:10:44,240
thing but for your internal company API

251
00:10:41,440 --> 00:10:46,959
that suddenly doesn't have all of these

252
00:10:44,240 --> 00:10:49,760
uh resources. Turns out API versions

253
00:10:46,959 --> 00:10:52,959
turn out also to be a huge problem for

254
00:10:49,760 --> 00:10:55,040
this. uh if the API has gone through

255
00:10:52,959 --> 00:10:58,480
five different versions as most widely

256
00:10:55,040 --> 00:11:00,560
used APIs uh have then suddenly you're

257
00:10:58,480 --> 00:11:02,240
going to get some mishmash of pieces

258
00:11:00,560 --> 00:11:05,519
that work with one version and pieces

259
00:11:02,240 --> 00:11:08,079
that work with another version. And uh

260
00:11:05,519 --> 00:11:10,480
this actually turns out to be quite uh

261
00:11:08,079 --> 00:11:13,839
problematic. But more importantly, there

262
00:11:10,480 --> 00:11:16,560
is this highle problem of how do you

263
00:11:13,839 --> 00:11:18,240
tell the system what it is that you want

264
00:11:16,560 --> 00:11:20,959
to do if you don't even know what is the

265
00:11:18,240 --> 00:11:25,360
internal language that it uses in order

266
00:11:20,959 --> 00:11:27,600
to do this. So one of the ideas that we

267
00:11:25,360 --> 00:11:30,959
uh we actually experimented with was

268
00:11:27,600 --> 00:11:34,480
allowing you to just take another system

269
00:11:30,959 --> 00:11:36,399
that was built using this framework and

270
00:11:34,480 --> 00:11:37,760
just start working with it. And at some

271
00:11:36,399 --> 00:11:39,040
point you get to the functionality that

272
00:11:37,760 --> 00:11:40,959
you like and you press a button that

273
00:11:39,040 --> 00:11:42,560
says, "Hey, I'm about to show you

274
00:11:40,959 --> 00:11:44,640
something. I'm about to show you the

275
00:11:42,560 --> 00:11:47,360
thing that I want." And you can go and

276
00:11:44,640 --> 00:11:49,519
exercise these functionality and then

277
00:11:47,360 --> 00:11:51,040
press another button and say there, you

278
00:11:49,519 --> 00:11:53,040
know, that thing that just happened,

279
00:11:51,040 --> 00:11:56,079
that thing you just saw, that's what I

280
00:11:53,040 --> 00:12:00,160
want you to figure out and tell me what

281
00:11:56,079 --> 00:12:02,040
to do, right? And that turns out it

282
00:12:00,160 --> 00:12:04,880
requires this very different way of

283
00:12:02,040 --> 00:12:08,399
interacting with the system, right? for

284
00:12:04,880 --> 00:12:10,399
those kind of situations where using uh

285
00:12:08,399 --> 00:12:12,320
just natural language is not enough. You

286
00:12:10,399 --> 00:12:14,160
really want to be able to give those

287
00:12:12,320 --> 00:12:16,160
live demonstrations. You really want to

288
00:12:14,160 --> 00:12:19,040
be able to show look the functionality

289
00:12:16,160 --> 00:12:22,320
that I want is like this one, but in

290
00:12:19,040 --> 00:12:24,320
this other uh context, but we're still

291
00:12:22,320 --> 00:12:30,000
at a very early stage in terms of being

292
00:12:24,320 --> 00:12:32,079
able to rely on these richer forms of uh

293
00:12:30,000 --> 00:12:33,920
feedback. And in fact, one of the things

294
00:12:32,079 --> 00:12:36,720
that becomes really essential to deal

295
00:12:33,920 --> 00:12:39,760
with that kind of a problem is having

296
00:12:36,720 --> 00:12:41,440
multimodal support through our language

297
00:12:39,760 --> 00:12:47,360
models. We're starting to see some of

298
00:12:41,440 --> 00:12:49,040
that in the uh uh frontier models today,

299
00:12:47,360 --> 00:12:52,000
but one of the problems that you've run

300
00:12:49,040 --> 00:12:53,920
into is that there's not a lot of really

301
00:12:52,000 --> 00:12:57,360
high quality data, especially when you

302
00:12:53,920 --> 00:13:01,440
go out towards the long tail of lesser

303
00:12:57,360 --> 00:13:03,760
used uh frameworks matching the actual

304
00:13:01,440 --> 00:13:05,600
code with the actual behavior, right?

305
00:13:03,760 --> 00:13:10,320
And this is an example for example from

306
00:13:05,600 --> 00:13:12,800
a project that um we just completed. Um

307
00:13:10,320 --> 00:13:16,399
this was uh really led by my colleague

308
00:13:12,800 --> 00:13:19,760
uh Voych Matusk uh and his students uh

309
00:13:16,399 --> 00:13:21,680
his student Bon uh Lee. But the idea of

310
00:13:19,760 --> 00:13:27,760
this project was that we wanted to

311
00:13:21,680 --> 00:13:29,760
target the kind of uh texture generation

312
00:13:27,760 --> 00:13:32,000
infrastructure that is used for things

313
00:13:29,760 --> 00:13:33,440
like video games, right? where

314
00:13:32,000 --> 00:13:35,200
essentially what you have is this little

315
00:13:33,440 --> 00:13:41,200
program that describes how to turn

316
00:13:35,200 --> 00:13:43,360
random noise into a nice um texture that

317
00:13:41,200 --> 00:13:45,519
uh that you can use to wrap your your

318
00:13:43,360 --> 00:13:49,200
shapes in in a video game, right? So, it

319
00:13:45,519 --> 00:13:51,120
turns out there are uh widely used tools

320
00:13:49,200 --> 00:13:53,839
that designers can use to design these

321
00:13:51,120 --> 00:13:57,760
kind of textures. And on top of these

322
00:13:53,839 --> 00:13:59,760
tools, there's also Python APIs. So you

323
00:13:57,760 --> 00:14:03,040
know as soon as there's a Python API you

324
00:13:59,760 --> 00:14:06,480
know that this is something where LLMs

325
00:14:03,040 --> 00:14:08,160
can can help you but what we really want

326
00:14:06,480 --> 00:14:10,079
is the following. We want to have a

327
00:14:08,160 --> 00:14:13,680
system where you can take a picture

328
00:14:10,079 --> 00:14:15,920
let's say of the carpet down here and

329
00:14:13,680 --> 00:14:19,440
from that picture you want to feed it to

330
00:14:15,920 --> 00:14:21,600
your language model and get out the code

331
00:14:19,440 --> 00:14:24,079
that when you run it is going to give

332
00:14:21,600 --> 00:14:25,760
you the equivalent texture. And often

333
00:14:24,079 --> 00:14:27,279
times, right on the first try, you're

334
00:14:25,760 --> 00:14:28,880
not going to get exactly the same

335
00:14:27,279 --> 00:14:31,040
texture. You're going have to do a

336
00:14:28,880 --> 00:14:33,800
little bit of local optimization in

337
00:14:31,040 --> 00:14:36,480
order to get really the right uh

338
00:14:33,800 --> 00:14:40,959
texture. But this is within the

339
00:14:36,480 --> 00:14:43,600
capabilities of modern LLMs except for

340
00:14:40,959 --> 00:14:45,680
the fact that even though they've seen

341
00:14:43,600 --> 00:14:47,360
some of these Python code, they haven't

342
00:14:45,680 --> 00:14:48,800
seen enough of it to really understand

343
00:14:47,360 --> 00:14:51,839
how it works. And in particular, they

344
00:14:48,800 --> 00:14:55,199
haven't seen enough data matching the

345
00:14:51,839 --> 00:14:56,959
code with the actual behavior that you

346
00:14:55,199 --> 00:15:02,560
want. Right? And this is where you

347
00:14:56,959 --> 00:15:05,839
really need uh to uh actually do some

348
00:15:02,560 --> 00:15:07,839
data augmentation. We actually had a uh

349
00:15:05,839 --> 00:15:11,760
a pretty sophisticated pipeline to

350
00:15:07,839 --> 00:15:14,399
generate uh about um half a million

351
00:15:11,760 --> 00:15:17,120
programs such that every one of these

352
00:15:14,399 --> 00:15:18,959
programs could be fed through a renderer

353
00:15:17,120 --> 00:15:21,040
to teach the model about the

354
00:15:18,959 --> 00:15:22,880
relationship between when the code looks

355
00:15:21,040 --> 00:15:25,519
like this. This is the kind of texture

356
00:15:22,880 --> 00:15:29,680
that that you get out. When you do that,

357
00:15:25,519 --> 00:15:31,600
you can actually get uh some pretty nice

358
00:15:29,680 --> 00:15:35,839
uh behaving system, right? These are

359
00:15:31,600 --> 00:15:39,279
some examples from some textures uh

360
00:15:35,839 --> 00:15:42,480
written in uh Blender comparing uh the

361
00:15:39,279 --> 00:15:45,199
input image with the

362
00:15:42,480 --> 00:15:48,079
uh image generated by the code produced

363
00:15:45,199 --> 00:15:50,079
by our system compared to a bunch of

364
00:15:48,079 --> 00:15:51,920
different uh baselines, right? And you

365
00:15:50,079 --> 00:15:54,880
can see that certainly most of the

366
00:15:51,920 --> 00:15:56,959
baselines uh you know even uh

367
00:15:54,880 --> 00:15:58,480
sophisticated frontier models just don't

368
00:15:56,959 --> 00:16:00,320
do a very good job again because they

369
00:15:58,480 --> 00:16:03,839
haven't really seen that relationship

370
00:16:00,320 --> 00:16:06,240
between the code and the behavior of

371
00:16:03,839 --> 00:16:09,759
that uh of that code. Right? Here's a

372
00:16:06,240 --> 00:16:12,880
few more examples from uh textures

373
00:16:09,759 --> 00:16:16,079
produced by different uh by a different

374
00:16:12,880 --> 00:16:20,000
framework. Here's actually some examples

375
00:16:16,079 --> 00:16:23,199
directly from pictures, right? uh actual

376
00:16:20,000 --> 00:16:26,320
pictures taken from a texture and what

377
00:16:23,199 --> 00:16:28,320
the model is able to uh to produce.

378
00:16:26,320 --> 00:16:30,639
Right? So on the one hand this shows

379
00:16:28,320 --> 00:16:33,720
that it is possible to bridge this gap

380
00:16:30,639 --> 00:16:38,240
between uh you know these different

381
00:16:33,720 --> 00:16:40,639
modalities of interaction and uh code

382
00:16:38,240 --> 00:16:43,680
and that uh you know fine-tuning a model

383
00:16:40,639 --> 00:16:47,440
that does this is within the reach of an

384
00:16:43,680 --> 00:16:51,279
academic uh lab like uh like ours,

385
00:16:47,440 --> 00:16:53,360
right? Um on the other hand it uh it

386
00:16:51,279 --> 00:16:57,040
also highlights some of the limitations

387
00:16:53,360 --> 00:16:59,440
of you know just business as usual. So

388
00:16:57,040 --> 00:17:02,160
where do we see things going forward? On

389
00:16:59,440 --> 00:17:04,400
the one hand I think programming tools

390
00:17:02,160 --> 00:17:06,640
will become more and more essential

391
00:17:04,400 --> 00:17:08,640
right to the days where you could be

392
00:17:06,640 --> 00:17:12,640
competitive as a programmer just writing

393
00:17:08,640 --> 00:17:14,640
code in VI with absolutely no tool

394
00:17:12,640 --> 00:17:18,559
support beyond your compiler or

395
00:17:14,640 --> 00:17:21,360
interpreter. I think might uh be

396
00:17:18,559 --> 00:17:24,079
reaching uh their limit. On the other

397
00:17:21,360 --> 00:17:26,000
hand, there is still and we believe for

398
00:17:24,079 --> 00:17:29,360
a very long time going to be a very

399
00:17:26,000 --> 00:17:31,360
crucial role for human expertise

400
00:17:29,360 --> 00:17:33,120
particularly the flexibility that humans

401
00:17:31,360 --> 00:17:36,320
can bring to the table in terms of very

402
00:17:33,120 --> 00:17:39,760
quickly being able to learn uh new

403
00:17:36,320 --> 00:17:42,880
things is actually going to be quite uh

404
00:17:39,760 --> 00:17:46,080
quite important, right? And you know AI

405
00:17:42,880 --> 00:17:48,480
tools for coding can truly be enablers

406
00:17:46,080 --> 00:17:52,080
of creativity, right? Allowing you to

407
00:17:48,480 --> 00:17:55,120
write code that otherwise would have

408
00:17:52,080 --> 00:17:58,720
been just too uh too difficult to write.

409
00:17:55,120 --> 00:18:01,360
But I think there is uh care that has to

410
00:17:58,720 --> 00:18:04,720
be taken in terms of protecting the

411
00:18:01,360 --> 00:18:07,400
health of the software ecosystem. What

412
00:18:04,720 --> 00:18:10,720
does that mean? Well, if you have a tool

413
00:18:07,400 --> 00:18:12,960
where the tool works way better, if

414
00:18:10,720 --> 00:18:15,919
you're using the old version of the

415
00:18:12,960 --> 00:18:18,960
framework for which there's uh hundreds

416
00:18:15,919 --> 00:18:20,720
of blog posts and hundreds of tutorials

417
00:18:18,960 --> 00:18:22,720
compared to the new version of the

418
00:18:20,720 --> 00:18:25,600
framework that just came out, that

419
00:18:22,720 --> 00:18:27,520
suddenly introduces a lot of inertia

420
00:18:25,600 --> 00:18:30,320
into the system, right? Right? And if

421
00:18:27,520 --> 00:18:32,960
you can't nurture the ecosystem for you

422
00:18:30,320 --> 00:18:36,160
know those tutorials and those uh help

423
00:18:32,960 --> 00:18:38,000
forums to keep up to date with the new

424
00:18:36,160 --> 00:18:40,480
tools and the new frameworks then I

425
00:18:38,000 --> 00:18:44,240
think there is uh there is some risk

426
00:18:40,480 --> 00:18:46,240
going into uh the future and finally I

427
00:18:44,240 --> 00:18:49,440
think we're going to start facing some

428
00:18:46,240 --> 00:18:52,960
important questions around uh you know

429
00:18:49,440 --> 00:18:55,080
this question of technical debt right uh

430
00:18:52,960 --> 00:18:57,280
we have these tools that we can use to

431
00:18:55,080 --> 00:19:00,480
dramatically improve our productivity

432
00:18:57,280 --> 00:19:03,000
and help us produce code that is much

433
00:19:00,480 --> 00:19:07,840
better structured, that is much more

434
00:19:03,000 --> 00:19:10,960
maintainable, that is freer from bugs,

435
00:19:07,840 --> 00:19:12,960
or we can use it to build lots and lots

436
00:19:10,960 --> 00:19:15,440
of really really bad code very very

437
00:19:12,960 --> 00:19:18,320
cheaply and very very quickly, right?

438
00:19:15,440 --> 00:19:21,360
And which one is it going to be? Uh both

439
00:19:18,320 --> 00:19:23,440
of those are possibilities, but I I have

440
00:19:21,360 --> 00:19:26,000
to say I much rather live in the world

441
00:19:23,440 --> 00:19:30,240
where we pick option one as opposed to

442
00:19:26,000 --> 00:19:32,080
option uh two. And so um with that I

443
00:19:30,240 --> 00:19:36,280
would like to uh now take some

444
00:19:32,080 --> 00:19:36,280
questions. Thank you.

445
00:19:37,350 --> 00:19:42,760
[Applause]

446
00:19:49,120 --> 00:19:52,799
So this is a really good question,

447
00:19:50,720 --> 00:19:55,360
right? What role will software engineers

448
00:19:52,799 --> 00:19:58,799
play in an industry where AI is

449
00:19:55,360 --> 00:20:02,720
increasingly generated generating code

450
00:19:58,799 --> 00:20:05,840
and how can they adapt to maintain their

451
00:20:02,720 --> 00:20:08,000
impact right so um I think there's many

452
00:20:05,840 --> 00:20:11,280
different uh answers to this question

453
00:20:08,000 --> 00:20:13,520
depending on what kind of code you are

454
00:20:11,280 --> 00:20:16,720
talking about right so first of all

455
00:20:13,520 --> 00:20:20,640
there's a kind of sort of frontier code

456
00:20:16,720 --> 00:20:23,919
that is you know difficult challenging

457
00:20:20,640 --> 00:20:26,320
to write that really requires all your

458
00:20:23,919 --> 00:20:28,240
creativity and brain power that looks

459
00:20:26,320 --> 00:20:30,720
really different from all the code out

460
00:20:28,240 --> 00:20:32,320
there on the internet. I don't think

461
00:20:30,720 --> 00:20:35,039
we're going to be writing that code

462
00:20:32,320 --> 00:20:36,960
entirely by hand. But I think the

463
00:20:35,039 --> 00:20:39,440
development of that code is now going to

464
00:20:36,960 --> 00:20:41,520
involve a lot of, you know, figuring out

465
00:20:39,440 --> 00:20:44,159
how to set up the problem, figuring out

466
00:20:41,520 --> 00:20:47,679
how to orchestrate all the compute power

467
00:20:44,159 --> 00:20:51,120
to really focus it on how to solve that

468
00:20:47,679 --> 00:20:53,760
one uh problem. Right? Today uh you know

469
00:20:51,120 --> 00:20:55,280
we see these very impressive results of

470
00:20:53,760 --> 00:20:58,159
tools

471
00:20:55,280 --> 00:20:59,840
uh solving you know competition level uh

472
00:20:58,159 --> 00:21:01,280
programming tasks. What we don't see is

473
00:20:59,840 --> 00:21:03,840
the enormous amount of effort and

474
00:21:01,280 --> 00:21:06,000
investment that went into actually

475
00:21:03,840 --> 00:21:08,320
setting up the tools and you know

476
00:21:06,000 --> 00:21:10,240
targeting it towards that particular

477
00:21:08,320 --> 00:21:12,960
kind of programming. I think there's

478
00:21:10,240 --> 00:21:15,440
going to be a style of programming that

479
00:21:12,960 --> 00:21:18,640
is really more about orchestrating the

480
00:21:15,440 --> 00:21:23,360
tools and setting up the thing so that

481
00:21:18,640 --> 00:21:25,280
you can now let your uh cluster run for

482
00:21:23,360 --> 00:21:27,039
a day and have some confidence that

483
00:21:25,280 --> 00:21:28,960
after a day or after a week of running

484
00:21:27,039 --> 00:21:33,679
you will actually get a piece of code

485
00:21:28,960 --> 00:21:36,559
that does what you want. Now um arguably

486
00:21:33,679 --> 00:21:38,640
most people today are not writing that

487
00:21:36,559 --> 00:21:40,400
kind of code and in fact uh you know

488
00:21:38,640 --> 00:21:42,559
people talk about what's going to happen

489
00:21:40,400 --> 00:21:45,440
when we have this revolution in

490
00:21:42,559 --> 00:21:48,159
programmer productivity. We already had

491
00:21:45,440 --> 00:21:49,919
uh not just one but multiple revolutions

492
00:21:48,159 --> 00:21:52,240
in programmer productivity. One of the

493
00:21:49,919 --> 00:21:55,280
most recent ones happened when we moved

494
00:21:52,240 --> 00:21:58,080
to managed languages which made it

495
00:21:55,280 --> 00:22:00,000
possible to actually not have to write

496
00:21:58,080 --> 00:22:02,880
lots of complicated algorithms all the

497
00:22:00,000 --> 00:22:06,080
time. Right? Most algorithms get written

498
00:22:02,880 --> 00:22:08,240
once, get put into the library and now

499
00:22:06,080 --> 00:22:09,919
it's just a matter of knowing how to

500
00:22:08,240 --> 00:22:13,440
call the right library and knowing how

501
00:22:09,919 --> 00:22:16,400
to use it. So writing these very very

502
00:22:13,440 --> 00:22:19,600
unique algorithms has already for many

503
00:22:16,400 --> 00:22:22,080
years been a bit of a very high-end but

504
00:22:19,600 --> 00:22:25,600
somewhat minority uh pursuit. When it

505
00:22:22,080 --> 00:22:29,280
comes to the broader volume of code, a

506
00:22:25,600 --> 00:22:31,600
lot of that is really about figuring out

507
00:22:29,280 --> 00:22:34,640
what do we want to build? What is this

508
00:22:31,600 --> 00:22:36,480
program supposed to do? And how do we

509
00:22:34,640 --> 00:22:38,919
navigate the trade-offs between

510
00:22:36,480 --> 00:22:43,679
performance and cost and

511
00:22:38,919 --> 00:22:45,760
usability? And how do we uh adjudicate

512
00:22:43,679 --> 00:22:47,520
all of these conflicts between what this

513
00:22:45,760 --> 00:22:51,840
customer wants and what that customer

514
00:22:47,520 --> 00:22:53,600
wants? And programming is a way to

515
00:22:51,840 --> 00:22:55,520
settle those questions with very very

516
00:22:53,600 --> 00:22:58,240
high precision, right? To say this is

517
00:22:55,520 --> 00:23:00,240
what the solution is going to be. That's

518
00:22:58,240 --> 00:23:02,159
not going to go away, right? We still

519
00:23:00,240 --> 00:23:04,000
have to figure out actually what it is

520
00:23:02,159 --> 00:23:05,679
that we want to build. What is it that

521
00:23:04,000 --> 00:23:07,520
the service is supposed to do? What is

522
00:23:05,679 --> 00:23:10,320
the service how is the service supposed

523
00:23:07,520 --> 00:23:13,919
to react when this particular uh crazy

524
00:23:10,320 --> 00:23:15,600
situation happens? So programming is

525
00:23:13,919 --> 00:23:17,039
going to be very very different. But a

526
00:23:15,600 --> 00:23:19,919
lot of those fundamental questions

527
00:23:17,039 --> 00:23:23,640
around system design are still very much

528
00:23:19,919 --> 00:23:23,640
going to be there.

529
00:23:24,210 --> 00:23:29,469
[Applause]

