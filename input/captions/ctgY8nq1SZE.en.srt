1
00:00:01,680 --> 00:00:06,480
Uh hi everyone, thank you for joining

2
00:00:03,679 --> 00:00:09,840
today. Jacob Lindenba is going to give

3
00:00:06,480 --> 00:00:12,800
us a primer on uh homorphic encryption

4
00:00:09,840 --> 00:00:15,360
and privacy preservation for uh genomics

5
00:00:12,800 --> 00:00:17,199
and he's a PhD candidate at uh in

6
00:00:15,360 --> 00:00:18,400
computer science at Columbia University.

7
00:00:17,199 --> 00:00:22,039
So I think we're going to get started

8
00:00:18,400 --> 00:00:22,039
now. Thank you, Jacob.

9
00:00:22,480 --> 00:00:27,359
>> Okay, does the microphone work? Perfect.

10
00:00:26,000 --> 00:00:29,199
Well, first of all, thank you guys so

11
00:00:27,359 --> 00:00:30,880
much for having me. I'm uh super excited

12
00:00:29,199 --> 00:00:34,000
to talk. Yes. And thank you for the

13
00:00:30,880 --> 00:00:36,079
introduction. Um so today's talk is

14
00:00:34,000 --> 00:00:38,160
going to focus on mainly homorphic

15
00:00:36,079 --> 00:00:39,920
encryption. I want to give you guys kind

16
00:00:38,160 --> 00:00:41,840
of a mathematical overview as well as

17
00:00:39,920 --> 00:00:43,520
kind of like a an overview for a

18
00:00:41,840 --> 00:00:45,520
practitioner so that you guys can apply

19
00:00:43,520 --> 00:00:47,840
these techniques. Uh and I'm going to

20
00:00:45,520 --> 00:00:51,600
end my talk with kind of an application

21
00:00:47,840 --> 00:00:54,239
in uh in the genome privacy space.

22
00:00:51,600 --> 00:00:56,480
So for data protection, right, there's

23
00:00:54,239 --> 00:00:59,039
three different kinds of ways we protect

24
00:00:56,480 --> 00:01:02,320
data. We protect data in transit with

25
00:00:59,039 --> 00:01:05,439
TLS uh where we kind of encrypt messages

26
00:01:02,320 --> 00:01:10,080
and data that gets sent between devices.

27
00:01:05,439 --> 00:01:12,640
We also encrypt data at rest using AES

28
00:01:10,080 --> 00:01:13,920
uh to keep it secure from attackers. And

29
00:01:12,640 --> 00:01:15,439
finally, we have this kind of new

30
00:01:13,920 --> 00:01:17,360
frontier that's that's recently

31
00:01:15,439 --> 00:01:19,439
developing which is encrypting data

32
00:01:17,360 --> 00:01:21,280
that's in use. So that's actually

33
00:01:19,439 --> 00:01:24,479
computing on encrypted data when it's in

34
00:01:21,280 --> 00:01:26,560
the cloud. Um there's like a few

35
00:01:24,479 --> 00:01:27,840
different developing technologies. These

36
00:01:26,560 --> 00:01:31,280
are called privacy-enhancing

37
00:01:27,840 --> 00:01:33,920
technologies. Um, but there's a there's

38
00:01:31,280 --> 00:01:35,520
a lot of challenges for for data in use

39
00:01:33,920 --> 00:01:37,840
because right now there's a huge

40
00:01:35,520 --> 00:01:39,840
performance hit. Applicability is low

41
00:01:37,840 --> 00:01:41,200
and usability is still a challenge. So,

42
00:01:39,840 --> 00:01:43,920
let's take a deep dive into some of

43
00:01:41,200 --> 00:01:46,479
these technologies real quick.

44
00:01:43,920 --> 00:01:48,880
The first one is a trusted execution

45
00:01:46,479 --> 00:01:52,799
environment which is like an Intel SGX.

46
00:01:48,880 --> 00:01:55,600
This is like a hardware chip uh that can

47
00:01:52,799 --> 00:01:58,479
perform this um this data in use

48
00:01:55,600 --> 00:02:00,640
encryption. Unfortunately, it's quite

49
00:01:58,479 --> 00:02:02,479
vulnerable to side channel attacks, but

50
00:02:00,640 --> 00:02:04,560
it's very performant. It's actually

51
00:02:02,479 --> 00:02:08,000
really close to to plain text, which is

52
00:02:04,560 --> 00:02:10,239
just computing it not on encrypted data.

53
00:02:08,000 --> 00:02:12,800
We also have secure multi-party

54
00:02:10,239 --> 00:02:16,000
computation where we kind of split data

55
00:02:12,800 --> 00:02:17,440
into pieces that we give to um separate

56
00:02:16,000 --> 00:02:21,440
computing parties and then each

57
00:02:17,440 --> 00:02:22,959
computing party can kind of um evaluate

58
00:02:21,440 --> 00:02:25,360
some function and it kind of reshare it

59
00:02:22,959 --> 00:02:26,879
back uh and none of the computing

60
00:02:25,360 --> 00:02:29,280
parties can essentially see the full

61
00:02:26,879 --> 00:02:31,280
data because it's split. This is more

62
00:02:29,280 --> 00:02:33,440
secure than trusted execution

63
00:02:31,280 --> 00:02:34,800
environment but it's a bit slower.

64
00:02:33,440 --> 00:02:36,959
Finally, and what we're going to focus

65
00:02:34,800 --> 00:02:39,760
on mainly in this talk is homorphic

66
00:02:36,959 --> 00:02:42,800
encryption, which lets us directly

67
00:02:39,760 --> 00:02:45,280
compute on encrypted data called cipher

68
00:02:42,800 --> 00:02:47,280
texts. Uh, and this is great because

69
00:02:45,280 --> 00:02:49,360
it's mathematically secure. So, there's

70
00:02:47,280 --> 00:02:51,840
like guaranteed properties of security.

71
00:02:49,360 --> 00:02:53,360
Unfortunately, as we'll show, it's uh

72
00:02:51,840 --> 00:02:55,360
it's very slow and it's not quite

73
00:02:53,360 --> 00:02:58,239
performant. It's about 100 to a million

74
00:02:55,360 --> 00:03:00,239
times slower. So let me take a a brief

75
00:02:58,239 --> 00:03:01,680
quick overview of homorphic encryption

76
00:03:00,239 --> 00:03:03,519
which really highlights what I want to

77
00:03:01,680 --> 00:03:05,519
bring home in this talk. So with

78
00:03:03,519 --> 00:03:08,159
homamorphic encryption we can kind of

79
00:03:05,519 --> 00:03:11,200
delegate computation to an untrusted

80
00:03:08,159 --> 00:03:14,959
party. So here in our little example we

81
00:03:11,200 --> 00:03:18,480
have um let's say some trusted party has

82
00:03:14,959 --> 00:03:20,720
some data X. They can encrypt this data

83
00:03:18,480 --> 00:03:22,480
send it to a trusted computing party

84
00:03:20,720 --> 00:03:24,400
that can evaluate some function let's

85
00:03:22,480 --> 00:03:25,680
say G. And this function could be

86
00:03:24,400 --> 00:03:28,080
something like uh let's say machine

87
00:03:25,680 --> 00:03:30,480
learning inference. Um they can send

88
00:03:28,080 --> 00:03:32,239
that data back.

89
00:03:30,480 --> 00:03:34,000
The the original party can then decrypt

90
00:03:32,239 --> 00:03:36,319
it and then see the the output of the

91
00:03:34,000 --> 00:03:37,760
the function. And in this scenario with

92
00:03:36,319 --> 00:03:39,280
homomorphic encryption, we have

93
00:03:37,760 --> 00:03:41,599
mathematical guarantees that the

94
00:03:39,280 --> 00:03:44,480
untrusted party will never be able to

95
00:03:41,599 --> 00:03:47,680
see the original data X because that X

96
00:03:44,480 --> 00:03:50,799
is always encrypted when it's being um

97
00:03:47,680 --> 00:03:53,440
computed on by the untrusted party. This

98
00:03:50,799 --> 00:03:57,040
is unfortunately computationally very

99
00:03:53,440 --> 00:03:59,280
expensive and uh unfortunately the the

100
00:03:57,040 --> 00:04:01,439
types of operations that we can do on

101
00:03:59,280 --> 00:04:03,760
this encrypted data is limited to

102
00:04:01,439 --> 00:04:05,519
additions and multiplications only. But

103
00:04:03,760 --> 00:04:07,680
that's nice because we can evaluate

104
00:04:05,519 --> 00:04:09,599
polomials. So when we're trying to do

105
00:04:07,680 --> 00:04:11,680
bioinformatics algorithms like let's say

106
00:04:09,599 --> 00:04:13,200
this untrusted party is trying to do a

107
00:04:11,680 --> 00:04:15,280
G-W was for example genomewide

108
00:04:13,200 --> 00:04:17,040
association study we have to simplify

109
00:04:15,280 --> 00:04:19,040
those algorithms to only use additions

110
00:04:17,040 --> 00:04:20,479
and multiplications.

111
00:04:19,040 --> 00:04:22,639
This is really what I want to take home.

112
00:04:20,479 --> 00:04:24,400
Uh the message I want to share with you

113
00:04:22,639 --> 00:04:26,880
guys today. Yes.

114
00:04:24,400 --> 00:04:28,400
>> Is there something uh like that doesn't

115
00:04:26,880 --> 00:04:31,520
work specifically about doing like

116
00:04:28,400 --> 00:04:32,400
inverse operations like division and

117
00:04:31,520 --> 00:04:34,080
subtraction?

118
00:04:32,400 --> 00:04:37,520
>> Yes. Oh, you can do subtraction.

119
00:04:34,080 --> 00:04:39,520
Division is is tricky. Um the way that

120
00:04:37,520 --> 00:04:41,840
people do that now is they basically

121
00:04:39,520 --> 00:04:43,840
find a polomial that's kind of

122
00:04:41,840 --> 00:04:46,479
approximates division and then you

123
00:04:43,840 --> 00:04:48,160
evaluate that. So that's it's a very

124
00:04:46,479 --> 00:04:50,080
expensive operation and we we'll get

125
00:04:48,160 --> 00:04:53,199
into that. Um I'll show you some

126
00:04:50,080 --> 00:04:56,080
examples soon. So let's dive very deeply

127
00:04:53,199 --> 00:04:58,000
into the math. So homorphic encryption

128
00:04:56,080 --> 00:05:00,080
is secure because of this problem called

129
00:04:58,000 --> 00:05:02,240
ringle learning with errors which

130
00:05:00,080 --> 00:05:04,639
cryptographers have deemed to be a

131
00:05:02,240 --> 00:05:07,199
difficult problem. In ringle learning

132
00:05:04,639 --> 00:05:08,720
with errors we work with polomials in

133
00:05:07,199 --> 00:05:10,000
this specific algebraic structure that

134
00:05:08,720 --> 00:05:13,120
looks really scary but I'll break it

135
00:05:10,000 --> 00:05:15,840
down. It's essentially polomials that

136
00:05:13,120 --> 00:05:18,240
have coefficients

137
00:05:15,840 --> 00:05:21,440
modulo q. So that means that they're

138
00:05:18,240 --> 00:05:25,199
between zero to q minus one and they're

139
00:05:21,440 --> 00:05:27,199
bounded to have a degree less than n.

140
00:05:25,199 --> 00:05:30,240
And if you have polomials with this kind

141
00:05:27,199 --> 00:05:34,160
of structure then for some secret

142
00:05:30,240 --> 00:05:35,759
polomial and a pair of polomials a and b

143
00:05:34,160 --> 00:05:37,840
where b is essentially just the

144
00:05:35,759 --> 00:05:40,720
multiplication of a times that secret

145
00:05:37,840 --> 00:05:42,560
plus a little bit of gaussian noise.

146
00:05:40,720 --> 00:05:44,400
It's theorized that this is very

147
00:05:42,560 --> 00:05:47,199
complicationally difficult to find that

148
00:05:44,400 --> 00:05:50,240
original secret polomial. So an attacker

149
00:05:47,199 --> 00:05:53,280
who sees a and b will basically never be

150
00:05:50,240 --> 00:05:55,919
able to extract s.

151
00:05:53,280 --> 00:05:57,680
Um, so this is great because we can then

152
00:05:55,919 --> 00:05:59,360
use this to build our homamorphic

153
00:05:57,680 --> 00:06:01,039
encryption scheme. And the one I'm going

154
00:05:59,360 --> 00:06:03,600
to be focusing on today is called the

155
00:06:01,039 --> 00:06:06,560
BGV scheme where we start with the

156
00:06:03,600 --> 00:06:08,880
secret key which is uh again that same

157
00:06:06,560 --> 00:06:11,600
polomial that we saw before. And then

158
00:06:08,880 --> 00:06:15,280
for encryption we get that same pair of

159
00:06:11,600 --> 00:06:18,080
polomials except we're going to add some

160
00:06:15,280 --> 00:06:20,000
noise again. That's T times our little

161
00:06:18,080 --> 00:06:22,560
bit of error. And then we're going to

162
00:06:20,000 --> 00:06:24,560
hide our message by just adding it to

163
00:06:22,560 --> 00:06:28,160
the end.

164
00:06:24,560 --> 00:06:30,560
Now under this scheme essentially this

165
00:06:28,160 --> 00:06:32,560
the this pair of polomials this A and B

166
00:06:30,560 --> 00:06:33,759
is going to look random with that if you

167
00:06:32,560 --> 00:06:38,400
don't have the knowledge of the secret

168
00:06:33,759 --> 00:06:40,960
key. Um so under RLWE essentially our

169
00:06:38,400 --> 00:06:42,800
message is hidden even if we share this

170
00:06:40,960 --> 00:06:44,560
this cipher text with the with the rest

171
00:06:42,800 --> 00:06:46,560
of the world. Decryption is quite

172
00:06:44,560 --> 00:06:50,160
simple. If you have the secret key, you

173
00:06:46,560 --> 00:06:53,120
can just multiply that by A and then do

174
00:06:50,160 --> 00:06:55,520
B minus A * S and you get back your

175
00:06:53,120 --> 00:06:57,600
original message. So this is great. We

176
00:06:55,520 --> 00:06:58,720
have an encryption scheme and I'll show

177
00:06:57,600 --> 00:07:01,840
you how to do addition and

178
00:06:58,720 --> 00:07:04,400
multiplication on this. Um, but before

179
00:07:01,840 --> 00:07:06,720
we get into that, I'm talking about

180
00:07:04,400 --> 00:07:08,560
messages here. We usually work with data

181
00:07:06,720 --> 00:07:10,960
that's integers and floats. So how does

182
00:07:08,560 --> 00:07:13,840
that all come together? Well, we can

183
00:07:10,960 --> 00:07:15,759
actually embed integers into polomials

184
00:07:13,840 --> 00:07:17,599
of degree n, which is our message

185
00:07:15,759 --> 00:07:19,360
polomial using what is known as the

186
00:07:17,599 --> 00:07:21,520
Chinese remainder theorem and residual

187
00:07:19,360 --> 00:07:24,960
number systems. And essentially we can

188
00:07:21,520 --> 00:07:26,560
take a polomial of degree m and store n

189
00:07:24,960 --> 00:07:28,800
integers

190
00:07:26,560 --> 00:07:31,120
um inside of it. And there's this nice

191
00:07:28,800 --> 00:07:34,319
isomorphism that that happens where if

192
00:07:31,120 --> 00:07:36,639
we add polomials with this embedding, we

193
00:07:34,319 --> 00:07:38,639
actually add all of the the basically

194
00:07:36,639 --> 00:07:40,560
like the vector components. And this

195
00:07:38,639 --> 00:07:42,000
works for addition and multiplication

196
00:07:40,560 --> 00:07:43,680
which as I said in homamorphic

197
00:07:42,000 --> 00:07:46,400
encryption are the only two operations

198
00:07:43,680 --> 00:07:49,120
that are supported. Um so this is quite

199
00:07:46,400 --> 00:07:52,240
nice. Now this kind of works in practice

200
00:07:49,120 --> 00:07:53,680
is we can take a bunch of a vector of a

201
00:07:52,240 --> 00:07:55,120
bunch of integers and another vector of

202
00:07:53,680 --> 00:07:58,080
a bunch of integers. We encrypt them

203
00:07:55,120 --> 00:08:01,840
into cipher texts uh into single cipher

204
00:07:58,080 --> 00:08:04,160
texts. We do one addition operation and

205
00:08:01,840 --> 00:08:07,280
then when we decrypt them uh we get the

206
00:08:04,160 --> 00:08:09,599
the pairwise sum of all of these. So

207
00:08:07,280 --> 00:08:12,560
really in homorphic encryption we're not

208
00:08:09,599 --> 00:08:14,960
doing very many operations. So the

209
00:08:12,560 --> 00:08:17,840
throughput it can be quite high because

210
00:08:14,960 --> 00:08:21,280
this this end the size of these these

211
00:08:17,840 --> 00:08:23,440
vectors can be up to 4,000 8,000 16,000.

212
00:08:21,280 --> 00:08:25,520
They're gigantic. But unfortunately the

213
00:08:23,440 --> 00:08:27,360
latency is quite high. So these ad

214
00:08:25,520 --> 00:08:29,680
operations are quite expensive. So you

215
00:08:27,360 --> 00:08:32,240
have to be quite clever with how you um

216
00:08:29,680 --> 00:08:33,839
kind of pack these uh these vectors

217
00:08:32,240 --> 00:08:36,240
inside of our cipher text and how we

218
00:08:33,839 --> 00:08:38,800
organize this data.

219
00:08:36,240 --> 00:08:41,039
So that was a bit of how we encode the

220
00:08:38,800 --> 00:08:42,800
data. Now we can talk about the exact

221
00:08:41,039 --> 00:08:44,959
operations we can perform on cipher

222
00:08:42,800 --> 00:08:47,440
texts. So as you remember each cipher

223
00:08:44,959 --> 00:08:49,760
text is a pair of polomials and

224
00:08:47,440 --> 00:08:51,680
homorphic addition is super simple. We

225
00:08:49,760 --> 00:08:54,160
basically just add the the components of

226
00:08:51,680 --> 00:08:56,160
two cipher texts. So if we have a cipher

227
00:08:54,160 --> 00:08:59,839
text one that's a1 b1 and a cipher text

228
00:08:56,160 --> 00:09:03,600
2 a2 b2 the sum is just going to be the

229
00:08:59,839 --> 00:09:05,040
a1 plus a2 and b1 plus b2

230
00:09:03,600 --> 00:09:07,760
correctness. Yep. When we do the

231
00:09:05,040 --> 00:09:10,880
decryption step with the secret key, we

232
00:09:07,760 --> 00:09:14,320
get our output that's M1 and M2. So

233
00:09:10,880 --> 00:09:16,480
exactly what we had before. Now there is

234
00:09:14,320 --> 00:09:18,560
something that is crucial to homorphic

235
00:09:16,480 --> 00:09:22,160
encryption which is that the error grew.

236
00:09:18,560 --> 00:09:24,399
If you see that the the E1 plus E2, it's

237
00:09:22,160 --> 00:09:27,360
now twice the error of the original

238
00:09:24,399 --> 00:09:30,640
cipher text. So for our visual people

239
00:09:27,360 --> 00:09:34,720
out there, if we have a a cipher text,

240
00:09:30,640 --> 00:09:38,240
you can kind of imagine it as a a um a

241
00:09:34,720 --> 00:09:40,480
block where we have our our payload, our

242
00:09:38,240 --> 00:09:45,120
message, and then we have that error

243
00:09:40,480 --> 00:09:46,480
that sits t push t above our payload and

244
00:09:45,120 --> 00:09:48,720
then we have what is known as a noise

245
00:09:46,480 --> 00:09:50,080
budget. And as we perform homorphic

246
00:09:48,720 --> 00:09:51,760
operations like this addition and

247
00:09:50,080 --> 00:09:53,279
multiplication, our error is going to

248
00:09:51,760 --> 00:09:55,360
grow and it's going to consume this

249
00:09:53,279 --> 00:09:58,640
noise budget. So as we saw with the

250
00:09:55,360 --> 00:10:00,800
addition, our error increased twofold.

251
00:09:58,640 --> 00:10:03,360
And if we keep doing these operations,

252
00:10:00,800 --> 00:10:05,519
our error can grow. And once the error

253
00:10:03,360 --> 00:10:07,680
exceeds the noise budget, because we're

254
00:10:05,519 --> 00:10:09,519
working modulo Q, it's going to wrap

255
00:10:07,680 --> 00:10:11,279
around the ring and it's going to enter

256
00:10:09,519 --> 00:10:13,600
what is our payload and it's actually

257
00:10:11,279 --> 00:10:16,079
going to corrupt our message and we will

258
00:10:13,600 --> 00:10:18,320
no longer be able to decrypt. So when we

259
00:10:16,079 --> 00:10:20,959
perform homamorphic operations, we have

260
00:10:18,320 --> 00:10:23,040
to be very cognizant of the error

261
00:10:20,959 --> 00:10:25,440
because if we consume too much and we

262
00:10:23,040 --> 00:10:27,279
exceed our noise budget, everything is

263
00:10:25,440 --> 00:10:29,519
kapoot. Yes.

264
00:10:27,279 --> 00:10:31,200
>> Is the noise budget something like a set

265
00:10:29,519 --> 00:10:32,000
of par bits? Is that how I should think

266
00:10:31,200 --> 00:10:32,560
about this?

267
00:10:32,000 --> 00:10:36,000
>> No.

268
00:10:32,560 --> 00:10:39,839
>> No. You should think about it as like

269
00:10:36,000 --> 00:10:43,040
um you basically just have a a log

270
00:10:39,839 --> 00:10:44,640
capacity and then after each operation

271
00:10:43,040 --> 00:10:46,480
your your error is going to take up more

272
00:10:44,640 --> 00:10:48,720
and more of this this capacity and then

273
00:10:46,480 --> 00:10:49,440
if as soon as it exceeds that then it's

274
00:10:48,720 --> 00:10:51,200
all gone.

275
00:10:49,440 --> 00:10:53,440
>> I guess what what's confusing me is how

276
00:10:51,200 --> 00:10:54,880
do you how do you make sure that the

277
00:10:53,440 --> 00:10:55,760
error is just taking up the noise

278
00:10:54,880 --> 00:10:59,120
budget?

279
00:10:55,760 --> 00:11:02,320
>> Yes. Yes. So when we do the these

280
00:10:59,120 --> 00:11:05,760
operations, the the error just grows

281
00:11:02,320 --> 00:11:08,079
because it's um

282
00:11:05,760 --> 00:11:09,760
it's just pushed t away from our payload

283
00:11:08,079 --> 00:11:14,079
message. So the error is only is always

284
00:11:09,760 --> 00:11:16,560
going to be t like uh t bits or log t

285
00:11:14,079 --> 00:11:18,399
bits from our payload message. And so

286
00:11:16,560 --> 00:11:20,160
it's never it's never going to be at the

287
00:11:18,399 --> 00:11:22,480
front. You can actually think of

288
00:11:20,160 --> 00:11:25,600
homorphic encryption really as these

289
00:11:22,480 --> 00:11:27,680
coefficients as this plus some masking

290
00:11:25,600 --> 00:11:29,200
which was that secret key times original

291
00:11:27,680 --> 00:11:30,959
random polomial that I was talking

292
00:11:29,200 --> 00:11:33,040
about. So if you remove that during

293
00:11:30,959 --> 00:11:35,440
decryption you essentially always get

294
00:11:33,040 --> 00:11:38,240
kind of messages that look like this.

295
00:11:35,440 --> 00:11:39,920
That makes sense.

296
00:11:38,240 --> 00:11:41,600
So for multiplication things get a

297
00:11:39,920 --> 00:11:43,839
little bit more tricky. Uh but we have a

298
00:11:41,600 --> 00:11:46,720
cipher text that's again a pair. uh when

299
00:11:43,839 --> 00:11:48,560
we multiply we're going to we have to do

300
00:11:46,720 --> 00:11:50,160
something special and we're going to get

301
00:11:48,560 --> 00:11:55,600
a cipher text that actually has three

302
00:11:50,160 --> 00:11:58,560
components a1 a2 a1 * b2 plus b2 b1 * a2

303
00:11:55,600 --> 00:12:01,279
and b1 * b2

304
00:11:58,560 --> 00:12:04,480
so given a cipher text that looks like

305
00:12:01,279 --> 00:12:05,680
this we can again run a decryption

306
00:12:04,480 --> 00:12:07,279
algorithm but this time it's a little

307
00:12:05,680 --> 00:12:09,200
bit more complicated because we need the

308
00:12:07,279 --> 00:12:11,200
secret key squared and we can do that

309
00:12:09,200 --> 00:12:13,040
because the secret key is a polinomial

310
00:12:11,200 --> 00:12:16,639
you guys can just trust me on this that

311
00:12:13,040 --> 00:12:19,760
that it works and it decrypts to um to

312
00:12:16,639 --> 00:12:21,440
produce our our messages squared. The

313
00:12:19,760 --> 00:12:24,959
important takeaway here is that the

314
00:12:21,440 --> 00:12:27,200
error is squared. So we can when we do

315
00:12:24,959 --> 00:12:29,839
multiplication we really quickly consume

316
00:12:27,200 --> 00:12:31,839
our noise budget because the error

317
00:12:29,839 --> 00:12:34,000
squares and then so if we do repeated

318
00:12:31,839 --> 00:12:36,000
multiplications then it would explode

319
00:12:34,000 --> 00:12:39,360
exponentially. So we need to have a

320
00:12:36,000 --> 00:12:41,839
technique to to deal with this and to

321
00:12:39,360 --> 00:12:43,360
give you guys some like

322
00:12:41,839 --> 00:12:46,800
um

323
00:12:43,360 --> 00:12:49,360
in pra in practice numbers uh if we have

324
00:12:46,800 --> 00:12:52,160
an n so that's the size of our polomials

325
00:12:49,360 --> 00:12:55,519
of about 4,000 which is pretty standard

326
00:12:52,160 --> 00:12:59,600
plain text t a plain text modulus t of

327
00:12:55,519 --> 00:13:01,920
127 and a log q of about 101 then just

328
00:12:59,600 --> 00:13:03,760
after three repeated squarings we

329
00:13:01,920 --> 00:13:05,519
already have accumulated enough noise

330
00:13:03,760 --> 00:13:08,480
that it exceeds and noise budget. So

331
00:13:05,519 --> 00:13:10,639
essentially our cipher text is ruined.

332
00:13:08,480 --> 00:13:12,959
So we need a technique to manage this.

333
00:13:10,639 --> 00:13:16,160
And in BGV luckily we can do something

334
00:13:12,959 --> 00:13:17,760
called uh modulus switching. So inside

335
00:13:16,160 --> 00:13:19,360
of our ciphertext modulus we can

336
00:13:17,760 --> 00:13:22,160
actually use it think about it as a

337
00:13:19,360 --> 00:13:24,959
chain where we have a bunch of prime

338
00:13:22,160 --> 00:13:27,279
factors that are are the decomposition

339
00:13:24,959 --> 00:13:29,519
of our original cipherex modulus. And so

340
00:13:27,279 --> 00:13:32,560
we start off with this big big cipherex

341
00:13:29,519 --> 00:13:34,800
modulus and then we kind of chop it up

342
00:13:32,560 --> 00:13:38,480
uh as we go along.

343
00:13:34,800 --> 00:13:41,360
And um yeah, the way we chop it up is we

344
00:13:38,480 --> 00:13:43,360
just multiply by the the new modulus

345
00:13:41,360 --> 00:13:45,120
which is slightly smaller divided by the

346
00:13:43,360 --> 00:13:48,560
old modulus and then we do some rounding

347
00:13:45,120 --> 00:13:51,839
operations. What's nice about this is

348
00:13:48,560 --> 00:13:54,560
that if we're smart about how we choose

349
00:13:51,839 --> 00:13:56,959
uh the cipher text modulus chain, then

350
00:13:54,560 --> 00:13:58,399
when we do the scaling down operation,

351
00:13:56,959 --> 00:14:00,560
we actually preserve our original

352
00:13:58,399 --> 00:14:03,680
message, but the error kind of decreases

353
00:14:00,560 --> 00:14:05,360
and our cipher text gets smaller.

354
00:14:03,680 --> 00:14:07,920
So yeah, and this is that property that

355
00:14:05,360 --> 00:14:09,920
I was talking about. Um, we can still

356
00:14:07,920 --> 00:14:11,360
run out of noise budget and then we

357
00:14:09,920 --> 00:14:13,360
would have to perform what is known as a

358
00:14:11,360 --> 00:14:14,800
bootstrapping operation which kind of

359
00:14:13,360 --> 00:14:17,360
resets the noise but it's extremely

360
00:14:14,800 --> 00:14:18,800
expensive. Okay, that was a lot. So I

361
00:14:17,360 --> 00:14:21,279
want to talk about how this all works in

362
00:14:18,800 --> 00:14:23,360
practice um using something that I think

363
00:14:21,279 --> 00:14:24,959
you guys probably all work on uh

364
00:14:23,360 --> 00:14:26,560
transformers.

365
00:14:24,959 --> 00:14:28,079
So here we have a simple transformer

366
00:14:26,560 --> 00:14:30,399
architecture

367
00:14:28,079 --> 00:14:33,600
uh with a an attention mechanism and

368
00:14:30,399 --> 00:14:36,079
then a feed forward network.

369
00:14:33,600 --> 00:14:38,480
So this paper uh that's a post on

370
00:14:36,079 --> 00:14:41,279
archive actually does this using

371
00:14:38,480 --> 00:14:42,639
homorphic encryption. So we can encrypt

372
00:14:41,279 --> 00:14:45,600
our input run it through this

373
00:14:42,639 --> 00:14:48,000
transformer um algorithm and get back an

374
00:14:45,600 --> 00:14:51,279
output that we can decrypt later. And

375
00:14:48,000 --> 00:14:54,000
the way that it looks like is is this

376
00:14:51,279 --> 00:14:55,760
table here where uh we have to perform

377
00:14:54,000 --> 00:14:58,480
some matrix multiplications and do a

378
00:14:55,760 --> 00:15:00,000
soft max more matrix multiplications

379
00:14:58,480 --> 00:15:01,600
layer normalization essentially go

380
00:15:00,000 --> 00:15:03,519
through all the normal transformer

381
00:15:01,600 --> 00:15:05,279
models. What I want to highlight here is

382
00:15:03,519 --> 00:15:07,040
the depth because this is kind of the

383
00:15:05,279 --> 00:15:09,920
the key when you're implementing these

384
00:15:07,040 --> 00:15:11,519
things. Um that's that cipher the size

385
00:15:09,920 --> 00:15:14,000
of that cipher text change. So we

386
00:15:11,519 --> 00:15:16,240
started off with uh a cipher text change

387
00:15:14,000 --> 00:15:19,199
that's 21

388
00:15:16,240 --> 00:15:20,720
um cipher text primes and then we

389
00:15:19,199 --> 00:15:21,920
decrease that all the way down to one

390
00:15:20,720 --> 00:15:23,760
and then we have to perform that

391
00:15:21,920 --> 00:15:25,120
expensive bootstrapping operation that I

392
00:15:23,760 --> 00:15:27,279
was talking about before to bring it

393
00:15:25,120 --> 00:15:30,720
back and replenish that noise and then

394
00:15:27,279 --> 00:15:32,880
we can keep going. Um

395
00:15:30,720 --> 00:15:34,720
so after each multiplication operation

396
00:15:32,880 --> 00:15:37,120
usually in homework encryption we

397
00:15:34,720 --> 00:15:40,320
perform this cipher text modulus so that

398
00:15:37,120 --> 00:15:42,000
the the noise growth stays minimal. And

399
00:15:40,320 --> 00:15:43,839
what's nice about this is when we

400
00:15:42,000 --> 00:15:46,079
perform this modulus switch, our cipher

401
00:15:43,839 --> 00:15:47,760
text as I showed before gets smaller,

402
00:15:46,079 --> 00:15:50,639
which means that our operations actually

403
00:15:47,760 --> 00:15:53,440
get much much faster. So as you see in

404
00:15:50,639 --> 00:15:58,000
the original matrix multiplication

405
00:15:53,440 --> 00:16:00,560
um at the the highest layer which is 21,

406
00:15:58,000 --> 00:16:02,800
it takes about what is that 65 seconds

407
00:16:00,560 --> 00:16:05,040
to perform this on the CPU. But when we

408
00:16:02,800 --> 00:16:09,279
do a very similar sized matrix

409
00:16:05,040 --> 00:16:11,600
multiplication on a depth of just two,

410
00:16:09,279 --> 00:16:13,519
it takes only two seconds. So it's much

411
00:16:11,600 --> 00:16:15,040
much faster. And this is why

412
00:16:13,519 --> 00:16:17,759
implementing these things right now is

413
00:16:15,040 --> 00:16:20,240
is quite tricky. and applying or taking

414
00:16:17,759 --> 00:16:22,240
genomic analysis and use and doing it

415
00:16:20,240 --> 00:16:24,000
homorphically is is tricky from an

416
00:16:22,240 --> 00:16:26,720
implementation standpoint because you

417
00:16:24,000 --> 00:16:29,360
need to be very careful with how you

418
00:16:26,720 --> 00:16:31,279
kind of organize your algorithm so that

419
00:16:29,360 --> 00:16:34,880
you maximize performance because it can

420
00:16:31,279 --> 00:16:36,639
there's a 30x difference here. Um so

421
00:16:34,880 --> 00:16:39,199
yeah you need to be you need to be smart

422
00:16:36,639 --> 00:16:41,120
about how you do implement these things

423
00:16:39,199 --> 00:16:43,040
for nonlinear operations like division

424
00:16:41,120 --> 00:16:47,600
that you were talking about before we

425
00:16:43,040 --> 00:16:48,880
have softmax layer norm um glu

426
00:16:47,600 --> 00:16:51,600
we have to approximate these with

427
00:16:48,880 --> 00:16:55,920
polomials so here's an example polomial

428
00:16:51,600 --> 00:16:57,839
that they use to approximate uh gu um

429
00:16:55,920 --> 00:17:00,160
these consume a lot of depth because

430
00:16:57,839 --> 00:17:03,360
they're quite complicated uh as you can

431
00:17:00,160 --> 00:17:06,240
see with the softmax right we go from 19

432
00:17:03,360 --> 00:17:08,400
to three. Um so we're consuming a lot of

433
00:17:06,240 --> 00:17:10,319
depth and uh they're also quite slow. If

434
00:17:08,400 --> 00:17:13,919
you look at 47

435
00:17:10,319 --> 00:17:15,919
47 seconds to perform this um softmax

436
00:17:13,919 --> 00:17:18,720
um oh yeah

437
00:17:15,919 --> 00:17:20,640
because secure transformers require so

438
00:17:18,720 --> 00:17:22,000
much so many operations we do have to

439
00:17:20,640 --> 00:17:23,439
perform this bootstrapping operation

440
00:17:22,000 --> 00:17:25,360
that I was talking about before to

441
00:17:23,439 --> 00:17:28,160
basically replenish the depth and get

442
00:17:25,360 --> 00:17:30,320
our noise budget back. And these are

443
00:17:28,160 --> 00:17:31,840
very very expensive operations. So when

444
00:17:30,320 --> 00:17:33,600
you're implementing these homorphic

445
00:17:31,840 --> 00:17:35,760
algorithms, you honestly want to avoid

446
00:17:33,600 --> 00:17:37,679
bootstrapping at all costs. You can see

447
00:17:35,760 --> 00:17:40,480
in the breakdown of the timings for each

448
00:17:37,679 --> 00:17:42,799
layer, the bootstrapping layer is by far

449
00:17:40,480 --> 00:17:47,840
the most expensive.

450
00:17:42,799 --> 00:17:50,160
Um taking almost 100 plus seconds to do.

451
00:17:47,840 --> 00:17:52,160
Thankfully, um we don't really have to

452
00:17:50,160 --> 00:17:54,000
worry about the the the foundational

453
00:17:52,160 --> 00:17:55,760
implementation of these homorphic

454
00:17:54,000 --> 00:17:57,840
encryption schemes because there's a lot

455
00:17:55,760 --> 00:18:01,039
of tools that exist out there to do them

456
00:17:57,840 --> 00:18:04,400
for us. So for the scheme I introduced

457
00:18:01,039 --> 00:18:07,120
today the BGV scheme um there's a bunch

458
00:18:04,400 --> 00:18:11,120
of implementations seal by Microsoft

459
00:18:07,120 --> 00:18:14,080
latigo EIB um and they perform this

460
00:18:11,120 --> 00:18:15,919
integer um they can do homorphic

461
00:18:14,080 --> 00:18:19,280
encryption on integers supporting

462
00:18:15,919 --> 00:18:21,039
addition and multiplication there's also

463
00:18:19,280 --> 00:18:24,320
tools out there using a scheme called

464
00:18:21,039 --> 00:18:27,840
CKKS to actually do homorphic encryption

465
00:18:24,320 --> 00:18:29,840
on floatingoint uh values so that's

466
00:18:27,840 --> 00:18:31,919
actually what was used in that secure

467
00:18:29,840 --> 00:18:33,520
transformer model uh that I showed

468
00:18:31,919 --> 00:18:36,480
before and that from that paper and then

469
00:18:33,520 --> 00:18:38,080
again seal and lato support this there's

470
00:18:36,480 --> 00:18:41,520
also a different type of scheme called

471
00:18:38,080 --> 00:18:43,520
CGI which supports bits and this is very

472
00:18:41,520 --> 00:18:44,880
good for like comparisons and nonlinear

473
00:18:43,520 --> 00:18:47,600
operations but it's not great for

474
00:18:44,880 --> 00:18:49,840
arithmetic operations uh but that uses

475
00:18:47,600 --> 00:18:55,120
kind of a different scheme uh and then

476
00:18:49,840 --> 00:18:57,600
you can use uh the tf library for that

477
00:18:55,120 --> 00:18:59,919
um so how does this all kind of work in

478
00:18:57,600 --> 00:19:02,559
practice this um I wanted to talk about

479
00:18:59,919 --> 00:19:04,160
a project I did with with Gamsa called

480
00:19:02,559 --> 00:19:08,000
ultra secure scalable and queryable

481
00:19:04,160 --> 00:19:09,520
genotype phenotype databases with squid

482
00:19:08,000 --> 00:19:11,760
and

483
00:19:09,520 --> 00:19:13,919
so for a quick background why do we keep

484
00:19:11,760 --> 00:19:16,720
genome secure it's it's a very important

485
00:19:13,919 --> 00:19:19,760
problem um there are a lot of attacks

486
00:19:16,720 --> 00:19:22,720
that even I taking anonymized genomes

487
00:19:19,760 --> 00:19:24,880
and anonymized data genomic data you can

488
00:19:22,720 --> 00:19:27,600
perform surname inferences you can find

489
00:19:24,880 --> 00:19:30,000
out familial connections

490
00:19:27,600 --> 00:19:32,799
And once your DNA is breached, there's

491
00:19:30,000 --> 00:19:35,280
really no way to change it. So it's out

492
00:19:32,799 --> 00:19:38,080
there forever. As well as like your your

493
00:19:35,280 --> 00:19:39,760
parents share a bunch of your DNA, your

494
00:19:38,080 --> 00:19:43,120
your children also share a bunch of your

495
00:19:39,760 --> 00:19:45,760
DNA. So it can be quite quite harmful.

496
00:19:43,120 --> 00:19:47,840
So when we perform genomic data like a

497
00:19:45,760 --> 00:19:50,240
genomic data analysis such as on the

498
00:19:47,840 --> 00:19:53,039
thousand genomes project, we typically

499
00:19:50,240 --> 00:19:54,640
have a data owner like the NIH uh that

500
00:19:53,039 --> 00:19:56,640
has all of the data that's encrypted at

501
00:19:54,640 --> 00:19:58,559
rest and then a researcher wants to

502
00:19:56,640 --> 00:20:00,160
analyze this. So they download it all

503
00:19:58,559 --> 00:20:02,559
locally

504
00:20:00,160 --> 00:20:05,600
and then they perform the analysis which

505
00:20:02,559 --> 00:20:08,000
is great. Um but as data continues to

506
00:20:05,600 --> 00:20:09,760
grow and we get more and more um more

507
00:20:08,000 --> 00:20:11,280
and more genomic data the the

508
00:20:09,760 --> 00:20:13,120
computational

509
00:20:11,280 --> 00:20:15,840
storage and the communication cost to

510
00:20:13,120 --> 00:20:18,000
just download it um start to really blow

511
00:20:15,840 --> 00:20:20,240
up. Furthermore, the data owner really

512
00:20:18,000 --> 00:20:22,960
has no control over any guarantees of

513
00:20:20,240 --> 00:20:24,160
privacy or security once the the data is

514
00:20:22,960 --> 00:20:26,480
in the hands of the researcher. It's

515
00:20:24,160 --> 00:20:29,039
kind of like assumed that uh the

516
00:20:26,480 --> 00:20:30,799
researcher will be smart about how they

517
00:20:29,039 --> 00:20:32,480
um

518
00:20:30,799 --> 00:20:34,159
how they handle and manipulate the data.

519
00:20:32,480 --> 00:20:36,400
If a patient wants to drop out from the

520
00:20:34,159 --> 00:20:38,240
cohort, it's a challenging process to

521
00:20:36,400 --> 00:20:40,400
have all the researchers kind of remove

522
00:20:38,240 --> 00:20:42,000
that that patient. So really, can we

523
00:20:40,400 --> 00:20:44,000
apply these techniques, this homorphic

524
00:20:42,000 --> 00:20:46,559
encryption technique to do inuse

525
00:20:44,000 --> 00:20:48,480
encryption. So we conjured up this

526
00:20:46,559 --> 00:20:50,559
scenario where a data owner who has all

527
00:20:48,480 --> 00:20:52,320
of the data basically encrypts it and

528
00:20:50,559 --> 00:20:53,919
sends it to the public cloud. And in

529
00:20:52,320 --> 00:20:56,159
clients, our researchers, they can

530
00:20:53,919 --> 00:20:59,600
analyze it by sending queries to the to

531
00:20:56,159 --> 00:21:02,240
the public cloud. Um,

532
00:20:59,600 --> 00:21:03,600
and yeah, in in this setting, like we're

533
00:21:02,240 --> 00:21:05,360
going to use homomorphic encryption,

534
00:21:03,600 --> 00:21:08,159
right? Because we don't want the public

535
00:21:05,360 --> 00:21:10,159
cloud to ever have access or can see

536
00:21:08,159 --> 00:21:12,640
what this uh genomic data is. We want to

537
00:21:10,159 --> 00:21:16,000
keep it keep it ultra secure. So, we

538
00:21:12,640 --> 00:21:18,000
built out a bunch of possible queries um

539
00:21:16,000 --> 00:21:19,760
that the researchers can perform when

540
00:21:18,000 --> 00:21:21,039
you perform this kind of scenario. And

541
00:21:19,760 --> 00:21:23,440
the one that I I kind of want to talk

542
00:21:21,039 --> 00:21:24,720
about is counting queries. Uh but before

543
00:21:23,440 --> 00:21:26,159
I get into that, I really want to

544
00:21:24,720 --> 00:21:27,520
quickly talk about how to do this data

545
00:21:26,159 --> 00:21:30,159
storage and how to store this in the

546
00:21:27,520 --> 00:21:31,520
cloud. So we worked with genomic data

547
00:21:30,159 --> 00:21:34,240
that looks like this. We have a bunch of

548
00:21:31,520 --> 00:21:35,360
snips uh for a bunch of patients. So

549
00:21:34,240 --> 00:21:37,200
very similar to kind of what the

550
00:21:35,360 --> 00:21:38,880
thousand genomes data set looks like.

551
00:21:37,200 --> 00:21:40,559
But we also have some phenotypes, sex,

552
00:21:38,880 --> 00:21:42,559
smoke, if they're smoker or not, or some

553
00:21:40,559 --> 00:21:45,520
disease that uh researchers might want

554
00:21:42,559 --> 00:21:47,039
to analyze. So right each row contains

555
00:21:45,520 --> 00:21:50,559
patient information and each column

556
00:21:47,039 --> 00:21:52,559
contains either a snip or a phenotype.

557
00:21:50,559 --> 00:21:54,480
Using that homorphic encryption packing

558
00:21:52,559 --> 00:21:59,039
that I discussed before, we can actually

559
00:21:54,480 --> 00:22:00,559
store these entire rows of um patients

560
00:21:59,039 --> 00:22:03,039
for like a single snip into a single

561
00:22:00,559 --> 00:22:04,559
cipher text. Uh which is great because

562
00:22:03,039 --> 00:22:07,360
it gives us kind of very natural

563
00:22:04,559 --> 00:22:09,840
parallelism.

564
00:22:07,360 --> 00:22:12,159
Um so how do we perform a counting

565
00:22:09,840 --> 00:22:14,320
query? Let's say a researcher submits

566
00:22:12,159 --> 00:22:17,280
can I count how many patients in this

567
00:22:14,320 --> 00:22:21,120
database have a have snip 2 is equal to

568
00:22:17,280 --> 00:22:24,640
one and sex is equal to one.

569
00:22:21,120 --> 00:22:25,760
um when this gets sent to uh the cloud

570
00:22:24,640 --> 00:22:26,880
we will kind of want to compute this

571
00:22:25,760 --> 00:22:28,480
query and then send it back to the

572
00:22:26,880 --> 00:22:31,360
researcher who can decrypt it using

573
00:22:28,480 --> 00:22:34,559
again homorphic encryption. So how do we

574
00:22:31,360 --> 00:22:36,080
perform this? Well when we get get this

575
00:22:34,559 --> 00:22:38,159
um query coming in we're going to have

576
00:22:36,080 --> 00:22:39,600
to first perform equality tests.

577
00:22:38,159 --> 00:22:42,240
Basically we need to check for each

578
00:22:39,600 --> 00:22:44,320
patient in a database uh do they have a

579
00:22:42,240 --> 00:22:46,559
one for snip two and do they have a one

580
00:22:44,320 --> 00:22:50,080
for sex one. Unfortunately an equality

581
00:22:46,559 --> 00:22:52,880
test is a nonlinear operation. So like

582
00:22:50,080 --> 00:22:55,360
we said we have to approximate this with

583
00:22:52,880 --> 00:22:58,320
um with a polomial. So we're going to

584
00:22:55,360 --> 00:23:01,679
first build out this truth table where

585
00:22:58,320 --> 00:23:03,679
um u is our database value and v is the

586
00:23:01,679 --> 00:23:05,840
query value and essentially it's just

587
00:23:03,679 --> 00:23:08,880
the one on the diagonal when the values

588
00:23:05,840 --> 00:23:10,320
are equal. Very simple.

589
00:23:08,880 --> 00:23:12,880
We are going to assume that the query

590
00:23:10,320 --> 00:23:15,200
value u is not private. The only value

591
00:23:12,880 --> 00:23:17,200
that is private is our database entry.

592
00:23:15,200 --> 00:23:19,039
So we can just generate three different

593
00:23:17,200 --> 00:23:21,919
polomials that kind of evaluate this

594
00:23:19,039 --> 00:23:23,600
this truth um function. And this is kind

595
00:23:21,919 --> 00:23:26,080
of how you actually normally would

596
00:23:23,600 --> 00:23:30,799
perform this translation of nonlinear

597
00:23:26,080 --> 00:23:32,799
functions into um into polomials that

598
00:23:30,799 --> 00:23:34,640
you can evaluate homorphically. So we

599
00:23:32,799 --> 00:23:37,600
generate three different polomials

600
00:23:34,640 --> 00:23:40,400
depending on what the query value was.

601
00:23:37,600 --> 00:23:42,000
Next, we're going to have to evaluate

602
00:23:40,400 --> 00:23:43,760
the

603
00:23:42,000 --> 00:23:46,480
uh boolean circuit to kind of compute a

604
00:23:43,760 --> 00:23:48,400
predicate. So again, here we need to

605
00:23:46,480 --> 00:23:49,919
first check if snip 2 is equal to one

606
00:23:48,400 --> 00:23:52,480
and sex is equal to one. So we're going

607
00:23:49,919 --> 00:23:53,840
to have to apply two equality tests. And

608
00:23:52,480 --> 00:23:55,679
then since we are doing an and

609
00:23:53,840 --> 00:23:57,280
operation, which is essentially a

610
00:23:55,679 --> 00:23:59,120
multiplication,

611
00:23:57,280 --> 00:24:01,039
uh we need to check if both are one. And

612
00:23:59,120 --> 00:24:02,320
if both are one, then if we multiply

613
00:24:01,039 --> 00:24:03,919
them together, the results, the

614
00:24:02,320 --> 00:24:06,799
predicate is going to be one. and that

615
00:24:03,919 --> 00:24:09,120
patient kind of passes this filter uh

616
00:24:06,799 --> 00:24:10,559
that we're querying for. We actually

617
00:24:09,120 --> 00:24:12,640
support two different query types, an

618
00:24:10,559 --> 00:24:14,240
and or an or operation. I'm going to

619
00:24:12,640 --> 00:24:16,880
keep it simple and just focus on the and

620
00:24:14,240 --> 00:24:19,360
which is just a multiplication.

621
00:24:16,880 --> 00:24:20,720
Thankfully, we have that SIMD packing

622
00:24:19,360 --> 00:24:22,159
that I was talking about before. So, we

623
00:24:20,720 --> 00:24:25,679
can actually compute all of this in

624
00:24:22,159 --> 00:24:28,080
parallel. we can just get a

625
00:24:25,679 --> 00:24:29,679
uh we can just look at the the cipher

626
00:24:28,080 --> 00:24:32,960
text for each column and perform this

627
00:24:29,679 --> 00:24:35,120
equality test once um to get the the

628
00:24:32,960 --> 00:24:36,640
full resulting vector back. And this

629
00:24:35,120 --> 00:24:38,880
predicate that I that I've mentioned

630
00:24:36,640 --> 00:24:41,120
before is basically going to be um zero

631
00:24:38,880 --> 00:24:43,760
or one depending on if the patient

632
00:24:41,120 --> 00:24:46,159
passes the filter or not. Again, we're

633
00:24:43,760 --> 00:24:48,400
computing this all homorphically. So the

634
00:24:46,159 --> 00:24:50,720
resulting vector for this predicate is

635
00:24:48,400 --> 00:24:54,000
going to be uh encrypted and it's going

636
00:24:50,720 --> 00:24:57,039
to have L slots which is that SIMD.

637
00:24:54,000 --> 00:24:58,960
Um we need to perform rotations and

638
00:24:57,039 --> 00:25:02,000
additions kind of to aggregate this to

639
00:24:58,960 --> 00:25:03,520
return back account for uh our

640
00:25:02,000 --> 00:25:06,720
researcher.

641
00:25:03,520 --> 00:25:08,640
So homorphic encryption also per um lets

642
00:25:06,720 --> 00:25:11,440
us perform rotation operations which is

643
00:25:08,640 --> 00:25:13,440
like rotating the cipher text slots um

644
00:25:11,440 --> 00:25:15,039
so that we can aggregate them. And this

645
00:25:13,440 --> 00:25:17,840
algorithm essentially just kind of

646
00:25:15,039 --> 00:25:19,919
rotates this log l times till we get the

647
00:25:17,840 --> 00:25:21,440
the inner sum of the entire vector and

648
00:25:19,919 --> 00:25:24,240
then we get back a count that we can

649
00:25:21,440 --> 00:25:26,559
finally return to a researcher.

650
00:25:24,240 --> 00:25:31,039
So what does this look like in practice?

651
00:25:26,559 --> 00:25:34,000
Well um for UK biioank scale for like

652
00:25:31,039 --> 00:25:36,159
let's say 5,000 patients and just having

653
00:25:34,000 --> 00:25:38,400
two filters like we have uh in this

654
00:25:36,159 --> 00:25:40,080
example counting query we can basically

655
00:25:38,400 --> 00:25:42,799
perform this entire operation in four

656
00:25:40,080 --> 00:25:45,919
minutes which is expensive. If you look

657
00:25:42,799 --> 00:25:48,159
uh at the the graph on the right where I

658
00:25:45,919 --> 00:25:50,240
have the the number of patients that

659
00:25:48,159 --> 00:25:53,279
we're performing a counting query on and

660
00:25:50,240 --> 00:25:55,440
the query time on the y-axis, it's much

661
00:25:53,279 --> 00:25:58,000
much slower than uh the plain text

662
00:25:55,440 --> 00:25:59,919
solution, but it's still on the order of

663
00:25:58,000 --> 00:26:02,320
minutes. So, it's not totally

664
00:25:59,919 --> 00:26:04,159
impractical.

665
00:26:02,320 --> 00:26:05,919
Um so, that was my introduction to Squid

666
00:26:04,159 --> 00:26:09,480
and the homorphic encryption primer. Do

667
00:26:05,919 --> 00:26:09,480
you guys have any questions?

668
00:26:19,919 --> 00:26:24,880
I I missed the beginning uh of your talk

669
00:26:22,240 --> 00:26:27,840
but uh can you use this for like real

670
00:26:24,880 --> 00:26:29,760
valued uh know expression so like gene

671
00:26:27,840 --> 00:26:31,279
expression or protein expression instead

672
00:26:29,760 --> 00:26:33,679
of just mutations?

673
00:26:31,279 --> 00:26:35,600
>> Yes. Yes. So

674
00:26:33,679 --> 00:26:37,679
I show I talked about an example of

675
00:26:35,600 --> 00:26:40,640
secure transformer inference which uses

676
00:26:37,679 --> 00:26:43,520
a protocol called CKKS

677
00:26:40,640 --> 00:26:45,520
um which works on floating point values

678
00:26:43,520 --> 00:26:48,159
and non non- integer values. Yes.

679
00:26:45,520 --> 00:26:50,640
>> And is the penalty similar to binary

680
00:26:48,159 --> 00:26:53,039
values or is the penalty much worse?

681
00:26:50,640 --> 00:26:57,520
>> No, it's about the the cost performance

682
00:26:53,039 --> 00:27:00,080
is about half. Um, so it's half half

683
00:26:57,520 --> 00:27:01,600
it's it takes twice as long to do this

684
00:27:00,080 --> 00:27:03,520
real value operation than it does for

685
00:27:01,600 --> 00:27:07,760
integers, but it's still very

686
00:27:03,520 --> 00:27:09,600
performant. It's a great question.

687
00:27:07,760 --> 00:27:10,159
>> Um, can we go back to the transformer

688
00:27:09,600 --> 00:27:10,799
examples?

689
00:27:10,159 --> 00:27:13,679
>> Yes.

690
00:27:10,799 --> 00:27:16,080
>> Um, I think these are the numbers for um

691
00:27:13,679 --> 00:27:18,559
with theom homorphic encryption that

692
00:27:16,080 --> 00:27:21,440
they're using, right? Um, what's the

693
00:27:18,559 --> 00:27:23,279
comparison with just

694
00:27:21,440 --> 00:27:25,360
without being concerned with the

695
00:27:23,279 --> 00:27:25,679
encryption? Yes, I should have included

696
00:27:25,360 --> 00:27:27,760
those

697
00:27:25,679 --> 00:27:30,000
>> a few orders of magnitude.

698
00:27:27,760 --> 00:27:32,559
>> Yes. Yes. Yes, for sure. Um because I

699
00:27:30,000 --> 00:27:34,960
mean a matrix multiplication of this

700
00:27:32,559 --> 00:27:36,559
input size is is going to be much much

701
00:27:34,960 --> 00:27:38,640
faster. I wish I had the numbers on

702
00:27:36,559 --> 00:27:41,640
here, but it's probably about 100 2,000x

703
00:27:38,640 --> 00:27:41,640
lower.

704
00:27:43,039 --> 00:27:46,480
>> I actually still have a couple questions

705
00:27:44,640 --> 00:27:48,080
that I I think I'm not understanding the

706
00:27:46,480 --> 00:27:49,120
uh

707
00:27:48,080 --> 00:27:52,080
>> the noise.

708
00:27:49,120 --> 00:27:54,480
>> Yes. Or is it just is this slowdown just

709
00:27:52,080 --> 00:27:58,080
because you have to like encode the

710
00:27:54,480 --> 00:27:59,360
values in a much larger uh data type

711
00:27:58,080 --> 00:28:01,679
than you normally would?

712
00:27:59,360 --> 00:28:05,360
>> Yeah, exactly. So how is it different

713
00:28:01,679 --> 00:28:10,080
from using like parody bits when you

714
00:28:05,360 --> 00:28:11,840
when you use when you do like regular

715
00:28:10,080 --> 00:28:12,880
you know signal analysis and things like

716
00:28:11,840 --> 00:28:13,919
that

717
00:28:12,880 --> 00:28:15,679
>> parody bits

718
00:28:13,919 --> 00:28:17,279
>> I mean so so the okay if if you're this

719
00:28:15,679 --> 00:28:19,120
is I was electrical engineer in a

720
00:28:17,279 --> 00:28:21,760
previous life so the idea is that

721
00:28:19,120 --> 00:28:24,640
basically you have um you know if you

722
00:28:21,760 --> 00:28:27,360
you you can uh make your addition and

723
00:28:24,640 --> 00:28:29,440
subtraction etc at the bit level more

724
00:28:27,360 --> 00:28:32,240
rob like robust to a certain number of

725
00:28:29,440 --> 00:28:34,000
arbitrary bits clips by adding in an

726
00:28:32,240 --> 00:28:34,799
extra set of parody bits and rules for

727
00:28:34,000 --> 00:28:35,840
checking them.

728
00:28:34,799 --> 00:28:36,240
>> Yes.

729
00:28:35,840 --> 00:28:37,200
>> Yes.

730
00:28:36,240 --> 00:28:39,679
>> Um

731
00:28:37,200 --> 00:28:41,520
>> you're just adding extra dimensions.

732
00:28:39,679 --> 00:28:42,480
>> You you just add more bits at the end of

733
00:28:41,520 --> 00:28:42,960
your number.

734
00:28:42,480 --> 00:28:44,880
>> I see.

735
00:28:42,960 --> 00:28:47,039
>> And then that lets you if you you can

736
00:28:44,880 --> 00:28:49,039
check to see like if any basically and

737
00:28:47,039 --> 00:28:50,799
they they represent like sums of the

738
00:28:49,039 --> 00:28:51,840
rest of the data.

739
00:28:50,799 --> 00:28:53,360
>> Oh, okay.

740
00:28:51,840 --> 00:28:54,799
>> And so then you can see like okay, if

741
00:28:53,360 --> 00:28:57,039
this part of the data doesn't sum to

742
00:28:54,799 --> 00:28:59,039
what the parody bits say they should,

743
00:28:57,039 --> 00:29:01,600
then you know that a bit flip has

744
00:28:59,039 --> 00:29:02,960
happened. And based on exactly how how

745
00:29:01,600 --> 00:29:04,240
the what the difference is, you can

746
00:29:02,960 --> 00:29:05,440
actually correct it.

747
00:29:04,240 --> 00:29:08,559
>> Yep.

748
00:29:05,440 --> 00:29:10,559
>> Um and that's sort of my mental model

749
00:29:08,559 --> 00:29:12,960
for how this might work. But I'm not

750
00:29:10,559 --> 00:29:15,600
sure if that's correct.

751
00:29:12,960 --> 00:29:18,720
>> Yeah, it's it's very different. Um

752
00:29:15,600 --> 00:29:20,240
because here we actually have to when we

753
00:29:18,720 --> 00:29:23,440
encrypt the message, we have to hide

754
00:29:20,240 --> 00:29:25,520
everything. Um so we have to essentially

755
00:29:23,440 --> 00:29:28,960
you can think about it as like a mask, a

756
00:29:25,520 --> 00:29:30,559
bit mask I guess essentially. um where

757
00:29:28,960 --> 00:29:33,120
we have our original data and then we

758
00:29:30,559 --> 00:29:34,960
have some masks secret and then we do

759
00:29:33,120 --> 00:29:37,919
some addition and that basically hides

760
00:29:34,960 --> 00:29:39,360
the the resulting data. Um there are no

761
00:29:37,919 --> 00:29:41,039
real I mean I guess there could be

762
00:29:39,360 --> 00:29:44,159
parity bits when you like send it back

763
00:29:41,039 --> 00:29:46,240
and forth. Um but nothing nothing here

764
00:29:44,159 --> 00:29:49,480
is is kind of related to this this idea

765
00:29:46,240 --> 00:29:49,480
of par.

766
00:29:59,679 --> 00:30:02,840
of my

767
00:30:10,320 --> 00:30:14,320
>> or if you use the par bits themselves as

768
00:30:12,559 --> 00:30:17,480
the encrypted message. Is that what you

769
00:30:14,320 --> 00:30:17,480
were thinking?

770
00:30:21,760 --> 00:30:25,720
>> That's a good point. Yeah. Okay.

771
00:30:31,279 --> 00:30:35,840
Maybe this is a silly question, but can

772
00:30:33,679 --> 00:30:37,840
you like is it possible to design

773
00:30:35,840 --> 00:30:40,080
hardware that does all these operations

774
00:30:37,840 --> 00:30:42,000
like in a customized way or are they so

775
00:30:40,080 --> 00:30:43,919
domain dependent or algorithm dependent

776
00:30:42,000 --> 00:30:46,399
that they change all the time?

777
00:30:43,919 --> 00:30:48,960
>> I I think there's work from an MIT group

778
00:30:46,399 --> 00:30:52,159
to do this on FPGAAS. I think that's the

779
00:30:48,960 --> 00:30:53,760
acronym. Um and it actually shows a

780
00:30:52,159 --> 00:30:57,279
quite significant improvement. I think

781
00:30:53,760 --> 00:31:00,880
they got um inference down to about a

782
00:30:57,279 --> 00:31:02,399
100 times slower than plain text. Um and

783
00:31:00,880 --> 00:31:06,240
you can also see that there's a lot of

784
00:31:02,399 --> 00:31:08,080
work to do it on GPUs. Nvidia, I think

785
00:31:06,240 --> 00:31:13,080
like two, three years ago, released

786
00:31:08,080 --> 00:31:13,080
Cutless, which was huge for our space

787
00:31:13,120 --> 00:31:17,840
um because it allowed us to do integer

788
00:31:15,200 --> 00:31:21,120
operations, 64-bit integer operations on

789
00:31:17,840 --> 00:31:23,279
a GPU since everything has to do every

790
00:31:21,120 --> 00:31:25,200
every operation,

791
00:31:23,279 --> 00:31:27,600
even if you're doing floating points

792
00:31:25,200 --> 00:31:29,039
from the CKKS that I introduced under

793
00:31:27,600 --> 00:31:30,799
the hood, these are still integer

794
00:31:29,039 --> 00:31:33,279
operations. You're just kind of scaling

795
00:31:30,799 --> 00:31:35,840
them to be uh from floats to to

796
00:31:33,279 --> 00:31:38,399
integers. Um so everything works under

797
00:31:35,840 --> 00:31:42,960
this integer uh ring that I introduced

798
00:31:38,399 --> 00:31:44,240
way in the beginning. Um so when Nvidia

799
00:31:42,960 --> 00:31:46,559
started releasing all of these new

800
00:31:44,240 --> 00:31:48,720
protocols do all these CUDA kernels to

801
00:31:46,559 --> 00:31:52,000
do this integer programming on a GPU

802
00:31:48,720 --> 00:31:53,840
that's kind of when this uh

803
00:31:52,000 --> 00:31:55,519
this this industry flu uh this this

804
00:31:53,840 --> 00:31:56,880
research angle flourished where people

805
00:31:55,519 --> 00:31:58,159
started to take these homorphic

806
00:31:56,880 --> 00:31:59,600
encryption algorithms and move them to

807
00:31:58,159 --> 00:32:02,640
the GPU and you can see quite a

808
00:31:59,600 --> 00:32:05,519
significant uh improvement. FPGAAS

809
00:32:02,640 --> 00:32:08,919
actually go even beyond what the the GPU

810
00:32:05,519 --> 00:32:08,919
performance is.

811
00:32:09,840 --> 00:32:13,600
>> Yeah. Still on hardware on the example

812
00:32:11,679 --> 00:32:16,000
you showed at the very end the four

813
00:32:13,600 --> 00:32:17,840
minute you know example. Yeah. What's

814
00:32:16,000 --> 00:32:19,679
the hardware roughly speaking?

815
00:32:17,840 --> 00:32:22,720
>> This is CPU.

816
00:32:19,679 --> 00:32:26,559
>> Um so unfortunately like the since we

817
00:32:22,720 --> 00:32:28,960
were using UK biioank data this is uh

818
00:32:26,559 --> 00:32:31,279
when we encrypted it it was around like

819
00:32:28,960 --> 00:32:32,880
one to two terabytes. It was huge. there

820
00:32:31,279 --> 00:32:34,640
there's quite a significant blow up when

821
00:32:32,880 --> 00:32:37,279
you perform this because the cipher text

822
00:32:34,640 --> 00:32:41,679
right you're storing a pair of polomials

823
00:32:37,279 --> 00:32:44,000
um for for each row in our database. So

824
00:32:41,679 --> 00:32:45,600
I it wasn't quite feasible to do this

825
00:32:44,000 --> 00:32:48,559
using hardware but it would certainly

826
00:32:45,600 --> 00:32:52,480
give hardware like GPUs but it would

827
00:32:48,559 --> 00:32:53,200
certainly give a nice performance boost.

828
00:32:52,480 --> 00:32:54,880
>> Yeah,

829
00:32:53,200 --> 00:32:57,519
>> I sort of have a question about Lauren's

830
00:32:54,880 --> 00:33:00,000
question. Sorry, I didn't understand how

831
00:32:57,519 --> 00:33:03,320
the parity bit stuff uh relate to the

832
00:33:00,000 --> 00:33:03,320
noise budget

833
00:33:03,760 --> 00:33:10,240
>> in the sense that like if you're doing

834
00:33:07,120 --> 00:33:12,480
binary operations like at the bit level,

835
00:33:10,240 --> 00:33:14,240
this is the it's a notion of a noise

836
00:33:12,480 --> 00:33:19,120
budget where like you can add more par

837
00:33:14,240 --> 00:33:20,799
bits to leave yourself room to have more

838
00:33:19,120 --> 00:33:24,159
Yeah. Yeah. So you can you can you can

839
00:33:20,799 --> 00:33:27,200
have more errors in your like you can

840
00:33:24,159 --> 00:33:30,799
have a noisier channel in the the um the

841
00:33:27,200 --> 00:33:33,120
signal analysis parlament um and by

842
00:33:30,799 --> 00:33:35,600
adding more but at the expense of your

843
00:33:33,120 --> 00:33:38,000
addition is now more cost or it's it's

844
00:33:35,600 --> 00:33:39,840
less cost effective because you are

845
00:33:38,000 --> 00:33:41,760
using more memory to perform the same

846
00:33:39,840 --> 00:33:44,960
operation.

847
00:33:41,760 --> 00:33:48,679
thinking back question.

848
00:33:44,960 --> 00:33:48,679
>> Oh, we have one more question.

849
00:33:49,279 --> 00:33:53,360
>> Sorry. Uh, so you talked about runtime.

850
00:33:51,679 --> 00:33:55,840
What about space? Do you have also like

851
00:33:53,360 --> 00:33:56,480
space penalties or

852
00:33:55,840 --> 00:34:00,720
there's a run?

853
00:33:56,480 --> 00:34:04,600
>> Yeah. Um, I can actually show you

854
00:34:00,720 --> 00:34:04,600
different slide deck.

855
00:34:09,040 --> 00:34:13,359
Yeah. So

856
00:34:11,200 --> 00:34:16,720
here we we kind of show the the storage

857
00:34:13,359 --> 00:34:20,800
costs. So this is for UK bio bank scale

858
00:34:16,720 --> 00:34:23,679
right when we do um

859
00:34:20,800 --> 00:34:28,240
let's see a whole genome sequencing it's

860
00:34:23,679 --> 00:34:30,000
about a thousand terabytes to store um a

861
00:34:28,240 --> 00:34:32,639
quarter of a million patients. So it's

862
00:34:30,000 --> 00:34:36,240
quite a significant blow up compared to

863
00:34:32,639 --> 00:34:37,760
the the plain text um storage. And if

864
00:34:36,240 --> 00:34:40,320
you're doing encryption at rest using

865
00:34:37,760 --> 00:34:43,359
AES, it's almost the same. Uh it's it's

866
00:34:40,320 --> 00:34:45,119
exactly the same. Um thankfully the

867
00:34:43,359 --> 00:34:46,879
packing algorithm really gives a nice

868
00:34:45,119 --> 00:34:48,399
performance boost where you can store a

869
00:34:46,879 --> 00:34:50,159
lot of information inside of a single

870
00:34:48,399 --> 00:34:53,679
cipher text. You just have to be kind of

871
00:34:50,159 --> 00:34:56,159
clever with um how you perform the query

872
00:34:53,679 --> 00:34:58,800
operations um afterwards.

873
00:34:56,159 --> 00:35:02,320
>> So this is storage cost. What about RAM?

874
00:34:58,800 --> 00:35:04,800
>> RAM. Yes. So the the way I kind of

875
00:35:02,320 --> 00:35:08,160
implemented Squid was everything is

876
00:35:04,800 --> 00:35:09,920
stored on disk and when you perform a

877
00:35:08,160 --> 00:35:11,839
query operation, you only load the

878
00:35:09,920 --> 00:35:13,839
cipher text into memory that you're

879
00:35:11,839 --> 00:35:15,760
going to use for a specific operation.

880
00:35:13,839 --> 00:35:19,040
So for the filtering query, right, we

881
00:35:15,760 --> 00:35:21,040
only look at uh in that example the snip

882
00:35:19,040 --> 00:35:22,800
2 column and the sex column. So you

883
00:35:21,040 --> 00:35:24,720
would load those into RAM from the

884
00:35:22,800 --> 00:35:26,880
database and then you would perform uh

885
00:35:24,720 --> 00:35:28,880
everything on them.

886
00:35:26,880 --> 00:35:31,359
So actually for the GPU example, you

887
00:35:28,880 --> 00:35:35,560
could um load those onto the GPU and

888
00:35:31,359 --> 00:35:35,560
then perform the uh the analysis.

889
00:35:37,040 --> 00:35:40,880
Those cipher texts individually are

890
00:35:38,480 --> 00:35:43,040
actually quite large still because you

891
00:35:40,880 --> 00:35:44,240
have basically one cipher text for

892
00:35:43,040 --> 00:35:48,119
almost all of your patients in your

893
00:35:44,240 --> 00:35:48,119
database when you do this.

894
00:35:48,560 --> 00:35:52,760
>> Thank you.

895
00:35:49,200 --> 00:35:52,760
>> Okay. Thank you.

