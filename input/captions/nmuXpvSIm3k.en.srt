1
00:00:12,920 --> 00:00:18,279
it's our last class which is happy

2
00:00:15,679 --> 00:00:19,800
because we get to go on break but

3
00:00:18,279 --> 00:00:22,119
there's so much more I want to tell you

4
00:00:19,800 --> 00:00:24,400
guys so but you know that's all we have

5
00:00:22,119 --> 00:00:26,480
time for uh there are cookies here for

6
00:00:24,400 --> 00:00:28,560
to make our last class sweet so please

7
00:00:26,480 --> 00:00:32,759
come and get some if you want they're

8
00:00:28,560 --> 00:00:35,000
very small so you can take to uh or you

9
00:00:32,759 --> 00:00:36,600
know if you didn't want to commit a

10
00:00:35,000 --> 00:00:42,039
large cookie you don't need

11
00:00:36,600 --> 00:00:43,559
to so uh okay so today uh finally we're

12
00:00:42,039 --> 00:00:45,640
going to actually construct the snars

13
00:00:43,559 --> 00:00:50,079
that we've been after that was kind of

14
00:00:45,640 --> 00:00:52,840
the goal uh is to uh construct uh snars

15
00:00:50,079 --> 00:00:56,320
s interactive arguments and like this

16
00:00:52,840 --> 00:00:57,640
entire course was a buildup to construct

17
00:00:56,320 --> 00:00:59,559
uh these snars and today we're going to

18
00:00:57,640 --> 00:01:00,960
see how to construct them uh they

19
00:00:59,559 --> 00:01:03,879
cookies

20
00:01:00,960 --> 00:01:06,040
guys cookies if you want from flower

21
00:01:03,879 --> 00:01:09,920
really good ones so feel free to take

22
00:01:06,040 --> 00:01:11,479
some um okay so uh what we're going to

23
00:01:09,920 --> 00:01:15,720
do today is show how to construct these

24
00:01:11,479 --> 00:01:18,920
snarks uh and uh we're gonna last class

25
00:01:15,720 --> 00:01:22,479
Jen Jang uh uh showed you is a really

26
00:01:18,920 --> 00:01:24,000
beautiful work on constructing bargs

27
00:01:22,479 --> 00:01:27,000
which are batch

28
00:01:24,000 --> 00:01:29,920
argument and you know on their own you

29
00:01:27,000 --> 00:01:31,079
can say uh why do we care about B

30
00:01:29,920 --> 00:01:33,479
argument I'm going to recall the

31
00:01:31,079 --> 00:01:35,560
definition but the I mean it's

32
00:01:33,479 --> 00:01:38,119
interesting on its own but what makes it

33
00:01:35,560 --> 00:01:40,520
super interesting is that we can use it

34
00:01:38,119 --> 00:01:43,040
in a pretty straightforward manner to

35
00:01:40,520 --> 00:01:44,719
construct snars so that's what we're

36
00:01:43,040 --> 00:01:47,240
going to see today we're going to see

37
00:01:44,719 --> 00:01:49,119
how to use these bars that I'm going to

38
00:01:47,240 --> 00:01:51,920
recall the definition in a second and

39
00:01:49,119 --> 00:01:54,759
also how to use I think Jen Jong called

40
00:01:51,920 --> 00:01:56,520
it a somewhere statistically binding

41
00:01:54,759 --> 00:01:58,719
hash functions it's also known in the

42
00:01:56,520 --> 00:02:00,399
literature as somewh extractable hash

43
00:01:58,719 --> 00:02:02,399
functions both are used so I'm just

44
00:02:00,399 --> 00:02:07,599
going to use the other just so familiar

45
00:02:02,399 --> 00:02:09,920
with both uh a uh formulations uh both

46
00:02:07,599 --> 00:02:12,680
names uh so what we're going to see

47
00:02:09,920 --> 00:02:14,640
today is how to use these bars with with

48
00:02:12,680 --> 00:02:17,360
these hash functions to get

49
00:02:14,640 --> 00:02:20,400
snars that's kind of uh the plan for

50
00:02:17,360 --> 00:02:24,200
today uh so let me first recall what a

51
00:02:20,400 --> 00:02:27,840
barg is really uh fast so a bar you want

52
00:02:24,200 --> 00:02:30,120
to kind of prove that many instances

53
00:02:27,840 --> 00:02:32,599
belong to an NP language so about Mark

54
00:02:30,120 --> 00:02:36,680
for an NP language L consists of three

55
00:02:32,599 --> 00:02:38,959
algorithm gen uh takes as input a

56
00:02:36,680 --> 00:02:41,519
security parameter the number of

57
00:02:38,959 --> 00:02:44,519
instances you want to batch maybe I'll

58
00:02:41,519 --> 00:02:47,840
close thank you can you close the door

59
00:02:44,519 --> 00:02:50,239
thanks uh K which is the number of

60
00:02:47,840 --> 00:02:52,440
instances you want to batch and N with

61
00:02:50,239 --> 00:02:54,440
which is the length of each instance and

62
00:02:52,440 --> 00:02:57,760
then

63
00:02:54,440 --> 00:02:57,760
output uh some

64
00:02:57,840 --> 00:03:03,480
CRS note Lambda is given in unary

65
00:03:01,040 --> 00:03:06,000
because we want them to run in time poly

66
00:03:03,480 --> 00:03:07,280
Lambda but K and N are given in binary

67
00:03:06,000 --> 00:03:10,480
so because it's polinomial time

68
00:03:07,280 --> 00:03:14,200
algorithm it runs in time poog in K poog

69
00:03:10,480 --> 00:03:18,920
in N the instant size okay and then the

70
00:03:14,200 --> 00:03:24,599
Prov algorithm takes as input uh the

71
00:03:18,920 --> 00:03:27,840
CRS and then X1 up to xn uh XK sorry so

72
00:03:24,599 --> 00:03:31,760
K elements with

73
00:03:27,840 --> 00:03:31,760
Witnesses and outputs

74
00:03:32,519 --> 00:03:38,280
uh proof

75
00:03:34,799 --> 00:03:42,319
Pi but importantly this proof should be

76
00:03:38,280 --> 00:03:42,319
small so this Pi is of

77
00:03:43,480 --> 00:03:53,439
size uh poly log or poly in security

78
00:03:49,120 --> 00:03:55,680
parameter but log K that's

79
00:03:53,439 --> 00:03:59,120
important okay we want it to depend only

80
00:03:55,680 --> 00:04:01,599
Poly arthic on on K that's kind of our

81
00:03:59,120 --> 00:04:03,879
goal okay okay and then maybe ideally

82
00:04:01,599 --> 00:04:05,840
also log n but the point is we want it

83
00:04:03,879 --> 00:04:08,120
to be succinct okay otherwise it's

84
00:04:05,840 --> 00:04:09,360
trivial you just output the witnesses

85
00:04:08,120 --> 00:04:13,599
and the

86
00:04:09,360 --> 00:04:18,639
verifier takes his input CRS the

87
00:04:13,599 --> 00:04:18,639
instances and a proof and it output

88
00:04:19,560 --> 00:04:26,560
01 accept or reject okay and this but

89
00:04:24,320 --> 00:04:28,800
when I say the size of the proof is this

90
00:04:26,560 --> 00:04:30,600
actually you can make it bigger smaller

91
00:04:28,800 --> 00:04:34,680
but we want it to be SU

92
00:04:30,600 --> 00:04:37,440
okay that's oh sorry I uh sorry I

93
00:04:34,680 --> 00:04:40,560
didn't we wanted to depend only

94
00:04:37,440 --> 00:04:45,919
logarithmically and K so on

95
00:04:40,560 --> 00:04:49,360
but we allow it to depend uh L polom and

96
00:04:45,919 --> 00:04:53,720
one in one witness okay so I can put it

97
00:04:49,360 --> 00:04:54,960
here a single witness one not many

98
00:04:53,720 --> 00:04:57,600
ideally we want to be as exing as

99
00:04:54,960 --> 00:05:01,440
possible but what we can get is a as a

100
00:04:57,600 --> 00:05:04,639
bar that depends grows with one instance

101
00:05:01,440 --> 00:05:07,680
one witness as opposed to K

102
00:05:04,639 --> 00:05:10,800
instances okay so uh so this is kind of

103
00:05:07,680 --> 00:05:12,600
the the algorithms uh then we want

104
00:05:10,800 --> 00:05:15,360
completeness and soundness completeness

105
00:05:12,600 --> 00:05:19,160
is the usual thing that just says if P

106
00:05:15,360 --> 00:05:21,400
has valid Witnesses and he generates a

107
00:05:19,160 --> 00:05:24,199
bar this bar is going to be accepting

108
00:05:21,400 --> 00:05:26,560
with probability one over kind of the

109
00:05:24,199 --> 00:05:29,199
CRS generation so that's the standard

110
00:05:26,560 --> 00:05:30,319
completeness and then uh the soundness

111
00:05:29,199 --> 00:05:33,720
property

112
00:05:30,319 --> 00:05:37,560
that uh that we have ideally you would

113
00:05:33,720 --> 00:05:40,160
want to say that uh so in soundless

114
00:05:37,560 --> 00:05:42,080
computational soundness we have adaptive

115
00:05:40,160 --> 00:05:43,560
soundness and nonadaptive soundness and

116
00:05:42,080 --> 00:05:46,319
we want to we want to say that the a

117
00:05:43,560 --> 00:05:48,919
cheating prover cannot convince you of a

118
00:05:46,319 --> 00:05:51,759
false statement so he cannot generate he

119
00:05:48,919 --> 00:05:54,800
cannot give you X's that are not all in

120
00:05:51,759 --> 00:05:58,280
the language with a valid proof that

121
00:05:54,800 --> 00:05:59,960
soundless okay there's an issue is when

122
00:05:58,280 --> 00:06:03,319
does the cheating Pro gets to choose

123
00:05:59,960 --> 00:06:06,560
these X's is it before he sees the CRS

124
00:06:03,319 --> 00:06:09,000
or after he sees the CRS if he needs to

125
00:06:06,560 --> 00:06:10,840
decide them before he sees the CRS then

126
00:06:09,000 --> 00:06:12,319
it's non adaptive if you get to decide

127
00:06:10,840 --> 00:06:15,639
it after then it's

128
00:06:12,319 --> 00:06:20,360
adaptive ideally we want to say it's

129
00:06:15,639 --> 00:06:23,319
secure for all like very uh all as big

130
00:06:20,360 --> 00:06:24,520
classes provs as possible and thus we

131
00:06:23,319 --> 00:06:26,800
would like to have sounds against

132
00:06:24,520 --> 00:06:30,280
adaptive provs to say even if a cheating

133
00:06:26,800 --> 00:06:33,199
prover chooses this X1 of XC

134
00:06:30,280 --> 00:06:36,919
adaptably after seeing the CRS if one of

135
00:06:33,199 --> 00:06:39,000
them is false he cannot generate a proof

136
00:06:36,919 --> 00:06:42,199
that's what we would like to say what we

137
00:06:39,000 --> 00:06:44,680
can say is what's called a semi adaptive

138
00:06:42,199 --> 00:06:48,759
something in between okay so let me just

139
00:06:44,680 --> 00:06:48,759
write it here so semi-adaptive sound

140
00:06:54,240 --> 00:07:02,360
is just says the adversary needs to tell

141
00:06:58,360 --> 00:07:05,479
you which in so he's going to give you K

142
00:07:02,360 --> 00:07:07,840
instances he can choose them adaptively

143
00:07:05,479 --> 00:07:10,879
but he needs to choose the ion which is

144
00:07:07,840 --> 00:07:12,680
going to cheat so he's a cheater so one

145
00:07:10,879 --> 00:07:15,919
of that eyes is not in the

146
00:07:12,680 --> 00:07:17,960
language which ey which location I the

147
00:07:15,919 --> 00:07:20,360
XI is going to be not in the language

148
00:07:17,960 --> 00:07:25,440
that should not depend on the CRS okay

149
00:07:20,360 --> 00:07:25,440
so so it says that for any poly

150
00:07:26,759 --> 00:07:35,800
size P star and for for every I which of

151
00:07:31,919 --> 00:07:37,879
course may depend on on Lambda because

152
00:07:35,800 --> 00:07:41,560
for any Lambda you have an i because the

153
00:07:37,879 --> 00:07:44,000
I is between one and K and K grows with

154
00:07:41,560 --> 00:07:47,360
can grow with Lambda so for any I you

155
00:07:44,000 --> 00:07:49,800
want to say the probability that P star

156
00:07:47,360 --> 00:07:49,800
given a

157
00:07:50,000 --> 00:08:00,280
CRS outputs X1 up to XK and

158
00:07:55,000 --> 00:08:04,400
Pi such that x i is not in the language

159
00:08:00,280 --> 00:08:06,560
and Pi is accepted is negligible so XI

160
00:08:04,400 --> 00:08:09,039
one of them is the XI one is not in the

161
00:08:06,560 --> 00:08:13,240
language and the I was chosen before he

162
00:08:09,039 --> 00:08:16,280
saw the CRS okay so for any P star he

163
00:08:13,240 --> 00:08:20,240
tells you I'm going to cheat on location

164
00:08:16,280 --> 00:08:23,319
I now he's given a CRS the probability

165
00:08:20,240 --> 00:08:25,319
that he gives you an accepting proof for

166
00:08:23,319 --> 00:08:27,919
X on of dek that he chose adaptively

167
00:08:25,319 --> 00:08:30,800
after seeing the CRS the probability

168
00:08:27,919 --> 00:08:36,440
that it's accepting so

169
00:08:30,800 --> 00:08:36,440
CRS uh X1 up to XK and Pi is

170
00:08:39,120 --> 00:08:45,040
one and X is not in the language x i is

171
00:08:43,200 --> 00:08:49,920
not is

172
00:08:45,040 --> 00:08:49,920
negligible this equals

173
00:08:51,560 --> 00:08:56,320
negligible okay so again for any

174
00:08:54,560 --> 00:08:58,880
cheating prover he needs to ahead of

175
00:08:56,320 --> 00:09:01,360
time I'm going to choose my xon XK

176
00:08:58,880 --> 00:09:03,320
adaptively after I see the CRS but I'm

177
00:09:01,360 --> 00:09:06,320
going to I'm going to cheat on location

178
00:09:03,320 --> 00:09:07,800
I the probability that he succeeds in

179
00:09:06,320 --> 00:09:11,680
cheating in location

180
00:09:07,800 --> 00:09:15,360
I in an accepting way is

181
00:09:11,680 --> 00:09:20,279
negligible that's the semi-adaptive

182
00:09:15,360 --> 00:09:22,560
soundness okay so and uh last class

183
00:09:20,279 --> 00:09:25,440
jenong kind of showed you the high level

184
00:09:22,560 --> 00:09:27,120
of how you construct such a like the

185
00:09:25,440 --> 00:09:30,480
construction of such a

186
00:09:27,120 --> 00:09:32,959
bar okay any questions yes uh is piz

187
00:09:30,480 --> 00:09:35,079
required like the indices other than I

188
00:09:32,959 --> 00:09:37,760
are those required to be act like in the

189
00:09:35,079 --> 00:09:40,160
language or no no we don't care so yeah

190
00:09:37,760 --> 00:09:42,120
good question so the P star can choose

191
00:09:40,160 --> 00:09:43,839
the rest of the X's however he wants in

192
00:09:42,120 --> 00:09:44,720
the language outside the language

193
00:09:43,839 --> 00:09:49,360
however he

194
00:09:44,720 --> 00:09:51,399
wants okay but he wins if the XI is not

195
00:09:49,360 --> 00:09:55,560
in the language and the pi is

196
00:09:51,399 --> 00:09:57,839
accepting and he wins with probability

197
00:09:55,560 --> 00:10:00,600
yes transforming this into fully

198
00:09:57,839 --> 00:10:02,839
adaptive will imply

199
00:10:00,600 --> 00:10:07,040
guessing

200
00:10:02,839 --> 00:10:10,480
yeah okay uh good so the question is can

201
00:10:07,040 --> 00:10:15,640
why like can we transform this into a

202
00:10:10,480 --> 00:10:18,079
fully adaptive snar so ah converting it

203
00:10:15,640 --> 00:10:22,200
into a fully adaptive

204
00:10:18,079 --> 00:10:25,800
snar is um non-trial and I'll tell you

205
00:10:22,200 --> 00:10:27,920
why you can you can guess I you can

206
00:10:25,800 --> 00:10:29,959
guess I and you'll guess it correctly

207
00:10:27,920 --> 00:10:30,760
with probability one over k

208
00:10:29,959 --> 00:10:33,600
in

209
00:10:30,760 --> 00:10:35,880
general but here is so you you can do

210
00:10:33,600 --> 00:10:39,320
the you can do it but here is the issue

211
00:10:35,880 --> 00:10:42,519
I'll tell you what what um complication

212
00:10:39,320 --> 00:10:45,320
is in the analysis so I I don't want to

213
00:10:42,519 --> 00:10:47,279
recall too much the construction but the

214
00:10:45,320 --> 00:10:48,839
high level idea of how these bars are

215
00:10:47,279 --> 00:10:51,000
analyzed even without kind of knowing

216
00:10:48,839 --> 00:10:54,519
the construction uh the way they're

217
00:10:51,000 --> 00:10:56,839
analyzed in this CRS so in the proof in

218
00:10:54,519 --> 00:10:57,839
the analysis we say Suppose there exists

219
00:10:56,839 --> 00:11:00,360
some cheating

220
00:10:57,839 --> 00:11:02,560
prover that Che on some

221
00:11:00,360 --> 00:11:04,760
ey in the

222
00:11:02,560 --> 00:11:06,200
CRS I'm going to I'm going to change the

223
00:11:04,760 --> 00:11:09,120
CRS now I'm going to tell the cheating

224
00:11:06,200 --> 00:11:11,680
Pro here's a new CRS and in this new CRS

225
00:11:09,120 --> 00:11:13,440
I'm going to kind of hardwire I I'm

226
00:11:11,680 --> 00:11:14,720
going to put some information about I in

227
00:11:13,440 --> 00:11:17,120
a way that's

228
00:11:14,720 --> 00:11:18,720
unnoticeable okay and when we'll see I'm

229
00:11:17,120 --> 00:11:22,079
going to call the somewh extractable

230
00:11:18,720 --> 00:11:24,639
hash or what J called SSB hash some more

231
00:11:22,079 --> 00:11:26,839
statistically binding and then you I'll

232
00:11:24,639 --> 00:11:29,880
remind you a little bit how we where we

233
00:11:26,839 --> 00:11:31,920
stick the the index ey but in analysis

234
00:11:29,880 --> 00:11:34,160
we say you know let me change the CRS to

235
00:11:31,920 --> 00:11:35,399
a CRS a different CRS it has a very

236
00:11:34,160 --> 00:11:36,959
different distribution but it's

237
00:11:35,399 --> 00:11:39,880
indistinguishable it looks the like the

238
00:11:36,959 --> 00:11:43,040
original CRS so P star can't distinguish

239
00:11:39,880 --> 00:11:46,320
between the two so he'll still give me a

240
00:11:43,040 --> 00:11:49,000
valid bar okay and now I'm going to say

241
00:11:46,320 --> 00:11:50,800
in this new CRS actually there's no way

242
00:11:49,000 --> 00:11:53,399
he can cheat on location I there's no

243
00:11:50,800 --> 00:11:55,399
way he can cheat okay what is the issue

244
00:11:53,399 --> 00:11:57,000
so now you're saying why why do we need

245
00:11:55,399 --> 00:12:00,639
why can't we do fully

246
00:11:57,000 --> 00:12:03,920
adaptive the the issue is it may be the

247
00:12:00,639 --> 00:12:06,360
case that once we switch the CRS it

248
00:12:03,920 --> 00:12:07,839
switches where he's cheating so here's

249
00:12:06,360 --> 00:12:09,800
an here's an alternative way let's say

250
00:12:07,839 --> 00:12:11,720
the approver tells you here you know I'm

251
00:12:09,800 --> 00:12:13,920
going to cheat in location I but I can

252
00:12:11,720 --> 00:12:16,480
be adaptive chosen based on the

253
00:12:13,920 --> 00:12:18,079
CRS so now in the analysis I'm going to

254
00:12:16,480 --> 00:12:19,720
say I'm GNA guess where he cheated I'm

255
00:12:18,079 --> 00:12:22,519
GNA say let's guess he cheated location

256
00:12:19,720 --> 00:12:25,480
seven I'm GNA hardwire kind of the CRS

257
00:12:22,519 --> 00:12:27,920
to depend on this location and then the

258
00:12:25,480 --> 00:12:30,279
cheatting pro doesn't cheat on seven it

259
00:12:27,920 --> 00:12:32,720
cheat on something else he can kind of

260
00:12:30,279 --> 00:12:34,320
evade me now you're saying oh if he

261
00:12:32,720 --> 00:12:36,560
cheat something else I can tell I can

262
00:12:34,320 --> 00:12:38,720
tell the difference so like I shouldn't

263
00:12:36,560 --> 00:12:40,040
be able to tell but the thing is you

264
00:12:38,720 --> 00:12:42,480
don't know what's in the language it's

265
00:12:40,040 --> 00:12:44,560
not what's not in the language so the

266
00:12:42,480 --> 00:12:46,639
the problem is whether XI is in the

267
00:12:44,560 --> 00:12:49,680
language or not in the language can be

268
00:12:46,639 --> 00:12:52,800
very hard to tell it may

269
00:12:49,680 --> 00:12:56,040
take and that's why kind of getting

270
00:12:52,800 --> 00:12:59,320
adaptive like just guessing is

271
00:12:56,040 --> 00:13:02,360
not is not uh good enough because he

272
00:12:59,320 --> 00:13:04,079
needs to the the issue is if you could

273
00:13:02,360 --> 00:13:07,240
tell efficiently whether exi is in the

274
00:13:04,079 --> 00:13:09,600
language or not in the language then yes

275
00:13:07,240 --> 00:13:12,680
but because it can be very

276
00:13:09,600 --> 00:13:15,760
hard that's where things become tricky

277
00:13:12,680 --> 00:13:20,680
so that's so you can guess but it's not

278
00:13:15,760 --> 00:13:20,680
good enough is is uh the

279
00:13:21,839 --> 00:13:28,120
answer okay any yeah

280
00:13:24,440 --> 00:13:30,720
even huh even if he commits to

281
00:13:28,120 --> 00:13:33,440
do will that

282
00:13:30,720 --> 00:13:35,800
be well he can com what do you mean he

283
00:13:33,440 --> 00:13:37,920
commits the so you're saying let's

284
00:13:35,800 --> 00:13:39,800
change the scheme kind of and have him

285
00:13:37,920 --> 00:13:43,440
add commitment

286
00:13:39,800 --> 00:13:46,079
or I guess not be

287
00:13:43,440 --> 00:13:48,800
that I I guess the issue is look when

288
00:13:46,079 --> 00:13:51,040
he's cheating we don't know whether like

289
00:13:48,800 --> 00:13:54,000
he gives you X1 of to XK and and approve

290
00:13:51,040 --> 00:13:55,639
Pi now he cheats if one of them is not

291
00:13:54,000 --> 00:13:58,519
in the language that's when he cheats

292
00:13:55,639 --> 00:14:00,560
it's hard to know whether one of them is

293
00:13:58,519 --> 00:14:02,639
in the language are not in the language

294
00:14:00,560 --> 00:14:03,680
and the concern is he can say I he can

295
00:14:02,639 --> 00:14:06,720
say whatever he wants he's going to

296
00:14:03,680 --> 00:14:09,480
cheat so nothing he says we we we

297
00:14:06,720 --> 00:14:11,759
believe right and the concern is that

298
00:14:09,480 --> 00:14:15,320
maybe when we switch the CRS to kind of

299
00:14:11,759 --> 00:14:17,600
depend on I all the exite becomes in the

300
00:14:15,320 --> 00:14:18,440
language and then what do you do and now

301
00:14:17,600 --> 00:14:19,519
you can say you can't tell the

302
00:14:18,440 --> 00:14:21,279
difference because exide in the language

303
00:14:19,519 --> 00:14:25,079
and outside the language they look the

304
00:14:21,279 --> 00:14:27,240
same so that's why kind of guessing is

305
00:14:25,079 --> 00:14:29,639
is in some sense not good enough like

306
00:14:27,240 --> 00:14:33,680
it's not helpful

307
00:14:29,639 --> 00:14:33,680
okay so this is uh any other

308
00:14:34,079 --> 00:14:37,759
questions okay so this is one ingredient

309
00:14:36,320 --> 00:14:42,040
that we're going to use to construct our

310
00:14:37,759 --> 00:14:45,839
snar the other ingredient is uh what's

311
00:14:42,040 --> 00:14:48,079
what uh the some extractable hash or SSB

312
00:14:45,839 --> 00:14:49,920
has so let me write it out I'm going to

313
00:14:48,079 --> 00:14:52,279
write it here uh so we'll keep it on the

314
00:14:49,920 --> 00:14:53,399
board so that's so let me just recall

315
00:14:52,279 --> 00:14:57,720
the

316
00:14:53,399 --> 00:14:59,680
definition uh somewhere extractable hash

317
00:14:57,720 --> 00:15:03,600
family uh

318
00:14:59,680 --> 00:15:05,720
consists of uh many several PPT

319
00:15:03,600 --> 00:15:08,120
algorithm let me start writing so so the

320
00:15:05,720 --> 00:15:12,360
first one is uh

321
00:15:08,120 --> 00:15:15,519
gen gen so now we're constructing a hash

322
00:15:12,360 --> 00:15:18,000
okay so gen takes a security

323
00:15:15,519 --> 00:15:20,000
parameter the length how many bits we're

324
00:15:18,000 --> 00:15:23,680
going to Hash so let's say n Bits we're

325
00:15:20,000 --> 00:15:25,720
going to hash and how many and okay so

326
00:15:23,680 --> 00:15:27,440
let's say in the location I this is

327
00:15:25,720 --> 00:15:29,160
going to be I and N this is where we're

328
00:15:27,440 --> 00:15:33,519
going to be binding on or where want to

329
00:15:29,160 --> 00:15:33,519
be extractable on and it

330
00:15:33,600 --> 00:15:40,240
outputs a hash key and a trap door this

331
00:15:38,360 --> 00:15:41,880
trapid door is going to be we're going

332
00:15:40,240 --> 00:15:46,000
to use it to kind of extract from the

333
00:15:41,880 --> 00:15:48,160
hash the I location of what we hashed

334
00:15:46,000 --> 00:15:50,519
okay so there's a hash key and a trapo I

335
00:15:48,160 --> 00:15:51,920
know when Jen Jen taught it then he just

336
00:15:50,519 --> 00:15:53,639
said hash key and he put kind of the

337
00:15:51,920 --> 00:15:55,000
trapo at the end so I'm I'm going to

338
00:15:53,639 --> 00:15:57,800
write it with a

339
00:15:55,000 --> 00:16:00,519
trapdoor okay so Jen outputs a hash key

340
00:15:57,800 --> 00:16:04,839
and a trapo and then you have eval

341
00:16:00,519 --> 00:16:08,240
algorithm it just takes the hash key uh

342
00:16:04,839 --> 00:16:12,399
uh input X and 01 to the

343
00:16:08,240 --> 00:16:16,279
n and then output a hash value

344
00:16:12,399 --> 00:16:20,959
V uh and then you have

345
00:16:16,279 --> 00:16:24,360
open where you take a hash key the X and

346
00:16:20,959 --> 00:16:28,319
some index J that you want to open

347
00:16:24,360 --> 00:16:29,440
to and it outputs an opening row or row

348
00:16:28,319 --> 00:16:34,040
J

349
00:16:29,440 --> 00:16:36,199
and this should be in 01 to the Lambda

350
00:16:34,040 --> 00:16:41,480
or poly Lambda similar here this should

351
00:16:36,199 --> 00:16:41,480
be small 01 to the Lambda or poly

352
00:16:45,079 --> 00:16:52,720
Lambda and then there's ver that

353
00:16:48,040 --> 00:16:54,600
verifies so ver takes a hash key a value

354
00:16:52,720 --> 00:16:58,240
and now you you let's say you want to

355
00:16:54,600 --> 00:17:01,040
say I'm going to open location J here's

356
00:16:58,240 --> 00:17:03,360
my B that opens and here's the

357
00:17:01,040 --> 00:17:07,280
opening and he checks is it valid

358
00:17:03,360 --> 00:17:07,280
opening or not so it

359
00:17:07,880 --> 00:17:11,439
outputs zero or

360
00:17:11,959 --> 00:17:18,880
one and finally so consist of

361
00:17:15,880 --> 00:17:21,720
five vpt

362
00:17:18,880 --> 00:17:25,199
algorithms so first you generate a hash

363
00:17:21,720 --> 00:17:28,039
key with a trapo then uh there's an eval

364
00:17:25,199 --> 00:17:31,640
algorithm that given nbit string outputs

365
00:17:28,039 --> 00:17:36,000
the hash value v short succinct then

366
00:17:31,640 --> 00:17:38,280
there's open that you can open given uh

367
00:17:36,000 --> 00:17:42,720
that you can generate an opening for

368
00:17:38,280 --> 00:17:45,280
specific index J so you generate row J

369
00:17:42,720 --> 00:17:47,720
which is an opening and anybody can

370
00:17:45,280 --> 00:17:50,039
verify the opening using only the

371
00:17:47,720 --> 00:17:53,240
succinct hash value okay so given a hash

372
00:17:50,039 --> 00:17:56,159
key the succinct hash value the index

373
00:17:53,240 --> 00:18:00,520
the bit you can verify the opening and

374
00:17:56,159 --> 00:18:00,520
finally that's the extract algorithm

375
00:18:01,360 --> 00:18:07,960
and it takes the

376
00:18:03,000 --> 00:18:13,400
trapo and the value and it outputs a

377
00:18:07,960 --> 00:18:18,760
bit and this bit should be

378
00:18:13,400 --> 00:18:21,760
XI okay so let me say the the uh

379
00:18:18,760 --> 00:18:21,760
properties

380
00:18:23,880 --> 00:18:29,240
so the first property is completeness

381
00:18:26,760 --> 00:18:32,000
that's kind of usually the a

382
00:18:29,240 --> 00:18:32,000
straightforward

383
00:18:33,520 --> 00:18:37,440
property which essentially says look if

384
00:18:35,559 --> 00:18:40,440
everybody's honest you get what you

385
00:18:37,440 --> 00:18:42,799
expect which means one the verifier

386
00:18:40,440 --> 00:18:47,200
would accept the opening and B the

387
00:18:42,799 --> 00:18:50,960
extract will output the I bit so it says

388
00:18:47,200 --> 00:18:53,159
that the probability okay so for every X

389
00:18:50,960 --> 00:18:57,039
for every Lambda for

390
00:18:53,159 --> 00:18:59,440
every uh n which is at most two to the

391
00:18:57,039 --> 00:19:02,080
Lambda we always restrict the length of

392
00:18:59,440 --> 00:19:03,159
what we're we're hashing to be at most 2

393
00:19:02,080 --> 00:19:07,919
to the

394
00:19:03,159 --> 00:19:07,919
Lambda and for every

395
00:19:08,120 --> 00:19:11,880
I we say that the

396
00:19:12,679 --> 00:19:16,640
probability that

397
00:19:17,120 --> 00:19:25,480
a open sorry that

398
00:19:21,200 --> 00:19:27,080
there an hash key generated from gen V

399
00:19:25,480 --> 00:19:30,960
which is

400
00:19:27,080 --> 00:19:30,960
theal ah and for every

401
00:19:33,480 --> 00:19:39,080
J J row

402
00:19:37,080 --> 00:19:42,159
generated by

403
00:19:39,080 --> 00:19:45,320
open it always outputs one it outputs on

404
00:19:42,159 --> 00:19:48,440
probability one and

405
00:19:45,320 --> 00:19:51,280
extract I'll just denote by okay extract

406
00:19:48,440 --> 00:19:56,400
let me denote by just X for Simplicity

407
00:19:51,280 --> 00:19:58,280
uh given trap door and V output x i and

408
00:19:56,400 --> 00:20:02,840
this hold with probability one where the

409
00:19:58,280 --> 00:20:07,520
probability is over what hash key and

410
00:20:02,840 --> 00:20:09,880
trapo are in gen so essentially I won't

411
00:20:07,520 --> 00:20:14,760
write it but the hash key is generated

412
00:20:09,880 --> 00:20:17,440
by this V is generated by this eval row

413
00:20:14,760 --> 00:20:19,159
or I'll call row J is

414
00:20:17,440 --> 00:20:22,520
generated by

415
00:20:19,159 --> 00:20:24,960
open and this just says if if everything

416
00:20:22,520 --> 00:20:27,559
was done correctly the ver always

417
00:20:24,960 --> 00:20:30,000
accepts and the extract indeed will

418
00:20:27,559 --> 00:20:31,640
extract the correct bit

419
00:20:30,000 --> 00:20:35,159
so this is just if everybody follows the

420
00:20:31,640 --> 00:20:40,840
protocol everything should be as you

421
00:20:35,159 --> 00:20:40,840
expect okay uh the soundness or

422
00:20:42,000 --> 00:20:48,320
binding or the statistical binding I

423
00:20:44,840 --> 00:20:51,240
should say somewh or I can call the SSB

424
00:20:48,320 --> 00:20:54,240
somewh statistically binding condition

425
00:20:51,240 --> 00:20:58,000
says that on

426
00:20:54,240 --> 00:21:01,799
location oh before I go to SSB uh

427
00:20:58,000 --> 00:21:01,799
there's another property which is index

428
00:21:03,159 --> 00:21:10,440
hiding index hiding

429
00:21:05,679 --> 00:21:12,320
means that the hash key hides the index

430
00:21:10,440 --> 00:21:16,480
okay if you see just hash key you have

431
00:21:12,320 --> 00:21:18,520
no idea what I is okay so it just says

432
00:21:16,480 --> 00:21:24,159
that for every I and

433
00:21:18,520 --> 00:21:28,120
J if you look at hash key generated by

434
00:21:24,159 --> 00:21:30,480
and I'll call it I or hash key generated

435
00:21:28,120 --> 00:21:31,880
by J

436
00:21:30,480 --> 00:21:33,600
they're

437
00:21:31,880 --> 00:21:36,840
indistinguishable okay this is just a

438
00:21:33,600 --> 00:21:39,840
notation to say hash key generated where

439
00:21:36,840 --> 00:21:41,799
here I have I and this is just a

440
00:21:39,840 --> 00:21:46,799
notation saying this is Hash key

441
00:21:41,799 --> 00:21:49,400
generated by uh giving J to gen okay so

442
00:21:46,799 --> 00:21:50,760
this the the hashy HIDs the index for

443
00:21:49,400 --> 00:21:53,640
any

444
00:21:50,760 --> 00:21:56,320
inj uh the hashy generated with I the

445
00:21:53,640 --> 00:22:00,279
has generate J they look the

446
00:21:56,320 --> 00:22:02,919
same okay so that's the index hiding and

447
00:22:00,279 --> 00:22:06,320
finally is The Binding

448
00:22:02,919 --> 00:22:09,279
condition and The Binding condition says

449
00:22:06,320 --> 00:22:12,799
that so the SSB the somewhere

450
00:22:09,279 --> 00:22:14,520
statistical binding says that for the

451
00:22:12,799 --> 00:22:19,480
location

452
00:22:14,520 --> 00:22:22,880
I that we that we're binding on even an

453
00:22:19,480 --> 00:22:29,000
all powerful adversary that is given

454
00:22:22,880 --> 00:22:31,720
hash key cannot generate V and and two

455
00:22:29,000 --> 00:22:34,960
different openings to location I an

456
00:22:31,720 --> 00:22:38,400
opening to zero and opening to one on

457
00:22:34,960 --> 00:22:41,240
location I so on location I you're

458
00:22:38,400 --> 00:22:44,200
really information theoretically bounded

459
00:22:41,240 --> 00:22:46,799
okay so again even in all powerful

460
00:22:44,200 --> 00:22:51,720
adversary that is given hash key with

461
00:22:46,799 --> 00:22:56,080
respect to a i on location I cannot open

462
00:22:51,720 --> 00:22:59,760
both to zero and to one except with Neal

463
00:22:56,080 --> 00:23:02,720
probability Okay so ah I hoped to put

464
00:22:59,760 --> 00:23:04,880
everything on that but I I'll I'll add

465
00:23:02,720 --> 00:23:08,760
one here so I'll put here The Binding

466
00:23:04,880 --> 00:23:08,760
condition so the SSB

467
00:23:09,039 --> 00:23:16,159
binding The summ Binding says that for

468
00:23:12,919 --> 00:23:16,159
every all

469
00:23:17,600 --> 00:23:26,880
powerful adversary a the probability

470
00:23:22,279 --> 00:23:28,760
that a and hash key where hash key is

471
00:23:26,880 --> 00:23:30,039
generated

472
00:23:28,760 --> 00:23:35,200
from

473
00:23:30,039 --> 00:23:37,919
gen 1 Lambda n and I the probability

474
00:23:35,200 --> 00:23:44,000
that he outputs any value

475
00:23:37,919 --> 00:23:44,000
V and row zero and Row

476
00:23:44,400 --> 00:23:50,360
one such that there would accept both so

477
00:23:47,279 --> 00:23:58,679
that for every B both zero and

478
00:23:50,360 --> 00:24:02,760
one there on hash key v i b Robby

479
00:23:58,679 --> 00:24:02,760
outputs one this is

480
00:24:03,200 --> 00:24:10,440
negligible okay so

481
00:24:06,360 --> 00:24:13,400
on on index I the one that we're the

482
00:24:10,440 --> 00:24:17,480
hatch came from that we're binding on he

483
00:24:13,400 --> 00:24:20,600
cannot open to both zero and open to one

484
00:24:17,480 --> 00:24:22,440
uh in an accepting way with uh accept

485
00:24:20,600 --> 00:24:25,039
probability yeah does have to be

486
00:24:22,440 --> 00:24:28,520
generated from eval here or no good good

487
00:24:25,039 --> 00:24:32,320
good good great question V malicious

488
00:24:28,520 --> 00:24:34,840
there's no a can be so the adversary

489
00:24:32,320 --> 00:24:37,440
he's not following any guidelines he's

490
00:24:34,840 --> 00:24:39,640
completely malicious he generates V

491
00:24:37,440 --> 00:24:42,039
according to his own will generating row

492
00:24:39,640 --> 00:24:45,440
zero and Row one however he wants he's

493
00:24:42,039 --> 00:24:48,640
still and he's all powerful he's still

494
00:24:45,440 --> 00:24:51,559
cannot uh generate two accepting

495
00:24:48,640 --> 00:24:55,440
openings for location

496
00:24:51,559 --> 00:24:57,039
I yeah just to follow up on that that's

497
00:24:55,440 --> 00:24:59,520
the only reason that we don't get this

498
00:24:57,039 --> 00:25:02,840
free from extraction right exactly good

499
00:24:59,520 --> 00:25:05,799
good good very good so let me just uh uh

500
00:25:02,840 --> 00:25:07,399
uh repeat what s said look in extraction

501
00:25:05,799 --> 00:25:10,240
we said that we're binding completely

502
00:25:07,399 --> 00:25:15,159
binding because guess what from V we can

503
00:25:10,240 --> 00:25:19,000
actually uh we can actually learn the

504
00:25:15,159 --> 00:25:21,039
the bit XI so XI is sitting there so

505
00:25:19,000 --> 00:25:23,559
yeah if you're honest XI is sitting

506
00:25:21,039 --> 00:25:25,679
there but if you're malicious you know

507
00:25:23,559 --> 00:25:27,399
you can do whatever you want and maybe

508
00:25:25,679 --> 00:25:30,320
if for malicious V maybe there's no you

509
00:25:27,399 --> 00:25:30,320
can't extract anything from

510
00:25:30,720 --> 00:25:33,720
it

511
00:25:37,919 --> 00:25:43,840
yeah right good good good very good yes

512
00:25:40,559 --> 00:25:46,080
yes yes this is the same as saying that

513
00:25:43,840 --> 00:25:50,880
there exists a

514
00:25:46,080 --> 00:25:53,399
v row zero for any H okay for almost all

515
00:25:50,880 --> 00:25:57,720
hash Keys the probability that there

516
00:25:53,399 --> 00:26:00,200
exists v r z and R1 is is is uh zero

517
00:25:57,720 --> 00:26:03,000
they don't exist for almost all hash

518
00:26:00,200 --> 00:26:07,320
keys this triplet that satisfies this

519
00:26:03,000 --> 00:26:10,360
does not exist yes yeah very

520
00:26:07,320 --> 00:26:13,240
good any any other

521
00:26:10,360 --> 00:26:15,320
questions okay so the plan for today is

522
00:26:13,240 --> 00:26:19,240
to show how to use these two building

523
00:26:15,320 --> 00:26:22,799
blocks to get a snar but before I do

524
00:26:19,240 --> 00:26:24,679
that I want to say a few more to first I

525
00:26:22,799 --> 00:26:26,880
want to give you time to digest and ask

526
00:26:24,679 --> 00:26:30,240
questions uh also I want to say a few

527
00:26:26,880 --> 00:26:30,240
more things about these two Primitives

528
00:26:31,679 --> 00:26:38,919
any questions before

529
00:26:34,080 --> 00:26:41,960
I okay so one thing I want to mention is

530
00:26:38,919 --> 00:26:45,279
even though the binding condition was

531
00:26:41,960 --> 00:26:47,720
only an I I said only on the specific

532
00:26:45,279 --> 00:26:49,520
eye I promise you you can't open two

533
00:26:47,720 --> 00:26:52,159
different ways now say what about the

534
00:26:49,520 --> 00:26:54,799
other eye what about J Jay can an ADV

535
00:26:52,159 --> 00:26:54,799
open two different

536
00:26:56,279 --> 00:27:01,360
ways and the answer is no actually he

537
00:26:58,520 --> 00:27:04,960
can't and we don't need to state that

538
00:27:01,360 --> 00:27:07,640
explicitly from from the SSB and the

539
00:27:04,960 --> 00:27:08,919
index hiding I want to argue already we

540
00:27:07,640 --> 00:27:11,880
can

541
00:27:08,919 --> 00:27:14,760
conclude that a poliz

542
00:27:11,880 --> 00:27:16,840
adversary cannot open a poze not all

543
00:27:14,760 --> 00:27:21,440
powerful but a poliz

544
00:27:16,840 --> 00:27:23,480
adversary cannot generate V any index

545
00:27:21,440 --> 00:27:26,720
J and two

546
00:27:23,480 --> 00:27:28,919
openings that will be accepted except NE

547
00:27:26,720 --> 00:27:30,360
probability

548
00:27:28,919 --> 00:27:32,600
okay so in other words I'm saying

549
00:27:30,360 --> 00:27:36,720
binding holes this local binding holes

550
00:27:32,600 --> 00:27:40,760
for every J not against all powerful but

551
00:27:36,720 --> 00:27:44,640
for any PPT or poly sizing we get this

552
00:27:40,760 --> 00:27:44,640
binding condition for every

553
00:27:44,720 --> 00:27:47,720
J

554
00:27:49,600 --> 00:27:54,200
why so because of the index hiding

555
00:27:51,919 --> 00:27:57,600
property where we cannot distinguish

556
00:27:54,200 --> 00:28:01,039
like index I or something else precisely

557
00:27:57,600 --> 00:28:03,399
so the reason is this a he doesn't know

558
00:28:01,039 --> 00:28:06,519
if hash key came from index I or index J

559
00:28:03,399 --> 00:28:09,080
they're they're indistinguishable so now

560
00:28:06,519 --> 00:28:11,480
if he can generate it for index

561
00:28:09,080 --> 00:28:13,399
J then he should be able to generate

562
00:28:11,480 --> 00:28:15,760
also for index so let's replace this

563
00:28:13,399 --> 00:28:17,399
with an J he can't distinguish so he'll

564
00:28:15,760 --> 00:28:18,880
fall in the same J again at some point

565
00:28:17,399 --> 00:28:21,000
and that that'll be a

566
00:28:18,880 --> 00:28:23,120
contradiction okay so because he has no

567
00:28:21,000 --> 00:28:26,159
idea what's sitting here the fact that

568
00:28:23,120 --> 00:28:27,840
he cannot do it for that index I even

569
00:28:26,159 --> 00:28:29,120
information theoretically means he can't

570
00:28:27,840 --> 00:28:31,519
do it for for any other

571
00:28:29,120 --> 00:28:33,399
index yeah so this indexing really

572
00:28:31,519 --> 00:28:35,200
statistical no this index hiding is

573
00:28:33,399 --> 00:28:38,159
computational

574
00:28:35,200 --> 00:28:39,600
actually oh good good good good so the

575
00:28:38,159 --> 00:28:43,720
corollary

576
00:28:39,600 --> 00:28:46,360
is for any poly

577
00:28:43,720 --> 00:28:49,360
size the cor say is that for only any

578
00:28:46,360 --> 00:28:52,799
poly size a the

579
00:28:49,360 --> 00:28:58,440
probability that a on hash key let's say

580
00:28:52,799 --> 00:29:00,640
from I same hash key outputs V or v j

581
00:28:58,440 --> 00:29:04,200
row zero and Row

582
00:29:00,640 --> 00:29:06,320
one such that the same thing here holds

583
00:29:04,200 --> 00:29:08,799
namely for every B he generates

584
00:29:06,320 --> 00:29:11,000
accepting answers for both zero and one

585
00:29:08,799 --> 00:29:11,000
is

586
00:29:11,640 --> 00:29:17,600
negligible because if there exist some J

587
00:29:15,519 --> 00:29:20,080
that he does that for non- Negal

588
00:29:17,600 --> 00:29:23,159
probability then let's replate replace

589
00:29:20,080 --> 00:29:24,320
HK with hash key generating like that's

590
00:29:23,159 --> 00:29:27,279
binding on this that actually

591
00:29:24,320 --> 00:29:30,000
statistically binding on this J A can

592
00:29:27,279 --> 00:29:31,760
distinguish so we'll still do this for

593
00:29:30,000 --> 00:29:33,679
that J with some prob non- negligent

594
00:29:31,760 --> 00:29:34,679
probability and that he cannot do even

595
00:29:33,679 --> 00:29:38,000
information

596
00:29:34,679 --> 00:29:40,440
theoretically so that's why we get like

597
00:29:38,000 --> 00:29:42,360
because index hiding actually just

598
00:29:40,440 --> 00:29:44,640
getting statistically binding on one of

599
00:29:42,360 --> 00:29:47,399
them is good enough it will imply

600
00:29:44,640 --> 00:29:49,760
computational binding and all the

601
00:29:47,399 --> 00:29:51,440
rest okay another thing I want to

602
00:29:49,760 --> 00:29:52,720
mention and this we'll use actually in

603
00:29:51,440 --> 00:29:56,640
our construction

604
00:29:52,720 --> 00:29:59,919
today I said that the hash is binding on

605
00:29:56,640 --> 00:30:03,000
one location and XI we can get it

606
00:29:59,919 --> 00:30:06,240
binding actually on L locations not just

607
00:30:03,000 --> 00:30:09,440
one how do I get it binding on L

608
00:30:06,240 --> 00:30:12,760
locations I'm going to just generate hk1

609
00:30:09,440 --> 00:30:14,840
hk2 up to hkl where the first L is Bing

610
00:30:12,760 --> 00:30:16,760
on the first I'm just going to

611
00:30:14,840 --> 00:30:19,440
generate L

612
00:30:16,760 --> 00:30:21,640
hashes I'm going to ask to generate the

613
00:30:19,440 --> 00:30:24,880
AAL on all these hashes so the hash

614
00:30:21,640 --> 00:30:27,720
value now is going to be V1 up to VL

615
00:30:24,880 --> 00:30:32,240
where the honest uh evalid is going to

616
00:30:27,720 --> 00:30:36,399
take X you want to hash and do eval hk1

617
00:30:32,240 --> 00:30:40,880
of X eval hk2 of X so just hash the same

618
00:30:36,399 --> 00:30:44,399
x with all L keys so now the hatch value

619
00:30:40,880 --> 00:30:46,360
is Grows by a factor of L and then when

620
00:30:44,399 --> 00:30:48,679
you open a certain bit a certain

621
00:30:46,360 --> 00:30:51,679
location you'll generate all the

622
00:30:48,679 --> 00:30:54,799
openings so just do the same thing kind

623
00:30:51,679 --> 00:30:57,360
of all times just repeat it all times

624
00:30:54,799 --> 00:31:00,559
and now what do we have from that if you

625
00:30:57,360 --> 00:31:03,559
by repeating our time so let me uh write

626
00:31:00,559 --> 00:31:03,559
it

627
00:31:08,760 --> 00:31:13,639
so uh let me erase the quary so I'll

628
00:31:11,480 --> 00:31:13,639
have

629
00:31:14,399 --> 00:31:19,799
room

630
00:31:16,159 --> 00:31:19,799
so uh no

631
00:31:23,880 --> 00:31:28,120
remark by repeating

632
00:31:29,320 --> 00:31:31,799
L

633
00:31:32,240 --> 00:31:40,240
times we

634
00:31:34,159 --> 00:31:40,240
get uh somewhere extractable hash that's

635
00:31:42,000 --> 00:31:46,000
extractable on L

636
00:31:48,360 --> 00:31:54,480
locations and moreover another property

637
00:31:51,679 --> 00:31:58,080
that's we're going to need even if I

638
00:31:54,480 --> 00:31:59,840
let's say gave you the trapo

639
00:31:58,080 --> 00:32:01,639
corresponding to some of the alloc not

640
00:31:59,840 --> 00:32:03,000
all the allocations let's say gave you

641
00:32:01,639 --> 00:32:03,919
trap door one trap door two and trap

642
00:32:03,000 --> 00:32:07,519
door

643
00:32:03,919 --> 00:32:11,279
three still what's in the location

644
00:32:07,519 --> 00:32:14,639
hidden in hq4 you have no idea what it

645
00:32:11,279 --> 00:32:18,679
is so even if I reveal some of the trap

646
00:32:14,639 --> 00:32:21,120
doors the other IND indic sees remain

647
00:32:18,679 --> 00:32:24,200
hidden okay and we're going to use this

648
00:32:21,120 --> 00:32:29,399
property okay so again if we repeat all

649
00:32:24,200 --> 00:32:31,880
times we're binding an L location

650
00:32:29,399 --> 00:32:34,720
but even if I destroy I kind of reveal

651
00:32:31,880 --> 00:32:36,519
the trapo corresponding to I don't know

652
00:32:34,720 --> 00:32:38,960
location to a couple

653
00:32:36,519 --> 00:32:41,080
locations the rest of the so of course

654
00:32:38,960 --> 00:32:42,760
if I give you the trapo then all bets

655
00:32:41,080 --> 00:32:45,639
are off you learn everything you learn

656
00:32:42,760 --> 00:32:47,440
the eye you learn everything that's

657
00:32:45,639 --> 00:32:48,480
that's the trapo our trap doors are such

658
00:32:47,440 --> 00:32:50,080
that once I give you the trap door you

659
00:32:48,480 --> 00:32:54,080
learn the index you learn

660
00:32:50,080 --> 00:32:56,760
everything but the other indices that

661
00:32:54,080 --> 00:32:59,039
are not in the not corresponding to the

662
00:32:56,760 --> 00:33:00,720
trap doors that I give that I gave are

663
00:32:59,039 --> 00:33:02,919
still completely hidden CU I did them

664
00:33:00,720 --> 00:33:04,679
completely in

665
00:33:02,919 --> 00:33:05,880
independent and this is something we're

666
00:33:04,679 --> 00:33:08,320
going to use when we're going to

667
00:33:05,880 --> 00:33:08,320
construct our

668
00:33:08,440 --> 00:33:13,919
snars okay so that's one thing we're

669
00:33:10,480 --> 00:33:15,559
going to use a I I want to mention a

670
00:33:13,919 --> 00:33:18,159
little I want to talk a little bit about

671
00:33:15,559 --> 00:33:20,799
the construction because I think maybe

672
00:33:18,159 --> 00:33:23,039
in Jen jang's uh lecture last time this

673
00:33:20,799 --> 00:33:25,279
was missed a little because he said it I

674
00:33:23,039 --> 00:33:27,519
think a little too fast so I want to say

675
00:33:25,279 --> 00:33:29,039
a few words about the construction but

676
00:33:27,519 --> 00:33:31,600
before I talk about the construction I

677
00:33:29,039 --> 00:33:34,240
want to say one more property about the

678
00:33:31,600 --> 00:33:36,440
bar that we're going to also use so what

679
00:33:34,240 --> 00:33:40,240
we're going to use about the bar so we

680
00:33:36,440 --> 00:33:41,760
said that these gen p and v are

681
00:33:40,240 --> 00:33:43,960
polinomial time algorithm probabilistic

682
00:33:41,760 --> 00:33:45,799
polinomial time algorithms in particular

683
00:33:43,960 --> 00:33:48,519
V I want to talk about v v is a

684
00:33:45,799 --> 00:33:51,519
polinomial Time algorithm but V's input

685
00:33:48,519 --> 00:33:53,360
is really large it has X1 up to XK so

686
00:33:51,519 --> 00:33:56,720
poom time means it runs at least in time

687
00:33:53,360 --> 00:34:00,360
poly K it needs to read its

688
00:33:56,720 --> 00:34:03,399
input ever turns out that the bars we

689
00:34:00,360 --> 00:34:06,519
have this is what J called bar for index

690
00:34:03,399 --> 00:34:10,000
languages if there exists a suing

691
00:34:06,519 --> 00:34:12,520
description of these X1 of to XK the

692
00:34:10,000 --> 00:34:15,000
verifier only needs to run in time that

693
00:34:12,520 --> 00:34:20,760
depends on the description in other

694
00:34:15,000 --> 00:34:23,079
words we can replace so uh

695
00:34:20,760 --> 00:34:26,839
if I didn't bring

696
00:34:23,079 --> 00:34:29,639
my okay I forgot to bring my colorful uh

697
00:34:26,839 --> 00:34:31,040
chalk so uh sorry but at least you have

698
00:34:29,639 --> 00:34:33,240
cookies I mean what would you prefer

699
00:34:31,040 --> 00:34:37,960
colorful chalks or

700
00:34:33,240 --> 00:34:40,440
cookies so if a if you can generate

701
00:34:37,960 --> 00:34:42,399
these X1 up to XK if there's kind of

702
00:34:40,440 --> 00:34:44,839
succinct

703
00:34:42,399 --> 00:34:47,480
description then the verify runs in

704
00:34:44,839 --> 00:34:51,079
polinomial time in the description okay

705
00:34:47,480 --> 00:34:52,599
so if let's say there exists some

706
00:34:51,079 --> 00:34:55,000
machine

707
00:34:52,599 --> 00:34:59,639
M such

708
00:34:55,000 --> 00:34:59,639
that for every I

709
00:35:00,760 --> 00:35:08,760
XI is just kind of the train

710
00:35:05,440 --> 00:35:10,359
machine on on input I so this kind of

711
00:35:08,760 --> 00:35:12,280
machine you can you should think this

712
00:35:10,359 --> 00:35:14,079
algorithm you should think of has kind

713
00:35:12,280 --> 00:35:17,880
of a succinct description of all the X

714
00:35:14,079 --> 00:35:21,800
on up to x k and you give him I you get

715
00:35:17,880 --> 00:35:24,040
it it gives you the X I if this is the

716
00:35:21,800 --> 00:35:28,040
case

717
00:35:24,040 --> 00:35:29,520
then V the runtime

718
00:35:28,040 --> 00:35:36,280
or I say

719
00:35:29,520 --> 00:35:38,839
time of v it grows with with the size of

720
00:35:36,280 --> 00:35:42,800
M as opposed to

721
00:35:38,839 --> 00:35:42,800
K okay so the

722
00:35:46,040 --> 00:35:51,119
grows with M and does not grow with K so

723
00:35:49,359 --> 00:35:52,560
of course if you give him xon to XK he

724
00:35:51,119 --> 00:35:55,200
need to read his input his run times

725
00:35:52,560 --> 00:35:57,480
grow K but if you can kind of generate

726
00:35:55,200 --> 00:35:58,800
in succinct way then he doesn't need to

727
00:35:57,480 --> 00:36:02,720
grow grow with

728
00:35:58,800 --> 00:36:05,839
K okay so the you should another way to

729
00:36:02,720 --> 00:36:09,119
think about it you can think of x i as

730
00:36:05,839 --> 00:36:12,280
like M comma

731
00:36:09,119 --> 00:36:15,760
I and the instance just says if you run

732
00:36:12,280 --> 00:36:17,200
M on i x i then XI in the language and

733
00:36:15,760 --> 00:36:19,400
that's why it's called index language

734
00:36:17,200 --> 00:36:21,119
because it's like there's an index yeah

735
00:36:19,400 --> 00:36:22,760
so this means that there still like a

736
00:36:21,119 --> 00:36:24,640
depend in these R time right yeah yeah

737
00:36:22,760 --> 00:36:26,680
yeah there is a lock dependence 100%

738
00:36:24,640 --> 00:36:29,359
sorry yeah yeah it just means yeah

739
00:36:26,680 --> 00:36:31,440
exactly that runs into time uh log K

740
00:36:29,359 --> 00:36:34,680
actually yeah you have I here which is

741
00:36:31,440 --> 00:36:38,319
log K so there is a log K dependence

742
00:36:34,680 --> 00:36:41,200
yeah the CRS is sublinear in K as well

743
00:36:38,319 --> 00:36:43,280
is that true the length of the CRS in

744
00:36:41,200 --> 00:36:47,400
general you want it to be sublinear in K

745
00:36:43,280 --> 00:36:50,240
in the snar construction it's po okay

746
00:36:47,400 --> 00:36:53,720
but yes but when we'll talk about snar

747
00:36:50,240 --> 00:36:55,640
so yeah in the the in the bar the bar

748
00:36:53,720 --> 00:36:59,480
construction we have the

749
00:36:55,640 --> 00:37:00,760
CRS MO most of our construction the SS

750
00:36:59,480 --> 00:37:03,520
is of size

751
00:37:00,760 --> 00:37:07,880
pology uh the one under lwe that Jing

752
00:37:03,520 --> 00:37:07,880
Jang showed is is of size

753
00:37:07,920 --> 00:37:14,760
poly so I know that if we have a bar

754
00:37:10,599 --> 00:37:17,680
that size these properties and function

755
00:37:14,760 --> 00:37:19,599
I guess you can always kind of like like

756
00:37:17,680 --> 00:37:21,480
add the property that you want here

757
00:37:19,599 --> 00:37:23,760
being able to extract a witness from the

758
00:37:21,480 --> 00:37:26,160
group itself is there a world like do we

759
00:37:23,760 --> 00:37:28,520
have any bars without the assumptions

760
00:37:26,160 --> 00:37:31,359
that we need for

761
00:37:28,520 --> 00:37:34,200
function you're asking is there a bar

762
00:37:31,359 --> 00:37:36,240
for which we we we don't know how to

763
00:37:34,200 --> 00:37:38,720
extract is that what you're asking okay

764
00:37:36,240 --> 00:37:42,040
okay so okay so let me you're asking a

765
00:37:38,720 --> 00:37:46,040
great question let me kind of uh

766
00:37:42,040 --> 00:37:49,240
uh okay so when we said when I when the

767
00:37:46,040 --> 00:37:53,200
soundness condition just says that a

768
00:37:49,240 --> 00:37:55,240
cheating prover cannot uh you know cheat

769
00:37:53,200 --> 00:37:56,960
cannot generate X1 up to XK that one of

770
00:37:55,240 --> 00:37:58,800
them the I is not in the language and

771
00:37:56,960 --> 00:38:01,839
yet convinced

772
00:37:58,800 --> 00:38:04,480
often time also in our snar in our snar

773
00:38:01,839 --> 00:38:07,000
construction we want something stronger

774
00:38:04,480 --> 00:38:08,160
what we want is that I can actually

775
00:38:07,000 --> 00:38:11,480
extract a

776
00:38:08,160 --> 00:38:14,560
witness from from this cheating prover

777
00:38:11,480 --> 00:38:16,040
so I want to say this cheating prover I

778
00:38:14,560 --> 00:38:21,480
can't extract all the

779
00:38:16,040 --> 00:38:24,880
witnesses but for some ey I can generate

780
00:38:21,480 --> 00:38:26,960
a CRS that looks like just standard CRS

781
00:38:24,880 --> 00:38:29,680
but I can kind of change the

782
00:38:26,960 --> 00:38:32,599
distribution a CRS to be such that using

783
00:38:29,680 --> 00:38:37,040
some trapo about the CRS I can actually

784
00:38:32,599 --> 00:38:38,280
extract from P star a witness for XI and

785
00:38:37,040 --> 00:38:40,079
once I extract a witness of course it

786
00:38:38,280 --> 00:38:41,760
has to be in the language I I argue not

787
00:38:40,079 --> 00:38:44,720
only it's in the language I can even

788
00:38:41,760 --> 00:38:45,960
find you know get a witness from him so

789
00:38:44,720 --> 00:38:50,359
that's called somewhere this is like

790
00:38:45,960 --> 00:38:53,400
somewh extractable bar now what Li was

791
00:38:50,359 --> 00:38:55,680
saying is that the bar that Jen Jong uh

792
00:38:53,400 --> 00:38:58,000
showed you last time was extra had the

793
00:38:55,680 --> 00:39:00,000
somewh extractable property okay was

794
00:38:58,000 --> 00:39:01,800
extractable actually let me tell you we

795
00:39:00,000 --> 00:39:04,440
also will need bar that are somewhere

796
00:39:01,800 --> 00:39:06,200
extractable I didn't write that here why

797
00:39:04,440 --> 00:39:10,720
didn't I write it here and this is where

798
00:39:06,200 --> 00:39:12,960
the exactly the answer is any bar we can

799
00:39:10,720 --> 00:39:16,640
make it somewhere extractable by just

800
00:39:12,960 --> 00:39:18,280
adding a hash so we can kind of up we

801
00:39:16,640 --> 00:39:21,520
don't need to worry about summer

802
00:39:18,280 --> 00:39:25,599
extractability of a bar because what we

803
00:39:21,520 --> 00:39:27,599
can always do is add put a hash of all

804
00:39:25,599 --> 00:39:29,440
the witnesses a some if you have some

805
00:39:27,599 --> 00:39:31,599
extractable hash if you have a somewh

806
00:39:29,440 --> 00:39:34,440
extractable hash you can tell the

807
00:39:31,599 --> 00:39:36,640
verifier put a somewh extractable hash

808
00:39:34,440 --> 00:39:38,280
of all your Witnesses so take witness

809
00:39:36,640 --> 00:39:42,440
one witness two witness three up to

810
00:39:38,280 --> 00:39:43,839
witness K hash them and in the analysis

811
00:39:42,440 --> 00:39:45,480
just jumping ahead we're going to be

812
00:39:43,839 --> 00:39:48,440
extractable on all the locations

813
00:39:45,480 --> 00:39:50,480
corresponding to witness I and now we're

814
00:39:48,440 --> 00:39:53,920
going to tell him we're going to say

815
00:39:50,480 --> 00:39:57,880
give me a bar the bar is not for the

816
00:39:53,920 --> 00:40:00,119
original language L the bar says

817
00:39:57,880 --> 00:40:03,319
the bar that X eyes in the language now

818
00:40:00,119 --> 00:40:05,720
says there is an opening for the hash

819
00:40:03,319 --> 00:40:08,960
value that in the locations conf find to

820
00:40:05,720 --> 00:40:12,200
Wi if you opened you would get a valid

821
00:40:08,960 --> 00:40:14,880
witness bar that language so instead of

822
00:40:12,200 --> 00:40:17,560
barging the original language bark a

823
00:40:14,880 --> 00:40:19,920
little bit kind of upgraded language

824
00:40:17,560 --> 00:40:22,920
that again says there's a so the

825
00:40:19,920 --> 00:40:25,960
verifier will give you a hash of all the

826
00:40:22,920 --> 00:40:28,400
witnesses and he will prove for every

827
00:40:25,960 --> 00:40:29,680
eye he won't won't prove just XIs in the

828
00:40:28,400 --> 00:40:34,040
language he's going to prove for every

829
00:40:29,680 --> 00:40:36,960
eye I have openings corresponding to

830
00:40:34,040 --> 00:40:39,640
witness eye so that the a the openings

831
00:40:36,960 --> 00:40:42,000
are valid and B wi is in the is in the

832
00:40:39,640 --> 00:40:44,960
language L that's the bar he's going to

833
00:40:42,000 --> 00:40:45,960
give you and now the fact that you're in

834
00:40:44,960 --> 00:40:50,000
the

835
00:40:45,960 --> 00:40:51,560
language means that it must be that if

836
00:40:50,000 --> 00:40:53,560
you take the trap door and look into it

837
00:40:51,560 --> 00:40:55,800
it must be by by

838
00:40:53,560 --> 00:40:57,319
soundless must be that's what's sitting

839
00:40:55,800 --> 00:40:58,880
there because you're binding if if

840
00:40:57,319 --> 00:41:00,480
you're going to be binding on that part

841
00:40:58,880 --> 00:41:01,960
you know that what's sitting there must

842
00:41:00,480 --> 00:41:05,560
be the correct

843
00:41:01,960 --> 00:41:08,680
witness so that's uh that's kind of uh

844
00:41:05,560 --> 00:41:10,800
why why actually we don't need to

845
00:41:08,680 --> 00:41:13,480
construct bars with with extractability

846
00:41:10,800 --> 00:41:15,440
we can always attach uh uh some

847
00:41:13,480 --> 00:41:17,440
constructible hash to them yeah I guess

848
00:41:15,440 --> 00:41:19,839
actually Wonder something assumptions do

849
00:41:17,440 --> 00:41:22,640
we have any constructions of bars from

850
00:41:19,839 --> 00:41:24,680
assumptions weaker than those needed to

851
00:41:22,640 --> 00:41:26,480
construct which would make it I guess

852
00:41:24,680 --> 00:41:29,440
interesting I see what you're saying I

853
00:41:26,480 --> 00:41:32,839
see uh um I don't think not that I yeah

854
00:41:29,440 --> 00:41:32,839
I don't think so I don't think

855
00:41:36,000 --> 00:41:40,400
so yeah I don't know how to construct a

856
00:41:38,400 --> 00:41:41,560
bar from an assumption for which I don't

857
00:41:40,400 --> 00:41:43,560
know how to construct a some

858
00:41:41,560 --> 00:41:48,319
constructible hash

859
00:41:43,560 --> 00:41:48,319
yeah okay a any other

860
00:41:49,760 --> 00:41:55,720
questions okay so I want to get to the

861
00:41:53,160 --> 00:41:58,280
bar to the construction of the snar but

862
00:41:55,720 --> 00:41:59,319
before I do so I I I do want to spend a

863
00:41:58,280 --> 00:42:01,880
little more time on the summer

864
00:41:59,319 --> 00:42:03,400
extractable hash and say a little bit

865
00:42:01,880 --> 00:42:07,920
about the way we construct it because

866
00:42:03,400 --> 00:42:12,240
I'm just want to make sure that a

867
00:42:07,920 --> 00:42:14,000
a that you you you you didn't miss a

868
00:42:12,240 --> 00:42:17,319
part from last lecture that I think was

869
00:42:14,000 --> 00:42:19,760
a bit said too succinctly so the high

870
00:42:17,319 --> 00:42:23,359
level idea of how you construct a Sumer

871
00:42:19,760 --> 00:42:26,040
extractable hash is using uh fully

872
00:42:23,359 --> 00:42:28,440
homomorphic encryption okay so I don't

873
00:42:26,040 --> 00:42:30,079
want to get into uh uh I don't want to

874
00:42:28,440 --> 00:42:32,559
recall too much the definition but I'll

875
00:42:30,079 --> 00:42:35,280
I'll give you a high level so the basic

876
00:42:32,559 --> 00:42:36,240
idea which doesn't work okay let me

877
00:42:35,280 --> 00:42:37,800
first tell you the idea that doesn't

878
00:42:36,240 --> 00:42:39,200
work because that's very natural and I

879
00:42:37,800 --> 00:42:42,720
think maybe that's what you got from

880
00:42:39,200 --> 00:42:47,559
last lecture so the basic idea that

881
00:42:42,720 --> 00:42:47,559
doesn't work is to say that

882
00:42:51,800 --> 00:42:56,400
gen will just output

883
00:42:57,480 --> 00:43:06,599
encryption so it'll give you a public

884
00:43:00,839 --> 00:43:06,599
key an encryption of I with this public

885
00:43:07,960 --> 00:43:11,400
key and the trap door that's going to be

886
00:43:10,319 --> 00:43:13,559
the hash

887
00:43:11,400 --> 00:43:15,920
key and the trap door is going to be the

888
00:43:13,559 --> 00:43:15,920
secret

889
00:43:16,280 --> 00:43:20,680
key okay so I'm just the hash key is

890
00:43:18,520 --> 00:43:23,680
going to be an encryption of of the

891
00:43:20,680 --> 00:43:23,680
index

892
00:43:24,480 --> 00:43:32,920
now I want X1 to X n Let Me Assume for

893
00:43:29,240 --> 00:43:32,920
Simplicity that n

894
00:43:34,800 --> 00:43:42,240
suppose N is a power of two otherwise

895
00:43:39,480 --> 00:43:43,640
you know pad okay so let's say big n is

896
00:43:42,240 --> 00:43:46,559
a power of two so it's some two to the

897
00:43:43,640 --> 00:43:49,160
small n now here's what I'm going to do

898
00:43:46,559 --> 00:43:50,520
let me so when I say encryption of I

899
00:43:49,160 --> 00:43:52,400
let's think of it as bid by bit

900
00:43:50,520 --> 00:43:54,720
encryption so it's

901
00:43:52,400 --> 00:43:57,960
encryption of

902
00:43:54,720 --> 00:44:00,400
i1 up to encryption

903
00:43:57,960 --> 00:44:00,400
of I

904
00:44:00,960 --> 00:44:05,280
in okay and now the idea

905
00:44:06,240 --> 00:44:15,200
is what we'll do is for for each like

906
00:44:12,720 --> 00:44:17,720
pair so I'm going to do kind of a Merkle

907
00:44:15,200 --> 00:44:20,000
hash and for each pair I'm going to

908
00:44:17,720 --> 00:44:22,960
encrypt so I'm going to do this Merle

909
00:44:20,000 --> 00:44:25,240
hash where for each node I'm going to

910
00:44:22,960 --> 00:44:26,720
associate a cipher text and the output

911
00:44:25,240 --> 00:44:29,040
is going to be the cipher text of the

912
00:44:26,720 --> 00:44:31,319
root that's my hash value the hash Val

913
00:44:29,040 --> 00:44:32,920
is give be a cipher text of the root and

914
00:44:31,319 --> 00:44:34,800
this Cypher text going be a cyppher text

915
00:44:32,920 --> 00:44:38,000
it's encryption of

916
00:44:34,800 --> 00:44:39,400
XI okay how do I asso so of course I can

917
00:44:38,000 --> 00:44:41,880
comp encryption of x i this is a

918
00:44:39,400 --> 00:44:44,040
homomorphic encryption given X an

919
00:44:41,880 --> 00:44:45,960
encryption of I I can do computation

920
00:44:44,040 --> 00:44:50,040
under the hood so I can compute

921
00:44:45,960 --> 00:44:51,880
encryption of xabi okay so because this

922
00:44:50,040 --> 00:44:53,480
is a a fully homomorphic

923
00:44:51,880 --> 00:44:58,280
encryption

924
00:44:53,480 --> 00:45:01,839
given X and encryption of I

925
00:44:58,280 --> 00:45:04,079
I can compute encryption of

926
00:45:01,839 --> 00:45:06,720
xabi of course there's public keys I'm

927
00:45:04,079 --> 00:45:08,720
omitting them for sness of

928
00:45:06,720 --> 00:45:10,760
rotation okay this is because I can

929
00:45:08,720 --> 00:45:13,240
compute under the

930
00:45:10,760 --> 00:45:14,880
hood the value of the root is going to

931
00:45:13,240 --> 00:45:17,920
be encryption of

932
00:45:14,880 --> 00:45:19,559
XI but what kind of encryption it's not

933
00:45:17,920 --> 00:45:22,839
any ENC so let me tell you how exactly

934
00:45:19,559 --> 00:45:26,400
how I compute this encryption so the

935
00:45:22,839 --> 00:45:27,680
idea would be so and and not only that

936
00:45:26,400 --> 00:45:29,960
how do I open

937
00:45:27,680 --> 00:45:31,680
okay I want to do local opening so the

938
00:45:29,960 --> 00:45:34,119
the way I'm going to do it is as follows

939
00:45:31,680 --> 00:45:36,520
for each for each pair I'm going to

940
00:45:34,119 --> 00:45:38,359
encrypt only one of them I'm going to

941
00:45:36,520 --> 00:45:41,040
either put here encryption of X1 or

942
00:45:38,359 --> 00:45:45,880
encryption of X2 which one depending on

943
00:45:41,040 --> 00:45:48,200
i1 so let's start with i1 if i1 is zero

944
00:45:45,880 --> 00:45:50,079
I'm gonna so I'm I'm GNA let's say

945
00:45:48,200 --> 00:45:52,720
choose X1 if i1 is one I'm going to

946
00:45:50,079 --> 00:45:54,280
choose X2 it's I'm gonna choose even

947
00:45:52,720 --> 00:45:57,960
other so that the output will be the

948
00:45:54,280 --> 00:46:01,839
correct one uh okay so I'm gonna the the

949
00:45:57,960 --> 00:46:03,520
i1 depending on encryption of i1 that's

950
00:46:01,839 --> 00:46:05,400
going to tell me which one to put here

951
00:46:03,520 --> 00:46:08,640
zero I put all the

952
00:46:05,400 --> 00:46:09,680
left like the left children or one I put

953
00:46:08,640 --> 00:46:11,720
the right

954
00:46:09,680 --> 00:46:12,800
children and then I do the exact same

955
00:46:11,720 --> 00:46:15,280
thing given

956
00:46:12,800 --> 00:46:18,160
these whether I choose the left or right

957
00:46:15,280 --> 00:46:20,559
depends on encryption of I2 if I2 is

958
00:46:18,160 --> 00:46:23,720
zero I choose the left if I2 is one I

959
00:46:20,559 --> 00:46:27,079
choose the right and so on so forth

960
00:46:23,720 --> 00:46:27,079
that's the idea

961
00:46:28,079 --> 00:46:32,760
it's it's like an OT it's really like an

962
00:46:30,000 --> 00:46:34,800
OT exactly exact I didn't Define what OT

963
00:46:32,760 --> 00:46:39,760
is but it's exactly like an

964
00:46:34,800 --> 00:46:39,760
OT okay this does not

965
00:46:40,440 --> 00:46:46,520
work okay it it almost works but it does

966
00:46:43,400 --> 00:46:47,880
not work so let me tell you why it seems

967
00:46:46,520 --> 00:46:53,359
like it should work and then I just want

968
00:46:47,880 --> 00:46:57,720
to mention the uh the um the the a the

969
00:46:53,359 --> 00:46:59,440
subtlety here so the reason it you so

970
00:46:57,720 --> 00:47:01,880
okay so first how do you generate local

971
00:46:59,440 --> 00:47:04,800
opening well you check so if you want to

972
00:47:01,880 --> 00:47:07,800
open XI I I'll tell you okay give me X1

973
00:47:04,800 --> 00:47:10,800
and X2 so I can check that this is

974
00:47:07,800 --> 00:47:12,720
corrected and then give me the hash the

975
00:47:10,800 --> 00:47:16,559
cipher text here and I can check that

976
00:47:12,720 --> 00:47:21,160
this is correct because each each Cipher

977
00:47:16,559 --> 00:47:25,319
text is some f valuation that depends on

978
00:47:21,160 --> 00:47:30,040
the two children and on the the hash key

979
00:47:25,319 --> 00:47:32,480
which is encryption so in in layer J it

980
00:47:30,040 --> 00:47:33,760
depends on the two children and

981
00:47:32,480 --> 00:47:39,000
encryption of

982
00:47:33,760 --> 00:47:42,599
IG okay each time the the the the

983
00:47:39,000 --> 00:47:45,960
node the the cipher text corresponding

984
00:47:42,599 --> 00:47:49,440
to some node is a deterministic function

985
00:47:45,960 --> 00:47:51,839
of the cipher text corresponding to the

986
00:47:49,440 --> 00:47:55,520
children and the hash key corresponding

987
00:47:51,839 --> 00:47:58,359
to that level so encryption of let's say

988
00:47:55,520 --> 00:48:00,119
JJ okay cu because remember if if I'm

989
00:47:58,359 --> 00:48:02,319
let's say in level two I have here

990
00:48:00,119 --> 00:48:06,520
Cipher text I don't know one and Cipher

991
00:48:02,319 --> 00:48:10,599
text two then I do

992
00:48:06,520 --> 00:48:14,000
U the way I compute the the parent uh

993
00:48:10,599 --> 00:48:19,240
Cipher text is just a homomorphic

994
00:48:14,000 --> 00:48:23,720
evaluation that takes if I uh if I to is

995
00:48:19,240 --> 00:48:26,520
zero it it takes cyppher text two if I

996
00:48:23,720 --> 00:48:28,720
two is one it takes sorry c one

997
00:48:26,520 --> 00:48:31,400
otherwise t i verx 2 okay so this is

998
00:48:28,720 --> 00:48:33,440
really just a deterministic homomorphic

999
00:48:31,400 --> 00:48:35,599
evaluation and so that's how I open I

1000
00:48:33,440 --> 00:48:37,800
just open all the relevant CER Tex and

1001
00:48:35,599 --> 00:48:39,839
the verifier will check that the

1002
00:48:37,800 --> 00:48:42,400
homomorphic evaluation was done

1003
00:48:39,839 --> 00:48:44,119
correctly so you can local opening you

1004
00:48:42,400 --> 00:48:46,319
can do local opening but it's not

1005
00:48:44,119 --> 00:48:49,680
binding or I don't know how to prove

1006
00:48:46,319 --> 00:48:51,640
that it's binding is the problem okay

1007
00:48:49,680 --> 00:48:53,119
and probably you can find a weird FHA

1008
00:48:51,640 --> 00:48:55,200
for which it's not binding I don't know

1009
00:48:53,119 --> 00:48:56,440
maybe for natural constructions it is

1010
00:48:55,200 --> 00:48:57,319
binding I don't know I don't know how to

1011
00:48:56,440 --> 00:48:59,720
prove it

1012
00:48:57,319 --> 00:49:02,079
but there's a problem with binding and

1013
00:48:59,720 --> 00:49:03,839
the problem with binding is that a

1014
00:49:02,079 --> 00:49:06,240
cheating so it seems like it should be

1015
00:49:03,839 --> 00:49:07,480
binding because look here is sitting

1016
00:49:06,240 --> 00:49:10,880
encryption of

1017
00:49:07,480 --> 00:49:12,799
XI but the thing is the reason why it's

1018
00:49:10,880 --> 00:49:14,319
not binding is because a

1019
00:49:12,799 --> 00:49:17,440
malicious

1020
00:49:14,319 --> 00:49:19,920
ah a malicious

1021
00:49:17,440 --> 00:49:23,720
adversary he may give Cipher Texs that

1022
00:49:19,920 --> 00:49:25,119
are are garbage are completely garbage

1023
00:49:23,720 --> 00:49:27,559
they don't actually they're not legal

1024
00:49:25,119 --> 00:49:29,760
Cipher texts and and he if he gives

1025
00:49:27,559 --> 00:49:30,760
Cypher Texs that are garbage I don't

1026
00:49:29,760 --> 00:49:34,000
know

1027
00:49:30,760 --> 00:49:36,799
why why would there be binding so I mean

1028
00:49:34,000 --> 00:49:40,599
maybe extract doesn't work okay here's

1029
00:49:36,799 --> 00:49:42,359
me I'm a malicious person I nothing ex

1030
00:49:40,599 --> 00:49:45,079
no you can't extract anything I just

1031
00:49:42,359 --> 00:49:46,040
want to ruin the binding my whole goal

1032
00:49:45,079 --> 00:49:49,160
is

1033
00:49:46,040 --> 00:49:51,799
to kind of Ruin binding here okay I'm

1034
00:49:49,160 --> 00:49:53,880
going to give you V that doesn't encrypt

1035
00:49:51,799 --> 00:49:56,720
anything it's a junk V and I'm going to

1036
00:49:53,880 --> 00:50:01,119
open it in two different ways Maybe

1037
00:49:56,720 --> 00:50:02,440
maybe I can generate a v like it's I

1038
00:50:01,119 --> 00:50:04,880
call it Cypher text but it's just a

1039
00:50:02,440 --> 00:50:07,119
bunch of bits that have no meaning

1040
00:50:04,880 --> 00:50:09,640
cannot be decrypted at all and maybe I

1041
00:50:07,119 --> 00:50:13,000
can somehow generate valid

1042
00:50:09,640 --> 00:50:15,599
openings so and I we don't know how to

1043
00:50:13,000 --> 00:50:18,079
argue that you cannot do that so in

1044
00:50:15,599 --> 00:50:21,079
order to actually get soundness I need

1045
00:50:18,079 --> 00:50:23,119
to make sure that the things are well

1046
00:50:21,079 --> 00:50:25,559
formed that these are actually valid

1047
00:50:23,119 --> 00:50:27,599
Cipher text or what I open to is a valid

1048
00:50:25,559 --> 00:50:32,520
Cipher text

1049
00:50:27,599 --> 00:50:34,720
and the way we get this is by making

1050
00:50:32,520 --> 00:50:37,880
this a little more

1051
00:50:34,720 --> 00:50:41,280
cumbersome so the way we get this is we

1052
00:50:37,880 --> 00:50:44,240
actually don't use one public key we use

1053
00:50:41,280 --> 00:50:47,240
small n public keys so for each layer

1054
00:50:44,240 --> 00:50:50,200
we'll use a different public key and

1055
00:50:47,240 --> 00:50:52,799
what we encrypt so what okay so what we

1056
00:50:50,200 --> 00:50:55,000
do is we

1057
00:50:52,799 --> 00:50:59,079
have public key

1058
00:50:55,000 --> 00:51:03,880
j for J goes from one to n okay so we

1059
00:50:59,079 --> 00:51:10,839
have n public keys and with public key

1060
00:51:03,880 --> 00:51:13,640
j we encrypt i j but also so the you one

1061
00:51:10,839 --> 00:51:15,359
I has I want up to i n we encrypt i j

1062
00:51:13,640 --> 00:51:19,720
but we also

1063
00:51:15,359 --> 00:51:22,040
encrypt skj minus one we I want to have

1064
00:51:19,720 --> 00:51:24,359
the decryption it's important me to have

1065
00:51:22,040 --> 00:51:28,799
the decryption

1066
00:51:24,359 --> 00:51:31,240
key now okay so the the the bit the

1067
00:51:28,799 --> 00:51:33,440
important bit is that homomorphic

1068
00:51:31,240 --> 00:51:36,720
evaluation I'm doing here I need to know

1069
00:51:33,440 --> 00:51:39,599
the secret key because I'm not just

1070
00:51:36,720 --> 00:51:41,799
gonna say before I said what's going on

1071
00:51:39,599 --> 00:51:43,880
underneath under the hood I'm saying

1072
00:51:41,799 --> 00:51:46,319
look I have I one I have two Cipher

1073
00:51:43,880 --> 00:51:48,240
texts give me one of them no no no no

1074
00:51:46,319 --> 00:51:52,359
what I want to do is to say the

1075
00:51:48,240 --> 00:51:57,000
following under the hood decrypt

1076
00:51:52,359 --> 00:51:57,000
this decrypt this

1077
00:51:57,119 --> 00:52:02,599
and give me only the relevant one so

1078
00:52:00,319 --> 00:52:05,920
that even if this does not

1079
00:52:02,599 --> 00:52:07,640
decrypt so okay so here's the point

1080
00:52:05,920 --> 00:52:11,960
let's say I want to open to

1081
00:52:07,640 --> 00:52:16,520
X2 okay so okay he gives me X1 these are

1082
00:52:11,960 --> 00:52:20,000
valid so this is valid good but

1083
00:52:16,520 --> 00:52:23,400
now Cypher Tex 2 can be completely not

1084
00:52:20,000 --> 00:52:25,079
valid cuz when he opens he gives me

1085
00:52:23,400 --> 00:52:26,720
Cypher Tex one with these two so I know

1086
00:52:25,079 --> 00:52:28,680
this was valid because this is

1087
00:52:26,720 --> 00:52:31,720
computation and then they give me Cypher

1088
00:52:28,680 --> 00:52:34,839
Tex 2 and I do this evaluation then they

1089
00:52:31,720 --> 00:52:38,680
G me so the The Sibling Cipher Tex that

1090
00:52:34,839 --> 00:52:41,839
he gives me they may not be valid I want

1091
00:52:38,680 --> 00:52:44,640
to Ure even if they're not valid even if

1092
00:52:41,839 --> 00:52:47,760
they're not valid this is going to be

1093
00:52:44,640 --> 00:52:50,680
valid the openings are going to be valid

1094
00:52:47,760 --> 00:52:52,920
kind of the on the path things are going

1095
00:52:50,680 --> 00:52:55,359
to be valid even though the siblings

1096
00:52:52,920 --> 00:52:57,240
that are given in order to just kind of

1097
00:52:55,359 --> 00:53:00,760
do the verify the opening even if

1098
00:52:57,240 --> 00:53:04,119
they're not valid the opening path will

1099
00:53:00,760 --> 00:53:07,960
be kind of valid Cipher texts so why are

1100
00:53:04,119 --> 00:53:10,240
they going to be valid because the way

1101
00:53:07,960 --> 00:53:11,640
that what is so now let's what is the

1102
00:53:10,240 --> 00:53:13,440
deterministic computation that's

1103
00:53:11,640 --> 00:53:16,119
happening here the deter or the

1104
00:53:13,440 --> 00:53:17,480
evaluation the the evaluated Cipher Tech

1105
00:53:16,119 --> 00:53:20,760
the way we do the evaluation is the

1106
00:53:17,480 --> 00:53:26,920
following I decrypt this and I decrypt

1107
00:53:20,760 --> 00:53:30,680
this and then I take the decrypted value

1108
00:53:26,920 --> 00:53:33,000
and I encrypted with the next public key

1109
00:53:30,680 --> 00:53:35,960
so the point is even if this didn't

1110
00:53:33,000 --> 00:53:37,160
decrypt maybe this didn't decrypt I

1111
00:53:35,960 --> 00:53:41,400
don't

1112
00:53:37,160 --> 00:53:41,400
care I'm this is still going to be

1113
00:53:41,839 --> 00:53:47,880
valid okay so the point is even if the

1114
00:53:45,160 --> 00:53:51,480
The Sibling Cipher texts that are given

1115
00:53:47,880 --> 00:53:54,480
only for verifying the opening even if

1116
00:53:51,480 --> 00:53:56,760
these sibling Cipher text are malale

1117
00:53:54,480 --> 00:53:58,920
formed if you give me the open openings

1118
00:53:56,760 --> 00:54:01,839
in the entire path I get the guarantee

1119
00:53:58,920 --> 00:54:04,839
that on the path not on the siblings on

1120
00:54:01,839 --> 00:54:06,280
the path things are well formed and I

1121
00:54:04,839 --> 00:54:07,920
mean well formed cyer these are Cipher

1122
00:54:06,280 --> 00:54:10,280
Texs that decrypt

1123
00:54:07,920 --> 00:54:12,839
correctly and that's what I need for for

1124
00:54:10,280 --> 00:54:16,040
the soundness so it's important to do

1125
00:54:12,839 --> 00:54:18,960
the decryption this is really uh crucial

1126
00:54:16,040 --> 00:54:20,240
okay you doing each I follow okay again

1127
00:54:18,960 --> 00:54:21,520
what what am I doing on each note good

1128
00:54:20,240 --> 00:54:24,880
good good so here's what I'm doing on

1129
00:54:21,520 --> 00:54:27,000
each Noe H the evaluation function takes

1130
00:54:24,880 --> 00:54:29,440
kind of i j

1131
00:54:27,000 --> 00:54:32,119
secret key j minus one and two Cipher

1132
00:54:29,440 --> 00:54:34,799
Tex Cipher Tex zero and Cipher Tex

1133
00:54:32,119 --> 00:54:37,280
one and what it does is the following

1134
00:54:34,799 --> 00:54:41,359
decrypt cyppher Tex zero so it

1135
00:54:37,280 --> 00:54:44,960
decrypts with SK J minus one uh cyppher

1136
00:54:41,359 --> 00:54:50,079
Tex Z cyppher text B for every B get get

1137
00:54:44,960 --> 00:54:54,640
some uh bit I don't know a a alpha

1138
00:54:50,079 --> 00:54:54,640
B and then it

1139
00:54:54,760 --> 00:54:59,720
outputs one of them I know Alpha B Star

1140
00:54:58,119 --> 00:55:05,079
Alpha

1141
00:54:59,720 --> 00:55:06,839
i j so so it gets to bits and he he he

1142
00:55:05,079 --> 00:55:09,440
chooses one of them which one depending

1143
00:55:06,839 --> 00:55:11,760
on the IG you want so what you will get

1144
00:55:09,440 --> 00:55:16,119
the point is what you will get is really

1145
00:55:11,760 --> 00:55:18,720
an encryption so the point is let's

1146
00:55:16,119 --> 00:55:20,880
say I do it under the hood this isn't a

1147
00:55:18,720 --> 00:55:23,119
computation that is done under the hood

1148
00:55:20,880 --> 00:55:26,000
yes so this is going to be encrypted in

1149
00:55:23,119 --> 00:55:29,160
and in in a box but what I'm going to do

1150
00:55:26,000 --> 00:55:33,280
Under the box is to say so these I have

1151
00:55:29,160 --> 00:55:36,000
so sorry these two are i j and skj minus

1152
00:55:33,280 --> 00:55:38,799
one are in a box and the computation

1153
00:55:36,000 --> 00:55:40,880
that I'm doing inside the box as I'm

1154
00:55:38,799 --> 00:55:43,480
saying I have these in a box I have

1155
00:55:40,880 --> 00:55:45,839
these in the clear Inside the Box what I

1156
00:55:43,480 --> 00:55:47,720
do is the following I say I have the

1157
00:55:45,839 --> 00:55:50,599
secret key j minus one and these two

1158
00:55:47,720 --> 00:55:52,240
Cipher texts let me decrypt both of them

1159
00:55:50,599 --> 00:55:54,640
I'm going to get two bits Alpha zero and

1160
00:55:52,240 --> 00:55:57,240
Alpha One now maybe one of them is bad

1161
00:55:54,640 --> 00:55:59,839
so but so maybe one of them doesn't

1162
00:55:57,240 --> 00:56:01,440
decrypt so the one that doesn't decrypt

1163
00:55:59,839 --> 00:56:04,799
I'll put

1164
00:56:01,440 --> 00:56:07,280
bot and then the output will be the

1165
00:56:04,799 --> 00:56:09,280
relevant one that according if if it's

1166
00:56:07,280 --> 00:56:11,559
zero I'm going to Output Alpha zero if

1167
00:56:09,280 --> 00:56:14,839
it's one I'm going to Output Alpha One

1168
00:56:11,559 --> 00:56:17,400
and now what I can argue is on the path

1169
00:56:14,839 --> 00:56:21,160
itself everything has to be well formed

1170
00:56:17,400 --> 00:56:23,720
so I'm actually going to get the the

1171
00:56:21,160 --> 00:56:26,640
correct Cipher text and I can argue that

1172
00:56:23,720 --> 00:56:28,400
by induction Okay so

1173
00:56:26,640 --> 00:56:29,559
here of course this is well form because

1174
00:56:28,400 --> 00:56:32,280
I this is just a deterministic

1175
00:56:29,559 --> 00:56:35,400
computation that's done locally now the

1176
00:56:32,280 --> 00:56:38,280
point is so let's say like I I want to

1177
00:56:35,400 --> 00:56:40,799
Output I want to I'm binding an X1 this

1178
00:56:38,280 --> 00:56:42,640
is X1 is what I want to open Okay so

1179
00:56:40,799 --> 00:56:46,200
this must be well formed and now the

1180
00:56:42,640 --> 00:56:48,440
point is even if this is not well

1181
00:56:46,200 --> 00:56:50,720
formed what will I do under the hood I'm

1182
00:56:48,440 --> 00:56:52,119
going to open this and open this this is

1183
00:56:50,720 --> 00:56:53,440
going to be the correct value this is

1184
00:56:52,119 --> 00:56:56,680
not going to be maybe the correct this

1185
00:56:53,440 --> 00:56:59,680
may be bot but this is the one I choose

1186
00:56:56,680 --> 00:57:01,680
and then I encrypt it so I have it here

1187
00:56:59,680 --> 00:57:04,400
and then again this may be bad I'm going

1188
00:57:01,680 --> 00:57:05,799
to decrypt it it may be bot but this is

1189
00:57:04,400 --> 00:57:08,400
going to be good and this is the one I

1190
00:57:05,799 --> 00:57:11,440
choose so one can argue kind of by

1191
00:57:08,400 --> 00:57:13,559
induction that this is going to be inp x

1192
00:57:11,440 --> 00:57:15,280
one this is going be inp everything in

1193
00:57:13,559 --> 00:57:16,400
of X1 until the end so there's no way

1194
00:57:15,280 --> 00:57:17,319
you can open two different ways you have

1195
00:57:16,400 --> 00:57:19,839
to open to

1196
00:57:17,319 --> 00:57:22,160
X1 and the verifier is also going to do

1197
00:57:19,839 --> 00:57:23,359
the same computation to check exactly

1198
00:57:22,160 --> 00:57:28,160
the verifier does the exact same

1199
00:57:23,359 --> 00:57:28,160
computation to check yes

1200
00:57:29,160 --> 00:57:35,480
yeah

1201
00:57:32,079 --> 00:57:39,000
only right this is not opening a general

1202
00:57:35,480 --> 00:57:41,810
good so this exactly this shows that the

1203
00:57:39,000 --> 00:57:44,240
specific uh so this

1204
00:57:41,810 --> 00:57:47,240
[Music]

1205
00:57:44,240 --> 00:57:47,240
um

1206
00:57:47,760 --> 00:57:55,599
uh okay this shows that the specific eye

1207
00:57:51,799 --> 00:57:58,000
that's encrypted here so there's one the

1208
00:57:55,599 --> 00:58:02,240
hash key is binding on one eye on

1209
00:57:58,000 --> 00:58:06,920
specific eye the the eye on which you're

1210
00:58:02,240 --> 00:58:09,119
binding you can only open in one way uh

1211
00:58:06,920 --> 00:58:11,200
statistically and then by the index

1212
00:58:09,119 --> 00:58:12,880
hiding it means that you can only for

1213
00:58:11,200 --> 00:58:15,920
any J you can only open one way

1214
00:58:12,880 --> 00:58:18,520
computationally because you can

1215
00:58:15,920 --> 00:58:20,559
distinguish yeah you avoid this chain of

1216
00:58:18,520 --> 00:58:23,880
keys if you happy to

1217
00:58:20,559 --> 00:58:26,680
ENC good very good good good yes so you

1218
00:58:23,880 --> 00:58:28,200
can avoid uh you can avoid avoid using

1219
00:58:26,680 --> 00:58:32,119
many public Keys you can just use one

1220
00:58:28,200 --> 00:58:34,079
public key encrypt the secret key and

1221
00:58:32,119 --> 00:58:36,319
and rely on what's called circular

1222
00:58:34,079 --> 00:58:38,480
security that's another option if you

1223
00:58:36,319 --> 00:58:40,760
wish s doesn't want to do

1224
00:58:38,480 --> 00:58:43,680
that but yes

1225
00:58:40,760 --> 00:58:46,520
exactly exactly

1226
00:58:43,680 --> 00:58:49,000
yeah you see get

1227
00:58:46,520 --> 00:58:51,839
resistance you okay so yeah so you're

1228
00:58:49,000 --> 00:58:53,640
asking will you get uh Collision like

1229
00:58:51,839 --> 00:58:54,599
Collision resistance and the answer is

1230
00:58:53,640 --> 00:58:58,280
yes

1231
00:58:54,599 --> 00:59:02,039
because for the specific eye that you

1232
00:58:58,280 --> 00:59:06,160
for the specific ey that kind of you en

1233
00:59:02,039 --> 00:59:08,599
encrypted in the hash key you get uh

1234
00:59:06,160 --> 00:59:09,720
binding kind of statistically okay

1235
00:59:08,599 --> 00:59:10,880
there's no way you can open two

1236
00:59:09,720 --> 00:59:13,799
different

1237
00:59:10,880 --> 00:59:16,160
ways

1238
00:59:13,799 --> 00:59:19,760
and what you have at the end is just the

1239
00:59:16,160 --> 00:59:22,200
encryption of that Index right right so

1240
00:59:19,760 --> 00:59:25,079
you're asking about a different J oh

1241
00:59:22,200 --> 00:59:28,039
sorry no that you you have two x's that

1242
00:59:25,079 --> 00:59:28,039
have the same uh

1243
00:59:28,160 --> 00:59:33,359
index have the same that index and then

1244
00:59:31,880 --> 00:59:36,440
but the are

1245
00:59:33,359 --> 00:59:38,799
different you get a different outut of

1246
00:59:36,440 --> 00:59:40,799
the if you take those two different X

1247
00:59:38,799 --> 00:59:43,599
good good good okay so if you take two

1248
00:59:40,799 --> 00:59:46,839
different X's for which let's say they

1249
00:59:43,599 --> 00:59:49,680
have the same X1 and let's say the hash

1250
00:59:46,839 --> 00:59:52,680
key is binding on location

1251
00:59:49,680 --> 00:59:55,319
one the value would get if you if you

1252
00:59:52,680 --> 00:59:56,760
hash them honestly will be actually very

1253
00:59:55,319 --> 00:59:59,480
different

1254
00:59:56,760 --> 01:00:01,640
but because you use different X's but so

1255
00:59:59,480 --> 01:00:03,680
you'll get different values but if you

1256
01:00:01,640 --> 01:00:06,400
decrypt these values correspond to a

1257
01:00:03,680 --> 01:00:08,440
cyppher text as values they're going to

1258
01:00:06,400 --> 01:00:10,880
look very different but if you decrypt

1259
01:00:08,440 --> 01:00:16,960
you will get the same bit which is

1260
01:00:10,880 --> 01:00:18,960
X1 yeah good okay so anyway if you if

1261
01:00:16,960 --> 01:00:20,240
you didn't follow the exact construction

1262
01:00:18,960 --> 01:00:24,599
it doesn't really matter I just wanted

1263
01:00:20,240 --> 01:00:26,079
to make sure that uh uh you know this it

1264
01:00:24,599 --> 01:00:28,720
was clear that you really needed to do

1265
01:00:26,079 --> 01:00:30,640
this decryption uh yeah the reason you

1266
01:00:28,720 --> 01:00:32,880
don't need circular security as it is

1267
01:00:30,640 --> 01:00:34,680
for this F is that each of these

1268
01:00:32,880 --> 01:00:37,760
computations is simple enough that you

1269
01:00:34,680 --> 01:00:40,160
don't need to like the bo strap is that

1270
01:00:37,760 --> 01:00:45,960
the reason Okay the reason I don't need

1271
01:00:40,160 --> 01:00:47,680
uh uh um circular security is I'm I'm

1272
01:00:45,960 --> 01:00:51,760
never

1273
01:00:47,680 --> 01:00:55,359
encrypting a secret key under its

1274
01:00:51,760 --> 01:00:57,119
publicy so sorry asking why the you're

1275
01:00:55,359 --> 01:01:01,039
using not need to be

1276
01:00:57,119 --> 01:01:03,200
unbounded oh oh oh okay okay okay you're

1277
01:01:01,039 --> 01:01:06,160
saying okay sorry sorry you're you're

1278
01:01:03,200 --> 01:01:08,440
asking okay got it you're saying well in

1279
01:01:06,160 --> 01:01:11,280
general if we want arbitrary FHA we need

1280
01:01:08,440 --> 01:01:12,599
to assume circular secure LW inside it

1281
01:01:11,280 --> 01:01:14,559
kind of and you're asking do we not need

1282
01:01:12,599 --> 01:01:16,559
to assum like you're kind of going into

1283
01:01:14,559 --> 01:01:18,319
the you're saying do we actually need

1284
01:01:16,559 --> 01:01:20,280
fully fully fully homomorphic encryption

1285
01:01:18,319 --> 01:01:21,880
because if we do then actually we need

1286
01:01:20,280 --> 01:01:24,359
to rely on like a circle security

1287
01:01:21,880 --> 01:01:26,039
assumption inside too the answer is we

1288
01:01:24,359 --> 01:01:28,599
we because the computation is very

1289
01:01:26,039 --> 01:01:30,400
specific and very small depth you don't

1290
01:01:28,599 --> 01:01:33,200
need to there's no you don't need like

1291
01:01:30,400 --> 01:01:34,880
full full FH you need FH for very

1292
01:01:33,200 --> 01:01:39,760
bounded depth

1293
01:01:34,880 --> 01:01:42,200
computations yeah great thank you a any

1294
01:01:39,760 --> 01:01:42,200
any other

1295
01:01:42,240 --> 01:01:48,160
questions okay so let's

1296
01:01:46,039 --> 01:01:49,440
snar well let me just make sure I

1297
01:01:48,160 --> 01:01:50,760
covered everything I wanted

1298
01:01:49,440 --> 01:01:55,079
[Music]

1299
01:01:50,760 --> 01:01:57,200
to okay after three months we SN we snar

1300
01:01:55,079 --> 01:01:59,079
okay the last kind of two hours in class

1301
01:01:57,200 --> 01:02:01,680
last we're going to

1302
01:01:59,079 --> 01:02:05,520
snar okay

1303
01:02:01,680 --> 01:02:08,520
so okay so now the snar is really simple

1304
01:02:05,520 --> 01:02:10,440
it's like as simple as one can like you

1305
01:02:08,520 --> 01:02:18,119
essentially can do it done we're done

1306
01:02:10,440 --> 01:02:18,119
okay so how do we we can go home uh okay

1307
01:02:20,079 --> 01:02:25,960
so anybody want a cookie before we

1308
01:02:23,559 --> 01:02:27,960
snar I feel like these grandmothers that

1309
01:02:25,960 --> 01:02:30,480
kind of you know constantly feed

1310
01:02:27,960 --> 01:02:35,319
you okay so here's the idea the idea is

1311
01:02:30,480 --> 01:02:35,319
very simple take any so

1312
01:02:41,400 --> 01:02:46,559
snar okay so let me first say kind of

1313
01:02:44,760 --> 01:02:48,319
the high level idea the high level idea

1314
01:02:46,559 --> 01:02:51,240
is the following here's what the prover

1315
01:02:48,319 --> 01:02:53,160
will do the so the prover wants to

1316
01:02:51,240 --> 01:02:55,640
convince that X is in the language

1317
01:02:53,160 --> 01:02:58,240
there's some verification circuit so you

1318
01:02:55,640 --> 01:02:59,440
have X let's start with let's take X in

1319
01:02:58,240 --> 01:03:02,520
the language

1320
01:02:59,440 --> 01:03:03,880
or there is some for any X you know it

1321
01:03:02,520 --> 01:03:08,359
doesn't matter for any

1322
01:03:03,880 --> 01:03:11,440
X you have a circuit C

1323
01:03:08,359 --> 01:03:14,440
subx and C subx takes a

1324
01:03:11,440 --> 01:03:16,440
witness and now put 0 one like it's a

1325
01:03:14,440 --> 01:03:17,839
verification circuit you can also think

1326
01:03:16,440 --> 01:03:22,160
of it if you want

1327
01:03:17,839 --> 01:03:24,720
c as taking X and a witness and I'll put

1328
01:03:22,160 --> 01:03:26,640
zero if it's a not valid witness and one

1329
01:03:24,720 --> 01:03:28,240
if it's a valid Witness if it's a

1330
01:03:26,640 --> 01:03:29,839
deterministic computation there's no

1331
01:03:28,240 --> 01:03:31,240
witness just say x and output zero or

1332
01:03:29,839 --> 01:03:33,400
one that's the

1333
01:03:31,240 --> 01:03:35,680
computation okay so when when I talk

1334
01:03:33,400 --> 01:03:37,760
about snarky you can think of snar of

1335
01:03:35,680 --> 01:03:39,119
non- deterministic snar of deterministic

1336
01:03:37,760 --> 01:03:41,039
any language L I don't even want to go

1337
01:03:39,119 --> 01:03:44,119
to specific okay but when I have a

1338
01:03:41,039 --> 01:03:45,480
language L you know what how what does

1339
01:03:44,119 --> 01:03:48,760
it mean a language well there's some

1340
01:03:45,480 --> 01:03:51,559
circuit it takes the instance maybe with

1341
01:03:48,760 --> 01:03:54,039
a witness and the circuit kind of does

1342
01:03:51,559 --> 01:03:55,920
some checks to decide if it's valid or

1343
01:03:54,039 --> 01:03:59,079
not valid

1344
01:03:55,920 --> 01:04:01,559
okay now I want to convince you I have

1345
01:03:59,079 --> 01:04:05,200
an X I want to give you a snar that this

1346
01:04:01,559 --> 01:04:07,279
C an X outputs one either that there's a

1347
01:04:05,200 --> 01:04:09,119
witness say that outputs one or maybe

1348
01:04:07,279 --> 01:04:12,680
it's DET terministic so just C of X Out

1349
01:04:09,119 --> 01:04:13,839
outputs one here's what I'm going to do

1350
01:04:12,680 --> 01:04:16,520
what I'm going to do I'm going to

1351
01:04:13,839 --> 01:04:19,319
compute all the wires of this circuit

1352
01:04:16,520 --> 01:04:21,319
I'm all the wires and I'm going to give

1353
01:04:19,319 --> 01:04:23,680
you a hash of all the wires now there's

1354
01:04:21,319 --> 01:04:24,720
a lot of wires so it's going to be a

1355
01:04:23,680 --> 01:04:27,079
shrinking

1356
01:04:24,720 --> 01:04:28,279
hash I'm gonna actually use a somewh

1357
01:04:27,079 --> 01:04:29,960
extractable

1358
01:04:28,279 --> 01:04:32,400
hash

1359
01:04:29,960 --> 01:04:35,640
so let's say we agreed on a hash key for

1360
01:04:32,400 --> 01:04:37,880
somewhere extractable hash I the prover

1361
01:04:35,640 --> 01:04:39,880
I'm going to compute all the wires of

1362
01:04:37,880 --> 01:04:41,680
this verification

1363
01:04:39,880 --> 01:04:44,480
circuit and I'm going to give you the

1364
01:04:41,680 --> 01:04:46,279
hash the hash of the the values of all

1365
01:04:44,480 --> 01:04:48,599
the

1366
01:04:46,279 --> 01:04:50,440
wires okay hash what are you going to do

1367
01:04:48,599 --> 01:04:52,319
with that so the other thing I'm going

1368
01:04:50,440 --> 01:04:57,160
to give you is I'm going to give you a

1369
01:04:52,319 --> 01:04:59,760
bar a proof a bar of what the bark I'm

1370
01:04:57,160 --> 01:05:03,079
going to give you is that every gate

1371
01:04:59,760 --> 01:05:05,839
here is satisfied so I committed to all

1372
01:05:03,079 --> 01:05:07,359
the wires I can commit to anything I I

1373
01:05:05,839 --> 01:05:09,559
mean I hashed all the wires now I'm

1374
01:05:07,359 --> 01:05:11,799
going to prove to you that for any gate

1375
01:05:09,559 --> 01:05:14,559
if you look at kind of the

1376
01:05:11,799 --> 01:05:16,720
two the in the two input wires to the

1377
01:05:14,559 --> 01:05:20,720
gate and the output wire of the gate

1378
01:05:16,720 --> 01:05:23,760
they satisfy the gate so for any for all

1379
01:05:20,720 --> 01:05:27,440
every gate in the circuit I'm going to

1380
01:05:23,760 --> 01:05:30,160
prove to you that there exists an

1381
01:05:27,440 --> 01:05:32,559
opening to this wire and an opening to

1382
01:05:30,160 --> 01:05:35,279
this wire and to this wire such that

1383
01:05:32,559 --> 01:05:39,200
these openings are valid and that the

1384
01:05:35,279 --> 01:05:42,079
values that I opened accept the the kind

1385
01:05:39,200 --> 01:05:44,200
of respect the

1386
01:05:42,079 --> 01:05:45,319
gate and I'm going to prove to you that

1387
01:05:44,200 --> 01:05:49,200
the

1388
01:05:45,319 --> 01:05:51,520
output that so I I I I said that I I

1389
01:05:49,200 --> 01:05:53,039
hashed all the wires I'm going to argue

1390
01:05:51,520 --> 01:05:55,960
I'm going to open the output wire so you

1391
01:05:53,039 --> 01:05:57,520
see the end output is one so again what

1392
01:05:55,960 --> 01:05:59,839
am I going to do I want to I want to

1393
01:05:57,520 --> 01:06:03,480
convince you that the output here is

1394
01:05:59,839 --> 01:06:05,279
one I'm going to Hash all the wires the

1395
01:06:03,480 --> 01:06:07,920
value of all the wires in the

1396
01:06:05,279 --> 01:06:10,440
circuit I'm going to prove that every

1397
01:06:07,920 --> 01:06:12,319
gate is kind of satisfied I have an

1398
01:06:10,440 --> 01:06:16,520
opening that's kind of respects each and

1399
01:06:12,319 --> 01:06:20,119
every gate and the output wire is

1400
01:06:16,520 --> 01:06:23,440
one that's my SN yeah how's this

1401
01:06:20,119 --> 01:06:27,799
different from gkr okay how is this

1402
01:06:23,440 --> 01:06:30,319
different from gkr uh G okay so gkr is

1403
01:06:27,799 --> 01:06:33,799
uh is very different in many ways first

1404
01:06:30,319 --> 01:06:37,799
of all it's a interactive protocol now

1405
01:06:33,799 --> 01:06:40,720
you can apply F to it but essentially in

1406
01:06:37,799 --> 01:06:43,279
gkr you kind of take the circuit you

1407
01:06:40,720 --> 01:06:46,079
compute all the wires in the circuit but

1408
01:06:43,279 --> 01:06:48,000
actually I don't bar say look all the

1409
01:06:46,079 --> 01:06:49,279
wires are satisfied instead I'm going to

1410
01:06:48,000 --> 01:06:52,160
kind of we're doing an interactive

1411
01:06:49,279 --> 01:06:54,359
process saying oh I'm going to I argue

1412
01:06:52,160 --> 01:06:55,960
the output wies one and then we do kind

1413
01:06:54,359 --> 01:06:58,640
of a little sum check or some inve

1414
01:06:55,960 --> 01:07:01,240
process to reduce checking that value to

1415
01:06:58,640 --> 01:07:03,839
checking a value in one layer below and

1416
01:07:01,240 --> 01:07:07,240
then we do an instructive process to say

1417
01:07:03,839 --> 01:07:09,400
Okay if that was false you know then the

1418
01:07:07,240 --> 01:07:11,680
layer below needs to be false until we

1419
01:07:09,400 --> 01:07:14,480
reach the the leaves and then you can

1420
01:07:11,680 --> 01:07:15,279
apply F chamir to that to kind of make

1421
01:07:14,480 --> 01:07:17,240
it a

1422
01:07:15,279 --> 01:07:19,279
snar here we're doing something very

1423
01:07:17,240 --> 01:07:21,119
differently we're starting with a bar

1424
01:07:19,279 --> 01:07:23,839
now it's true that the construction you

1425
01:07:21,119 --> 01:07:25,720
saw for bar uses F also but some

1426
01:07:23,839 --> 01:07:27,200
constructions don't use f actually for

1427
01:07:25,720 --> 01:07:29,319
bar there are various constructions of

1428
01:07:27,200 --> 01:07:32,599
bargs you saw one of them but there are

1429
01:07:29,319 --> 01:07:35,400
others so we say take any

1430
01:07:32,599 --> 01:07:36,880
bar and there's no interaction here like

1431
01:07:35,400 --> 01:07:38,960
besides maybe they're inside the bark

1432
01:07:36,880 --> 01:07:41,359
but maybe the bark doesn't have any F or

1433
01:07:38,960 --> 01:07:44,119
anything to it and we're saying just

1434
01:07:41,359 --> 01:07:45,559
hash all the wires of the circuit and

1435
01:07:44,119 --> 01:07:46,760
prove that everything is consistent

1436
01:07:45,559 --> 01:07:49,880
that's

1437
01:07:46,760 --> 01:07:52,480
it that's really what we're

1438
01:07:49,880 --> 01:07:55,760
doing so let me write this down so it

1439
01:07:52,480 --> 01:07:59,440
will be so that my ingredients that I

1440
01:07:55,760 --> 01:08:02,720
have for my snar is uh so okay so

1441
01:07:59,440 --> 01:08:02,720
ingredients maybe I'll write it

1442
01:08:04,680 --> 01:08:08,119
here so my

1443
01:08:10,799 --> 01:08:17,080
ingredients is a

1444
01:08:13,880 --> 01:08:19,799
bar and Sumer extractable

1445
01:08:17,080 --> 01:08:22,920
hash these are my ingredients and I'm

1446
01:08:19,799 --> 01:08:29,319
going to show you my snar okay so snar

1447
01:08:22,920 --> 01:08:29,319
has uh three algorithms we have a gen

1448
01:08:30,199 --> 01:08:33,600
algorithm and here's what my gen

1449
01:08:32,159 --> 01:08:36,920
algorithm is going to

1450
01:08:33,600 --> 01:08:39,600
do it's going to let's say the Gen also

1451
01:08:36,920 --> 01:08:39,600
has an input

1452
01:08:40,080 --> 01:08:45,400
length ah we don't need it

1453
01:08:43,400 --> 01:08:47,960
okay here's what it's going to okay

1454
01:08:45,400 --> 01:08:50,960
let's say it has an input

1455
01:08:47,960 --> 01:08:52,199
length so this says you know you're

1456
01:08:50,960 --> 01:08:55,560
going to prove to me statements of

1457
01:08:52,199 --> 01:08:57,920
length that the input X is of length n

1458
01:08:55,560 --> 01:09:01,839
okay so here's what we're going to do

1459
01:08:57,920 --> 01:09:01,839
first thing we do is we're going to

1460
01:09:04,400 --> 01:09:08,319
generate a hash

1461
01:09:09,880 --> 01:09:16,440
key for Gen of the Sumer extractable

1462
01:09:14,319 --> 01:09:17,920
hash so generate a hash key

1463
01:09:16,440 --> 01:09:20,920
corresponding to the summer extractable

1464
01:09:17,920 --> 01:09:24,000
hash this is going to be with security

1465
01:09:20,920 --> 01:09:28,319
parameter n is going to

1466
01:09:24,000 --> 01:09:31,960
be this is going to be number of

1467
01:09:28,319 --> 01:09:34,560
wires in the circuit C this is the

1468
01:09:31,960 --> 01:09:37,239
circuit that takes X of length n

1469
01:09:34,560 --> 01:09:39,719
possibly a witness and output zero or

1470
01:09:37,239 --> 01:09:43,159
one okay so this is going to be the

1471
01:09:39,719 --> 01:09:45,279
number of wires and take any I I don't

1472
01:09:43,159 --> 01:09:47,679
know whatever I equals 1 take any I in

1473
01:09:45,279 --> 01:09:50,159
between one to n it doesn't matter

1474
01:09:47,679 --> 01:09:52,839
choose it arbitrarily your favorite

1475
01:09:50,159 --> 01:09:56,400
number okay so that's first thing and

1476
01:09:52,839 --> 01:09:58,800
then you also generate a CRS for the bar

1477
01:09:56,400 --> 01:09:58,800
so you

1478
01:09:59,159 --> 01:10:03,159
generate a CRS for

1479
01:10:04,400 --> 01:10:10,480
bar this is for the

1480
01:10:07,040 --> 01:10:13,520
bar and this will be with input one to

1481
01:10:10,480 --> 01:10:15,280
the with the sc one to the Lambda K the

1482
01:10:13,520 --> 01:10:18,440
number of statements is like the number

1483
01:10:15,280 --> 01:10:21,320
of gates in the circuit so K is going to

1484
01:10:18,440 --> 01:10:24,920
be number of

1485
01:10:21,320 --> 01:10:26,000
gates in C because we're going to

1486
01:10:24,920 --> 01:10:28,400
remember we're going to say we're going

1487
01:10:26,000 --> 01:10:30,679
to prove that for every gate is

1488
01:10:28,400 --> 01:10:32,320
satisfied so usually K and N are very

1489
01:10:30,679 --> 01:10:34,880
similar it's like essentially the same

1490
01:10:32,320 --> 01:10:36,640
number but you know uh let me just be

1491
01:10:34,880 --> 01:10:40,080
clear that this is we're going to have

1492
01:10:36,640 --> 01:10:42,400
the number of gates and the length n

1493
01:10:40,080 --> 01:10:44,880
there and let me call it n Prime we'll

1494
01:10:42,400 --> 01:10:46,920
see what it is it's a we'll see what

1495
01:10:44,880 --> 01:10:50,199
this n Prime is in a in a minute so the

1496
01:10:46,920 --> 01:10:53,600
we're going to Bar statements not of

1497
01:10:50,199 --> 01:10:55,640
length n but of a different length n

1498
01:10:53,600 --> 01:10:59,199
Prime we're going to see what that is

1499
01:10:55,640 --> 01:10:59,199
but the output is just

1500
01:10:59,920 --> 01:11:07,239
a uh let me call this CRS bar so you

1501
01:11:04,120 --> 01:11:09,800
output CRS which is equal to Hash key

1502
01:11:07,239 --> 01:11:09,800
and CRS

1503
01:11:15,520 --> 01:11:21,199
bar okay so that's how you generate so

1504
01:11:18,040 --> 01:11:23,520
the key generation the CRS has a CRS for

1505
01:11:21,199 --> 01:11:26,360
the bar and a hash

1506
01:11:23,520 --> 01:11:27,880
key now we're going going

1507
01:11:26,360 --> 01:11:31,199
to

1508
01:11:27,880 --> 01:11:34,719
a uh what does the prover do so the

1509
01:11:31,199 --> 01:11:35,719
prover gets his input X maybe a witness

1510
01:11:34,719 --> 01:11:39,800
if it's an

1511
01:11:35,719 --> 01:11:42,040
NP maybe there's no witness let me say

1512
01:11:39,800 --> 01:11:43,840
generally with a witness but uh actually

1513
01:11:42,040 --> 01:11:44,880
the bar we're going to construct today

1514
01:11:43,840 --> 01:11:47,280
is going to be for deterministic

1515
01:11:44,880 --> 01:11:48,400
languages but let me write it also for

1516
01:11:47,280 --> 01:11:49,760
because I'm going to show you kind of a

1517
01:11:48,400 --> 01:11:56,120
general

1518
01:11:49,760 --> 01:11:58,480
framework so p is going to get a CRS

1519
01:11:56,120 --> 01:12:02,239
X and maybe a witness if it's an

1520
01:11:58,480 --> 01:12:06,560
NP and he needs to generate a snar so

1521
01:12:02,239 --> 01:12:06,560
what does he what does it do

1522
01:12:06,920 --> 01:12:11,719
compute all the wires in the circuit so

1523
01:12:09,800 --> 01:12:12,800
X is fixed let's think of X is like

1524
01:12:11,719 --> 01:12:15,400
that's not part of the wires because

1525
01:12:12,800 --> 01:12:16,239
it's fixed but let's compute all the

1526
01:12:15,400 --> 01:12:22,280
like

1527
01:12:16,239 --> 01:12:25,440
W1 up to w a n which is the wires of the

1528
01:12:22,280 --> 01:12:27,239
circuit you can think of the first m has

1529
01:12:25,440 --> 01:12:28,880
kind of the actual witness let's say the

1530
01:12:27,239 --> 01:12:31,920
if you have a witness and it's of length

1531
01:12:28,880 --> 01:12:34,199
M W1 w m is the witness but then the

1532
01:12:31,920 --> 01:12:35,880
rest are the wires so I'm thinking the

1533
01:12:34,199 --> 01:12:37,360
wires include kind of the witness and

1534
01:12:35,880 --> 01:12:38,880
everything above and if there's no

1535
01:12:37,360 --> 01:12:44,239
witness then it doesn't include a

1536
01:12:38,880 --> 01:12:44,239
witness so I compute these are all the

1537
01:12:44,400 --> 01:12:50,080
wires in

1538
01:12:47,040 --> 01:12:52,920
C except

1539
01:12:50,080 --> 01:12:54,440
X except the input Y is corresponding

1540
01:12:52,920 --> 01:12:56,000
the input Y is corresponding to X cuz

1541
01:12:54,440 --> 01:12:57,360
that's kind of we know what it is the

1542
01:12:56,000 --> 01:13:00,880
verifier knows

1543
01:12:57,360 --> 01:13:03,239
it okay so you compute all the wires and

1544
01:13:00,880 --> 01:13:06,840
then you

1545
01:13:03,239 --> 01:13:08,600
compute hash of the you compute V which

1546
01:13:06,840 --> 01:13:13,280
is a hash the

1547
01:13:08,600 --> 01:13:16,639
eval with hash key of W1 up to

1548
01:13:13,280 --> 01:13:18,320
WN so you hash all these wires together

1549
01:13:16,639 --> 01:13:19,800
okay so the verifier computed all the

1550
01:13:18,320 --> 01:13:23,480
wires of the

1551
01:13:19,800 --> 01:13:26,880
circuit hashed all the

1552
01:13:23,480 --> 01:13:29,560
wires oh uh okay actually let me just

1553
01:13:26,880 --> 01:13:29,560
say

1554
01:13:31,639 --> 01:13:38,000
sorry when you generate a key I said you

1555
01:13:34,280 --> 01:13:40,480
know use a a a su constructible hash yes

1556
01:13:38,000 --> 01:13:44,080
exactly but let's you don't need to just

1557
01:13:40,480 --> 01:13:48,199
use one index okay so let's use it with

1558
01:13:44,080 --> 01:13:50,920
few index i l now you can ask what is

1559
01:13:48,199 --> 01:13:54,280
L we'll see you know you can think of it

1560
01:13:50,920 --> 01:13:56,880
as a few L's you can think of poly log l

1561
01:13:54,280 --> 01:13:59,639
the bigger the is the less extinct the

1562
01:13:56,880 --> 01:14:03,239
snar is going to be so the snar is going

1563
01:13:59,639 --> 01:14:05,080
to grow with L because the hash key

1564
01:14:03,239 --> 01:14:06,679
grows with L it's like L hash Keys

1565
01:14:05,080 --> 01:14:09,000
essentially because we're

1566
01:14:06,679 --> 01:14:11,960
repeating so here I'm going to be

1567
01:14:09,000 --> 01:14:11,960
binding on L

1568
01:14:12,360 --> 01:14:16,960
locations the hash value grow with L

1569
01:14:15,239 --> 01:14:20,440
because you're like you're Computing

1570
01:14:16,960 --> 01:14:23,719
essentially L hash values so the more

1571
01:14:20,440 --> 01:14:25,280
the bigger L is in some sense the more

1572
01:14:23,719 --> 01:14:28,360
secure we're going to we're going to get

1573
01:14:25,280 --> 01:14:30,480
we'll see but the more non succinct it's

1574
01:14:28,360 --> 01:14:32,280
going to be so L now is going to be a

1575
01:14:30,480 --> 01:14:34,679
parameter and when we talk about then

1576
01:14:32,280 --> 01:14:35,880
Elis we'll see which L we want yeah is

1577
01:14:34,679 --> 01:14:38,120
there any hope for getting like

1578
01:14:35,880 --> 01:14:39,960
sublinear dependence in L like any other

1579
01:14:38,120 --> 01:14:44,040
construction instead of a direct product

1580
01:14:39,960 --> 01:14:46,920
construction so okay in V there's no way

1581
01:14:44,040 --> 01:14:49,480
to get sublinear and L because you need

1582
01:14:46,920 --> 01:14:51,960
to extract it's like a there's must have

1583
01:14:49,480 --> 01:14:56,280
information so in V there's no way to

1584
01:14:51,960 --> 01:14:58,440
have to have in the Hat key on the other

1585
01:14:56,280 --> 01:15:04,400
hand

1586
01:14:58,440 --> 01:15:06,520
um okay if the I I want up to I L can be

1587
01:15:04,400 --> 01:15:09,480
shrunk somehow if there's a sucin

1588
01:15:06,520 --> 01:15:11,440
description of i1 to I for example in

1589
01:15:09,480 --> 01:15:14,199
the case of a witness you know I'm I

1590
01:15:11,440 --> 01:15:16,440
want to be extractable and witness I

1591
01:15:14,199 --> 01:15:18,600
these are consecutive locations so I

1592
01:15:16,440 --> 01:15:20,679
don't need to write location I I plus

1593
01:15:18,600 --> 01:15:22,199
one I plus you can just say I and go

1594
01:15:20,679 --> 01:15:24,600
from I to n there's a very suin

1595
01:15:22,199 --> 01:15:25,760
description in the case where there's Su

1596
01:15:24,600 --> 01:15:28,320
description

1597
01:15:25,760 --> 01:15:30,280
you can hope to get the hash key

1598
01:15:28,320 --> 01:15:33,960
smaller and we do know how to get the

1599
01:15:30,280 --> 01:15:36,440
hash key smaller but in general uh for

1600
01:15:33,960 --> 01:15:39,199
the Val value there's no way information

1601
01:15:36,440 --> 01:15:44,000
theoretically great great

1602
01:15:39,199 --> 01:15:45,679
question okay so a okay so you compute

1603
01:15:44,000 --> 01:15:47,520
the the hash value of all the wires and

1604
01:15:45,679 --> 01:15:50,639
then you add a Barb so the last thing

1605
01:15:47,520 --> 01:15:50,639
you do is you

1606
01:15:51,679 --> 01:15:57,159
compute uh the P bar like you take the a

1607
01:15:55,199 --> 01:15:59,800
bar

1608
01:15:57,159 --> 01:16:03,679
prover and here's our bar prover you

1609
01:15:59,800 --> 01:16:03,679
give it CRS of

1610
01:16:04,159 --> 01:16:10,000
bar and you have axes and Witnesses now

1611
01:16:07,679 --> 01:16:12,639
what are the axes and the witnesses okay

1612
01:16:10,000 --> 01:16:14,040
I want to use I want to argue I'm going

1613
01:16:12,639 --> 01:16:17,400
to generate a bunch of axes and

1614
01:16:14,040 --> 01:16:19,400
Witnesses and generate a proof so what

1615
01:16:17,400 --> 01:16:25,239
is it that I'm what are so I'm going to

1616
01:16:19,400 --> 01:16:26,639
give you X1 star x k star and W1 star

1617
01:16:25,239 --> 01:16:30,120
I'll tell you what these are in a second

1618
01:16:26,639 --> 01:16:33,440
w k star so this is going to be Pi this

1619
01:16:30,120 --> 01:16:33,440
is going to be

1620
01:16:35,280 --> 01:16:41,840
compute Pi

1621
01:16:38,480 --> 01:16:45,280
Bar so you bar case statements but what

1622
01:16:41,840 --> 01:16:47,400
are these statements so so let me just

1623
01:16:45,280 --> 01:16:50,400
tell you what these and these

1624
01:16:47,400 --> 01:16:50,400
are

1625
01:16:50,480 --> 01:16:55,840
so

1626
01:16:52,320 --> 01:16:58,239
X star J

1627
01:16:55,840 --> 01:17:00,520
is essentially it's going to it's going

1628
01:16:58,239 --> 01:17:04,440
to be hash

1629
01:17:00,520 --> 01:17:09,080
key value and

1630
01:17:04,440 --> 01:17:13,280
J okay that's X that so what I'm going

1631
01:17:09,080 --> 01:17:17,000
to prove that for each gate

1632
01:17:13,280 --> 01:17:20,080
J I have an opening to the input wires

1633
01:17:17,000 --> 01:17:21,400
of the gate and the out wire of the gate

1634
01:17:20,080 --> 01:17:25,400
with respect I have an opening with

1635
01:17:21,400 --> 01:17:28,600
respect to V that satisfi the gate okay

1636
01:17:25,400 --> 01:17:33,960
so the XJ is going to be well I have the

1637
01:17:28,600 --> 01:17:38,600
hash ke I have the hash value and gate J

1638
01:17:33,960 --> 01:17:43,440
and the witness for gate J is going to

1639
01:17:38,600 --> 01:17:47,520
be opening so I'm going to have a like

1640
01:17:43,440 --> 01:17:49,080
bit uh like a left child right child

1641
01:17:47,520 --> 01:17:52,280
output

1642
01:17:49,080 --> 01:17:55,040
child not child I'll put the

1643
01:17:52,280 --> 01:17:57,040
parent uh so left child right right

1644
01:17:55,040 --> 01:18:01,080
child and parent of the

1645
01:17:57,040 --> 01:18:04,920
gate opening row of left child row of

1646
01:18:01,080 --> 01:18:04,920
right child row of the

1647
01:18:05,920 --> 01:18:11,600
output that's going to be a witness and

1648
01:18:08,639 --> 01:18:16,920
it's a valid witness

1649
01:18:11,600 --> 01:18:17,880
if b0 row zero are valid opening of the

1650
01:18:16,920 --> 01:18:20,000
left

1651
01:18:17,880 --> 01:18:25,120
child of

1652
01:18:20,000 --> 01:18:29,159
GJ B1 Row one are a valid opening of the

1653
01:18:25,120 --> 01:18:31,800
right child of gate J B out and row out

1654
01:18:29,159 --> 01:18:33,199
are valid openings of the output wire of

1655
01:18:31,800 --> 01:18:37,120
gate J

1656
01:18:33,199 --> 01:18:40,520
and these satisfy the gate so if it's a

1657
01:18:37,120 --> 01:18:43,000
end gate this and this is

1658
01:18:40,520 --> 01:18:46,239
this okay that's gonna that's what

1659
01:18:43,000 --> 01:18:49,920
that's G to that's so a valid witness is

1660
01:18:46,239 --> 01:18:53,639
a six tupo like this that all these

1661
01:18:49,920 --> 01:18:55,719
openings are accepted and these bits

1662
01:18:53,639 --> 01:18:57,760
satisfy the gate

1663
01:18:55,719 --> 01:18:59,960
and are valid opening with respect to

1664
01:18:57,760 --> 01:19:02,400
which wires the wires that are defined

1665
01:18:59,960 --> 01:19:05,560
by the gate so think of that you know we

1666
01:19:02,400 --> 01:19:08,600
have this circuit C the gates are kind

1667
01:19:05,560 --> 01:19:10,440
of uh numbered and for any Gates J we

1668
01:19:08,600 --> 01:19:13,600
know there's we know the number of the

1669
01:19:10,440 --> 01:19:15,040
input an output wire okay because it's

1670
01:19:13,600 --> 01:19:17,760
this is uniform everything the circuit

1671
01:19:15,040 --> 01:19:22,360
is uniform so for every gate J we

1672
01:19:17,760 --> 01:19:25,159
corresponds to you know I know I yre I

1673
01:19:22,360 --> 01:19:27,600
yre J and yre K yeah and so these

1674
01:19:25,159 --> 01:19:31,360
openings should be with respect to y i y

1675
01:19:27,600 --> 01:19:33,000
j and y k the same hash key for same

1676
01:19:31,360 --> 01:19:35,600
hash key for all of them yeah because I

1677
01:19:33,000 --> 01:19:37,800
used one hash key I mean it's one hash

1678
01:19:35,600 --> 01:19:40,080
key that's binding and and allocations

1679
01:19:37,800 --> 01:19:41,520
but I'm uh now I'm thinking just just

1680
01:19:40,080 --> 01:19:43,360
one hash key that's binding how I

1681
01:19:41,520 --> 01:19:46,000
construct it

1682
01:19:43,360 --> 01:19:47,679
will abstract that for now but yeah I

1683
01:19:46,000 --> 01:19:51,280
have one hash key that's binding on a

1684
01:19:47,679 --> 01:19:53,000
location I hash all the values of the

1685
01:19:51,280 --> 01:19:55,080
the W the values of all the wires to

1686
01:19:53,000 --> 01:20:00,000
this specific hash key and then add a

1687
01:19:55,080 --> 01:20:02,600
bar for any uh gate J that I have an

1688
01:20:00,000 --> 01:20:07,880
opening for the input the two input

1689
01:20:02,600 --> 01:20:12,120
children the output output uh um wire of

1690
01:20:07,880 --> 01:20:15,040
gate J that satisfy the gate yeah only

1691
01:20:12,120 --> 01:20:16,360
differ index itself so it's like one of

1692
01:20:15,040 --> 01:20:18,719
the

1693
01:20:16,360 --> 01:20:20,760
index yeah yeah yeah yeah good so you're

1694
01:20:18,719 --> 01:20:24,239
saying where's J here where's

1695
01:20:20,760 --> 01:20:27,199
J is that you're saying no more like

1696
01:20:24,239 --> 01:20:29,480
like J star and XJ the only difference

1697
01:20:27,199 --> 01:20:32,239
is J okay so this is an index kind of

1698
01:20:29,480 --> 01:20:35,920
language yeah this note this is kind of

1699
01:20:32,239 --> 01:20:39,800
it's that X1 X1 star X2 star are the

1700
01:20:35,920 --> 01:20:41,639
same hash KV K one two 3 four up to K so

1701
01:20:39,800 --> 01:20:44,120
it's kind of an index language we're

1702
01:20:41,639 --> 01:20:45,800
going to get back to it when uh because

1703
01:20:44,120 --> 01:20:48,679
we want the efficiency of V so we'll

1704
01:20:45,800 --> 01:20:48,679
talk about that but

1705
01:20:49,360 --> 01:20:56,040
yes any question about the the prover

1706
01:20:53,040 --> 01:20:56,040
here

1707
01:20:56,480 --> 01:21:00,320
okay so now the verifier what the

1708
01:20:58,639 --> 01:21:03,760
verifier

1709
01:21:00,320 --> 01:21:05,960
does is uh okay so now let's write the

1710
01:21:03,760 --> 01:21:10,280
verifier

1711
01:21:05,960 --> 01:21:14,000
somewhere oh that's sad I want to keep

1712
01:21:10,280 --> 01:21:16,000
this okay if you don't mind we'll write

1713
01:21:14,000 --> 01:21:20,239
the verifier

1714
01:21:16,000 --> 01:21:23,199
here okay so what does the verifier do V

1715
01:21:20,239 --> 01:21:27,520
takes his input a CRS which

1716
01:21:23,199 --> 01:21:27,520
is hash key and CRS

1717
01:21:28,800 --> 01:21:37,040
bar that's the CRS and it takes an

1718
01:21:33,239 --> 01:21:40,280
instance X and a proof what is the proof

1719
01:21:37,040 --> 01:21:40,280
a proof is a

1720
01:21:41,000 --> 01:21:47,600
value and um a

1721
01:21:44,040 --> 01:21:50,840
bar a hash value and a bar okay so the

1722
01:21:47,600 --> 01:21:54,880
verifier he gets the CRS which is of

1723
01:21:50,840 --> 01:21:58,120
this form he gets an input X and he gets

1724
01:21:54,880 --> 01:22:02,719
snar a snar is oh did I say what did

1725
01:21:58,120 --> 01:22:02,719
output sorry okay sorry compute

1726
01:22:04,800 --> 01:22:08,719
output V and P

1727
01:22:13,000 --> 01:22:20,840
bar so now he takes the The Snug which

1728
01:22:17,719 --> 01:22:25,120
is a

1729
01:22:20,840 --> 01:22:27,760
hash and uh and a bar

1730
01:22:25,120 --> 01:22:31,080
and it just outputs

1731
01:22:27,760 --> 01:22:31,080
one and

1732
01:22:31,639 --> 01:22:38,880
output the output of V bar he accepts if

1733
01:22:35,239 --> 01:22:44,960
and only if the bar is accepting what do

1734
01:22:38,880 --> 01:22:49,760
I mean the bar V bar takes CRS

1735
01:22:44,960 --> 01:22:51,159
bar and X1 star up to XK star which are

1736
01:22:49,760 --> 01:22:52,800
essentially an index language

1737
01:22:51,159 --> 01:22:54,960
corresponding to

1738
01:22:52,800 --> 01:22:57,239
HK V

1739
01:22:54,960 --> 01:22:57,239
and

1740
01:23:01,239 --> 01:23:08,840
J so it

1741
01:23:03,840 --> 01:23:08,840
accepts if and only if the bar is

1742
01:23:10,120 --> 01:23:13,520
accepted that's the

1743
01:23:20,639 --> 01:23:28,080
snar one thing I so again you a the

1744
01:23:25,600 --> 01:23:30,239
again what is the snar in the CRS

1745
01:23:28,080 --> 01:23:32,600
generated generation you generate a hash

1746
01:23:30,239 --> 01:23:35,679
key for the sum extractable hash and you

1747
01:23:32,600 --> 01:23:38,159
generate a CRS for the barg the

1748
01:23:35,679 --> 01:23:40,560
prover computes the values of all the

1749
01:23:38,159 --> 01:23:42,920
wires in the circuits hashes it using

1750
01:23:40,560 --> 01:23:46,320
the hash key to generate a value a hash

1751
01:23:42,920 --> 01:23:49,120
value V and then he proves he gives a

1752
01:23:46,320 --> 01:23:51,639
bar that all the gates are satisfied

1753
01:23:49,120 --> 01:23:54,280
namely for every gate he has an opening

1754
01:23:51,639 --> 01:23:56,679
valid that's satisfi that respects the

1755
01:23:54,280 --> 01:23:58,120
gate gate and that the upper gate is one

1756
01:23:56,679 --> 01:23:59,320
that's another thing you also prove that

1757
01:23:58,120 --> 01:24:01,679
in the B you also prove that the upper

1758
01:23:59,320 --> 01:24:05,040
gate is one so for the upper gate you

1759
01:24:01,679 --> 01:24:06,920
prove it respects namely you prove it's

1760
01:24:05,040 --> 01:24:09,440
one

1761
01:24:06,920 --> 01:24:11,440
um good so that's and and how do you

1762
01:24:09,440 --> 01:24:14,440
verify you just verify the

1763
01:24:11,440 --> 01:24:18,960
bar now here's one important thing to

1764
01:24:14,440 --> 01:24:21,360
note this V bar takes his input the bar

1765
01:24:18,960 --> 01:24:24,440
of length k k is like the number of

1766
01:24:21,360 --> 01:24:26,719
wires in the circuit we do not want want

1767
01:24:24,440 --> 01:24:28,560
the verifier to run in time K that would

1768
01:24:26,719 --> 01:24:31,080
be the the size of the circuit no we

1769
01:24:28,560 --> 01:24:33,639
want the verifier to be very

1770
01:24:31,080 --> 01:24:35,199
efficient but that's but that's okay

1771
01:24:33,639 --> 01:24:38,239
because he actually doesn't need to run

1772
01:24:35,199 --> 01:24:39,880
in time K because actually it's an in

1773
01:24:38,239 --> 01:24:44,040
it's what's called an index language

1774
01:24:39,880 --> 01:24:46,800
namely X1 up to XK

1775
01:24:44,040 --> 01:24:50,679
star essentially it's like an index on

1776
01:24:46,800 --> 01:24:53,840
an Hash k and V so the the you can

1777
01:24:50,679 --> 01:24:54,920
generate them kind of you can um Express

1778
01:24:53,840 --> 01:24:57,560
them very

1779
01:24:54,920 --> 01:25:00,840
succinctly right the you can you can

1780
01:24:57,560 --> 01:25:03,600
express them by hash key V and all the

1781
01:25:00,840 --> 01:25:05,040
index between one and K that's it so

1782
01:25:03,600 --> 01:25:07,440
because they have a succinct

1783
01:25:05,040 --> 01:25:10,159
representation the RM of the verifier

1784
01:25:07,440 --> 01:25:12,679
only grows with hash key and V PO with

1785
01:25:10,159 --> 01:25:15,880
hash and V he does not need to grow with

1786
01:25:12,679 --> 01:25:18,560
K that's kind of the um efficiency

1787
01:25:15,880 --> 01:25:19,960
property of index languages and that's

1788
01:25:18,560 --> 01:25:21,719
very important without it we can't use

1789
01:25:19,960 --> 01:25:25,600
it for the bar for the

1790
01:25:21,719 --> 01:25:27,239
snar so the so in terms of efficiency if

1791
01:25:25,600 --> 01:25:31,639
the bar has good efficiency and let's

1792
01:25:27,239 --> 01:25:34,960
say the the dependence is poly log on K

1793
01:25:31,639 --> 01:25:39,080
then the V is going to be so what what

1794
01:25:34,960 --> 01:25:42,080
is the what's the the snar grows with v

1795
01:25:39,080 --> 01:25:43,679
and with a bar proof the bar proof is

1796
01:25:42,080 --> 01:25:46,199
very if it grows with poly

1797
01:25:43,679 --> 01:25:48,119
logarithmically with K it's like poly

1798
01:25:46,199 --> 01:25:52,360
log the circuit sign very

1799
01:25:48,119 --> 01:25:55,000
efficient V grows with the number of

1800
01:25:52,360 --> 01:25:57,920
indices we're binding on so it grows

1801
01:25:55,000 --> 01:26:00,960
with L so okay grows with L we'll try to

1802
01:25:57,920 --> 01:26:03,679
minimize L we ideally want L to be poly

1803
01:26:00,960 --> 01:26:06,119
log K okay so that's what we want we'll

1804
01:26:03,679 --> 01:26:08,600
see what we get but ideally this should

1805
01:26:06,119 --> 01:26:11,040
be polylog K and the runtime of the

1806
01:26:08,600 --> 01:26:15,800
verifier because it's an index language

1807
01:26:11,040 --> 01:26:21,800
is also going to be poog K assuming uh

1808
01:26:15,800 --> 01:26:24,639
a sorry uh and he needs to to um to

1809
01:26:21,800 --> 01:26:27,520
uh he does run in time x because he also

1810
01:26:24,639 --> 01:26:31,760
needs to check to check this Pi Bar is

1811
01:26:27,520 --> 01:26:35,159
Pi Bar comma of X because when you check

1812
01:26:31,760 --> 01:26:38,760
the validity of the of that each gate is

1813
01:26:35,159 --> 01:26:42,159
satisfied the the gates in layer one

1814
01:26:38,760 --> 01:26:46,159
depend on the on X so to the gates in

1815
01:26:42,159 --> 01:26:47,880
layer one the input wires are x x i XJ

1816
01:26:46,159 --> 01:26:50,560
so the bug needs to know X the verifier

1817
01:26:47,880 --> 01:26:51,719
of course needs to know X but but uh

1818
01:26:50,560 --> 01:26:55,119
that's it so he doesn't need to run in

1819
01:26:51,719 --> 01:26:57,400
time linear in X but the bar itself s is

1820
01:26:55,119 --> 01:26:59,000
very short so the The Snug is very short

1821
01:26:57,400 --> 01:27:01,679
the verify of course run needs to run

1822
01:26:59,000 --> 01:27:03,760
time x he needs to read the input but

1823
01:27:01,679 --> 01:27:08,760
that's

1824
01:27:03,760 --> 01:27:08,760
it okay so any

1825
01:27:09,040 --> 01:27:15,199
questions okay so let's take a break a

1826
01:27:13,239 --> 01:27:16,440
cookie break a fun break and let's start

1827
01:27:15,199 --> 01:27:18,239
again like 10 minutes and then we'll

1828
01:27:16,440 --> 01:27:19,639
talk about the analysis and when but

1829
01:27:18,239 --> 01:27:22,199
this is all that's done we're done with

1830
01:27:19,639 --> 01:27:23,960
the construction this is your snar okay

1831
01:27:22,199 --> 01:27:29,199
and we built up to it here it is and

1832
01:27:23,960 --> 01:27:29,199
then we'll analyze it uh after the break

