1
00:00:12,880 --> 00:00:17,000
Let's uh let's go back so I want to say

2
00:00:15,000 --> 00:00:19,400
before actually I tell you the just a

3
00:00:17,000 --> 00:00:21,279
high level idea of the other proof I

4
00:00:19,400 --> 00:00:23,320
just want to I got a very good question

5
00:00:21,279 --> 00:00:26,320
in the break so I want to emphasize I

6
00:00:23,320 --> 00:00:29,039
want to answer it kind of for the class

7
00:00:26,320 --> 00:00:31,359
so the question was the following when I

8
00:00:29,039 --> 00:00:33,120
talked about interactive proof I said

9
00:00:31,359 --> 00:00:35,440
sound is half and if you want more than

10
00:00:33,120 --> 00:00:38,160
half do

11
00:00:35,440 --> 00:00:41,039
repetition do par repetition and now

12
00:00:38,160 --> 00:00:43,039
when I talked about argument I went to

13
00:00:41,039 --> 00:00:45,440
negligible so the question is why don't

14
00:00:43,039 --> 00:00:47,960
I do have like why why is the change of

15
00:00:45,440 --> 00:00:50,000
language of terminology why for proofs I

16
00:00:47,960 --> 00:00:53,039
said half and you can do repetition and

17
00:00:50,000 --> 00:00:54,640
for argument I immediately said no I

18
00:00:53,039 --> 00:00:57,199
have I want it to be

19
00:00:54,640 --> 00:01:01,039
negligible and the answer is actually

20
00:00:57,199 --> 00:01:04,400
pretty weird the answer is that for

21
00:01:01,039 --> 00:01:06,720
proofs we can do we can repeat if you

22
00:01:04,400 --> 00:01:09,600
have an interactive proof and you repeat

23
00:01:06,720 --> 00:01:13,040
it in parallel let's say Lambda times

24
00:01:09,600 --> 00:01:14,840
then the soundus goes down exponentially

25
00:01:13,040 --> 00:01:17,880
with Lambda if it was half now it's one

26
00:01:14,840 --> 00:01:20,600
over two to the Lambda like you would

27
00:01:17,880 --> 00:01:22,000
expect with arguments that's not

28
00:01:20,600 --> 00:01:24,759
necessarily the

29
00:01:22,000 --> 00:01:27,840
case once we go to the land of crypto

30
00:01:24,759 --> 00:01:31,920
Things become a little weird and it's

31
00:01:27,840 --> 00:01:34,479
not the case that any argument if you

32
00:01:31,920 --> 00:01:36,880
repeat it in parallel Lambda times if

33
00:01:34,479 --> 00:01:38,960
you had complete if you had sound is

34
00:01:36,880 --> 00:01:40,560
half now it sound is one over two to the

35
00:01:38,960 --> 00:01:41,640
like one over two to the Lambda that's

36
00:01:40,560 --> 00:01:44,399
not the case

37
00:01:41,640 --> 00:01:45,320
anymore now we have examples that show

38
00:01:44,399 --> 00:01:47,560
this is not the case that actually

39
00:01:45,320 --> 00:01:50,040
sounds doesn't go down but these

40
00:01:47,560 --> 00:01:54,640
examples are very contrived very very

41
00:01:50,040 --> 00:01:57,479
contrived it's not natural uh a

42
00:01:54,640 --> 00:01:59,119
arguments my guess is for every for any

43
00:01:57,479 --> 00:02:01,960
natural argument however you Define

44
00:01:59,119 --> 00:02:03,759
natural soundness probably does go down

45
00:02:01,960 --> 00:02:07,039
exponentially when you repeat in

46
00:02:03,759 --> 00:02:09,720
parallel now but but it's not true all

47
00:02:07,039 --> 00:02:11,800
the time so actually we you know this

48
00:02:09,720 --> 00:02:14,959
par repetition you can't kind of rely on

49
00:02:11,800 --> 00:02:17,280
it now we can do sequential repetition

50
00:02:14,959 --> 00:02:20,000
and then the soundness does go down if

51
00:02:17,280 --> 00:02:21,760
you do once and then you do the so you

52
00:02:20,000 --> 00:02:24,840
do the interactive argument once you

53
00:02:21,760 --> 00:02:27,080
were done do it again done do it again

54
00:02:24,840 --> 00:02:29,400
do it l the times and accept if and only

55
00:02:27,080 --> 00:02:31,280
if all of them accept then sound this

56
00:02:29,400 --> 00:02:34,680
does go

57
00:02:31,280 --> 00:02:36,800
uh exponentially like you would expect

58
00:02:34,680 --> 00:02:38,280
however then you increase the number of

59
00:02:36,800 --> 00:02:40,760
rounds by Lambda so you went from

60
00:02:38,280 --> 00:02:42,560
constant maybe to non-constant so

61
00:02:40,760 --> 00:02:44,920
there's a price so it's not like for

62
00:02:42,560 --> 00:02:46,519
free you like in interactive proof

63
00:02:44,920 --> 00:02:49,200
setting it's like for free just repeat

64
00:02:46,519 --> 00:02:51,440
in parallel it's like for free here be

65
00:02:49,200 --> 00:02:54,280
now the round complexity changes it's

66
00:02:51,440 --> 00:02:55,680
not very free anymore so we don't we

67
00:02:54,280 --> 00:02:57,959
that's why we put here

68
00:02:55,680 --> 00:03:02,000
negligible that that just explain the

69
00:02:57,959 --> 00:03:03,720
change of of uh kind kind of language

70
00:03:02,000 --> 00:03:07,200
why here we chose negligible before we

71
00:03:03,720 --> 00:03:10,519
chose half or 1/3 2/3 whatever the

72
00:03:07,200 --> 00:03:15,480
conent didn't matter because you can

73
00:03:10,519 --> 00:03:18,280
amplify a okay questions before I go

74
00:03:15,480 --> 00:03:20,360
back to say a few words about So the

75
00:03:18,280 --> 00:03:24,000
plan for the lesson now we have left I

76
00:03:20,360 --> 00:03:25,959
want to say a few words about the Barak

77
00:03:24,000 --> 00:03:28,400
proof called they call the universal

78
00:03:25,959 --> 00:03:31,319
arguments uh that paper and then we'll

79
00:03:28,400 --> 00:03:33,879
move on to construct hash function

80
00:03:31,319 --> 00:03:35,599
yeah okay so let me just say a few words

81
00:03:33,879 --> 00:03:38,239
I don't want to go into details about

82
00:03:35,599 --> 00:03:41,840
the the but just to tell you kind of the

83
00:03:38,239 --> 00:03:44,280
the H of idea this proof what it did

84
00:03:41,840 --> 00:03:45,840
what it tried to do is to to say look if

85
00:03:44,280 --> 00:03:49,000
there are no collisions I'm going to

86
00:03:45,840 --> 00:03:50,640
construct an entire PCP I'm going to try

87
00:03:49,000 --> 00:03:52,319
as much as I can and now got a

88
00:03:50,640 --> 00:03:55,120
contradiction because there's no PCP and

89
00:03:52,319 --> 00:03:57,879
hence I I get I conclude that there was

90
00:03:55,120 --> 00:04:00,120
a hatch function but for this I needed

91
00:03:57,879 --> 00:04:02,480
to construct an entire PCP and therefore

92
00:04:00,120 --> 00:04:08,760
run in time that's proportional to the

93
00:04:02,480 --> 00:04:11,760
to the PCP size okay instead the pro

94
00:04:08,760 --> 00:04:16,320
what they say they say let's look at

95
00:04:11,760 --> 00:04:18,479
each kind of query separately so in

96
00:04:16,320 --> 00:04:23,320
other words let the PCP let's say has

97
00:04:18,479 --> 00:04:26,720
length M okay let's look at uh the PCP

98
00:04:23,320 --> 00:04:29,080
at location I and I asked the following

99
00:04:26,720 --> 00:04:30,600
query the following question here's the

100
00:04:29,080 --> 00:04:33,440
question they ask

101
00:04:30,600 --> 00:04:36,199
in location I if I run the

102
00:04:33,440 --> 00:04:39,919
PCP I have a cheating prover here yeah

103
00:04:36,199 --> 00:04:42,039
if I run him twice or many times where

104
00:04:39,919 --> 00:04:45,320
all the times have location I in there

105
00:04:42,039 --> 00:04:48,360
one ey not all the PCP for a certain

106
00:04:45,320 --> 00:04:49,919
index ey let me run the PCP verif let me

107
00:04:48,360 --> 00:04:52,199
give the cheating

108
00:04:49,919 --> 00:04:55,400
prover like

109
00:04:52,199 --> 00:04:58,800
a a Randomness from the verifier so that

110
00:04:55,400 --> 00:05:00,880
the queries include index I and let me

111
00:04:58,800 --> 00:05:03,000
take many of them

112
00:05:00,880 --> 00:05:05,199
is there a collision in I or is all the

113
00:05:03,000 --> 00:05:07,400
time he answers in the same way that's

114
00:05:05,199 --> 00:05:10,960
the question so for an index ey does he

115
00:05:07,400 --> 00:05:12,120
always answer with the same bit or the

116
00:05:10,960 --> 00:05:13,280
assuming he answers correctly if he

117
00:05:12,120 --> 00:05:15,120
doesn't answer correctly if he's

118
00:05:13,280 --> 00:05:17,960
rejected then we throw it out but all

119
00:05:15,120 --> 00:05:20,560
the time that he answers correctly when

120
00:05:17,960 --> 00:05:24,400
ask location I does he answer

121
00:05:20,560 --> 00:05:30,240
consistently with the same bit or

122
00:05:24,400 --> 00:05:32,039
not now if if he's answered if he if if

123
00:05:30,240 --> 00:05:34,199
not if some prob probability I don't

124
00:05:32,039 --> 00:05:35,560
know Epsilon he answers with zero and

125
00:05:34,199 --> 00:05:37,840
probility Epsilon he answers was one we

126
00:05:35,560 --> 00:05:37,840
found a

127
00:05:38,400 --> 00:05:43,800
collision that's then we're happy if not

128
00:05:41,440 --> 00:05:46,919
we didn't find the Collision okay now

129
00:05:43,800 --> 00:05:48,880
they ask so let's call an index like uh

130
00:05:46,919 --> 00:05:51,400
good if there's no collisions on that

131
00:05:48,880 --> 00:05:54,600
index like then he behaved like the

132
00:05:51,400 --> 00:05:58,319
prover behaved well he behaved good so

133
00:05:54,600 --> 00:06:00,160
for every index I ask is it good in the

134
00:05:58,319 --> 00:06:01,440
analysis I don't yet I don't have an

135
00:06:00,160 --> 00:06:04,400
adversary yet I'm just saying look

136
00:06:01,440 --> 00:06:06,759
there's a cheating prover for every

137
00:06:04,400 --> 00:06:08,840
index let's look at the

138
00:06:06,759 --> 00:06:10,880
probability that when he answers

139
00:06:08,840 --> 00:06:13,120
correctly he answers always the with the

140
00:06:10,880 --> 00:06:15,759
same bit let's say we the same bit with

141
00:06:13,120 --> 00:06:18,520
probability what condition an answer or

142
00:06:15,759 --> 00:06:21,919
he answers correctly but with two

143
00:06:18,520 --> 00:06:23,880
different answers with probability like

144
00:06:21,919 --> 00:06:26,160
greater than I don't know Epsilon to the

145
00:06:23,880 --> 00:06:27,680
third whatever some some function of

146
00:06:26,160 --> 00:06:30,400
Epsilon that's not

147
00:06:27,680 --> 00:06:32,080
negligible so it's good if if he doesn't

148
00:06:30,400 --> 00:06:35,440
do that he he answers consistently

149
00:06:32,080 --> 00:06:37,120
almost always and it's bad if he answers

150
00:06:35,440 --> 00:06:38,960
inconsistently probability at least I

151
00:06:37,120 --> 00:06:43,120
don't know Epson to the

152
00:06:38,960 --> 00:06:47,919
third and now what they say is many it

153
00:06:43,120 --> 00:06:50,599
must be that many eyes are bad if almost

154
00:06:47,919 --> 00:06:53,280
all the eyes are good like a a

155
00:06:50,599 --> 00:06:54,840
significant fraction of the eyes must be

156
00:06:53,280 --> 00:06:58,479
bad namely there should be collisions on

157
00:06:54,840 --> 00:07:01,599
them why if almost all of them were good

158
00:06:58,479 --> 00:07:05,879
then on the good ones I will in the okay

159
00:07:01,599 --> 00:07:09,240
so first they say many of the indexes I

160
00:07:05,879 --> 00:07:10,440
must be bad once you establish that then

161
00:07:09,240 --> 00:07:12,400
you just you break collisions by

162
00:07:10,440 --> 00:07:13,680
choosing a random eye hope it's bad and

163
00:07:12,400 --> 00:07:16,319
you're

164
00:07:13,680 --> 00:07:18,800
done you you're not doing many eyes like

165
00:07:16,319 --> 00:07:20,240
we did just one random eye with some

166
00:07:18,800 --> 00:07:22,160
good probability or bad if it's bad you

167
00:07:20,240 --> 00:07:25,000
found a collision

168
00:07:22,160 --> 00:07:26,440
done okay but one can say maybe there's

169
00:07:25,000 --> 00:07:28,479
maybe the number of bad is like one over

170
00:07:26,440 --> 00:07:30,199
n maybe you need to repeat it n times

171
00:07:28,479 --> 00:07:32,280
until you find a bad one

172
00:07:30,199 --> 00:07:34,479
so they say no the number of V need to

173
00:07:32,280 --> 00:07:37,680
be like polinomial and

174
00:07:34,479 --> 00:07:41,039
like at least abs like non negligible in

175
00:07:37,680 --> 00:07:43,080
Lambda why if almost all of them were

176
00:07:41,039 --> 00:07:46,240
kind of good where there's no Collision

177
00:07:43,080 --> 00:07:48,400
like every then you can okay and these

178
00:07:46,240 --> 00:07:50,280
reconstruct the PCP and the good ones do

179
00:07:48,400 --> 00:07:53,120
the same

180
00:07:50,280 --> 00:07:54,720
a kind of idea of reconstructing the PCP

181
00:07:53,120 --> 00:07:57,240
but only in the good

182
00:07:54,720 --> 00:07:59,159
indices then they show that if you have

183
00:07:57,240 --> 00:08:00,879
enough good indices then you'll be

184
00:07:59,159 --> 00:08:03,120
accept with non

185
00:08:00,879 --> 00:08:05,759
probability so there there must be

186
00:08:03,120 --> 00:08:09,120
enough kind of bad indices indices that

187
00:08:05,759 --> 00:08:11,919
the cheating prover kind of answers

188
00:08:09,120 --> 00:08:13,919
inconsistently once you have that then

189
00:08:11,919 --> 00:08:16,479
now now once you establish that in your

190
00:08:13,919 --> 00:08:18,960
head that you you we understand that now

191
00:08:16,479 --> 00:08:23,039
here's the adversary just chooses one

192
00:08:18,960 --> 00:08:27,240
random eye he runs the PCP verifier

193
00:08:23,039 --> 00:08:29,919
twice kind of he generates two two

194
00:08:27,240 --> 00:08:32,880
Randomness that generates two kind of

195
00:08:29,919 --> 00:08:34,399
fresh index set that include I so they

196
00:08:32,880 --> 00:08:38,440
had one assumption that they needed

197
00:08:34,399 --> 00:08:43,039
about the PCP that given I it is easy to

198
00:08:38,440 --> 00:08:45,480
cons to find R so that the PCP verifier

199
00:08:43,039 --> 00:08:49,519
and input R output to set that includes

200
00:08:45,480 --> 00:08:52,959
I and turns out all pcps we know or all

201
00:08:49,519 --> 00:08:54,399
pcps I know satisfied this property so

202
00:08:52,959 --> 00:08:57,080
you know that's kind of it turns out

203
00:08:54,399 --> 00:09:01,360
it's a natural property it's easy given

204
00:08:57,080 --> 00:09:05,959
I to find randomness kind of uh true

205
00:09:01,360 --> 00:09:09,440
Randomness that is generates this a set

206
00:09:05,959 --> 00:09:10,480
of queries conditioned on I being in in

207
00:09:09,440 --> 00:09:12,760
that

208
00:09:10,480 --> 00:09:15,399
set once you can do that then he choses

209
00:09:12,760 --> 00:09:17,560
two RS Randomness that have i in the set

210
00:09:15,399 --> 00:09:19,200
and hope for collision and then you can

211
00:09:17,560 --> 00:09:20,800
argue that you get collision with nonnal

212
00:09:19,200 --> 00:09:23,760
probability because non-n fraction of

213
00:09:20,800 --> 00:09:25,320
them are bad and the bad ones are

214
00:09:23,760 --> 00:09:28,120
defined so that when you choose two

215
00:09:25,320 --> 00:09:30,240
random kind of invocation that include I

216
00:09:28,120 --> 00:09:32,800
you find a collision so they found a

217
00:09:30,240 --> 00:09:34,640
collision so they just did it kind of

218
00:09:32,800 --> 00:09:37,519
the difference is they did it index by

219
00:09:34,640 --> 00:09:39,839
index they said does he find Collision I

220
00:09:37,519 --> 00:09:41,959
have a cheating Pro P star does he find

221
00:09:39,839 --> 00:09:44,120
the Collision on index one does he find

222
00:09:41,959 --> 00:09:46,440
a collision on this two this is an

223
00:09:44,120 --> 00:09:48,760
analysis once and then they establish he

224
00:09:46,440 --> 00:09:51,200
must find collisions at many indices and

225
00:09:48,760 --> 00:09:53,000
now they're ready to break the Collision

226
00:09:51,200 --> 00:09:55,760
the hash function they just chose the

227
00:09:53,000 --> 00:09:58,120
random ey and break by running the

228
00:09:55,760 --> 00:10:01,440
cheating Pro

229
00:09:58,120 --> 00:10:04,600
twice so so it's just a more uh

230
00:10:01,440 --> 00:10:07,480
efficient way of of breaking it instead

231
00:10:04,600 --> 00:10:10,600
of the prover running in time n their

232
00:10:07,480 --> 00:10:13,200
prover instead of the adversary running

233
00:10:10,600 --> 00:10:16,320
in time n because they in this proof we

234
00:10:13,200 --> 00:10:20,040
ran the cheating prover end times or

235
00:10:16,320 --> 00:10:22,839
size of the PCP times at least times one

236
00:10:20,040 --> 00:10:25,519
over Epsilon they run it only security

237
00:10:22,839 --> 00:10:28,760
parameter times divided by Epsilon with

238
00:10:25,519 --> 00:10:31,000
polinomial overhead but inde pend ofen

239
00:10:28,760 --> 00:10:32,959
is the point

240
00:10:31,000 --> 00:10:35,440
AR

241
00:10:32,959 --> 00:10:37,680
Universal okay good you're asking what

242
00:10:35,440 --> 00:10:40,760
why what what what's that related to

243
00:10:37,680 --> 00:10:43,440
Universal yeah because uh the the reason

244
00:10:40,760 --> 00:10:45,160
they call Universal is because uh yeah I

245
00:10:43,440 --> 00:10:47,600
guess the fact that it doesn't depend on

246
00:10:45,160 --> 00:10:49,320
N It's really because they they talked

247
00:10:47,600 --> 00:10:52,240
about like the universal language that

248
00:10:49,320 --> 00:10:54,000
has like a tring machine x and t and

249
00:10:52,240 --> 00:10:56,120
it's in the language of there a witness

250
00:10:54,000 --> 00:10:57,399
for that this twing machine runs in time

251
00:10:56,120 --> 00:10:58,720
te and they didn't want things to blow

252
00:10:57,399 --> 00:11:01,800
up with t like they want to this

253
00:10:58,720 --> 00:11:03,120
Universal did so they want kind of one

254
00:11:01,800 --> 00:11:05,760
hash function that works for this

255
00:11:03,120 --> 00:11:07,160
language and T now is given in binary in

256
00:11:05,760 --> 00:11:09,600
this language so how can you have one

257
00:11:07,160 --> 00:11:13,200
hash Function One universal hash family

258
00:11:09,600 --> 00:11:13,200
and that's why the name

259
00:11:13,279 --> 00:11:18,720
Universal yeah what is it name the paper

260
00:11:17,240 --> 00:11:21,079
the name of the paper is universal

261
00:11:18,720 --> 00:11:22,600
arguments I I'll I'll link to it in in

262
00:11:21,079 --> 00:11:24,399
the website yeah it's not there yet I

263
00:11:22,600 --> 00:11:26,760
only linked mikali but I'll link to it

264
00:11:24,399 --> 00:11:28,279
it's a good it's a really nice it's a

265
00:11:26,760 --> 00:11:31,000
really really nice especially the

266
00:11:28,279 --> 00:11:33,639
overview explains it very nicely it

267
00:11:31,000 --> 00:11:36,839
explains the proof I gave here and it

268
00:11:33,639 --> 00:11:39,600
explains their proof in a very nice kind

269
00:11:36,839 --> 00:11:43,320
of way so I'll add a

270
00:11:39,600 --> 00:11:46,360
link okay uh any any other

271
00:11:43,320 --> 00:11:50,040
questions before we go and construct the

272
00:11:46,360 --> 00:11:50,040
hash function so let

273
00:11:50,890 --> 00:11:54,100
[Applause]

274
00:11:54,560 --> 00:11:59,240
me this is what I want to construct but

275
00:11:57,639 --> 00:12:01,079
any questions before we go ahead and

276
00:11:59,240 --> 00:12:04,639
construct

277
00:12:01,079 --> 00:12:04,639
it okay let's do

278
00:12:05,760 --> 00:12:11,120
it okay so what I'm going to do is I'm

279
00:12:09,720 --> 00:12:13,639
going to first

280
00:12:11,120 --> 00:12:16,880
construct a hash

281
00:12:13,639 --> 00:12:19,360
function that's not quite what I want

282
00:12:16,880 --> 00:12:22,320
but it's going to be a building block to

283
00:12:19,360 --> 00:12:24,199
get what I want and this hash function

284
00:12:22,320 --> 00:12:27,199
first it doesn't have a local

285
00:12:24,199 --> 00:12:30,760
opening so it doesn't satisfy that and

286
00:12:27,199 --> 00:12:34,240
second it's not even goes from 01 star

287
00:12:30,760 --> 00:12:37,399
to 01 to the Lambda which is what I want

288
00:12:34,240 --> 00:12:39,160
it actually goes from 01 to Lambda to 01

289
00:12:37,399 --> 00:12:41,160
to the Lambda so it just shrinks a

290
00:12:39,160 --> 00:12:43,000
little bit it doesn't shrink like by an

291
00:12:41,160 --> 00:12:46,079
arbitrary amount it just shrinks by a

292
00:12:43,000 --> 00:12:48,959
factor of two that's it and it doesn't

293
00:12:46,079 --> 00:12:51,440
have local opening so it's a bit of

294
00:12:48,959 --> 00:12:52,639
pathetic uh but uh we'll do that first

295
00:12:51,440 --> 00:12:53,639
and then we'll show how to use that to

296
00:12:52,639 --> 00:12:56,519
get what we

297
00:12:53,639 --> 00:13:00,279
want okay so the first so now we're

298
00:12:56,519 --> 00:13:00,279
going to talk about Construction

299
00:13:09,839 --> 00:13:14,680
so let me first show you a construction

300
00:13:12,000 --> 00:13:16,560
based so all all of cryptography in

301
00:13:14,680 --> 00:13:19,399
particular cry and hash functions are

302
00:13:16,560 --> 00:13:23,519
based on assumptions an assumption that

303
00:13:19,399 --> 00:13:24,600
some math problem is hard and uh we have

304
00:13:23,519 --> 00:13:26,320
we know how to construct Collision

305
00:13:24,600 --> 00:13:28,560
resistant hasch functions from a bunch

306
00:13:26,320 --> 00:13:31,279
of assumptions many many assumptions I'm

307
00:13:28,560 --> 00:13:33,560
going to show you one that's just very

308
00:13:31,279 --> 00:13:36,600
simple and based on the discrete log

309
00:13:33,560 --> 00:13:39,000
problem so the discrete log problem just

310
00:13:36,600 --> 00:13:42,480
says that there's some group you can

311
00:13:39,000 --> 00:13:43,920
think of zp star so uh everything

312
00:13:42,480 --> 00:13:47,160
multiplication mod

313
00:13:43,920 --> 00:13:49,880
P uh but in general there's a group such

314
00:13:47,160 --> 00:13:53,040
that so this is the discrete

315
00:13:49,880 --> 00:13:53,040
log uh

316
00:13:53,639 --> 00:13:57,720
assumption this is what we're relying on

317
00:13:56,000 --> 00:14:02,120
the hardness of this on the hardness of

318
00:13:57,720 --> 00:14:05,240
this problem that says that given a

319
00:14:02,120 --> 00:14:08,440
group a group

320
00:14:05,240 --> 00:14:08,440
G of

321
00:14:08,800 --> 00:14:15,279
order a number order meaning number of

322
00:14:11,959 --> 00:14:16,920
elements let's say two to the Lambda so

323
00:14:15,279 --> 00:14:20,480
it has like two to the Lambda elements

324
00:14:16,920 --> 00:14:24,120
so I have like a you know a family of

325
00:14:20,480 --> 00:14:24,120
groups and given a

326
00:14:27,480 --> 00:14:33,480
generator G so so every element think of

327
00:14:30,959 --> 00:14:37,480
multiplicative multiplicative groups

328
00:14:33,480 --> 00:14:42,040
okay so any this group is like G to the

329
00:14:37,480 --> 00:14:44,920
x uh so uh for every you know all the

330
00:14:42,040 --> 00:14:48,720
group is of form G generates the entire

331
00:14:44,920 --> 00:14:50,079
group the assumption is so uh given a

332
00:14:48,720 --> 00:14:52,759
group of order so it's a finite group

333
00:14:50,079 --> 00:14:54,040
with two to the Lambda elements so order

334
00:14:52,759 --> 00:14:57,759
more or less to the lambas and the

335
00:14:54,040 --> 00:15:01,720
assumption is that given a random given

336
00:14:57,759 --> 00:15:01,720
G to the x for a random

337
00:15:03,480 --> 00:15:09,880
X take a random X in the group like a in

338
00:15:07,320 --> 00:15:09,880
the size of the

339
00:15:10,120 --> 00:15:15,079
group given G to the X it's hard to find

340
00:15:16,079 --> 00:15:21,480
X that's the Assumption so in other

341
00:15:18,639 --> 00:15:21,480
words for

342
00:15:22,360 --> 00:15:28,360
any po

343
00:15:24,320 --> 00:15:31,920
Lambda adversary a the probability there

344
00:15:28,360 --> 00:15:31,920
exists a NE ible

345
00:15:32,560 --> 00:15:38,279
function the

346
00:15:34,279 --> 00:15:40,160
probability that a a knows G and P the

347
00:15:38,279 --> 00:15:42,279
then the and the group these are kind of

348
00:15:40,160 --> 00:15:47,920
fixed okay the generator the group are

349
00:15:42,279 --> 00:15:47,920
fixed he gets G to the X for a random

350
00:15:49,040 --> 00:15:55,399
X and the probability that he can find X

351
00:15:53,199 --> 00:15:55,399
is

352
00:15:56,279 --> 00:16:00,160
negligible okay usually we think of

353
00:15:58,199 --> 00:16:03,160
these groups as an element of the group

354
00:16:00,160 --> 00:16:05,279
is described by so any group any element

355
00:16:03,160 --> 00:16:09,800
of the group you can describe as a

356
00:16:05,279 --> 00:16:12,759
element every uh for every H in G you

357
00:16:09,800 --> 00:16:14,600
can think of H as being in 01 to the

358
00:16:12,759 --> 00:16:17,440
Lambda you can describe it as kind of

359
00:16:14,600 --> 00:16:19,319
efficiently in Lambda bits and just

360
00:16:17,440 --> 00:16:21,639
think of zp star if you want as a you

361
00:16:19,319 --> 00:16:24,040
know all the elements mod P with

362
00:16:21,639 --> 00:16:27,160
multiplication mod P that's kind of an

363
00:16:24,040 --> 00:16:29,440
example so this is the Assumption now

364
00:16:27,160 --> 00:16:31,839
some groups this all some groups it

365
00:16:29,440 --> 00:16:33,480
doesn't hold okay for example you can

366
00:16:31,839 --> 00:16:37,160
think of it as in a group in the

367
00:16:33,480 --> 00:16:38,759
additive group mod P this is false but

368
00:16:37,160 --> 00:16:40,720
in the multiplicative group we believe

369
00:16:38,759 --> 00:16:41,959
that it's true is it really true we

370
00:16:40,720 --> 00:16:43,000
don't know we don't actually know we

371
00:16:41,959 --> 00:16:45,360
believe it's true and we base

372
00:16:43,000 --> 00:16:48,279
cryptography on this assumption okay so

373
00:16:45,360 --> 00:16:52,399
we base cryptography on the fact that in

374
00:16:48,279 --> 00:16:55,120
zp star in the if you take elements um

375
00:16:52,399 --> 00:16:58,639
in the multiplicative group zp star mod

376
00:16:55,120 --> 00:17:00,800
P then if I give you like a random you

377
00:16:58,639 --> 00:17:03,040
know if you take a a generator of this

378
00:17:00,800 --> 00:17:05,679
group and you raise it to the power of a

379
00:17:03,040 --> 00:17:07,400
random element uh if I give you a random

380
00:17:05,679 --> 00:17:09,000
element in the group essentially then

381
00:17:07,400 --> 00:17:12,880
finding the discret log we believe is

382
00:17:09,000 --> 00:17:17,760
hard yeah we know

383
00:17:12,880 --> 00:17:19,559
like quantum's EAS good yeah so okay I

384
00:17:17,760 --> 00:17:20,280
say we believe it's hard why we believe

385
00:17:19,559 --> 00:17:23,959
it's

386
00:17:20,280 --> 00:17:25,480
hard I have no idea I think the only the

387
00:17:23,959 --> 00:17:27,480
only reason we believe it's hard is

388
00:17:25,480 --> 00:17:29,480
because we don't know how to break it

389
00:17:27,480 --> 00:17:30,960
that's really it because quantum

390
00:17:29,480 --> 00:17:35,880
computers can break it there

391
00:17:30,960 --> 00:17:37,960
subexponential algorithms like if and if

392
00:17:35,880 --> 00:17:39,760
you you know if we didn't think we were

393
00:17:37,960 --> 00:17:41,640
that smart we would have think it's easy

394
00:17:39,760 --> 00:17:43,679
because every evidence we have is that

395
00:17:41,640 --> 00:17:45,760
it's not that hard but because we don't

396
00:17:43,679 --> 00:17:49,520
know how to break it and we think we're

397
00:17:45,760 --> 00:17:51,840
pretty smart then we you know but no the

398
00:17:49,520 --> 00:17:54,799
truth is really I have no evidence for

399
00:17:51,840 --> 00:17:56,480
why this that why this problem is hard

400
00:17:54,799 --> 00:17:59,320
the only evidence we have is that we

401
00:17:56,480 --> 00:18:01,200
didn't succeed in breaking it there's no

402
00:17:59,320 --> 00:18:03,760
other evidence like the fact that it can

403
00:18:01,200 --> 00:18:06,200
be broken it can be broken pomal Time by

404
00:18:03,760 --> 00:18:08,360
quantum computers

405
00:18:06,200 --> 00:18:09,840
yeah and even classically we have

406
00:18:08,360 --> 00:18:12,720
subexponential algorithms so we have

407
00:18:09,840 --> 00:18:18,080
some non-trivial algorithms for doing it

408
00:18:12,720 --> 00:18:19,520
like but uh a but not in polinomial time

409
00:18:18,080 --> 00:18:21,120
the best algorithms like something like

410
00:18:19,520 --> 00:18:23,120
time two to the end to the thir

411
00:18:21,120 --> 00:18:27,760
something like

412
00:18:23,120 --> 00:18:30,679
that so uh but this is the problem okay

413
00:18:27,760 --> 00:18:34,360
so now let me go to the construction of

414
00:18:30,679 --> 00:18:34,360
our hash function

415
00:18:34,520 --> 00:18:40,880
so I'm going to fix a group of prime

416
00:18:38,280 --> 00:18:42,559
order okay for the construction I'm

417
00:18:40,880 --> 00:18:44,360
going to assume that I have a group of

418
00:18:42,559 --> 00:18:46,520
prime

419
00:18:44,360 --> 00:18:49,080
order I'm going to tell you how I find

420
00:18:46,520 --> 00:18:50,600
the group in Prime order in a second but

421
00:18:49,080 --> 00:18:54,240
think of a group that has number of

422
00:18:50,600 --> 00:18:57,360
elements in the group as Prime so let

423
00:18:54,240 --> 00:19:01,080
G be a

424
00:18:57,360 --> 00:19:01,080
group of Prime

425
00:19:01,320 --> 00:19:06,679
order which just means that the number

426
00:19:03,720 --> 00:19:10,159
of elements in G is

427
00:19:06,679 --> 00:19:12,679
prime that's all it means and now here's

428
00:19:10,159 --> 00:19:15,039
my and now every element except for the

429
00:19:12,679 --> 00:19:17,120
unit now is is a generator so it's easy

430
00:19:15,039 --> 00:19:19,840
to find generators here and now here's

431
00:19:17,120 --> 00:19:25,600
my hash function my hash

432
00:19:19,840 --> 00:19:28,440
function um depends on G and H okay so

433
00:19:25,600 --> 00:19:30,280
what's the key the key is a so there's a

434
00:19:28,440 --> 00:19:33,880
Okay so so we have a generator G you can

435
00:19:30,280 --> 00:19:33,880
think of G is fixed that's just a

436
00:19:34,320 --> 00:19:38,679
generator if you want you can choose it

437
00:19:36,200 --> 00:19:42,360
also randomly because any element is a

438
00:19:38,679 --> 00:19:46,000
generator here H has a key so okay so

439
00:19:42,360 --> 00:19:49,080
now the hash function so

440
00:19:46,000 --> 00:19:52,720
gen and one to the Lambda this is like

441
00:19:49,080 --> 00:19:55,080
sub Lambda what it does is it chooses

442
00:19:52,720 --> 00:19:57,880
random H and

443
00:19:55,080 --> 00:19:59,400
g a random element that's what it does

444
00:19:57,880 --> 00:20:02,880
that's the key

445
00:19:59,400 --> 00:20:04,520
okay so hash key is just H just the

446
00:20:02,880 --> 00:20:07,520
random

447
00:20:04,520 --> 00:20:07,520
element

448
00:20:07,640 --> 00:20:14,400
eval okay so IAL takes his input before

449
00:20:10,679 --> 00:20:19,600
we said IAL takes his input uh hash key

450
00:20:14,400 --> 00:20:21,360
anyx any X now no now less so that's

451
00:20:19,600 --> 00:20:25,880
what I'm saying it's not let me denote

452
00:20:21,360 --> 00:20:29,320
the number of elements in G by Q now IAL

453
00:20:25,880 --> 00:20:34,919
takes his input a hash key and X but now

454
00:20:29,320 --> 00:20:37,480
X is not everything it's just in zq * zq

455
00:20:34,919 --> 00:20:38,840
so it's it's bounded later we'll show

456
00:20:37,480 --> 00:20:41,760
how to get everything but for now I'm

457
00:20:38,840 --> 00:20:45,600
bounded okay it goes from zq to zq and

458
00:20:41,760 --> 00:20:48,840
what it does uh it generates so so let

459
00:20:45,600 --> 00:20:51,120
me call it x0 and

460
00:20:48,840 --> 00:20:57,559
X1 because it has a pair and what it

461
00:20:51,120 --> 00:20:57,559
does it gives you g to the x0 times

462
00:20:59,400 --> 00:21:04,080
H to the

463
00:21:01,679 --> 00:21:05,600
X1 in the group multiplication in the

464
00:21:04,080 --> 00:21:08,320
group that's the hash function so this

465
00:21:05,600 --> 00:21:08,320
is an element in

466
00:21:11,360 --> 00:21:17,720
G okay this is the hash function now why

467
00:21:14,240 --> 00:21:20,840
is it even shrinking because this is

468
00:21:17,720 --> 00:21:24,760
kind of the the group has only Q

469
00:21:20,840 --> 00:21:27,200
elements so it's like this is Q elements

470
00:21:24,760 --> 00:21:29,400
and this is two Q elements like this

471
00:21:27,200 --> 00:21:31,679
this is one out of Q and this is you

472
00:21:29,400 --> 00:21:34,520
have one out you can think of G as like

473
00:21:31,679 --> 00:21:38,279
uh embedded in like you can like think

474
00:21:34,520 --> 00:21:40,120
of G as isomorphic to kind of uh you

475
00:21:38,279 --> 00:21:44,360
know

476
00:21:40,120 --> 00:21:46,360
zq you know you can so this you know if

477
00:21:44,360 --> 00:21:49,000
if if you think of Q if you can think of

478
00:21:46,360 --> 00:21:51,159
Q as like a in you know 0 one to the

479
00:21:49,000 --> 00:21:53,080
Lambda then here you have two 01 like 0

480
00:21:51,159 --> 00:21:55,760
one to the two

481
00:21:53,080 --> 00:21:57,159
Lambda but let me actually make it more

482
00:21:55,760 --> 00:21:59,440
concrete for you so it'll be just easy

483
00:21:57,159 --> 00:22:01,919
to think about it cuz I said a generator

484
00:21:59,440 --> 00:22:03,640
and let me just Prime let me just give

485
00:22:01,919 --> 00:22:06,559
you the concrete example you can think

486
00:22:03,640 --> 00:22:10,200
of look at zp star so just

487
00:22:06,559 --> 00:22:13,520
multiplication mod P okay where p is a

488
00:22:10,200 --> 00:22:17,000
safe Prime safe Prime I mean it's 2 Q +

489
00:22:13,520 --> 00:22:17,000
one where Q is

490
00:22:17,360 --> 00:22:23,120
prime okay there's a lot of safe primes

491
00:22:20,120 --> 00:22:25,159
so it's easy there uh you know choose

492
00:22:23,120 --> 00:22:27,520
one at random check if it's safe you can

493
00:22:25,159 --> 00:22:29,480
check check primality and if you choose

494
00:22:27,520 --> 00:22:32,200
enough times you'll hit a safe one

495
00:22:29,480 --> 00:22:35,640
they're there uh there enough of them to

496
00:22:32,200 --> 00:22:38,000
hit one with good probability okay and

497
00:22:35,640 --> 00:22:42,240
now G is just going to be the set of

498
00:22:38,000 --> 00:22:44,400
quadratic residus mod P so this is all

499
00:22:42,240 --> 00:22:46,880
the kind of X

500
00:22:44,400 --> 00:22:54,080
sared mod

501
00:22:46,880 --> 00:22:56,720
P for X in like one up to P minus

502
00:22:54,080 --> 00:22:59,000
one all the

503
00:22:56,720 --> 00:23:02,480
squares okay how many squ squares are

504
00:22:59,000 --> 00:23:05,000
there like half so z p star has P minus

505
00:23:02,480 --> 00:23:07,880
one elements one up to P minus one and

506
00:23:05,000 --> 00:23:11,520
half of them are square so the number of

507
00:23:07,880 --> 00:23:13,000
quatic residus is p minus1 / 2 which is

508
00:23:11,520 --> 00:23:15,679
exactly

509
00:23:13,000 --> 00:23:19,320
Q so really one can think if you want to

510
00:23:15,679 --> 00:23:21,840
be think of the Quad residue is mod

511
00:23:19,320 --> 00:23:26,400
P okay that's

512
00:23:21,840 --> 00:23:28,039
um so this great so now you can think of

513
00:23:26,400 --> 00:23:31,880
this is all the quadratic residues this

514
00:23:28,039 --> 00:23:33,760
is all the quadratic residus and uh

515
00:23:31,880 --> 00:23:37,760
sorry so this sorry this isn't zq this

516
00:23:33,760 --> 00:23:40,039
is zq this is quadratic residus mod P

517
00:23:37,760 --> 00:23:43,440
and you can you can embed the quadratic

518
00:23:40,039 --> 00:23:45,720
quadratic residus mod P very easily you

519
00:23:43,440 --> 00:23:48,559
can kind of embed them in zq you can

520
00:23:45,720 --> 00:23:50,640
represent each element here in zq how

521
00:23:48,559 --> 00:23:53,240
take any quadratic residue look find the

522
00:23:50,640 --> 00:23:55,640
two square roots so if you have X it's a

523
00:23:53,240 --> 00:23:58,120
quad residue so look at plus minus

524
00:23:55,640 --> 00:23:59,440
square root of x one of them is going to

525
00:23:58,120 --> 00:24:01,440
be

526
00:23:59,440 --> 00:24:03,320
smaller than Q one's going to be bigger

527
00:24:01,440 --> 00:24:05,240
one's in the upper half one in the lower

528
00:24:03,320 --> 00:24:07,880
half write the one that's in the lower

529
00:24:05,240 --> 00:24:10,919
half that's kind of a way to express the

530
00:24:07,880 --> 00:24:12,200
quadratic residues as zq the reason I'm

531
00:24:10,919 --> 00:24:13,360
telling you that is because I want you

532
00:24:12,200 --> 00:24:15,120
to think that you can this is you can

533
00:24:13,360 --> 00:24:17,080
think of it as a hash function that goes

534
00:24:15,120 --> 00:24:19,880
from zq * zq to

535
00:24:17,080 --> 00:24:22,600
zq okay because you go from zq to zq to

536
00:24:19,880 --> 00:24:26,120
quadratic residus mod P and then just

537
00:24:22,600 --> 00:24:28,440
efficiently kind of convert this to the

538
00:24:26,120 --> 00:24:31,559
square root which one the one that's

539
00:24:28,440 --> 00:24:33,679
smaller the one that's between one and Q

540
00:24:31,559 --> 00:24:35,039
and that's that that would be the output

541
00:24:33,679 --> 00:24:37,120
it's you could it's you can go from one

542
00:24:35,039 --> 00:24:39,320
to the other very efficiently so does a

543
00:24:37,120 --> 00:24:40,520
way to represent the quadratic residue

544
00:24:39,320 --> 00:24:43,120
so it doesn't really

545
00:24:40,520 --> 00:24:44,760
matter okay and the reason I'm I'm

546
00:24:43,120 --> 00:24:47,679
representing the quadratic residu is an

547
00:24:44,760 --> 00:24:49,000
element in zq is just so you see that

548
00:24:47,679 --> 00:24:51,600
it's really shrinking that you can see

549
00:24:49,000 --> 00:24:53,720
okay I have from zq to zq from zq * zq

550
00:24:51,600 --> 00:24:56,440
to zq that's my hash

551
00:24:53,720 --> 00:24:59,640
function okay the fact that it goes from

552
00:24:56,440 --> 00:25:03,919
zq to zq time zq to Q I'm later going to

553
00:24:59,640 --> 00:25:08,320
use this fact to kind of increase the

554
00:25:03,919 --> 00:25:11,000
the the domain to 0 one star okay but

555
00:25:08,320 --> 00:25:12,080
before I increase the domain why is this

556
00:25:11,000 --> 00:25:14,640
a hat

557
00:25:12,080 --> 00:25:16,320
function so in other words why is it

558
00:25:14,640 --> 00:25:18,279
what do I need from the hash function

559
00:25:16,320 --> 00:25:20,240
well there's no opening here so it's not

560
00:25:18,279 --> 00:25:22,240
local opening so this doesn't hold but I

561
00:25:20,240 --> 00:25:24,360
want to make sure that uh it's Collision

562
00:25:22,240 --> 00:25:27,799
resistant why is it Collision resistant

563
00:25:24,360 --> 00:25:29,760
so I want to argue that I cannot open if

564
00:25:27,799 --> 00:25:32,760
someone gave gives me if an adversary

565
00:25:29,760 --> 00:25:35,640
gave me a uh

566
00:25:32,760 --> 00:25:37,240
uh a value a hash value he cannot he

567
00:25:35,640 --> 00:25:39,679
cannot open in two different

568
00:25:37,240 --> 00:25:42,919
ways so let me actually try to argue

569
00:25:39,679 --> 00:25:42,919
that you cannot open in two different

570
00:25:43,320 --> 00:25:48,720
ways do it

571
00:25:45,240 --> 00:25:48,720
here okay so

572
00:25:49,279 --> 00:25:53,720
why suppose there's a cheating prover

573
00:25:51,760 --> 00:25:55,200
that can open in two different ways then

574
00:25:53,720 --> 00:25:57,240
I argue that I can break the discrete

575
00:25:55,200 --> 00:25:59,039
log problem I can just use them to break

576
00:25:57,240 --> 00:26:01,520
the discret log problem

577
00:25:59,039 --> 00:26:05,000
why so let's say I get H I'm an

578
00:26:01,520 --> 00:26:08,760
adversary there's this G and there's you

579
00:26:05,000 --> 00:26:11,960
know uh and I got hash

580
00:26:08,760 --> 00:26:14,279
key sorry I'm going to the discret log

581
00:26:11,960 --> 00:26:17,399
so I got H which is supposed to

582
00:26:14,279 --> 00:26:20,120
supposedly like G to the X I'm G to find

583
00:26:17,399 --> 00:26:22,919
X okay here's how I find

584
00:26:20,120 --> 00:26:26,240
X I got H I'm going to give this

585
00:26:22,919 --> 00:26:30,240
adversary here the so if I can find a

586
00:26:26,240 --> 00:26:30,240
collision so suppose

587
00:26:30,840 --> 00:26:34,360
there exists a collision

588
00:26:36,039 --> 00:26:43,279
finder let me call him B then I I

589
00:26:39,360 --> 00:26:45,799
construct a that uses B to break the

590
00:26:43,279 --> 00:26:49,159
discrete log how do I break the discret

591
00:26:45,799 --> 00:26:52,799
log what he gets H he needs to find

592
00:26:49,159 --> 00:26:54,159
X yeah he has G he gets the input H he

593
00:26:52,799 --> 00:26:56,039
need to find the discret log of H how

594
00:26:54,159 --> 00:26:58,760
does he find the discret log he goes to

595
00:26:56,039 --> 00:27:02,000
the Collision finder let me write him as

596
00:26:58,760 --> 00:27:04,080
a c for Collision it's better he goes to

597
00:27:02,000 --> 00:27:07,679
the Collision finder and he tells me oh

598
00:27:04,080 --> 00:27:09,880
here's your key hash key equals

599
00:27:07,679 --> 00:27:12,080
H Now find the

600
00:27:09,880 --> 00:27:17,720
Collision now we find the Collision it's

601
00:27:12,080 --> 00:27:20,960
a V and two inputs so I don't know uh

602
00:27:17,720 --> 00:27:23,440
um two he gives a V and two

603
00:27:20,960 --> 00:27:31,520
openings so two inputs so let me call

604
00:27:23,440 --> 00:27:33,679
one x0 X1 and the other x0 Prime X1

605
00:27:31,520 --> 00:27:35,919
Prime such

606
00:27:33,679 --> 00:27:38,240
that

607
00:27:35,919 --> 00:27:40,679
a this is a pre-image and this is a

608
00:27:38,240 --> 00:27:45,559
pre-image so G to the

609
00:27:40,679 --> 00:27:50,440
x0 H to the X1 is equal to G to the x0

610
00:27:45,559 --> 00:27:53,399
prime H to the X1 Prime that's a

611
00:27:50,440 --> 00:27:56,440
collision now I can I claim if he gives

612
00:27:53,399 --> 00:28:00,200
me this I can use this to find the

613
00:27:56,440 --> 00:28:04,000
discrete log of H with respect to G how

614
00:28:00,200 --> 00:28:09,080
I just what is this this is just gx0 -

615
00:28:04,000 --> 00:28:14,240
x0 Prime equals H X1 Prime minus X1 I

616
00:28:09,080 --> 00:28:18,799
just moved uh arithmetics and now g a h

617
00:28:14,240 --> 00:28:22,159
is nothing but G to the x0 - x0 Prime

618
00:28:18,799 --> 00:28:25,279
divided by X1 Prime -

619
00:28:22,159 --> 00:28:29,000
X1 this is the discrete

620
00:28:25,279 --> 00:28:31,200
log done

621
00:28:29,000 --> 00:28:34,000
so what is the discret he gives me a

622
00:28:31,200 --> 00:28:37,480
collision what is the discrete log of H

623
00:28:34,000 --> 00:28:42,720
with respect to G it's just x0 - x0

624
00:28:37,480 --> 00:28:42,720
Prime divided by X1 Prime minus

625
00:28:44,159 --> 00:28:49,559
X1 now where did I use the fact that the

626
00:28:47,360 --> 00:28:51,840
G remember I said g needs to be a prime

627
00:28:49,559 --> 00:28:55,799
Order Group where did I use the fact

628
00:28:51,840 --> 00:28:58,159
that it's a prime order because this you

629
00:28:55,799 --> 00:29:01,480
compute this mod

630
00:28:58,159 --> 00:29:03,640
Q mod the order of the group if it's not

631
00:29:01,480 --> 00:29:06,320
a prime order it's not clear you can

632
00:29:03,640 --> 00:29:08,559
divide not every element has an inverse

633
00:29:06,320 --> 00:29:09,880
if you're not in a prime Order Group so

634
00:29:08,559 --> 00:29:12,120
I want it to be in a prime order group

635
00:29:09,880 --> 00:29:13,840
so that every element has an inverse now

636
00:29:12,120 --> 00:29:15,640
another thing you need to make sure is

637
00:29:13,840 --> 00:29:18,519
that one you can say wait X1 Prime may

638
00:29:15,640 --> 00:29:22,279
be equal to X1 and then again you can't

639
00:29:18,519 --> 00:29:24,720
you're out of luck but if this if X1 if

640
00:29:22,279 --> 00:29:27,039
this if these are equal then these have

641
00:29:24,720 --> 00:29:29,559
to be equal because if these are equal

642
00:29:27,039 --> 00:29:31,960
means this is one and the only case

643
00:29:29,559 --> 00:29:33,799
where G to the power is one if it's the

644
00:29:31,960 --> 00:29:36,559
power of zero because it's a generator

645
00:29:33,799 --> 00:29:40,399
any other element is not zero is not

646
00:29:36,559 --> 00:29:43,279
one so if they're different if if these

647
00:29:40,399 --> 00:29:46,720
two are different that's what a

648
00:29:43,279 --> 00:29:48,200
collision means then X1 Prime must be

649
00:29:46,720 --> 00:29:51,440
different from X1 and therefore we can

650
00:29:48,200 --> 00:29:51,440
divide and we're

651
00:29:52,880 --> 00:29:59,360
done so this is why this is the proof

652
00:29:55,519 --> 00:29:59,360
that this is a collagen resistant

653
00:30:02,320 --> 00:30:05,279
okay any any

654
00:30:06,080 --> 00:30:10,440
questions yeah do you have a way to

655
00:30:08,840 --> 00:30:15,039
sample

656
00:30:10,440 --> 00:30:17,360
H during J do I have again a way to

657
00:30:15,039 --> 00:30:19,039
simple H during the generation what do

658
00:30:17,360 --> 00:30:22,279
you what do you mean to simp what do you

659
00:30:19,039 --> 00:30:25,000
mean to just take H the element

660
00:30:22,279 --> 00:30:26,840
without learning something about so H H

661
00:30:25,000 --> 00:30:28,720
is just I choose it randomly from G the

662
00:30:26,840 --> 00:30:31,320
the key generation the key generation

663
00:30:28,720 --> 00:30:35,679
algorithm of the hash function H is just

664
00:30:31,320 --> 00:30:39,080
a random element in the in the group so

665
00:30:35,679 --> 00:30:41,679
if you use kind of this specific group

666
00:30:39,080 --> 00:30:44,519
you choose zp star all the elements mod

667
00:30:41,679 --> 00:30:46,720
P and where p is a safe Prime you make

668
00:30:44,519 --> 00:30:48,880
sure p a safe Prime and the way you

669
00:30:46,720 --> 00:30:52,880
choose H is a random quadratic residue

670
00:30:48,880 --> 00:30:55,840
so I choose a random x and x squ is my H

671
00:30:52,880 --> 00:30:58,639
so it's a the key gen algorithm is very

672
00:30:55,840 --> 00:31:01,240
simple and note by the way here you can

673
00:30:58,639 --> 00:31:04,840
indeed it's it's also random there's no

674
00:31:01,240 --> 00:31:06,519
secret going back to the uh kilan mikali

675
00:31:04,840 --> 00:31:09,919
protocol that the first message hashy

676
00:31:06,519 --> 00:31:11,279
it's just random it's random uh quad

677
00:31:09,919 --> 00:31:13,559
resid there's no secrets you can send

678
00:31:11,279 --> 00:31:15,039
the randomness it's not uh there's no

679
00:31:13,559 --> 00:31:18,480
secrets in the hashy or anything like

680
00:31:15,039 --> 00:31:20,240
that it's a very very very simple

681
00:31:18,480 --> 00:31:22,279
construction this is by the way known as

682
00:31:20,240 --> 00:31:23,960
Pon commitment for those who studied

683
00:31:22,279 --> 00:31:26,799
cryptography

684
00:31:23,960 --> 00:31:28,760
um uh it also has some hiding properties

685
00:31:26,799 --> 00:31:30,120
which are nice but we're not we only

686
00:31:28,760 --> 00:31:32,960
care about Collision resistance here so

687
00:31:30,120 --> 00:31:32,960
we don't care about

688
00:31:33,360 --> 00:31:38,440
hiding any any qu any other questions

689
00:31:36,000 --> 00:31:41,639
about why it's Collision resistant

690
00:31:38,440 --> 00:31:41,639
about the

691
00:31:43,360 --> 00:31:48,559
construction okay so let me just say by

692
00:31:46,320 --> 00:31:50,120
the way as a side note uh these kind of

693
00:31:48,559 --> 00:31:52,600
groups of Prim order in particular kind

694
00:31:50,120 --> 00:31:55,080
of quadratic residues mod P uh where

695
00:31:52,600 --> 00:31:57,480
pizza safe Prime is a very useful kind

696
00:31:55,080 --> 00:31:59,960
of group we use it a lot in cryptography

697
00:31:57,480 --> 00:32:02,279
uh a so it comes up in many many

698
00:31:59,960 --> 00:32:05,200
Primitives we all working with groups of

699
00:32:02,279 --> 00:32:07,639
primot is very comfortable and the

700
00:32:05,200 --> 00:32:10,399
examples we have often is either quad

701
00:32:07,639 --> 00:32:11,919
res mod P where p a primot group or

702
00:32:10,399 --> 00:32:13,720
elliptic curves which is a whole

703
00:32:11,919 --> 00:32:18,639
different

704
00:32:13,720 --> 00:32:21,279
story okay so the ne oh yeah so all

705
00:32:18,639 --> 00:32:23,519
order are isomorphic right they're yeah

706
00:32:21,279 --> 00:32:24,919
so like the special thing is in the

707
00:32:23,519 --> 00:32:26,960
actual structure of the group it's like

708
00:32:24,919 --> 00:32:30,399
the representation of elements something

709
00:32:26,960 --> 00:32:34,399
and the way it's like yeah like you

710
00:32:30,399 --> 00:32:37,720
can't evenor to group definition like

711
00:32:34,399 --> 00:32:40,039
you can't compute that exactly exactly

712
00:32:37,720 --> 00:32:41,480
exactly yeah isomorphic is a is an

713
00:32:40,039 --> 00:32:43,039
information theoretic term it's not

714
00:32:41,480 --> 00:32:46,080
clear that you can efficiently go from

715
00:32:43,039 --> 00:32:49,720
one to the other yeah exactly exactly

716
00:32:46,080 --> 00:32:51,240
good good point yeah okay so uh if

717
00:32:49,720 --> 00:32:55,399
there's no further questions let's just

718
00:32:51,240 --> 00:32:58,399
go to the to show how to go a how to get

719
00:32:55,399 --> 00:33:00,519
local how to uh go for from Collision

720
00:32:58,399 --> 00:33:03,799
resistant to one with local opening so

721
00:33:00,519 --> 00:33:07,279
okay this fell short in two ways first

722
00:33:03,799 --> 00:33:11,639
this construction goes only from zq time

723
00:33:07,279 --> 00:33:15,159
zq to zq it doesn't go from 0 one star

724
00:33:11,639 --> 00:33:17,840
to zq Second there's no notion of local

725
00:33:15,159 --> 00:33:21,039
opening which is also a problem so what

726
00:33:17,840 --> 00:33:24,480
we're going to do now is we're going to

727
00:33:21,039 --> 00:33:28,840
show actually a generic transformation

728
00:33:24,480 --> 00:33:30,360
from any hash function that goes from zq

729
00:33:28,840 --> 00:33:33,679
time zq to

730
00:33:30,360 --> 00:33:37,399
zq with that's Collision resistant to

731
00:33:33,679 --> 00:33:38,960
the one to to what we want okay so now

732
00:33:37,399 --> 00:33:42,760
we're going to do the construction from

733
00:33:38,960 --> 00:33:46,600
loc with local opening and arbitrary

734
00:33:42,760 --> 00:33:46,600
domain and here is how it

735
00:33:49,679 --> 00:33:55,480
goes okay so a

736
00:34:03,840 --> 00:34:07,639
and this is from I'm going to assume I

737
00:34:09,480 --> 00:34:16,960
have which is Gen and

738
00:34:13,159 --> 00:34:19,800
eval like above but eval goes let's say

739
00:34:16,960 --> 00:34:23,679
I said zq * zq to zq let me just write

740
00:34:19,800 --> 00:34:26,560
it as 01 to the Lambda time 01 to the

741
00:34:23,679 --> 00:34:28,159
Lambda to 01 to the Lambda I'm writing

742
00:34:26,560 --> 00:34:30,839
it because that's how we usually write

743
00:34:28,159 --> 00:34:33,839
it but if you want to think of zq zq zq

744
00:34:30,839 --> 00:34:35,320
that's Al that's totally fine it's uh

745
00:34:33,839 --> 00:34:38,159
because that that's what we saw it's

746
00:34:35,320 --> 00:34:39,639
just um most constructions of hash go to

747
00:34:38,159 --> 00:34:41,599
we think of it as 01 to the Lambda

748
00:34:39,639 --> 00:34:43,040
that's why I write it this way but

749
00:34:41,599 --> 00:34:46,159
everything I say you can replace 0 1 to

750
00:34:43,040 --> 00:34:48,520
the Lambda with zq and it will work okay

751
00:34:46,159 --> 00:34:52,119
so I have that I want to now get an

752
00:34:48,520 --> 00:34:53,560
entire family of of hash functions from

753
00:34:52,119 --> 00:34:55,839
like I want to make the domain much

754
00:34:53,560 --> 00:34:58,240
bigger and I want to get local

755
00:34:55,839 --> 00:35:00,079
openings so how do I do it actually I do

756
00:34:58,240 --> 00:35:02,119
it in one shot okay I get the domain

757
00:35:00,079 --> 00:35:05,000
bigger and get local opening at the same

758
00:35:02,119 --> 00:35:08,599
time and here is the idea so I do it via

759
00:35:05,000 --> 00:35:12,839
what's called Merkel hash it's idea by

760
00:35:08,599 --> 00:35:15,960
Merkel it's really beautiful clever and

761
00:35:12,839 --> 00:35:18,839
simple and here's what he does he says

762
00:35:15,960 --> 00:35:21,760
look you want to Hash something if it's

763
00:35:18,839 --> 00:35:24,560
less than two lamb bits long done you

764
00:35:21,760 --> 00:35:26,680
have a hash use your hash but what if

765
00:35:24,560 --> 00:35:29,920
it's longer if it's more than two Lambda

766
00:35:26,680 --> 00:35:33,640
bits okay okay so do it iteratively what

767
00:35:29,920 --> 00:35:33,640
does that mean take your

768
00:35:33,760 --> 00:35:39,720
input let's say so I'm okay so sorry

769
00:35:36,839 --> 00:35:42,920
first J so let me the Gen is exactly the

770
00:35:39,720 --> 00:35:44,839
same as J the same

771
00:35:42,920 --> 00:35:48,000
thingal is so I need to give these

772
00:35:44,839 --> 00:35:49,839
algorithm Jal open and verify J is this

773
00:35:48,000 --> 00:35:52,520
gen you have a gen for this algorithm

774
00:35:49,839 --> 00:35:55,640
use this now you have a hash key what

775
00:35:52,520 --> 00:35:57,160
about IAL IAL well if your input is

776
00:35:55,640 --> 00:36:00,040
small smaller than two Lambda you can

777
00:35:57,160 --> 00:36:00,880
use this algorithm you're done what if

778
00:36:00,040 --> 00:36:03,560
it's

779
00:36:00,880 --> 00:36:06,760
bigger so if it's bigger the idea is you

780
00:36:03,560 --> 00:36:09,440
know if you have only so convert your

781
00:36:06,760 --> 00:36:13,119
input to

782
00:36:09,440 --> 00:36:14,680
blocks if you have only two blocks or

783
00:36:13,119 --> 00:36:17,119
less you're done we have a eval

784
00:36:14,680 --> 00:36:19,480
algorithm for you we're

785
00:36:17,119 --> 00:36:22,280
good but what if you have let's say four

786
00:36:19,480 --> 00:36:27,760
blocks what do you do so the idea is oh

787
00:36:22,280 --> 00:36:27,760
don't worry apply eval to these two

788
00:36:28,319 --> 00:36:32,640
so you have a hash key compute

789
00:36:32,800 --> 00:36:40,440
eval with hash key and these two you get

790
00:36:36,240 --> 00:36:40,440
a value comput

791
00:36:41,599 --> 00:36:46,680
Val with hash key same hash key and

792
00:36:45,000 --> 00:36:49,079
these

793
00:36:46,680 --> 00:36:51,079
values now I don't want to open I don't

794
00:36:49,079 --> 00:36:54,839
want to Output both of them that's two

795
00:36:51,079 --> 00:36:58,599
Lambda I want to get Lambda okay so no

796
00:36:54,839 --> 00:36:58,599
worries apply van

797
00:37:03,920 --> 00:37:08,680
and this is your your

798
00:37:06,599 --> 00:37:10,880
value now you're saying wait what I have

799
00:37:08,680 --> 00:37:16,920
if I have more no worries you have two

800
00:37:10,880 --> 00:37:19,359
more sure apply Val you have more apply

801
00:37:16,920 --> 00:37:22,880
Val now you can apply

802
00:37:19,359 --> 00:37:27,240
Val and you can apply

803
00:37:22,880 --> 00:37:29,200
Val so just you know you can just apply

804
00:37:27,240 --> 00:37:30,480
value Val Val and you're done that's

805
00:37:29,200 --> 00:37:33,280
really the

806
00:37:30,480 --> 00:37:35,560
algorithm now there's two problems with

807
00:37:33,280 --> 00:37:37,839
the the okay what I I didn't tell the

808
00:37:35,560 --> 00:37:41,000
entire story for two

809
00:37:37,839 --> 00:37:44,319
reasons so first of all there's an issue

810
00:37:41,000 --> 00:37:46,119
of how many blocks are there really so

811
00:37:44,319 --> 00:37:49,200
usually what we do we say let's assume

812
00:37:46,119 --> 00:37:52,480
that the number of blocks is two to the

813
00:37:49,200 --> 00:37:55,200
L for some L just to make this tree

814
00:37:52,480 --> 00:37:59,040
complete okay so usually what we say we

815
00:37:55,200 --> 00:38:01,240
don't actually do X from 01 star we

816
00:37:59,040 --> 00:38:03,640
assume that all the inputs are of size 2

817
00:38:01,240 --> 00:38:05,720
to the L for some L now you're saying

818
00:38:03,640 --> 00:38:08,560
wait but that's not the case oh with

819
00:38:05,720 --> 00:38:12,720
padding you can make it the case so the

820
00:38:08,560 --> 00:38:15,960
idea is given X always put like so you

821
00:38:12,720 --> 00:38:19,400
want to do EV Val X don't do eval of X

822
00:38:15,960 --> 00:38:22,800
put eval x aend with one and

823
00:38:19,400 --> 00:38:24,160
zeros how many zeros as the minimum

824
00:38:22,800 --> 00:38:25,839
amount that will give you size two to

825
00:38:24,160 --> 00:38:28,599
the L

826
00:38:25,839 --> 00:38:33,200
forl it increases the length of it yes

827
00:38:28,599 --> 00:38:37,480
but only by by you know factor of two so

828
00:38:33,200 --> 00:38:39,880
it's not that bad so now one what okay

829
00:38:37,480 --> 00:38:42,319
good good good great so's like why am I

830
00:38:39,880 --> 00:38:42,319
putting here

831
00:38:43,400 --> 00:38:49,720
one exactly otherwise you don't know is

832
00:38:46,520 --> 00:38:51,960
this part of X or so this you know so

833
00:38:49,720 --> 00:38:53,760
now when you have padding you know all

834
00:38:51,960 --> 00:38:56,000
this is padding until the one including

835
00:38:53,760 --> 00:38:57,880
and this is the X so this is just to

836
00:38:56,000 --> 00:39:00,400
make it kind of one to one great

837
00:38:57,880 --> 00:39:02,359
question yes cause issues that if you

838
00:39:00,400 --> 00:39:04,040
like take this tree and you Pat in this

839
00:39:02,359 --> 00:39:06,160
way you were like very close but only

840
00:39:04,040 --> 00:39:08,640
barely above the power like the entire

841
00:39:06,160 --> 00:39:11,359
right hand side will be a ton of like

842
00:39:08,640 --> 00:39:14,880
yeah you're right so here's the thing if

843
00:39:11,359 --> 00:39:17,920
this is exactly a power of two exactly

844
00:39:14,880 --> 00:39:19,760
I'm always going to add a one and depend

845
00:39:17,920 --> 00:39:21,720
as so it's some like I shouldn't have

846
00:39:19,760 --> 00:39:23,520
added a one but my algorithm is always

847
00:39:21,720 --> 00:39:26,040
append the one and make it a power of

848
00:39:23,520 --> 00:39:27,520
two so if it was original Power of Two I

849
00:39:26,040 --> 00:39:28,880
unfortunately I had one now I'm stuck

850
00:39:27,520 --> 00:39:31,560
need to add a bunch of zeros so all

851
00:39:28,880 --> 00:39:34,880
these are going to be zeros yeah you has

852
00:39:31,560 --> 00:39:36,920
that okay I guess like it just

853
00:39:34,880 --> 00:39:38,880
seemed okay never mind maybe the rest

854
00:39:36,920 --> 00:39:40,800
the construction will make it clear it's

855
00:39:38,880 --> 00:39:41,920
you okay so there's there's another part

856
00:39:40,800 --> 00:39:43,839
of the construction that's missing and

857
00:39:41,920 --> 00:39:45,920
I'll tell you but let's uh there was

858
00:39:43,839 --> 00:39:51,000
another question

859
00:39:45,920 --> 00:39:52,599
or this not impct the okay good so so

860
00:39:51,000 --> 00:39:55,200
the question will it impact the

861
00:39:52,599 --> 00:39:56,680
correctness and the answer is it won't

862
00:39:55,200 --> 00:39:58,480
impact the correctness if the eval

863
00:39:56,680 --> 00:40:00,720
algorithm now so let me be clear on what

864
00:39:58,480 --> 00:40:02,400
the eval algorithm is the eval algorithm

865
00:40:00,720 --> 00:40:06,480
takes his input

866
00:40:02,400 --> 00:40:08,640
X it adds a one and as the minimum

867
00:40:06,480 --> 00:40:12,240
amount of zeros to get a power of

868
00:40:08,640 --> 00:40:15,440
two once he has X that's the length is a

869
00:40:12,240 --> 00:40:17,119
power of two like two to the L then he

870
00:40:15,440 --> 00:40:19,760
does

871
00:40:17,119 --> 00:40:22,000
IAL in a treewise

872
00:40:19,760 --> 00:40:24,319
manner and now he's just going to have

873
00:40:22,000 --> 00:40:26,079
one root the reason I made it because if

874
00:40:24,319 --> 00:40:29,040
it's not a power of two then there's

875
00:40:26,079 --> 00:40:30,280
kind of dangle Roots hanging hanging out

876
00:40:29,040 --> 00:40:32,280
right and I don't want to deal with

877
00:40:30,280 --> 00:40:34,440
these dangling Roots so I'm just going

878
00:40:32,280 --> 00:40:37,640
to make it a power of two now what is

879
00:40:34,440 --> 00:40:39,880
the output the output is the last hash

880
00:40:37,640 --> 00:40:41,160
value usually we denote it by root

881
00:40:39,880 --> 00:40:42,920
because it's the root of the tree so

882
00:40:41,160 --> 00:40:45,880
often if you see hash you'll see they

883
00:40:42,920 --> 00:40:48,440
denote that hash instead of V for Value

884
00:40:45,880 --> 00:40:51,119
they denote it by

885
00:40:48,440 --> 00:40:52,640
root but the output is not only root and

886
00:40:51,119 --> 00:40:55,359
I think that goes back to maybe your

887
00:40:52,640 --> 00:40:57,920
concern the output is not only root it's

888
00:40:55,359 --> 00:41:01,720
also the depth of the tree

889
00:40:57,920 --> 00:41:01,720
okay so the hash value so

890
00:41:02,839 --> 00:41:11,760
eval given given hash key and x what it

891
00:41:07,720 --> 00:41:14,560
does is one uh

892
00:41:11,760 --> 00:41:19,839
compute let me call it X Prime which is

893
00:41:14,560 --> 00:41:24,240
X One 0 like the padded this is of

894
00:41:19,839 --> 00:41:27,440
length 2 to the L for some L then

895
00:41:24,240 --> 00:41:30,560
to compute

896
00:41:27,440 --> 00:41:30,560
root via

897
00:41:31,000 --> 00:41:35,359
tree so you compute all these hash value

898
00:41:33,760 --> 00:41:38,079
hash value hash value hash value hash

899
00:41:35,359 --> 00:41:41,560
come all these hat until you get to the

900
00:41:38,079 --> 00:41:41,560
root and

901
00:41:44,480 --> 00:41:49,800
output

902
00:41:46,040 --> 00:41:53,000
root and depth of the tree this is very

903
00:41:49,800 --> 00:41:55,839
important I you have to Output the depth

904
00:41:53,000 --> 00:41:57,800
if you don't output the depth then it's

905
00:41:55,839 --> 00:42:00,960
easy to find collisions the reason it's

906
00:41:57,800 --> 00:42:02,480
easy to find collisions is I can let's

907
00:42:00,960 --> 00:42:05,480
say generate this

908
00:42:02,480 --> 00:42:07,560
randomly compute comp and then I can

909
00:42:05,480 --> 00:42:10,960
either open to these two say oh I just

910
00:42:07,560 --> 00:42:12,480
hash to these or say I hash to

911
00:42:10,960 --> 00:42:14,920
this

912
00:42:12,480 --> 00:42:16,280
and you know it's it's a collision both

913
00:42:14,920 --> 00:42:17,200
of them has the same value they're

914
00:42:16,280 --> 00:42:21,800
different

915
00:42:17,200 --> 00:42:23,839
sizes so without the depth one can argue

916
00:42:21,800 --> 00:42:25,920
you can you cannot finding you cannot

917
00:42:23,839 --> 00:42:27,920
find collisions of the same size of the

918
00:42:25,920 --> 00:42:30,240
same length

919
00:42:27,920 --> 00:42:31,760
but it's easy to find collisions for

920
00:42:30,240 --> 00:42:34,200
inputs of differing

921
00:42:31,760 --> 00:42:35,720
lengths by just that ATT that I said I'm

922
00:42:34,200 --> 00:42:38,520
an adversary I'm going to choose a

923
00:42:35,720 --> 00:42:43,160
random long input honestly compute the

924
00:42:38,520 --> 00:42:45,280
root and then open either to this layer

925
00:42:43,160 --> 00:42:47,599
say or open to this layer open to this

926
00:42:45,280 --> 00:42:48,800
layer all them are going to be kind of

927
00:42:47,599 --> 00:42:52,000
valid

928
00:42:48,800 --> 00:42:55,200
openings so I found collisions once I

929
00:42:52,000 --> 00:42:56,839
have the depth I can't do that anymore

930
00:42:55,200 --> 00:42:57,720
because it won't correspond if I open

931
00:42:56,839 --> 00:42:59,559
this

932
00:42:57,720 --> 00:43:01,640
well it's it's it doesn't correspond to

933
00:42:59,559 --> 00:43:04,880
this depth this is a depth one and I

934
00:43:01,640 --> 00:43:04,880
I'll put it depth

935
00:43:05,000 --> 00:43:11,520
yeah is that this is no longer

936
00:43:08,800 --> 00:43:15,720
L good okay okay very good what you're

937
00:43:11,520 --> 00:43:19,440
saying ah yeah you know you lied because

938
00:43:15,720 --> 00:43:21,720
this root is of size

939
00:43:19,440 --> 00:43:23,280
Lambda this depth can be actually even

940
00:43:21,720 --> 00:43:26,880
bigger than

941
00:43:23,280 --> 00:43:29,160
Lambda yeah you promise Lambda okay so

942
00:43:26,880 --> 00:43:31,119
let me let me tell you how I deal with

943
00:43:29,160 --> 00:43:33,680
it if

944
00:43:31,119 --> 00:43:35,599
you okay this is a nitpicky I can make

945
00:43:33,680 --> 00:43:38,000
it Lambda how do I make it Lambda you

946
00:43:35,599 --> 00:43:40,319
know what I'm going to run here's my new

947
00:43:38,000 --> 00:43:43,079
gen algorithm the Gen algorithm on input

948
00:43:40,319 --> 00:43:46,920
one to the Lambda will run the original

949
00:43:43,079 --> 00:43:46,920
gen algorithm with Lambda over

950
00:43:47,559 --> 00:43:54,720
two and then this is a size Lambda over

951
00:43:52,119 --> 00:43:58,359
two a root now is the size Lambda over

952
00:43:54,720 --> 00:44:00,240
two so now have I have Lambda over too

953
00:43:58,359 --> 00:44:02,079
spare to play and I can use it this for

954
00:44:00,240 --> 00:44:04,160
the depth but actually you know what let

955
00:44:02,079 --> 00:44:07,160
me make it simpler you know what if

956
00:44:04,160 --> 00:44:10,240
you'll excuse me I'll write V to be two

957
00:44:07,160 --> 00:44:12,610
Lambda make it two Lambda let me allow

958
00:44:10,240 --> 00:44:15,780
myself here

959
00:44:12,610 --> 00:44:15,780
[Applause]

960
00:44:16,960 --> 00:44:22,480
slack can't the be good you're right

961
00:44:20,680 --> 00:44:24,720
you're saying wait but the depth can be

962
00:44:22,480 --> 00:44:27,400
unbounded so you know what if it's more

963
00:44:24,720 --> 00:44:29,240
than two to the Lambda

964
00:44:27,400 --> 00:44:31,160
sorry if the depth is more than

965
00:44:29,240 --> 00:44:34,240
Lambda I will

966
00:44:31,160 --> 00:44:36,000
output a you

967
00:44:34,240 --> 00:44:41,880
know

968
00:44:36,000 --> 00:44:41,880
fail the point is okay so

969
00:44:45,920 --> 00:44:52,280
okay let's do two to the Lambda

970
00:44:49,319 --> 00:44:54,559
here I always think of I always think of

971
00:44:52,280 --> 00:44:57,319
everything the inputs are always at most

972
00:44:54,559 --> 00:44:58,960
size two to the Lambda that's the truth

973
00:44:57,319 --> 00:45:00,640
so just think of the input that we also

974
00:44:58,960 --> 00:45:02,319
have correctness only for inputs of size

975
00:45:00,640 --> 00:45:03,760
two to the Lambda like our guarantees

976
00:45:02,319 --> 00:45:06,559
hold only for inputs of size two to the

977
00:45:03,760 --> 00:45:07,640
Lambda so let's just think of it as t

978
00:45:06,559 --> 00:45:08,960
two to the Lambda you're right if it's

979
00:45:07,640 --> 00:45:11,359
not two to the Lambda I don't have any

980
00:45:08,960 --> 00:45:13,079
guarantees so why even talk about more

981
00:45:11,359 --> 00:45:15,760
than two to the

982
00:45:13,079 --> 00:45:19,359
Lambda so I guess the way to think about

983
00:45:15,760 --> 00:45:22,280
it you can handle any input length but

984
00:45:19,359 --> 00:45:27,119
the security param the hash function

985
00:45:22,280 --> 00:45:27,119
will grow with log the

986
00:45:27,720 --> 00:45:31,200
the input

987
00:45:28,880 --> 00:45:33,240
length so you're right you're right if

988
00:45:31,200 --> 00:45:34,760
you want to use any Star you should

989
00:45:33,240 --> 00:45:36,359
let's think of that always Bound by two

990
00:45:34,760 --> 00:45:37,559
to the Lambda anyway we'll need it for

991
00:45:36,359 --> 00:45:39,440
completeness we'll need it for soundness

992
00:45:37,559 --> 00:45:42,240
we need it for everything so just assume

993
00:45:39,440 --> 00:45:42,240
that it's two to the

994
00:45:49,119 --> 00:45:52,119
Lambda

995
00:45:55,000 --> 00:45:59,960
uhuh so you're saying you can Mark each

996
00:45:57,520 --> 00:46:02,400
node but for what what's your purpose

997
00:45:59,960 --> 00:46:06,119
for so we Mark

998
00:46:02,400 --> 00:46:06,119
leaves that's one

999
00:46:08,319 --> 00:46:12,000
uhhuh zero

1000
00:46:14,359 --> 00:46:18,160
okay oh you're thinking there's an

1001
00:46:16,559 --> 00:46:21,319
attack

1002
00:46:18,160 --> 00:46:24,559
no oh Sol solves solves which problem

1003
00:46:21,319 --> 00:46:26,720
the deps oh you're saying okay okay yeah

1004
00:46:24,559 --> 00:46:31,280
yeah yeah what you're saying is uh maybe

1005
00:46:26,720 --> 00:46:32,680
we can uh solve okay so you're saying

1006
00:46:31,280 --> 00:46:35,480
maybe we don't need to get the depth

1007
00:46:32,680 --> 00:46:37,800
here and instead what we can do is

1008
00:46:35,480 --> 00:46:40,319
you're saying the honest Pro the honest

1009
00:46:37,800 --> 00:46:42,640
person he will add zero to everything

1010
00:46:40,319 --> 00:46:45,640
here and he will add a one to everything

1011
00:46:42,640 --> 00:46:45,640
here

1012
00:46:49,720 --> 00:46:54,880
and yeah okay yeah so you need to make

1013
00:46:52,760 --> 00:46:58,079
sure one bit is probably not good

1014
00:46:54,880 --> 00:46:59,960
because uh I guess

1015
00:46:58,079 --> 00:47:02,119
my concern is if you're not this is what

1016
00:46:59,960 --> 00:47:05,200
I'm going to do if I'm honest but I'm

1017
00:47:02,119 --> 00:47:07,079
not honest so I'm I'm going to go ahead

1018
00:47:05,200 --> 00:47:11,800
with my original

1019
00:47:07,079 --> 00:47:13,800
crazy thing you know and of uh you know

1020
00:47:11,800 --> 00:47:16,200
you okay fine if you one I'll I'll put

1021
00:47:13,800 --> 00:47:19,839
here zero and I won't put ones I'm just

1022
00:47:16,200 --> 00:47:21,599
going to compute not without your tags

1023
00:47:19,839 --> 00:47:23,559
because I'm malicious and now when I

1024
00:47:21,599 --> 00:47:25,040
open maybe some of them are going to be

1025
00:47:23,559 --> 00:47:27,680
one and I'm

1026
00:47:25,040 --> 00:47:29,359
lucky you see what I mean are zero and

1027
00:47:27,680 --> 00:47:32,480
I'm lucky no but if you add different

1028
00:47:29,359 --> 00:47:35,319
tags for the you add tags of zero on the

1029
00:47:32,480 --> 00:47:36,960
very bottom row you also add tags of one

1030
00:47:35,319 --> 00:47:38,960
yeah but you're right okay but now I

1031
00:47:36,960 --> 00:47:41,480
don't do that's what I should do but I'm

1032
00:47:38,960 --> 00:47:45,480
malicious I don't do

1033
00:47:41,480 --> 00:47:47,319
that so what um what two inputs would

1034
00:47:45,480 --> 00:47:50,880
you give that give the

1035
00:47:47,319 --> 00:47:52,520
same so so I I mean if I'm allowed to

1036
00:47:50,880 --> 00:47:54,839
put one or not put one I'm always going

1037
00:47:52,520 --> 00:47:54,839
to put

1038
00:47:55,280 --> 00:47:59,359
zero oh okay okay sorry what you're

1039
00:47:57,800 --> 00:48:02,280
saying okay okay now I understand you're

1040
00:47:59,359 --> 00:48:06,119
saying if I want to open it this has to

1041
00:48:02,280 --> 00:48:07,359
be a one okay therefore okay now I

1042
00:48:06,119 --> 00:48:09,000
understand what you're saying okay got

1043
00:48:07,359 --> 00:48:12,000
it so you're saying this may solve the

1044
00:48:09,000 --> 00:48:12,000
problem

1045
00:48:14,760 --> 00:48:18,760
um it's a good

1046
00:48:16,800 --> 00:48:22,760
suggestion you

1047
00:48:18,760 --> 00:48:22,760
like he

1048
00:48:28,359 --> 00:48:35,160
yeah sorry I'm yes to increase the

1049
00:48:31,240 --> 00:48:38,960
length of block at each level by one

1050
00:48:35,160 --> 00:48:41,680
would get the exact same

1051
00:48:38,960 --> 00:48:43,160
thing the opening will be well the

1052
00:48:41,680 --> 00:48:45,359
opening will grow with the

1053
00:48:43,160 --> 00:48:50,040
depth like if

1054
00:48:45,359 --> 00:48:52,480
we're we need to have a hash function

1055
00:48:50,040 --> 00:48:54,480
which will allow us to walk in the this

1056
00:48:52,480 --> 00:48:57,440
is not a leaf intermediate thing so the

1057
00:48:54,480 --> 00:49:01,319
hash function needs to now take like one

1058
00:48:57,440 --> 00:49:04,240
bits in oneit level

1059
00:49:01,319 --> 00:49:07,760
two oh you're saying it will grow I see

1060
00:49:04,240 --> 00:49:10,040
presumably the is still like K to K goes

1061
00:49:07,760 --> 00:49:11,599
to K but in order to keep adding

1062
00:49:10,040 --> 00:49:14,839
additional pad so you're saying if you

1063
00:49:11,599 --> 00:49:16,839
pad here this will go to k+ one if it go

1064
00:49:14,839 --> 00:49:18,839
to Lambda plus one and then you add one

1065
00:49:16,839 --> 00:49:21,520
it'll go to Lambda plus two yeah so

1066
00:49:18,839 --> 00:49:21,520
you're just got LDA

1067
00:49:23,720 --> 00:49:28,440
plus can you I wonder if you can get

1068
00:49:26,040 --> 00:49:33,040
around this though don't to power don't

1069
00:49:28,440 --> 00:49:33,040
make it a complete tree make it like you

1070
00:49:35,400 --> 00:49:39,760
know it's a good question if you could

1071
00:49:37,480 --> 00:49:41,799
do it like with complete like without

1072
00:49:39,760 --> 00:49:44,599
blowing up full

1073
00:49:41,799 --> 00:49:48,680
completeness what the domain extension

1074
00:49:44,599 --> 00:49:51,400
have like Mir Dam construction can with

1075
00:49:48,680 --> 00:49:54,880
two Lambda plus two bits can still

1076
00:49:51,400 --> 00:49:56,880
shrink it that into like two and then do

1077
00:49:54,880 --> 00:49:58,599
right that's yeah yeah yeah you can prob

1078
00:49:56,880 --> 00:50:00,200
that's what I was saying you can go you

1079
00:49:58,599 --> 00:50:01,760
write that it grows but you can maybe

1080
00:50:00,200 --> 00:50:04,640
shrink a little bit and then continue

1081
00:50:01,760 --> 00:50:04,640
shrink a little bit and then

1082
00:50:05,079 --> 00:50:10,079
continue not have

1083
00:50:08,200 --> 00:50:14,119
open okay so we didn't talk about

1084
00:50:10,079 --> 00:50:14,119
opening yet

1085
00:50:14,960 --> 00:50:18,559
H look you gave really interesting idea

1086
00:50:17,400 --> 00:50:20,600
then I'm trying to think if I can make

1087
00:50:18,559 --> 00:50:23,160
it into pie something in the pie

1088
00:50:20,600 --> 00:50:26,119
[Music]

1089
00:50:23,160 --> 00:50:27,720
set okay I'll think about offline anyway

1090
00:50:26,119 --> 00:50:29,599
let's we have five minutes so let me

1091
00:50:27,720 --> 00:50:30,960
quickly talk about like how do you do

1092
00:50:29,599 --> 00:50:33,640
local opening and about Collision

1093
00:50:30,960 --> 00:50:35,640
resistance of this thing so this is so

1094
00:50:33,640 --> 00:50:37,599
first we managed to do domain extension

1095
00:50:35,640 --> 00:50:40,319
okay so now the domain can be up to two

1096
00:50:37,599 --> 00:50:42,520
to the Lambda and the hash value is just

1097
00:50:40,319 --> 00:50:44,240
Lambda plus Lambda because we assume

1098
00:50:42,520 --> 00:50:45,319
that the in size to the Lambda the depth

1099
00:50:44,240 --> 00:50:48,119
is the most

1100
00:50:45,319 --> 00:50:52,000
Lambda yeah so we're happy with the

1101
00:50:48,119 --> 00:50:54,720
size how do you open so let's say I want

1102
00:50:52,000 --> 00:50:57,720
to open to one point here I want to open

1103
00:50:54,720 --> 00:51:00,720
to this bit how how do I open to this BD

1104
00:50:57,720 --> 00:51:04,319
only well what I do is I identify the

1105
00:51:00,720 --> 00:51:06,960
block that it sits on okay so now I know

1106
00:51:04,319 --> 00:51:09,119
what I want to open is this I'm going to

1107
00:51:06,960 --> 00:51:10,960
open to this entire Block it's not it's

1108
00:51:09,119 --> 00:51:13,799
only Lambda bits so I can remember the

1109
00:51:10,960 --> 00:51:16,240
opening is poly Lambda bits I can allow

1110
00:51:13,799 --> 00:51:18,160
poly lamba bits in my opening so I'm

1111
00:51:16,240 --> 00:51:20,240
going to just open to the entire

1112
00:51:18,160 --> 00:51:21,960
block okay so I can give you the block

1113
00:51:20,240 --> 00:51:25,119
but how do you know it's the right

1114
00:51:21,960 --> 00:51:28,240
block so what I do I give you you know

1115
00:51:25,119 --> 00:51:31,000
what I'm going to give you the block and

1116
00:51:28,240 --> 00:51:33,440
The Sibling block that is needed to

1117
00:51:31,000 --> 00:51:33,440
compute the

1118
00:51:33,559 --> 00:51:39,079
parent so I'm going to give you both of

1119
00:51:35,960 --> 00:51:40,520
these now you can compute the parent and

1120
00:51:39,079 --> 00:51:43,079
then I'm going to give you the sibling

1121
00:51:40,520 --> 00:51:44,839
block that is needed to compute the

1122
00:51:43,079 --> 00:51:46,079
parent and then I'm going to give you

1123
00:51:44,839 --> 00:51:48,520
the sibling

1124
00:51:46,079 --> 00:51:50,799
block that is needed to compute the

1125
00:51:48,520 --> 00:51:53,920
parent so for every

1126
00:51:50,799 --> 00:51:56,880
layer I give you the sibling block that

1127
00:51:53,920 --> 00:51:59,160
you need to compute the parent so the

1128
00:51:56,880 --> 00:52:02,599
number of blocks I give you is like the

1129
00:51:59,160 --> 00:52:05,480
depth at each layer I give you a sibling

1130
00:52:02,599 --> 00:52:08,799
block so it's depth number of block each

1131
00:52:05,480 --> 00:52:11,280
block is size Lambda so I give you po

1132
00:52:08,799 --> 00:52:13,440
like Lambda squared

1133
00:52:11,280 --> 00:52:16,559
bits okay so this is the opening the

1134
00:52:13,440 --> 00:52:19,240
opening just contains the block of the

1135
00:52:16,559 --> 00:52:22,760
bit you want to open with all with the

1136
00:52:19,240 --> 00:52:25,440
sibling blocks of each layer The Sibling

1137
00:52:22,760 --> 00:52:27,599
blocks that of of the parent yeah the

1138
00:52:25,440 --> 00:52:31,200
The Sibling corresponding to the

1139
00:52:27,599 --> 00:52:34,240
parent all the way up how do you verify

1140
00:52:31,200 --> 00:52:36,040
it well so that's that's the opening so

1141
00:52:34,240 --> 00:52:37,359
the opening are all the kind of green

1142
00:52:36,040 --> 00:52:39,240
well this green you can on your own so

1143
00:52:37,359 --> 00:52:43,200
you don't give it but you know think of

1144
00:52:39,240 --> 00:52:46,160
it all the green a blocks

1145
00:52:43,200 --> 00:52:49,200
here how do you verify you just verify

1146
00:52:46,160 --> 00:52:52,000
you check you check that this these two

1147
00:52:49,200 --> 00:52:54,040
hash to this these two hash to this

1148
00:52:52,000 --> 00:52:57,240
these two hash to the root where the

1149
00:52:54,040 --> 00:52:59,319
root of the that's the hash value

1150
00:52:57,240 --> 00:53:01,160
so actually like this you don't need to

1151
00:52:59,319 --> 00:53:02,319
give because you can compute this you

1152
00:53:01,160 --> 00:53:05,680
don't need to give because you can

1153
00:53:02,319 --> 00:53:07,559
compute but this you need to give and

1154
00:53:05,680 --> 00:53:09,760
the point is you re you can Rec you can

1155
00:53:07,559 --> 00:53:11,880
ask the the verifier to recompute this

1156
00:53:09,760 --> 00:53:13,040
recompute this but at the end he needs

1157
00:53:11,880 --> 00:53:15,799
to make sure you consistent with the

1158
00:53:13,040 --> 00:53:17,200
root with the with the hash value that

1159
00:53:15,799 --> 00:53:19,240
he committed to you say you just need

1160
00:53:17,200 --> 00:53:20,880
the siblings you just need the siblings

1161
00:53:19,240 --> 00:53:22,599
but it doesn't matter yeah you can just

1162
00:53:20,880 --> 00:53:26,599
give the kind of one sibling you can

1163
00:53:22,599 --> 00:53:26,599
give D instead of 2D

1164
00:53:26,799 --> 00:53:30,520
that's the opening that's the

1165
00:53:27,799 --> 00:53:32,160
verification yeah how do you sure like

1166
00:53:30,520 --> 00:53:34,599
this opening doesn't like it's

1167
00:53:32,160 --> 00:53:36,920
consistent like it doesn't say one block

1168
00:53:34,599 --> 00:53:41,319
is different next time say open a

1169
00:53:36,920 --> 00:53:43,920
different block so oh okay there's a

1170
00:53:41,319 --> 00:53:45,280
so the the only thing I need to check is

1171
00:53:43,920 --> 00:53:46,400
Collision resistant I don't know what do

1172
00:53:45,280 --> 00:53:49,960
you mean by

1173
00:53:46,400 --> 00:53:52,040
consistent like give like a differ BL

1174
00:53:49,960 --> 00:53:53,760
next fine I can do whatever I want look

1175
00:53:52,040 --> 00:53:56,200
I can do whatever I

1176
00:53:53,760 --> 00:53:58,119
want like I can I can do whatever look

1177
00:53:56,200 --> 00:53:59,920
I'm cheat I'll I'll do whatever I want

1178
00:53:58,119 --> 00:54:01,119
whatever I can whatever I can do to get

1179
00:53:59,920 --> 00:54:04,440
and I get away with that's what I'm

1180
00:54:01,119 --> 00:54:05,599
going to do okay the question is I'm

1181
00:54:04,440 --> 00:54:08,079
what the honest Pro what the honest

1182
00:54:05,599 --> 00:54:10,640
prover should do like what the honest

1183
00:54:08,079 --> 00:54:12,680
the honest open algorithm he should give

1184
00:54:10,640 --> 00:54:14,200
all the correct blocks now you're saying

1185
00:54:12,680 --> 00:54:16,480
he won't what if he

1186
00:54:14,200 --> 00:54:18,040
doesn't so now I'm going to tell here's

1187
00:54:16,480 --> 00:54:20,400
what I want to argue look he may not I

1188
00:54:18,040 --> 00:54:22,880
don't know what he's giving okay all I

1189
00:54:20,400 --> 00:54:24,640
need to argue is Collision resistance I

1190
00:54:22,880 --> 00:54:27,000
mean first note

1191
00:54:24,640 --> 00:54:28,400
completeness correctness is I said we

1192
00:54:27,000 --> 00:54:30,839
get if you're honest you're going to be

1193
00:54:28,400 --> 00:54:32,480
accepted if you're honest you generate

1194
00:54:30,839 --> 00:54:34,720
this gigantic thing like you should have

1195
00:54:32,480 --> 00:54:36,720
you have the entire tree and when you

1196
00:54:34,720 --> 00:54:38,960
want to open this you actually give all

1197
00:54:36,720 --> 00:54:40,240
these everything should hash the hash is

1198
00:54:38,960 --> 00:54:43,359
good it computes correctly and you'll

1199
00:54:40,240 --> 00:54:46,480
get you'll accept with probility one

1200
00:54:43,359 --> 00:54:49,920
okay always that's not a problem what

1201
00:54:46,480 --> 00:54:52,240
you're concerned like wait okay I tell I

1202
00:54:49,920 --> 00:54:53,799
tell the cheating person who wants to

1203
00:54:52,240 --> 00:54:55,520
find collisions this is what you should

1204
00:54:53,799 --> 00:54:56,839
do give the opening you say he won't

1205
00:54:55,520 --> 00:54:59,799
give he won't give this he will give

1206
00:54:56,839 --> 00:55:02,640
this BL or who knows what he's going to

1207
00:54:59,799 --> 00:55:05,200
do who says he can give whatever he

1208
00:55:02,640 --> 00:55:08,559
wants so how do you know that this is

1209
00:55:05,200 --> 00:55:08,559
how do you know that this is Collision

1210
00:55:09,520 --> 00:55:13,000
resistance you're not

1211
00:55:15,920 --> 00:55:22,240
happy yeah yeah I was more um concerned

1212
00:55:19,880 --> 00:55:24,119
about like the soundness like the

1213
00:55:22,240 --> 00:55:26,160
soundness that we get from there like

1214
00:55:24,119 --> 00:55:28,520
yeah how how do we know like um he can't

1215
00:55:26,160 --> 00:55:31,000
like each time you query he just kind of

1216
00:55:28,520 --> 00:55:32,880
like for his proofs of those siing

1217
00:55:31,000 --> 00:55:36,079
blocks he can just construct them in

1218
00:55:32,880 --> 00:55:38,319
such a way that it ends up um at your Ro

1219
00:55:36,079 --> 00:55:41,880
I how do you make sure that he can't

1220
00:55:38,319 --> 00:55:44,680
just construct them so that you know

1221
00:55:41,880 --> 00:55:45,839
fir you you should be concerned so first

1222
00:55:44,680 --> 00:55:47,319
when you say sound is human Collision

1223
00:55:45,839 --> 00:55:48,760
resistant I wrote soundness but right

1224
00:55:47,319 --> 00:55:50,160
that's the yeah that's kind of thing

1225
00:55:48,760 --> 00:55:52,400
yeah and you're right you're saying how

1226
00:55:50,160 --> 00:55:54,359
do you know he givs he does whatever you

1227
00:55:52,400 --> 00:55:56,000
want he wants how do you know that at

1228
00:55:54,359 --> 00:55:58,799
the end of the day somehow he doesn't

1229
00:55:56,000 --> 00:56:00,680
man man maybe manages to mix Max and do

1230
00:55:58,799 --> 00:56:02,960
it and magically get to the root in two

1231
00:56:00,680 --> 00:56:02,960
different

1232
00:56:04,319 --> 00:56:10,280
ways so the answer is he can't actually

1233
00:56:08,160 --> 00:56:12,839
the only way he can generate two

1234
00:56:10,280 --> 00:56:15,160
different openings for the root like the

1235
00:56:12,839 --> 00:56:17,039
only way if you could generate two

1236
00:56:15,160 --> 00:56:19,960
different openings for this one block

1237
00:56:17,039 --> 00:56:22,680
and a different block with the valid

1238
00:56:19,960 --> 00:56:25,520
openings I argue I can find collisions

1239
00:56:22,680 --> 00:56:27,720
to the original hash function that I

1240
00:56:25,520 --> 00:56:30,520
started with

1241
00:56:27,720 --> 00:56:32,839
from like two Lambda to Lambda the

1242
00:56:30,520 --> 00:56:34,280
reigon why I'll find collisions we're

1243
00:56:32,839 --> 00:56:37,520
out of time so we'll have to do it next

1244
00:56:34,280 --> 00:56:41,640
week so Friday at same time next week

1245
00:56:37,520 --> 00:56:41,640
finally we have consecutive weeks

