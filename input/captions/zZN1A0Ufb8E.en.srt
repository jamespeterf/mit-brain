1
00:00:11,280 --> 00:00:14,559
Um, so today we're going to be talking

2
00:00:12,960 --> 00:00:16,560
about Huffman codes which is a pretty

3
00:00:14,559 --> 00:00:18,560
elegant topic. So I just want to give

4
00:00:16,560 --> 00:00:20,800
you a reminder from last time. So what

5
00:00:18,560 --> 00:00:22,400
did we talk about last time was we

6
00:00:20,800 --> 00:00:25,439
talked about this notion of a first

7
00:00:22,400 --> 00:00:27,680
order source that defines a distribution

8
00:00:25,439 --> 00:00:29,840
on an alphabet of size K. So you think

9
00:00:27,680 --> 00:00:32,320
about the entries in the set A as being

10
00:00:29,840 --> 00:00:34,320
all the symbols that could arise. And

11
00:00:32,320 --> 00:00:36,800
then what we wanted was we wanted a way

12
00:00:34,320 --> 00:00:39,280
to compress the outputs of our first

13
00:00:36,800 --> 00:00:41,040
order channel. So we did last time was

14
00:00:39,280 --> 00:00:43,440
we had this crucial definition which was

15
00:00:41,040 --> 00:00:46,399
called a coding function. So we talked

16
00:00:43,440 --> 00:00:50,000
about a function which maps from length

17
00:00:46,399 --> 00:00:52,719
n sequences of the alphabet into some

18
00:00:50,000 --> 00:00:55,360
binary code of some varying length. So

19
00:00:52,719 --> 00:00:57,600
just the sequence of zeros and ones. And

20
00:00:55,360 --> 00:01:00,160
we want the crucial property that it can

21
00:00:57,600 --> 00:01:03,039
be decoded. So we want the property that

22
00:01:00,160 --> 00:01:05,040
for any two sequences that our channel

23
00:01:03,039 --> 00:01:06,640
could generate, as long as they're

24
00:01:05,040 --> 00:01:09,360
different, they map to different

25
00:01:06,640 --> 00:01:10,960
outputs. And last time what we talked

26
00:01:09,360 --> 00:01:13,200
about was we talked about Shannon's

27
00:01:10,960 --> 00:01:15,760
theorem that gave us both upper and

28
00:01:13,200 --> 00:01:17,680
lower bounds on how well we could do. So

29
00:01:15,760 --> 00:01:20,159
in particular, the main thing we proved

30
00:01:17,680 --> 00:01:22,479
was this upper bound that we defined

31
00:01:20,159 --> 00:01:25,200
this quantity called the binary entropy

32
00:01:22,479 --> 00:01:28,080
of the channel. And we showed that the

33
00:01:25,200 --> 00:01:31,040
expected length of our code is at most n

34
00:01:28,080 --> 00:01:32,960
times the per symbol entropy plus little

35
00:01:31,040 --> 00:01:34,560
o of n.

36
00:01:32,960 --> 00:01:35,920
So that was the context of what we did

37
00:01:34,560 --> 00:01:38,560
last time and today we're going to

38
00:01:35,920 --> 00:01:40,560
drastically improve upon this. So first

39
00:01:38,560 --> 00:01:43,119
of all you can wonder you know how small

40
00:01:40,560 --> 00:01:44,799
we can make this little o of n. But

41
00:01:43,119 --> 00:01:47,439
there's another point which is a little

42
00:01:44,799 --> 00:01:50,000
bit more subtle. See this scheme is not

43
00:01:47,439 --> 00:01:51,680
really so computationally efficient

44
00:01:50,000 --> 00:01:54,479
because if I think about what I have to

45
00:01:51,680 --> 00:01:59,520
do, I might in principle have to write

46
00:01:54,479 --> 00:02:02,479
down uh one you know code word for each

47
00:01:59,520 --> 00:02:04,560
possible output of my channel. So as the

48
00:02:02,479 --> 00:02:07,439
length of my channel becomes larger and

49
00:02:04,560 --> 00:02:10,479
larger now I have k to the n possible

50
00:02:07,439 --> 00:02:12,319
strings. So, I'm writing down this giant

51
00:02:10,479 --> 00:02:14,560
table of what are all the possible

52
00:02:12,319 --> 00:02:16,959
outputs? And that might be a very

53
00:02:14,560 --> 00:02:18,400
inefficient way to do these things

54
00:02:16,959 --> 00:02:20,720
because maybe I don't want to come up

55
00:02:18,400 --> 00:02:22,319
with my coding scheme by brute force by

56
00:02:20,720 --> 00:02:24,640
writing down everything that could

57
00:02:22,319 --> 00:02:26,560
possibly output from the channel and

58
00:02:24,640 --> 00:02:28,640
mapping it to, you know, what the coding

59
00:02:26,560 --> 00:02:30,640
function would send it to. So, we're

60
00:02:28,640 --> 00:02:32,800
going to do a lot better today with uh

61
00:02:30,640 --> 00:02:34,000
something called Huffman coding. In

62
00:02:32,800 --> 00:02:36,800
fact, let me tell you a bit of the

63
00:02:34,000 --> 00:02:42,160
history of Huffman coding. So Huffman

64
00:02:36,800 --> 00:02:45,400
coding was invented back in 1951

65
00:02:42,160 --> 00:02:45,400
by Huffman

66
00:02:45,680 --> 00:02:52,879
and it was invented you know right here

67
00:02:48,560 --> 00:02:55,360
at MIT in fact not by a professor but by

68
00:02:52,879 --> 00:02:57,280
a grad student. So what happened here

69
00:02:55,360 --> 00:03:00,160
was that the grad student was taking a

70
00:02:57,280 --> 00:03:01,840
graduate seminar and as is often the

71
00:03:00,160 --> 00:03:03,840
case with these types of things you know

72
00:03:01,840 --> 00:03:06,159
students don't want to take final exams.

73
00:03:03,840 --> 00:03:09,440
I'm sure you guys don't.

74
00:03:06,159 --> 00:03:12,000
And so his uh professor uh Bob Fano,

75
00:03:09,440 --> 00:03:14,239
who's still here, uh he offered him the

76
00:03:12,000 --> 00:03:17,200
choice of whether he could write a term

77
00:03:14,239 --> 00:03:19,760
paper or do the final. So he chose, of

78
00:03:17,200 --> 00:03:22,000
course, writing a term paper. And the

79
00:03:19,760 --> 00:03:23,680
term paper had to be about improving

80
00:03:22,000 --> 00:03:25,920
something in the state-of-the-art in

81
00:03:23,680 --> 00:03:27,599
coding theory. Coding theory was a topic

82
00:03:25,920 --> 00:03:28,640
that was just developing around that

83
00:03:27,599 --> 00:03:31,040
time.

84
00:03:28,640 --> 00:03:33,280
uh he was pretty stuck and then uh he

85
00:03:31,040 --> 00:03:35,519
thought okay I better cut my losses and

86
00:03:33,280 --> 00:03:37,120
start studying for the final and then at

87
00:03:35,519 --> 00:03:39,120
the very last minute he came up with

88
00:03:37,120 --> 00:03:41,120
this amazing new algorithm which we

89
00:03:39,120 --> 00:03:44,239
teach in a lot of our undergraduate

90
00:03:41,120 --> 00:03:46,560
classes as you know a a neat example and

91
00:03:44,239 --> 00:03:48,080
a powerful example so that's what we'll

92
00:03:46,560 --> 00:03:50,560
be covering today is you know some of

93
00:03:48,080 --> 00:03:54,080
the work that went into Huffman's PhD

94
00:03:50,560 --> 00:03:56,400
thesis so uh as I mentioned we'll come

95
00:03:54,080 --> 00:03:59,200
back to the comparison to Shannon uh

96
00:03:56,400 --> 00:04:01,760
Shannon uh later on. But let me give you

97
00:03:59,200 --> 00:04:04,480
a crucial definition. So we're going to

98
00:04:01,760 --> 00:04:07,599
be interested in a stronger notion of an

99
00:04:04,480 --> 00:04:10,879
encoding. We'll define what's called a

100
00:04:07,599 --> 00:04:12,959
prefix code. Now in comparison to the

101
00:04:10,879 --> 00:04:15,920
coding function that took an entire

102
00:04:12,959 --> 00:04:18,799
sequence of symbols of length n and it

103
00:04:15,920 --> 00:04:22,160
outputs some binary string. A prefix

104
00:04:18,799 --> 00:04:24,560
code is just going to take one single

105
00:04:22,160 --> 00:04:27,759
symbol from our alphabet and it's going

106
00:04:24,560 --> 00:04:30,320
to output some binary string of variable

107
00:04:27,759 --> 00:04:32,080
length. But now we have a stronger

108
00:04:30,320 --> 00:04:35,080
condition on what we want out of this

109
00:04:32,080 --> 00:04:35,080
code.

110
00:04:37,520 --> 00:04:43,600
So we want it to satisfy the condition

111
00:04:40,080 --> 00:04:46,880
that for any two input symbols AI and AJ

112
00:04:43,600 --> 00:04:48,400
that are different, we want that five of

113
00:04:46,880 --> 00:04:50,880
AI

114
00:04:48,400 --> 00:04:54,199
is not

115
00:04:50,880 --> 00:04:54,199
a prefix

116
00:04:55,199 --> 00:05:01,280
of five of AJ. So this is a stronger

117
00:04:59,520 --> 00:05:02,880
condition than them merely being

118
00:05:01,280 --> 00:05:06,639
different in terms of their binary

119
00:05:02,880 --> 00:05:08,479
strings. We want that whatever AI is

120
00:05:06,639 --> 00:05:11,680
mapped to, we want that that binary

121
00:05:08,479 --> 00:05:15,120
string doesn't occur in the in the front

122
00:05:11,680 --> 00:05:17,039
in the beginning of what uh AJ is mapped

123
00:05:15,120 --> 00:05:18,560
to and vice versa. Of course, we want

124
00:05:17,039 --> 00:05:21,039
this to be true for all pairs of

125
00:05:18,560 --> 00:05:22,720
distinct symbols.

126
00:05:21,039 --> 00:05:24,320
So, in fact, what I claim is that

127
00:05:22,720 --> 00:05:28,960
there's a nice way to think about a

128
00:05:24,320 --> 00:05:32,000
prefix code as a binary tree. So, let's

129
00:05:28,960 --> 00:05:36,800
develop a way to think about binary

130
00:05:32,000 --> 00:05:40,479
codes. uh prefix free codes as uh sorry

131
00:05:36,800 --> 00:05:43,919
prefix free codes.

132
00:05:40,479 --> 00:05:47,800
Uh let's develop a way to visualize them

133
00:05:43,919 --> 00:05:47,800
as binary trees.

134
00:05:49,120 --> 00:05:54,800
So first let me give you an example of a

135
00:05:51,759 --> 00:05:56,560
prefix free code.

136
00:05:54,800 --> 00:05:58,639
So let's imagine and this will be our

137
00:05:56,560 --> 00:06:00,880
running example today as we see the

138
00:05:58,639 --> 00:06:03,680
algorithm under the hood of Huffman

139
00:06:00,880 --> 00:06:03,680
coding.

140
00:06:06,400 --> 00:06:13,600
So, let's imagine that we have symbols

141
00:06:08,479 --> 00:06:19,199
A, B, C, D, E, and F. And I'm going to

142
00:06:13,600 --> 00:06:22,080
map these to the code words 1 0 0

143
00:06:19,199 --> 00:06:27,600
1 1 0

144
00:06:22,080 --> 00:06:30,319
0 1 0 0 1 and one one one.

145
00:06:27,600 --> 00:06:32,720
So you can check that this is a prefix

146
00:06:30,319 --> 00:06:34,720
free code because you can check for each

147
00:06:32,720 --> 00:06:37,199
of the possible outputs for your

148
00:06:34,720 --> 00:06:39,360
encoding function. One zero doesn't

149
00:06:37,199 --> 00:06:42,080
appear at the start of any of these

150
00:06:39,360 --> 00:06:44,479
strings. And that's true for all of the

151
00:06:42,080 --> 00:06:46,960
other, you know, encodings for each of

152
00:06:44,479 --> 00:06:48,560
these symbols. And one of the ways that

153
00:06:46,960 --> 00:06:51,840
we can think about this is we can think

154
00:06:48,560 --> 00:06:53,840
about it as a binary tree in which each

155
00:06:51,840 --> 00:06:56,400
branch in the binary tree tells us

156
00:06:53,840 --> 00:06:59,280
whether the next symbol is either a zero

157
00:06:56,400 --> 00:07:02,160
or one. So in this case, let's arrange

158
00:06:59,280 --> 00:07:04,800
these into a binary tree where the

159
00:07:02,160 --> 00:07:07,360
leaves are going to represent what the

160
00:07:04,800 --> 00:07:09,919
actual symbols are. So when I have a

161
00:07:07,360 --> 00:07:13,280
symbol like D that my prefix free code

162
00:07:09,919 --> 00:07:15,919
is mapping to the string 01 then I get

163
00:07:13,280 --> 00:07:18,880
that just by tracing from my root to

164
00:07:15,919 --> 00:07:21,680
that leaf. I concatenate these symbols

165
00:07:18,880 --> 00:07:25,680
in order and I get 01. And let me do

166
00:07:21,680 --> 00:07:28,240
this for all of the different symbols in

167
00:07:25,680 --> 00:07:30,240
my prefix free code.

168
00:07:28,240 --> 00:07:32,000
And every time going left down the tree

169
00:07:30,240 --> 00:07:34,639
is going to correspond to concatenating

170
00:07:32,000 --> 00:07:36,560
with a zero. And every time going right

171
00:07:34,639 --> 00:07:39,199
is going to correspond to concatenating

172
00:07:36,560 --> 00:07:41,520
with a one. So when I put this all

173
00:07:39,199 --> 00:07:45,639
together, I'll get a binary tree that

174
00:07:41,520 --> 00:07:45,639
looks like this.

175
00:07:47,919 --> 00:07:53,360
And you can check me on the details that

176
00:07:50,240 --> 00:07:56,160
you know indeed each symbol is mapped to

177
00:07:53,360 --> 00:07:58,479
the position in the binary tree where

178
00:07:56,160 --> 00:08:02,160
its associated word comes from just

179
00:07:58,479 --> 00:08:05,120
following the roottoleaf path. Right?

180
00:08:02,160 --> 00:08:08,319
And now what is the condition that this

181
00:08:05,120 --> 00:08:11,120
code is prefix free? Well, you know, if

182
00:08:08,319 --> 00:08:13,039
I had one leaf, if I had one symbol

183
00:08:11,120 --> 00:08:15,280
appear right here, right in the middle

184
00:08:13,039 --> 00:08:17,599
of this tree, I would have another

185
00:08:15,280 --> 00:08:20,160
symbol that's a descendant of it. And

186
00:08:17,599 --> 00:08:23,120
that would correspond to some a code

187
00:08:20,160 --> 00:08:24,720
that's not prefix free because in that

188
00:08:23,120 --> 00:08:26,879
case, the way that I would reach this

189
00:08:24,720 --> 00:08:29,599
symbol would be a prefix of how I reach

190
00:08:26,879 --> 00:08:32,000
this later symbol. So in fact what this

191
00:08:29,599 --> 00:08:34,240
constraint on prefix freess is another

192
00:08:32,000 --> 00:08:36,399
way to think about it is that when I

193
00:08:34,240 --> 00:08:39,360
arrange all of the symbols into this

194
00:08:36,399 --> 00:08:42,479
binary tree describing their encoding. I

195
00:08:39,360 --> 00:08:44,720
want the property that each position in

196
00:08:42,479 --> 00:08:47,839
the tree that describes the encoding of

197
00:08:44,720 --> 00:08:50,080
a symbol has no other descendants that

198
00:08:47,839 --> 00:08:51,760
are symbols beneath it. So that's an

199
00:08:50,080 --> 00:08:54,240
equivalent way to think about prefix

200
00:08:51,760 --> 00:08:57,680
free. So any questions about this key

201
00:08:54,240 --> 00:08:59,760
definition? Does this make sense? Yeah.

202
00:08:57,680 --> 00:09:02,000
All right.

203
00:08:59,760 --> 00:09:06,320
So now uh we can talk about what's the

204
00:09:02,000 --> 00:09:08,160
important thing about prefix free codes.

205
00:09:06,320 --> 00:09:11,440
So what I claim is that it actually

206
00:09:08,160 --> 00:09:15,320
makes decoding much much easier. So

207
00:09:11,440 --> 00:09:15,320
let's see why that is.

208
00:09:22,320 --> 00:09:27,680
See, when I talked about Shannon, I had

209
00:09:24,640 --> 00:09:31,040
to specify how the entire string of

210
00:09:27,680 --> 00:09:33,040
length n was mapped to a binary output.

211
00:09:31,040 --> 00:09:35,279
But now what I can do is I have a much

212
00:09:33,040 --> 00:09:38,080
simpler code that operates on a symbol

213
00:09:35,279 --> 00:09:39,760
by symbol basis. So all I'm going to do

214
00:09:38,080 --> 00:09:42,000
is I'm going to take my sequence of

215
00:09:39,760 --> 00:09:45,040
symbols and I'm just going to map them

216
00:09:42,000 --> 00:09:46,880
to 01 strings using my prefix free

217
00:09:45,040 --> 00:09:49,600
encoding and then I'm going to

218
00:09:46,880 --> 00:09:51,760
concatenate them all together.

219
00:09:49,600 --> 00:09:55,839
So let's do an example, right? What if I

220
00:09:51,760 --> 00:10:00,440
tell you I started off with a word and I

221
00:09:55,839 --> 00:10:00,440
ended up with this binary string.

222
00:10:00,640 --> 00:10:04,800
How would I figure out what was the

223
00:10:02,320 --> 00:10:07,120
sequence of symbols that I started off

224
00:10:04,800 --> 00:10:09,440
from? So, we're going to have to use the

225
00:10:07,120 --> 00:10:11,600
fact that it's prefix fe crucially,

226
00:10:09,440 --> 00:10:13,279
right? So, how can I go about figuring

227
00:10:11,600 --> 00:10:16,160
out what the first letter is? Any

228
00:10:13,279 --> 00:10:19,360
guesses for the first letter?

229
00:10:16,160 --> 00:10:21,839
F. Right? So in fact what I can do is I

230
00:10:19,360 --> 00:10:23,519
can see that you know if I chop off

231
00:10:21,839 --> 00:10:28,959
these first three symbols that's the

232
00:10:23,519 --> 00:10:32,880
encoding of f what's my next uh symbol

233
00:10:28,959 --> 00:10:35,279
a. So you can see what's tricky here is

234
00:10:32,880 --> 00:10:37,680
that because my output has variable

235
00:10:35,279 --> 00:10:40,240
length I don't know where the breaks

236
00:10:37,680 --> 00:10:43,279
are. Right? I smooshed everything

237
00:10:40,240 --> 00:10:45,200
together when I did this. But how did I

238
00:10:43,279 --> 00:10:48,079
know that the next break should be

239
00:10:45,200 --> 00:10:51,440
distance two?

240
00:10:48,079 --> 00:10:54,480
How did you guys figure that out?

241
00:10:51,440 --> 00:10:57,120
>> Yeah, youverse down the tree.

242
00:10:54,480 --> 00:10:58,880
>> That's right. That's right. And so if I

243
00:10:57,120 --> 00:11:01,040
traverse down the tree and hit a leaf,

244
00:10:58,880 --> 00:11:03,600
that's right. So we can continue this.

245
00:11:01,040 --> 00:11:05,440
We'll get the next letter is D. And last

246
00:11:03,600 --> 00:11:08,079
but not least, we'll get E. So it

247
00:11:05,440 --> 00:11:10,720
started off with the word fate. But now

248
00:11:08,079 --> 00:11:13,040
here's the crucial question.

249
00:11:10,720 --> 00:11:16,000
Why couldn't there be some other way

250
00:11:13,040 --> 00:11:20,079
hypothetically to break up the string

251
00:11:16,000 --> 00:11:22,880
into pieces in a different way

252
00:11:20,079 --> 00:11:26,880
that results in a totally different

253
00:11:22,880 --> 00:11:28,240
decoding of what my original string was?

254
00:11:26,880 --> 00:11:30,800
You see, when I started off with

255
00:11:28,240 --> 00:11:33,519
Shannon's encoding theorem, right, I was

256
00:11:30,800 --> 00:11:35,440
doing it on the entire string. And the

257
00:11:33,519 --> 00:11:38,240
property was that two different strings

258
00:11:35,440 --> 00:11:41,519
map to different outputs. Now I'm doing

259
00:11:38,240 --> 00:11:44,399
this on a symbol by symbol basis. Why am

260
00:11:41,519 --> 00:11:46,959
I guaranteed you know with my prefix

261
00:11:44,399 --> 00:11:49,519
free encoding that there's no other way

262
00:11:46,959 --> 00:11:51,760
to break this up that makes sense is

263
00:11:49,519 --> 00:11:54,079
really because of the prefix freess

264
00:11:51,760 --> 00:11:56,000
right so what if the break point had

265
00:11:54,079 --> 00:11:58,640
really happened at this yellow line so

266
00:11:56,000 --> 00:12:00,800
that I pulled out the first two symbols

267
00:11:58,640 --> 00:12:02,800
well if that really mapped to another

268
00:12:00,800 --> 00:12:05,279
symbol if there was a symbol whose

269
00:12:02,800 --> 00:12:07,120
associated code word was one one then

270
00:12:05,279 --> 00:12:09,920
the trouble is that my code word my

271
00:12:07,120 --> 00:12:11,680
encoding scheme would not be prefix free

272
00:12:09,920 --> 00:12:14,720
because that symbol would have an

273
00:12:11,680 --> 00:12:17,839
encoding that's a prefix of that of f.

274
00:12:14,720 --> 00:12:20,639
Right? So prefix freess is just the

275
00:12:17,839 --> 00:12:23,279
constraint that you can sequentially do

276
00:12:20,639 --> 00:12:25,920
decoding symbol by symbol in an

277
00:12:23,279 --> 00:12:28,160
unambiguous way. I always know where the

278
00:12:25,920 --> 00:12:30,240
breaks are even when I erase them. So

279
00:12:28,160 --> 00:12:33,600
does that make sense?

280
00:12:30,240 --> 00:12:36,800
All right. So prefix freess is an

281
00:12:33,600 --> 00:12:39,040
awesome property. um it's not obvious

282
00:12:36,800 --> 00:12:40,800
you know how it compares to what the

283
00:12:39,040 --> 00:12:44,720
fundamental limits were that we proved

284
00:12:40,800 --> 00:12:47,200
last time using Shannon right we also

285
00:12:44,720 --> 00:12:49,200
don't know what's the best way to you

286
00:12:47,200 --> 00:12:51,360
know what's the way to choose the prefix

287
00:12:49,200 --> 00:12:54,480
free code that minimizes the expected

288
00:12:51,360 --> 00:12:55,760
length so that'll be our goal today is

289
00:12:54,480 --> 00:12:58,800
we're going to be interested in the

290
00:12:55,760 --> 00:13:01,279
following very basic algorithmic problem

291
00:12:58,800 --> 00:13:04,160
we want to design

292
00:13:01,279 --> 00:13:07,600
a prefix

293
00:13:04,160 --> 00:13:11,000
free code

294
00:13:07,600 --> 00:13:11,000
that minimizes

295
00:13:11,519 --> 00:13:15,000
expected length.

296
00:13:17,839 --> 00:13:22,800
And just to be clear, what is our

297
00:13:19,920 --> 00:13:24,480
expected length here? It's just on a by

298
00:13:22,800 --> 00:13:27,440
symbol basis, right? We're thinking

299
00:13:24,480 --> 00:13:30,399
about outputs of our first order source

300
00:13:27,440 --> 00:13:32,639
that are just length one for simplicity.

301
00:13:30,399 --> 00:13:35,519
And what I want is I want that the sum

302
00:13:32,639 --> 00:13:37,279
over all of the symbols in my alphabet

303
00:13:35,519 --> 00:13:43,760
the probability that the symbol is

304
00:13:37,279 --> 00:13:47,200
chosen times LA a where LA is the length

305
00:13:43,760 --> 00:13:49,279
of the encoding of five of A. I want to

306
00:13:47,200 --> 00:13:52,240
minimize this quantity because

307
00:13:49,279 --> 00:13:54,800
intuitively now when I really care about

308
00:13:52,240 --> 00:13:57,360
the case where n is large and is not

309
00:13:54,800 --> 00:13:59,360
one. Well, my expected length is just

310
00:13:57,360 --> 00:14:02,240
going to be n times whatever I can

311
00:13:59,360 --> 00:14:05,120
achieve for a single symbol, right? And

312
00:14:02,240 --> 00:14:06,800
we know how encoding and decoding work.

313
00:14:05,120 --> 00:14:08,880
So our goal is just to solve this

314
00:14:06,800 --> 00:14:11,519
algorithmic problem and then we're going

315
00:14:08,880 --> 00:14:13,760
to compare it back with Shannon.

316
00:14:11,519 --> 00:14:16,079
So are there any questions?

317
00:14:13,760 --> 00:14:18,800
Make sense?

318
00:14:16,079 --> 00:14:21,279
All right. So, as I told you, you know,

319
00:14:18,800 --> 00:14:23,519
Huffman, uh, you know, in lie of taking

320
00:14:21,279 --> 00:14:26,079
a final exam at MIT, he designed a

321
00:14:23,519 --> 00:14:28,399
simple greedy algorithm for optimally

322
00:14:26,079 --> 00:14:30,720
solving this problem. And that's what

323
00:14:28,399 --> 00:14:32,480
we're going to do. We'll explain how the

324
00:14:30,720 --> 00:14:35,920
approach works through a running

325
00:14:32,480 --> 00:14:37,839
example. Okay? And our running example

326
00:14:35,920 --> 00:14:40,000
will be the same one that I wrote up

327
00:14:37,839 --> 00:14:41,600
there. Uh, you know, our running

328
00:14:40,000 --> 00:14:45,079
example, let me just write it here so

329
00:14:41,600 --> 00:14:45,079
that we have it.

330
00:14:51,040 --> 00:14:58,240
We'll consider the problem with symbols

331
00:14:53,279 --> 00:15:00,399
A, B, C, D, E, and F. And their

332
00:14:58,240 --> 00:15:02,399
associated probabilities because of

333
00:15:00,399 --> 00:15:05,519
course the optimal encoding depends

334
00:15:02,399 --> 00:15:07,360
crucially on these probabilities will be

335
00:15:05,519 --> 00:15:09,760
0.4

336
00:15:07,360 --> 00:15:12,160
0.05

337
00:15:09,760 --> 00:15:14,480
0.18

338
00:15:12,160 --> 00:15:17,480
0.07 07

339
00:15:14,480 --> 00:15:17,480
0.20.10

340
00:15:18,079 --> 00:15:22,560
and if I did this right they all sum up

341
00:15:19,920 --> 00:15:25,199
to one. So what we want to do is we want

342
00:15:22,560 --> 00:15:27,839
to understand what is the optimal prefix

343
00:15:25,199 --> 00:15:30,720
free encoding for this particular first

344
00:15:27,839 --> 00:15:32,639
order source and we'll see that you know

345
00:15:30,720 --> 00:15:34,560
in solving this problem we're going to

346
00:15:32,639 --> 00:15:38,240
come up with a general algorithm that

347
00:15:34,560 --> 00:15:43,920
works really for any channel.

348
00:15:38,240 --> 00:15:47,600
Okay. So now uh let's get started.

349
00:15:43,920 --> 00:15:50,240
So let's imagine let me tell you uh you

350
00:15:47,600 --> 00:15:52,560
know what our strategy is going to be.

351
00:15:50,240 --> 00:15:54,399
We're going to start off with some

352
00:15:52,560 --> 00:15:56,959
encoding which we remember we think

353
00:15:54,399 --> 00:16:00,000
about as a binary tree and we're going

354
00:15:56,959 --> 00:16:02,160
to pretend that this encoding is optimal

355
00:16:00,000 --> 00:16:04,720
and we're going to derive structural

356
00:16:02,160 --> 00:16:06,399
properties about this optimal encoding

357
00:16:04,720 --> 00:16:08,880
that will be enough to figure out what

358
00:16:06,399 --> 00:16:11,279
the encoding is. So that's our game

359
00:16:08,880 --> 00:16:15,440
plan. So I'm going to pretend that

360
00:16:11,279 --> 00:16:19,399
someone has given me already an optimal

361
00:16:15,440 --> 00:16:19,399
prefix free code.

362
00:16:23,839 --> 00:16:28,079
And what I'm going to do is I'm going to

363
00:16:25,600 --> 00:16:30,480
reverse engineer

364
00:16:28,079 --> 00:16:34,079
uh you know properties of this binary

365
00:16:30,480 --> 00:16:36,399
tree. Now just for simplicity I'm going

366
00:16:34,079 --> 00:16:39,279
to assume

367
00:16:36,399 --> 00:16:41,279
that there are no ties.

368
00:16:39,279 --> 00:16:43,680
What I mean by that is when I start off

369
00:16:41,279 --> 00:16:45,279
with all of these symbols, none of the

370
00:16:43,680 --> 00:16:47,600
symbols have exactly the same

371
00:16:45,279 --> 00:16:49,519
probability. It'll just be a bit more of

372
00:16:47,600 --> 00:16:51,920
a pain to talk about what the structural

373
00:16:49,519 --> 00:16:53,839
properties are when we allow ties, even

374
00:16:51,920 --> 00:16:56,720
though the same algorithm is essentially

375
00:16:53,839 --> 00:16:59,519
going to work as is. So I'll assume that

376
00:16:56,720 --> 00:17:01,600
none of these symbols have probabilities

377
00:16:59,519 --> 00:17:03,440
that are tied. And we're going to create

378
00:17:01,600 --> 00:17:04,559
new synthetic symbols along the way. And

379
00:17:03,440 --> 00:17:06,160
I'm going to assume that there are no

380
00:17:04,559 --> 00:17:08,720
ties even after we make those

381
00:17:06,160 --> 00:17:11,439
operations.

382
00:17:08,720 --> 00:17:14,079
So now let's state the first key lema

383
00:17:11,439 --> 00:17:17,280
that's going to get us started in terms

384
00:17:14,079 --> 00:17:22,280
of structural properties of this tree T.

385
00:17:17,280 --> 00:17:22,280
So what I claim is that the smallest

386
00:17:22,880 --> 00:17:28,319
probability symbol, so whichever symbol

387
00:17:26,240 --> 00:17:31,360
has the smallest probability in our

388
00:17:28,319 --> 00:17:34,559
first order source, has the property

389
00:17:31,360 --> 00:17:36,080
that it's at least tied

390
00:17:34,559 --> 00:17:39,799
for

391
00:17:36,080 --> 00:17:39,799
the longest encoding.

392
00:17:43,200 --> 00:17:46,559
So what I'm claiming is that whatever is

393
00:17:45,200 --> 00:17:48,960
the symbol with the smallest

394
00:17:46,559 --> 00:17:53,600
probability, in this case it's the

395
00:17:48,960 --> 00:17:56,720
symbol B right here, I claim that that

396
00:17:53,600 --> 00:17:58,559
symbol had better be in one of the

397
00:17:56,720 --> 00:18:01,200
deepest

398
00:17:58,559 --> 00:18:05,679
nodes in my binary tree that corresponds

399
00:18:01,200 --> 00:18:08,080
my prefix free code. Okay, so let's

400
00:18:05,679 --> 00:18:10,880
prove this fact and then we're going to

401
00:18:08,080 --> 00:18:14,559
prove a related fact about the symbol

402
00:18:10,880 --> 00:18:17,280
with the second smallest probability.

403
00:18:14,559 --> 00:18:21,880
So this thing is very easy to prove once

404
00:18:17,280 --> 00:18:21,880
uh you know what you're trying to prove.

405
00:18:22,559 --> 00:18:27,440
Does anyone have any intuition for how

406
00:18:24,320 --> 00:18:29,039
we could try and prove this lema?

407
00:18:27,440 --> 00:18:31,039
>> Why should it be true? Yeah,

408
00:18:29,039 --> 00:18:33,120
>> if like if it is not tied for the

409
00:18:31,039 --> 00:18:34,480
longest, then you could swap it with

410
00:18:33,120 --> 00:18:36,240
something with higher probability.

411
00:18:34,480 --> 00:18:38,400
>> That's right. That's right. So that's

412
00:18:36,240 --> 00:18:40,080
exactly how our proof is going to go

413
00:18:38,400 --> 00:18:41,760
because you can see the way that this

414
00:18:40,080 --> 00:18:44,240
proof is structured, it makes it a lot

415
00:18:41,760 --> 00:18:46,799
easier to, you know, have the algorithm

416
00:18:44,240 --> 00:18:48,480
fall out at the end because I'm not in

417
00:18:46,799 --> 00:18:51,200
one shot trying to tell you what the

418
00:18:48,480 --> 00:18:53,840
optimal tree is. I'm just trying to say

419
00:18:51,200 --> 00:18:55,679
if you gave me the optimal tree, I could

420
00:18:53,840 --> 00:18:58,000
find some interesting structural

421
00:18:55,679 --> 00:19:01,600
properties that constrain something

422
00:18:58,000 --> 00:19:03,280
about the tree that I'm looking for. So

423
00:19:01,600 --> 00:19:05,280
that's exactly right. Our proof is going

424
00:19:03,280 --> 00:19:09,520
to be, you know, if not, we're going to

425
00:19:05,280 --> 00:19:12,000
swap and contradict the optimality of T.

426
00:19:09,520 --> 00:19:14,880
So let's do a proof by contradiction

427
00:19:12,000 --> 00:19:17,919
following exactly that logic. So suppose

428
00:19:14,880 --> 00:19:25,240
that this lema is not true.

429
00:19:17,919 --> 00:19:25,240
Well, let's let you know B be the symbol

430
00:19:25,600 --> 00:19:34,559
with the lowest probability

431
00:19:29,280 --> 00:19:40,360
like in our example. And let's let C be

432
00:19:34,559 --> 00:19:40,360
the symbol which is tied for

433
00:19:40,400 --> 00:19:43,960
longest encoding.

434
00:19:46,880 --> 00:19:52,440
Now the crucial thing is that if we swap

435
00:19:52,880 --> 00:19:56,120
the encodings

436
00:19:57,840 --> 00:20:04,880
of B and C. Well, first of all, that's

437
00:20:01,520 --> 00:20:07,200
still a valid prefix free code, right?

438
00:20:04,880 --> 00:20:09,840
Because the property of being a prefix

439
00:20:07,200 --> 00:20:11,679
free code doesn't actually depend on how

440
00:20:09,840 --> 00:20:13,919
the symbols are mapped to the binary

441
00:20:11,679 --> 00:20:16,880
strings. It's purely a property of the

442
00:20:13,919 --> 00:20:19,360
binary strings I've selected. When you

443
00:20:16,880 --> 00:20:22,160
think about graphically how we visualize

444
00:20:19,360 --> 00:20:24,640
the prefix free code, it just had this

445
00:20:22,160 --> 00:20:26,720
property that all of these nodes which

446
00:20:24,640 --> 00:20:28,880
were boxes that correspond the symbols

447
00:20:26,720 --> 00:20:31,360
being mapped to them. We needed the

448
00:20:28,880 --> 00:20:34,480
property that no box had another box as

449
00:20:31,360 --> 00:20:37,840
its descendant. And now if I interchange

450
00:20:34,480 --> 00:20:40,640
the contents of these boxes, if I swap B

451
00:20:37,840 --> 00:20:42,400
and C, then it doesn't actually change

452
00:20:40,640 --> 00:20:45,280
this cominatorial condition of being

453
00:20:42,400 --> 00:20:47,760
prefix free. So this is a valid move.

454
00:20:45,280 --> 00:20:49,600
We're allowed to swap the encodings. And

455
00:20:47,760 --> 00:20:52,559
what we can do is if we swap these

456
00:20:49,600 --> 00:20:55,200
encodings, we can track how the expected

457
00:20:52,559 --> 00:20:58,240
length changes.

458
00:20:55,200 --> 00:21:02,120
So let's in particular compute how the

459
00:20:58,240 --> 00:21:02,120
expected length changes.

460
00:21:04,880 --> 00:21:11,120
So we have originally well our new uh

461
00:21:08,640 --> 00:21:13,919
you know new encoding is going to have

462
00:21:11,120 --> 00:21:17,760
the probability of the symbol B times

463
00:21:13,919 --> 00:21:21,760
the length of the encoding for symbol C

464
00:21:17,760 --> 00:21:24,880
plus the probability of the symbol C

465
00:21:21,760 --> 00:21:26,640
times the length of the encoding for B.

466
00:21:24,880 --> 00:21:29,200
That'll be some sort of contribution to

467
00:21:26,640 --> 00:21:32,159
the new expected length because you know

468
00:21:29,200 --> 00:21:34,559
every time I sample the symbol B, its

469
00:21:32,159 --> 00:21:37,440
encoding is what the encoding of C

470
00:21:34,559 --> 00:21:39,840
previously was. And every time I sample

471
00:21:37,440 --> 00:21:41,840
the symbol C, its length will be the

472
00:21:39,840 --> 00:21:44,400
length of the encoding of what B

473
00:21:41,840 --> 00:21:47,840
previously was. But now I have to

474
00:21:44,400 --> 00:21:51,679
subtract off what it was before. Right?

475
00:21:47,840 --> 00:21:55,440
So I'm going to get PB * the length of

476
00:21:51,679 --> 00:21:59,679
the encoding for B minus

477
00:21:55,440 --> 00:22:01,840
PC * the length of the encoding for C.

478
00:21:59,679 --> 00:22:03,679
So in particular when I have my formula

479
00:22:01,840 --> 00:22:06,880
for the expected length which is right

480
00:22:03,679 --> 00:22:10,159
here. Notice that for none of the other

481
00:22:06,880 --> 00:22:12,640
symbols am I changing their probability

482
00:22:10,159 --> 00:22:14,960
or the length of their encoding. The

483
00:22:12,640 --> 00:22:17,360
only changes are happening between B and

484
00:22:14,960 --> 00:22:19,919
C. So when I look at the difference in

485
00:22:17,360 --> 00:22:23,120
the expected length of my old prefix

486
00:22:19,919 --> 00:22:25,280
free code and my new one, the change in

487
00:22:23,120 --> 00:22:26,960
the length is you know this quantity

488
00:22:25,280 --> 00:22:29,919
right here because all of the other

489
00:22:26,960 --> 00:22:31,760
things cancel out.

490
00:22:29,919 --> 00:22:33,900
So let's figure out you know what's

491
00:22:31,760 --> 00:22:36,640
going on here.

492
00:22:33,900 --> 00:22:38,159
[clears throat] So this is

493
00:22:36,640 --> 00:22:42,559
we can write this out in a more

494
00:22:38,159 --> 00:22:47,520
convenient way. This is just PB * delta

495
00:22:42,559 --> 00:22:51,840
minus PC * delta where delta is equal to

496
00:22:47,520 --> 00:22:58,600
the length of the encoding of

497
00:22:51,840 --> 00:22:58,600
C minus the length of the encoding of B.

498
00:22:59,039 --> 00:23:02,799
And we know by assumption, you know,

499
00:23:01,360 --> 00:23:06,400
because we're trying to prove something

500
00:23:02,799 --> 00:23:09,679
by contradiction that by assumption

501
00:23:06,400 --> 00:23:13,440
that uh C is the symbol with the longest

502
00:23:09,679 --> 00:23:16,159
encoding, right? So B is not tied for

503
00:23:13,440 --> 00:23:17,760
the same length of the encoding. So we

504
00:23:16,159 --> 00:23:21,200
know that the difference between these

505
00:23:17,760 --> 00:23:23,919
encoding lengths is at least one, right?

506
00:23:21,200 --> 00:23:26,159
So it's strictly positive. And we also

507
00:23:23,919 --> 00:23:30,640
know

508
00:23:26,159 --> 00:23:32,720
that PB is less than PC.

509
00:23:30,640 --> 00:23:37,039
Why is that true? Because of the way

510
00:23:32,720 --> 00:23:39,280
that I defined PB. PB was the symbol

511
00:23:37,039 --> 00:23:41,679
with the smallest probability and I

512
00:23:39,280 --> 00:23:44,640
assumed that there were no ties. So

513
00:23:41,679 --> 00:23:47,440
whatever PB is, PC is strictly larger

514
00:23:44,640 --> 00:23:49,760
than that. So if you look at these two

515
00:23:47,440 --> 00:23:53,360
quantities together, then what this

516
00:23:49,760 --> 00:23:55,440
means is that you actually have a change

517
00:23:53,360 --> 00:23:58,480
that's strictly

518
00:23:55,440 --> 00:24:01,360
negative. So I've actually decreased the

519
00:23:58,480 --> 00:24:04,159
expected length of my code. So that's

520
00:24:01,360 --> 00:24:06,000
the proof of the first key lema. It

521
00:24:04,159 --> 00:24:08,159
tells us this really nice structural

522
00:24:06,000 --> 00:24:10,720
property. And you can see that the proof

523
00:24:08,159 --> 00:24:12,400
is a very simple proof by contradiction

524
00:24:10,720 --> 00:24:14,000
where I just have to figure out that I

525
00:24:12,400 --> 00:24:16,640
want to use the swap and make the

526
00:24:14,000 --> 00:24:18,880
calculation of how much I've improved

527
00:24:16,640 --> 00:24:20,880
the length and argue that it really is

528
00:24:18,880 --> 00:24:22,960
an improvement. So are there any

529
00:24:20,880 --> 00:24:24,640
questions so far?

530
00:24:22,960 --> 00:24:26,960
Good.

531
00:24:24,640 --> 00:24:29,919
All right.

532
00:24:26,960 --> 00:24:33,200
So I claim that there's a companion lema

533
00:24:29,919 --> 00:24:35,200
that the same lema holds also for the

534
00:24:33,200 --> 00:24:37,760
symbol with the second smallest

535
00:24:35,200 --> 00:24:41,120
probability. So let me state what I mean

536
00:24:37,760 --> 00:24:42,640
exactly by a version of this lema that

537
00:24:41,120 --> 00:24:45,039
holds for the second smallest

538
00:24:42,640 --> 00:24:47,279
probability and then we'll prove it. The

539
00:24:45,039 --> 00:24:50,720
proof will build on our proof of lema

540
00:24:47,279 --> 00:24:55,039
one and then we'll be off to the races.

541
00:24:50,720 --> 00:24:57,679
So what I claim is that this lema

542
00:24:55,039 --> 00:25:00,799
holds

543
00:24:57,679 --> 00:25:03,799
for second

544
00:25:00,799 --> 00:25:03,799
smallest

545
00:25:04,159 --> 00:25:07,159
probability

546
00:25:09,039 --> 00:25:12,880
two.

547
00:25:10,799 --> 00:25:15,880
So let's formally state what this lema

548
00:25:12,880 --> 00:25:15,880
is.

549
00:25:20,799 --> 00:25:24,520
The second smallest

550
00:25:26,720 --> 00:25:29,720
symbol

551
00:25:30,080 --> 00:25:36,159
I claim is second smallest probability

552
00:25:34,080 --> 00:25:40,480
symbol because that's how we're

553
00:25:36,159 --> 00:25:43,760
measuring their contribution is tied

554
00:25:40,480 --> 00:25:43,760
for the longest encoding.

555
00:25:48,559 --> 00:25:53,840
Okay. And so the proof for this lema is

556
00:25:51,600 --> 00:25:55,679
going to very closely mirror the proof

557
00:25:53,840 --> 00:26:01,159
for lema one, but it's just going to

558
00:25:55,679 --> 00:26:01,159
build on it. So let's prove this fact.

559
00:26:01,200 --> 00:26:05,679
Actually, in my example, what is my

560
00:26:03,360 --> 00:26:07,520
second smallest probability? Let's

561
00:26:05,679 --> 00:26:09,600
double check.

562
00:26:07,520 --> 00:26:12,600
Okay, so it's

563
00:26:09,600 --> 00:26:12,600
D.

564
00:26:13,760 --> 00:26:18,000
So now what I'm claiming between lema

565
00:26:15,520 --> 00:26:20,320
one and lema 2 is that these two symbols

566
00:26:18,000 --> 00:26:21,919
both had better be tied for the longest

567
00:26:20,320 --> 00:26:24,720
encoding.

568
00:26:21,919 --> 00:26:27,120
So let's you know follow our lema. So

569
00:26:24,720 --> 00:26:31,799
let's let

570
00:26:27,120 --> 00:26:31,799
B be the symbol

571
00:26:31,919 --> 00:26:39,600
with the lowest probability.

572
00:26:34,640 --> 00:26:44,440
Let's let D be the symbol

573
00:26:39,600 --> 00:26:44,440
with the second lowest probability.

574
00:26:44,799 --> 00:26:52,919
And now what we know from lema one,

575
00:26:49,200 --> 00:26:52,919
what we already proved

576
00:26:52,960 --> 00:26:57,760
is that if we look in our optimal tree,

577
00:26:55,279 --> 00:26:59,679
we start off at the root, we follow some

578
00:26:57,760 --> 00:27:03,279
path,

579
00:26:59,679 --> 00:27:04,880
and then we reach our symbol uh B, which

580
00:27:03,279 --> 00:27:06,799
is the symbol with the smallest

581
00:27:04,880 --> 00:27:10,080
probability.

582
00:27:06,799 --> 00:27:11,600
And let's imagine that we call P the

583
00:27:10,080 --> 00:27:14,640
parent.

584
00:27:11,600 --> 00:27:17,600
So whoever comes before

585
00:27:14,640 --> 00:27:19,360
So this is not the image of a symbol

586
00:27:17,600 --> 00:27:21,919
because we have this prefix free

587
00:27:19,360 --> 00:27:24,159
constraint but it's still a node in our

588
00:27:21,919 --> 00:27:26,960
binary tree. There is some parent of

589
00:27:24,159 --> 00:27:30,559
wherever B gets mapped to.

590
00:27:26,960 --> 00:27:33,120
And now what I claim is that

591
00:27:30,559 --> 00:27:39,720
but P you know the way that I've drawn

592
00:27:33,120 --> 00:27:39,720
it I claim must have another child.

593
00:27:43,840 --> 00:27:52,080
I claim that there must be some node in

594
00:27:47,039 --> 00:27:53,440
my binary tree that's the sibling of P.

595
00:27:52,080 --> 00:27:57,440
So let's make sure we're on the same

596
00:27:53,440 --> 00:28:02,360
page. So why is this claim true? Why can

597
00:27:57,440 --> 00:28:02,360
I assert that P has another child?

598
00:28:03,360 --> 00:28:07,559
If it didn't, what would it contradict?

599
00:28:19,520 --> 00:28:22,960
Yeah.

600
00:28:20,000 --> 00:28:24,960
>> Would it not be a binary tree then?

601
00:28:22,960 --> 00:28:27,039
>> Well, it would still be a binary tree.

602
00:28:24,960 --> 00:28:29,200
So, we'll allow, you know, zero, one or

603
00:28:27,039 --> 00:28:31,039
two children. But there's something else

604
00:28:29,200 --> 00:28:33,840
that's really crucial. So, think back to

605
00:28:31,039 --> 00:28:36,159
my proof strategy. What am I trying to

606
00:28:33,840 --> 00:28:39,360
do? I'm trying to say that T is an

607
00:28:36,159 --> 00:28:42,000
optimal prefix free code. And then my

608
00:28:39,360 --> 00:28:44,640
first lema was a structural statement

609
00:28:42,000 --> 00:28:47,520
about some property that must be true of

610
00:28:44,640 --> 00:28:49,919
that optimal binary tree.

611
00:28:47,520 --> 00:28:53,120
Lema 2 is an even stronger structural

612
00:28:49,919 --> 00:28:55,760
property about that optimal binary tree.

613
00:28:53,120 --> 00:28:58,720
So what would happen if P really didn't

614
00:28:55,760 --> 00:28:59,360
have another child right here?

615
00:28:58,720 --> 00:29:00,799
>> Yeah.

616
00:28:59,360 --> 00:29:03,360
>> No longer be an optimal code.

617
00:29:00,799 --> 00:29:05,840
>> Yes. It would no longer be optimal. Why?

618
00:29:03,360 --> 00:29:07,600
because you have an empty space,

619
00:29:05,840 --> 00:29:10,240
>> right? But another way to think about it

620
00:29:07,600 --> 00:29:12,000
is that you know I know that there's no

621
00:29:10,240 --> 00:29:15,200
symbol that's mapped to P because it's

622
00:29:12,000 --> 00:29:17,760
prefix free. If P didn't have another

623
00:29:15,200 --> 00:29:21,039
child, I could just promote this node

624
00:29:17,760 --> 00:29:22,960
and delete everything underneath. Right?

625
00:29:21,039 --> 00:29:25,679
So in this case I would be strictly

626
00:29:22,960 --> 00:29:28,240
improving the expected length of my

627
00:29:25,679 --> 00:29:30,480
prefix free code because I'm not

628
00:29:28,240 --> 00:29:33,200
changing anything except for the length

629
00:29:30,480 --> 00:29:36,000
of the encoding of B which is decreasing

630
00:29:33,200 --> 00:29:39,760
by one. So what I claim is that P must

631
00:29:36,000 --> 00:29:45,720
have another child otherwise

632
00:29:39,760 --> 00:29:45,720
T is definitely not optimal.

633
00:29:45,760 --> 00:29:52,080
Does that make sense? Okay. So now I

634
00:29:49,840 --> 00:29:55,440
know that this child really must be

635
00:29:52,080 --> 00:29:58,960
there. And let's call this child C,

636
00:29:55,440 --> 00:30:02,240
which is just the sibling, right? And so

637
00:29:58,960 --> 00:30:05,440
what I claim now is that if I look in

638
00:30:02,240 --> 00:30:09,679
this tree and I have some path that goes

639
00:30:05,440 --> 00:30:12,559
to my other symbol, which is D, my

640
00:30:09,679 --> 00:30:16,559
second smallest probability. Well, what

641
00:30:12,559 --> 00:30:18,720
could I do if D was not tied for the

642
00:30:16,559 --> 00:30:21,200
second not tied for the longest

643
00:30:18,720 --> 00:30:24,080
encoding? You know, we know that B has

644
00:30:21,200 --> 00:30:26,000
the longest encoding. So, D better have,

645
00:30:24,080 --> 00:30:28,080
you know, an encoding length that's less

646
00:30:26,000 --> 00:30:30,559
than or equal to it. But what if it was

647
00:30:28,080 --> 00:30:33,039
strictly less than the length of the

648
00:30:30,559 --> 00:30:35,440
encoding of B? We know that there's

649
00:30:33,039 --> 00:30:38,720
another child C that has the same length

650
00:30:35,440 --> 00:30:40,720
encoding as B. So what should I do if

651
00:30:38,720 --> 00:30:43,120
you know D wasn't tied for the second

652
00:30:40,720 --> 00:30:46,880
longest encoding? I can do the same

653
00:30:43,120 --> 00:30:49,760
trick as before, right? I can swap. So

654
00:30:46,880 --> 00:30:52,000
what I claim is that now

655
00:30:49,760 --> 00:30:54,000
if

656
00:30:52,000 --> 00:30:59,720
uh D

657
00:30:54,000 --> 00:30:59,720
has a strictly shorter encoding.

658
00:31:02,320 --> 00:31:10,799
What I claim is that I can swap

659
00:31:07,039 --> 00:31:12,399
C and D,

660
00:31:10,799 --> 00:31:17,399
right?

661
00:31:12,399 --> 00:31:17,399
And improve the expected length.

662
00:31:20,000 --> 00:31:24,080
So this is the same proof as before,

663
00:31:22,399 --> 00:31:26,480
right? So this is a bit subtle, but it's

664
00:31:24,080 --> 00:31:27,840
a purely combinatorial proof. Are there

665
00:31:26,480 --> 00:31:30,799
any questions? So you know the way that

666
00:31:27,840 --> 00:31:32,640
this worked logically from lema one, we

667
00:31:30,799 --> 00:31:35,039
know that B is tied for the longest

668
00:31:32,640 --> 00:31:38,080
encoding. So nothing can have an

669
00:31:35,039 --> 00:31:41,840
encoding length that's strictly longer.

670
00:31:38,080 --> 00:31:44,320
We we argued that B has a parent P and

671
00:31:41,840 --> 00:31:46,240
that P had better have another child.

672
00:31:44,320 --> 00:31:48,799
And if P has another child, this would

673
00:31:46,240 --> 00:31:51,600
better be some other symbol in terms of

674
00:31:48,799 --> 00:31:53,440
the encoding. And if D were strictly off

675
00:31:51,600 --> 00:31:55,039
this line and the length of its coding

676
00:31:53,440 --> 00:31:57,360
were shorter than the length of the

677
00:31:55,039 --> 00:32:00,000
encoding of B and C, what we could do is

678
00:31:57,360 --> 00:32:01,600
we could just swap D and C. And then the

679
00:32:00,000 --> 00:32:03,840
same type of computation that we did in

680
00:32:01,600 --> 00:32:06,320
the proof of lema one will show us that

681
00:32:03,840 --> 00:32:08,320
we've strictly improved. Why? Because

682
00:32:06,320 --> 00:32:11,679
the probability of D is strictly less

683
00:32:08,320 --> 00:32:14,480
than the probability of C. Okay, so

684
00:32:11,679 --> 00:32:16,559
these are our two key structural lemas.

685
00:32:14,480 --> 00:32:19,200
And now we're actually almost in good

686
00:32:16,559 --> 00:32:22,799
shape. So we're almost uh ready to talk

687
00:32:19,200 --> 00:32:27,120
about Huffman's algorithm.

688
00:32:22,799 --> 00:32:28,559
So let me do one more claim. The slash

689
00:32:27,120 --> 00:32:32,080
structural property is the thing that's

690
00:32:28,559 --> 00:32:35,039
going to make Huffman's greedy algorithm

691
00:32:32,080 --> 00:32:36,720
work. So I claim building off of lema

692
00:32:35,039 --> 00:32:39,120
one and lema two, we can say something

693
00:32:36,720 --> 00:32:41,200
even stronger.

694
00:32:39,120 --> 00:32:46,240
What I claim is that without loss of

695
00:32:41,200 --> 00:32:48,559
generality, these two symbols B and D,

696
00:32:46,240 --> 00:32:51,120
which are the smallest and second

697
00:32:48,559 --> 00:32:53,840
smallest probabilities respectively, I

698
00:32:51,120 --> 00:32:56,240
claim without loss generality they're

699
00:32:53,840 --> 00:32:59,720
siblings.

700
00:32:56,240 --> 00:32:59,720
in the tree.

701
00:33:02,240 --> 00:33:10,039
So why is this true? Well, from lema one

702
00:33:06,399 --> 00:33:10,039
and lema 2.

703
00:33:13,679 --> 00:33:18,000
What do we know? We can draw it out

704
00:33:15,360 --> 00:33:21,039
pictorially. We know that we start off

705
00:33:18,000 --> 00:33:25,679
from the root. We take some path to the

706
00:33:21,039 --> 00:33:29,760
parent P and then we reach our symbol D,

707
00:33:25,679 --> 00:33:33,360
right? And we know that P has some other

708
00:33:29,760 --> 00:33:37,600
child maybe it's C and then we know that

709
00:33:33,360 --> 00:33:40,159
there's a path that reaches

710
00:33:37,600 --> 00:33:42,320
the other symbol B which has the second

711
00:33:40,159 --> 00:33:44,640
smallest probability according to our

712
00:33:42,320 --> 00:33:47,360
channel and we know that all of these

713
00:33:44,640 --> 00:33:49,120
things are tied for the same length. So

714
00:33:47,360 --> 00:33:52,240
what could I do in this case is I could

715
00:33:49,120 --> 00:33:53,760
just swap the positions of B and C. That

716
00:33:52,240 --> 00:33:56,080
doesn't change anything about the

717
00:33:53,760 --> 00:33:58,960
lengths of the encoding, but it has the

718
00:33:56,080 --> 00:34:02,000
property now that B and D are siblings

719
00:33:58,960 --> 00:34:03,919
of each other. Right?

720
00:34:02,000 --> 00:34:07,360
So the proof for all of these structural

721
00:34:03,919 --> 00:34:10,879
statements lema 1, lema 2 and this claim

722
00:34:07,360 --> 00:34:13,040
is really just if not swap. Lema one was

723
00:34:10,879 --> 00:34:15,760
if B isn't the longest then swap and

724
00:34:13,040 --> 00:34:18,800
you'll improve the length. Lema two was

725
00:34:15,760 --> 00:34:20,560
well we know where B is but if B is also

726
00:34:18,800 --> 00:34:23,520
not the same length then swap and

727
00:34:20,560 --> 00:34:25,440
improve the length and finally even

728
00:34:23,520 --> 00:34:27,679
knowing that they're tied for the same

729
00:34:25,440 --> 00:34:29,599
length of the encoding swap so that

730
00:34:27,679 --> 00:34:31,520
they're siblings.

731
00:34:29,599 --> 00:34:33,440
So this is the key structural property

732
00:34:31,520 --> 00:34:36,480
that we're going to use. Without wash

733
00:34:33,440 --> 00:34:38,240
generality, B and D are siblings. And

734
00:34:36,480 --> 00:34:40,079
now we can come back to our running

735
00:34:38,240 --> 00:34:42,800
example and we can build up what the

736
00:34:40,079 --> 00:34:44,480
optimal tree is and we'll be able to,

737
00:34:42,800 --> 00:34:46,480
you know, Huffman's algorithm is just

738
00:34:44,480 --> 00:34:48,320
going to fall out as a consequence.

739
00:34:46,480 --> 00:34:51,760
Okay,

740
00:34:48,320 --> 00:34:54,320
so let's do the same, you know,

741
00:34:51,760 --> 00:34:57,200
intuition on this, right? So we don't

742
00:34:54,320 --> 00:35:00,400
know what our optimal tree looks like.

743
00:34:57,200 --> 00:35:03,440
I'll just draw it as a big blob. Right?

744
00:35:00,400 --> 00:35:07,680
But we know from our claim that without

745
00:35:03,440 --> 00:35:10,240
loss of generality, B and D are siblings

746
00:35:07,680 --> 00:35:12,480
of each other.

747
00:35:10,240 --> 00:35:14,000
And so now here's the idea. What I'm

748
00:35:12,480 --> 00:35:16,480
going to do is I'm going to take these

749
00:35:14,000 --> 00:35:20,000
two symbols and I'm going to replace

750
00:35:16,480 --> 00:35:22,800
them with a new symbol. So I'm going to

751
00:35:20,000 --> 00:35:24,880
write down a new symbol alpha. And so

752
00:35:22,800 --> 00:35:27,200
here's the step in my Huffman coding

753
00:35:24,880 --> 00:35:30,200
algorithm. I'm going to replace these

754
00:35:27,200 --> 00:35:30,200
symbols

755
00:35:30,240 --> 00:35:37,480
B and D

756
00:35:33,599 --> 00:35:37,480
with a new symbol

757
00:35:38,160 --> 00:35:42,119
which I'm going to call alpha.

758
00:35:42,320 --> 00:35:47,040
And I'm going to have the property that

759
00:35:44,320 --> 00:35:49,760
my probability of this new symbol is

760
00:35:47,040 --> 00:35:52,240
going to be the sum of the probabilities

761
00:35:49,760 --> 00:35:54,240
of the symbols that I've merged. So

762
00:35:52,240 --> 00:35:56,160
that's the key idea. So, I'm going to

763
00:35:54,240 --> 00:35:58,720
set its probability to be equal to the

764
00:35:56,160 --> 00:36:01,040
sum of the two old probabilities. This

765
00:35:58,720 --> 00:36:04,079
way, when I get rid of these two symbols

766
00:36:01,040 --> 00:36:06,240
from my list and instead add my symbol

767
00:36:04,079 --> 00:36:07,920
alpha at the bottom, I'm still going to

768
00:36:06,240 --> 00:36:10,400
have a valid distribution because I've

769
00:36:07,920 --> 00:36:11,680
just merged those two probabilities. But

770
00:36:10,400 --> 00:36:14,400
now, what we're going to do, the main

771
00:36:11,680 --> 00:36:16,400
idea behind Huffman

772
00:36:14,400 --> 00:36:18,800
is we're going to solve the optimal

773
00:36:16,400 --> 00:36:21,680
problem on this smaller uh set of

774
00:36:18,800 --> 00:36:23,839
symbols, right? And then from the

775
00:36:21,680 --> 00:36:26,079
optimal binary tree for this new

776
00:36:23,839 --> 00:36:28,480
problem, we're going to derive what the

777
00:36:26,079 --> 00:36:30,560
optimal binary tree was for our original

778
00:36:28,480 --> 00:36:32,320
problem. So are there any questions

779
00:36:30,560 --> 00:36:34,640
about the strategy? Does this make

780
00:36:32,320 --> 00:36:37,359
sense?

781
00:36:34,640 --> 00:36:41,480
All right. So let's do that and let's

782
00:36:37,359 --> 00:36:41,480
see what Huffman would do.

783
00:36:42,800 --> 00:36:48,200
So the corresponding transformation on

784
00:36:45,040 --> 00:36:48,200
the tree.

785
00:36:53,760 --> 00:36:59,599
We started off with this tree T and now

786
00:36:56,800 --> 00:37:01,440
we're going to have this tree T prime.

787
00:36:59,599 --> 00:37:06,960
And what's going to happen is I've

788
00:37:01,440 --> 00:37:09,599
replaced the parent of B and D instead

789
00:37:06,960 --> 00:37:12,240
with this new symbol alpha that occurs

790
00:37:09,599 --> 00:37:14,160
in the same exact place in the tree. But

791
00:37:12,240 --> 00:37:15,760
then I've changed nothing else about the

792
00:37:14,160 --> 00:37:21,560
tree.

793
00:37:15,760 --> 00:37:21,560
So now we get to the key lema.

794
00:37:25,440 --> 00:37:32,160
What I claim

795
00:37:28,000 --> 00:37:35,160
is that this new tree t prime is also

796
00:37:32,160 --> 00:37:35,160
optimal

797
00:37:42,320 --> 00:37:48,240
for our new problem where our new

798
00:37:44,960 --> 00:37:53,119
alphabet is a prime. So we take our old

799
00:37:48,240 --> 00:37:56,400
alphabet A, we add in this new element

800
00:37:53,119 --> 00:37:59,040
alpha, we subtract off the two symbols B

801
00:37:56,400 --> 00:38:01,680
and D. And we've already talked about

802
00:37:59,040 --> 00:38:04,640
how we update the probabilities.

803
00:38:01,680 --> 00:38:06,640
So this is the key property that I pro

804
00:38:04,640 --> 00:38:09,200
you know I was assuming that someone

805
00:38:06,640 --> 00:38:11,680
gave me the optimal tree T for my

806
00:38:09,200 --> 00:38:13,200
original problem. Now I said something

807
00:38:11,680 --> 00:38:15,119
structurally about without loss

808
00:38:13,200 --> 00:38:17,440
generality where B and D have to occur

809
00:38:15,119 --> 00:38:20,240
in relation to each other. And now I've

810
00:38:17,440 --> 00:38:23,440
created a subpros on a smaller number of

811
00:38:20,240 --> 00:38:27,280
symbols. But I claim that just this new

812
00:38:23,440 --> 00:38:30,800
tree uh t prime that I get had actually

813
00:38:27,280 --> 00:38:33,200
be an optimal uh answer to the new

814
00:38:30,800 --> 00:38:36,320
problem that I've constructed.

815
00:38:33,200 --> 00:38:41,240
So does this make sense intuitively?

816
00:38:36,320 --> 00:38:41,240
Okay. So let's prove this lema.

817
00:38:43,680 --> 00:38:52,240
So just for notation, let's let L be the

818
00:38:48,240 --> 00:38:56,240
expected length

819
00:38:52,240 --> 00:38:58,960
of T. I'm going to let L prime be the

820
00:38:56,240 --> 00:39:01,599
expected length of T prime, this new

821
00:38:58,960 --> 00:39:05,119
tree that I've constructed.

822
00:39:01,599 --> 00:39:07,200
And let's prove this lema that T prime

823
00:39:05,119 --> 00:39:09,040
is optimal.

824
00:39:07,200 --> 00:39:10,960
So to make sure you guys are following.

825
00:39:09,040 --> 00:39:13,680
So does anyone have any intuition for

826
00:39:10,960 --> 00:39:17,400
how I can prove this lema that t prime

827
00:39:13,680 --> 00:39:17,400
is again optimal?

828
00:39:19,280 --> 00:39:24,839
There's basically only one proof we have

829
00:39:21,839 --> 00:39:24,839
today.

830
00:39:26,400 --> 00:39:30,800
>> Yeah. Um I was thinking you could like

831
00:39:29,040 --> 00:39:33,440
swap it, but I was a little bit

832
00:39:30,800 --> 00:39:35,599
concerned cuz if you like swap the

833
00:39:33,440 --> 00:39:38,000
probabilities together, maybe it gets

834
00:39:35,599 --> 00:39:38,000
big.

835
00:39:38,240 --> 00:39:41,680
Okay, so let's think about what we're

836
00:39:40,320 --> 00:39:44,480
trying to prove, right? We're trying to

837
00:39:41,680 --> 00:39:47,280
prove that T prime is an optimal prefix

838
00:39:44,480 --> 00:39:50,560
free code for this new sub problem I've

839
00:39:47,280 --> 00:39:54,400
constructed on a smaller alphabet,

840
00:39:50,560 --> 00:39:56,800
right? So uh what proof strategy do you

841
00:39:54,400 --> 00:40:00,040
think makes sense to prove that T prime

842
00:39:56,800 --> 00:40:00,040
is optimal?

843
00:40:00,800 --> 00:40:06,599
Greedy induction some other proof

844
00:40:03,599 --> 00:40:06,599
strategy

845
00:40:15,280 --> 00:40:18,920
proof by contradiction.

846
00:40:23,040 --> 00:40:28,800
Yeah.

847
00:40:25,520 --> 00:40:31,839
>> Okay, that's right. Um because in fact

848
00:40:28,800 --> 00:40:35,280
like the easiest way to prove this is

849
00:40:31,839 --> 00:40:38,800
what if t prime is not optimal then what

850
00:40:35,280 --> 00:40:40,640
I can do is I could hope to construct

851
00:40:38,800 --> 00:40:42,880
you know I could take whatever tree is

852
00:40:40,640 --> 00:40:46,240
optimal for this sub problem and then

853
00:40:42,880 --> 00:40:47,680
what would I want to do with that tree

854
00:40:46,240 --> 00:40:49,200
you know let's say that proof by

855
00:40:47,680 --> 00:40:54,520
contradiction is the right way to do

856
00:40:49,200 --> 00:40:54,520
this right so suppose not

857
00:40:54,560 --> 00:41:02,800
suppose there's is a better

858
00:41:00,079 --> 00:41:06,880
tree.

859
00:41:02,800 --> 00:41:09,520
Let's call this tree, I don't know, S.

860
00:41:06,880 --> 00:41:11,040
What should I do with my better tree?

861
00:41:09,520 --> 00:41:14,040
How am I trying to prove a proof by

862
00:41:11,040 --> 00:41:14,040
contradiction?

863
00:41:20,720 --> 00:41:25,599
So you can either answer the question or

864
00:41:23,839 --> 00:41:27,760
ask me a question about what we covered

865
00:41:25,599 --> 00:41:29,680
so far. So it's your choice, but

866
00:41:27,760 --> 00:41:30,160
someone's got to answer.

867
00:41:29,680 --> 00:41:32,319
>> Yeah,

868
00:41:30,160 --> 00:41:34,640
>> I presume you can show that S is

869
00:41:32,319 --> 00:41:38,079
actually just T prime.

870
00:41:34,640 --> 00:41:40,880
>> Uh S is actually T prime.

871
00:41:38,079 --> 00:41:43,880
That's true, but it's harder than I

872
00:41:40,880 --> 00:41:43,880
want.

873
00:41:44,720 --> 00:41:48,079
So some of these things you kind of have

874
00:41:46,079 --> 00:41:49,680
to have a little bit of intuition about

875
00:41:48,079 --> 00:41:52,319
which proof technique would be the

876
00:41:49,680 --> 00:41:54,480
easiest. So we already agreed it's proof

877
00:41:52,319 --> 00:41:57,200
by contradiction. But the question is

878
00:41:54,480 --> 00:41:58,160
what am I trying to contradict and how?

879
00:41:57,200 --> 00:42:01,720
Because that's how proof by

880
00:41:58,160 --> 00:42:01,720
contradiction works.

881
00:42:02,160 --> 00:42:07,480
So what can I do with S? Yeah.

882
00:42:10,560 --> 00:42:13,920
>> Can you backtrack to make another

883
00:42:12,720 --> 00:42:16,960
version of T.

884
00:42:13,920 --> 00:42:21,200
>> Yeah. Okay. So, let's think about S. I

885
00:42:16,960 --> 00:42:25,119
like that. So, S is some other blob,

886
00:42:21,200 --> 00:42:27,359
right? And it's better.

887
00:42:25,119 --> 00:42:29,520
Um, what are the symbols that occur in

888
00:42:27,359 --> 00:42:31,040
S?

889
00:42:29,520 --> 00:42:37,440
Well,

890
00:42:31,040 --> 00:42:40,720
A, C, E, F, and alpha. My new symbol.

891
00:42:37,440 --> 00:42:42,960
So, alpha appears somewhere,

892
00:42:40,720 --> 00:42:45,920
right?

893
00:42:42,960 --> 00:42:48,079
What should I do with alpha now?

894
00:42:45,920 --> 00:42:52,319
Well, maybe I can try and construct a

895
00:42:48,079 --> 00:42:54,720
better encoding for my original problem.

896
00:42:52,319 --> 00:42:57,280
Right? So that's the idea is that

897
00:42:54,720 --> 00:43:00,000
there's a proof by contradiction. So we

898
00:42:57,280 --> 00:43:03,359
suppose that there's a better tree s.

899
00:43:00,000 --> 00:43:05,760
Right? And this better tree is a better

900
00:43:03,359 --> 00:43:09,119
tree for this particular problem on this

901
00:43:05,760 --> 00:43:12,640
new alphabet A prime. And what I want to

902
00:43:09,119 --> 00:43:15,599
do is I want to use this S to construct

903
00:43:12,640 --> 00:43:18,720
a better answer to my original problem

904
00:43:15,599 --> 00:43:21,040
that contradicts the optimality of T.

905
00:43:18,720 --> 00:43:22,800
Right? So think about how the logic of

906
00:43:21,040 --> 00:43:25,680
this proof worked. Someone gave me an

907
00:43:22,800 --> 00:43:28,480
optimal tree T. I proved a structural

908
00:43:25,680 --> 00:43:31,599
property about you know where B and D

909
00:43:28,480 --> 00:43:35,119
occur. And now what I'm doing is I'm

910
00:43:31,599 --> 00:43:38,079
saying that I want that when I contract

911
00:43:35,119 --> 00:43:40,960
B and D the result I get is optimal for

912
00:43:38,079 --> 00:43:42,800
the corresponding subpro because if it

913
00:43:40,960 --> 00:43:45,599
weren't optimal for the corresponding

914
00:43:42,800 --> 00:43:47,280
sub problem then my original tree T

915
00:43:45,599 --> 00:43:49,680
could not have been optimal to begin

916
00:43:47,280 --> 00:43:51,040
with. Right? So this is the key point

917
00:43:49,680 --> 00:43:53,599
for the logic of the proof. Even though

918
00:43:51,040 --> 00:43:55,040
the proof is very simple, it takes a

919
00:43:53,599 --> 00:43:57,599
little bit to wrap your head around the

920
00:43:55,040 --> 00:44:00,560
logic. All right? So let's imagine that

921
00:43:57,599 --> 00:44:04,400
there's a better prefix code S and the

922
00:44:00,560 --> 00:44:08,880
associated tree and let's say that it

923
00:44:04,400 --> 00:44:12,960
has expected length

924
00:44:08,880 --> 00:44:14,720
which is LP prime. Okay, remember L

925
00:44:12,960 --> 00:44:17,599
prime was the expected length of T

926
00:44:14,720 --> 00:44:20,560
prime. So we're assuming for the purpose

927
00:44:17,599 --> 00:44:23,680
of contradiction that LP prime is

928
00:44:20,560 --> 00:44:26,480
strictly less than L prime that it does

929
00:44:23,680 --> 00:44:30,079
strictly better. So in this case what we

930
00:44:26,480 --> 00:44:35,160
can do is we can convert we can invert

931
00:44:30,079 --> 00:44:35,160
the operation that we just did right.

932
00:44:40,079 --> 00:44:44,200
So we can invert the operation

933
00:44:46,960 --> 00:44:52,480
which took us from the problem on the

934
00:44:49,839 --> 00:44:55,440
full alphabet A to the sub problem on

935
00:44:52,480 --> 00:44:57,680
alphabet A prime. We can replace the

936
00:44:55,440 --> 00:45:01,960
symbol alpha that was our new synthetic

937
00:44:57,680 --> 00:45:01,960
symbol by

938
00:45:02,400 --> 00:45:08,480
this gadget right here. Right? And so

939
00:45:05,839 --> 00:45:12,400
when we do that, let's track what the

940
00:45:08,480 --> 00:45:17,160
new expected length is. Right?

941
00:45:12,400 --> 00:45:17,160
So the new expected length

942
00:45:19,760 --> 00:45:26,240
is LP prime because I still pay the

943
00:45:22,480 --> 00:45:30,160
expected length you know until I um you

944
00:45:26,240 --> 00:45:33,280
know for this answer S right but now by

945
00:45:30,160 --> 00:45:38,079
replacing alpha with B and D every time

946
00:45:33,280 --> 00:45:40,640
I incur encounter either B or D

947
00:45:38,079 --> 00:45:42,000
I'm going to pay one extra unit of

948
00:45:40,640 --> 00:45:44,079
length.

949
00:45:42,000 --> 00:45:47,520
because previously I stopped at the

950
00:45:44,079 --> 00:45:50,000
symbol alpha and now I have to continue

951
00:45:47,520 --> 00:45:52,720
wherever alpha was that's not the end I

952
00:45:50,000 --> 00:45:55,520
have to go further down to either B or D

953
00:45:52,720 --> 00:45:58,640
that happens with probability PB plus PD

954
00:45:55,520 --> 00:46:01,920
respectively so this is my new expected

955
00:45:58,640 --> 00:46:04,800
length when I take my you know new

956
00:46:01,920 --> 00:46:07,520
better answer for this sub problem and

957
00:46:04,800 --> 00:46:09,920
replace it

958
00:46:07,520 --> 00:46:12,640
with inverting this operation that's my

959
00:46:09,920 --> 00:46:14,720
new expected length. But when I think

960
00:46:12,640 --> 00:46:17,440
about how this compares to my old

961
00:46:14,720 --> 00:46:21,599
expected length, see if I had the

962
00:46:17,440 --> 00:46:24,400
original tree prime here, right? Then I

963
00:46:21,599 --> 00:46:27,119
pay expected length L prime. And the way

964
00:46:24,400 --> 00:46:30,000
that I get from T prime to T was I do

965
00:46:27,119 --> 00:46:33,440
that same operation where I take alpha

966
00:46:30,000 --> 00:46:36,720
and replace it with B and D. So my old

967
00:46:33,440 --> 00:46:40,319
expected length was actually L prime

968
00:46:36,720 --> 00:46:44,240
plus PD uh sorry plus PB

969
00:46:40,319 --> 00:46:45,839
plus PD and this is just equal to L. So

970
00:46:44,240 --> 00:46:48,079
does everyone see how I got this? This

971
00:46:45,839 --> 00:46:49,359
is the crucial point in the proof. If

972
00:46:48,079 --> 00:46:53,040
you don't understand this, you don't

973
00:46:49,359 --> 00:46:56,240
understand Huffman coding. Okay. And so

974
00:46:53,040 --> 00:46:58,800
the crucial thing right here is that now

975
00:46:56,240 --> 00:47:00,880
I've come up with a better solution for

976
00:46:58,800 --> 00:47:03,880
my original problem. And this

977
00:47:00,880 --> 00:47:03,880
contradicts

978
00:47:04,720 --> 00:47:08,040
the optimality

979
00:47:10,560 --> 00:47:19,839
of T. Okay. So this is the proof

980
00:47:15,599 --> 00:47:21,680
and I'm not going to go on further until

981
00:47:19,839 --> 00:47:26,800
you convince me you understand the

982
00:47:21,680 --> 00:47:29,359
proof. Okay. So who can explain to me

983
00:47:26,800 --> 00:47:33,119
how this proof works in your own words?

984
00:47:29,359 --> 00:47:35,280
the one that's on the board

985
00:47:33,119 --> 00:47:37,119
or ask me a question. Those are your two

986
00:47:35,280 --> 00:47:39,040
options.

987
00:47:37,119 --> 00:47:40,960
I guess the third option is try and

988
00:47:39,040 --> 00:47:43,960
avoid eye contact, but that won't be as

989
00:47:40,960 --> 00:47:43,960
effective.

990
00:47:47,760 --> 00:47:51,040
>> Yeah, go for it.

991
00:47:49,359 --> 00:47:53,040
>> So, basically, we're trying to do it by

992
00:47:51,040 --> 00:47:55,440
contradiction by saying that there's a

993
00:47:53,040 --> 00:47:58,400
more optimal tree S. Yeah. And we're

994
00:47:55,440 --> 00:48:00,880
going to show that the expected um that

995
00:47:58,400 --> 00:48:05,040
when we like make S back into the same

996
00:48:00,880 --> 00:48:06,720
alphabet with T that S like finds that

997
00:48:05,040 --> 00:48:07,440
another shape is more optimal.

998
00:48:06,720 --> 00:48:07,920
>> Yeah.

999
00:48:07,440 --> 00:48:08,800
>> Yeah.

1000
00:48:07,920 --> 00:48:09,440
>> My prediction because our first

1001
00:48:08,800 --> 00:48:11,200
assumption is

1002
00:48:09,440 --> 00:48:14,079
>> that's right. So to do that we

1003
00:48:11,200 --> 00:48:15,599
calculated the new expected length for S

1004
00:48:14,079 --> 00:48:18,640
and then given that S is like more

1005
00:48:15,599 --> 00:48:20,480
optimal than T prime um we can we know

1006
00:48:18,640 --> 00:48:24,079
that that optimal length is less than L

1007
00:48:20,480 --> 00:48:26,000
prime plus the like reverting L prime

1008
00:48:24,079 --> 00:48:29,359
which is equal to T.

1009
00:48:26,000 --> 00:48:32,079
>> Okay. Yeah. Very good. That was that was

1010
00:48:29,359 --> 00:48:33,440
perfect. Uh let's stress test our

1011
00:48:32,079 --> 00:48:36,000
understanding. You know I think the

1012
00:48:33,440 --> 00:48:37,599
right way to understand proofs is to

1013
00:48:36,000 --> 00:48:39,760
think about them like an engineer to

1014
00:48:37,599 --> 00:48:42,640
look at each individual piece, right? So

1015
00:48:39,760 --> 00:48:46,240
we proved a bunch of things today uh all

1016
00:48:42,640 --> 00:48:48,559
you know getting to this key lema right

1017
00:48:46,240 --> 00:48:51,440
um and uh you know one of the key things

1018
00:48:48,559 --> 00:48:54,880
we had was this claim that without los

1019
00:48:51,440 --> 00:48:57,119
generality in the optimal tree B and D

1020
00:48:54,880 --> 00:48:59,040
the symbols with the smallest and second

1021
00:48:57,119 --> 00:49:01,280
smallest probability

1022
00:48:59,040 --> 00:49:04,079
are siblings.

1023
00:49:01,280 --> 00:49:06,720
Where in the proof of this uh or in the

1024
00:49:04,079 --> 00:49:09,720
setup of this lema 3 did I use this

1025
00:49:06,720 --> 00:49:09,720
claim?

1026
00:49:12,480 --> 00:49:18,559
>> Yeah, they have to be siblings in order

1027
00:49:14,960 --> 00:49:21,119
for you to like remove B and D and

1028
00:49:18,559 --> 00:49:23,680
>> that's exactly right because I used it

1029
00:49:21,119 --> 00:49:26,640
even in the setup the definition. So how

1030
00:49:23,680 --> 00:49:29,839
did I define T prime? T prime was what I

1031
00:49:26,640 --> 00:49:31,760
got from taking an optimal tree T and

1032
00:49:29,839 --> 00:49:34,079
then taking the symbols with the

1033
00:49:31,760 --> 00:49:36,880
smallest and second smallest probability

1034
00:49:34,079 --> 00:49:39,599
and replacing them with alpha.

1035
00:49:36,880 --> 00:49:41,200
And in the tree, the only way that that

1036
00:49:39,599 --> 00:49:44,319
can make sense is if they're actually

1037
00:49:41,200 --> 00:49:47,119
siblings of each other. So I invoked

1038
00:49:44,319 --> 00:49:50,240
this claim implicitly when I said that

1039
00:49:47,119 --> 00:49:53,520
let T be an optimal tree without loss

1040
00:49:50,240 --> 00:49:55,680
generality. The two symbols B and D are

1041
00:49:53,520 --> 00:49:58,400
siblings of each other. And then this

1042
00:49:55,680 --> 00:50:00,640
operation makes sense, this contraction

1043
00:49:58,400 --> 00:50:03,200
operation where I replaced B and D with

1044
00:50:00,640 --> 00:50:05,040
the new symbol alpha. And that was what

1045
00:50:03,200 --> 00:50:07,359
allowed me to proceed with this proof,

1046
00:50:05,040 --> 00:50:10,079
right? Because once I had that that

1047
00:50:07,359 --> 00:50:13,280
operation made sense, the key point was

1048
00:50:10,079 --> 00:50:16,079
exactly as you said that if this new uh

1049
00:50:13,280 --> 00:50:18,079
tree t prime weren't optimal, then I

1050
00:50:16,079 --> 00:50:20,559
could do better by inverting my

1051
00:50:18,079 --> 00:50:22,079
operation, calculating the expected

1052
00:50:20,559 --> 00:50:24,800
length, and that would contradict the

1053
00:50:22,079 --> 00:50:27,040
optimality of t. Okay.

1054
00:50:24,800 --> 00:50:32,000
So now are we all on the same page?

1055
00:50:27,040 --> 00:50:33,200
We're good. Happy. Okay. All right. So,

1056
00:50:32,000 --> 00:50:34,800
uh, this is, you know, when you're

1057
00:50:33,200 --> 00:50:36,720
trying to learn things yourself, I think

1058
00:50:34,800 --> 00:50:39,520
this is a good way to try and do it

1059
00:50:36,720 --> 00:50:42,079
because you should stress test yourself.

1060
00:50:39,520 --> 00:50:44,240
All right. So, but I claim that now

1061
00:50:42,079 --> 00:50:46,640
we're basically done. So, we're going to

1062
00:50:44,240 --> 00:50:48,160
have, you know, Huffman's main result

1063
00:50:46,640 --> 00:50:50,559
because it'll just be a lot of pretty

1064
00:50:48,160 --> 00:50:54,680
pictures.

1065
00:50:50,559 --> 00:50:54,680
So, let's do the pretty pictures.

1066
00:50:58,960 --> 00:51:02,240
And don't fear, I still have more

1067
00:51:00,640 --> 00:51:05,240
questions for the audience as we do

1068
00:51:02,240 --> 00:51:05,240
this.

1069
00:51:07,280 --> 00:51:12,640
So let's just keep track of applying

1070
00:51:09,359 --> 00:51:15,520
this lema again and again, right? What I

1071
00:51:12,640 --> 00:51:17,440
know is that when I replace the symbols

1072
00:51:15,520 --> 00:51:20,559
with the smallest and second smallest

1073
00:51:17,440 --> 00:51:23,200
probabilities with a new symbol, I know

1074
00:51:20,559 --> 00:51:25,119
that you know my finding the optimal

1075
00:51:23,200 --> 00:51:28,079
solution to that problem will help me

1076
00:51:25,119 --> 00:51:30,160
solve my original problem. So let's just

1077
00:51:28,079 --> 00:51:32,640
track it through and figure out you know

1078
00:51:30,160 --> 00:51:35,440
what happens to our original problem. So

1079
00:51:32,640 --> 00:51:39,680
our original problem that we cared about

1080
00:51:35,440 --> 00:51:41,200
was just you know we have A B C D E and

1081
00:51:39,680 --> 00:51:44,559
F

1082
00:51:41,200 --> 00:51:46,240
and they had associated probabilities

1083
00:51:44,559 --> 00:51:48,559
0.4

1084
00:51:46,240 --> 00:51:50,559
0.05

1085
00:51:48,559 --> 00:51:52,480
0.18

1086
00:51:50,559 --> 00:51:55,839
0.07

1087
00:51:52,480 --> 00:51:59,119
0.20 200.10.

1088
00:51:55,839 --> 00:52:01,680
And then what I'm going to do in my next

1089
00:51:59,119 --> 00:52:06,800
problem is I'm going to have symbols A,

1090
00:52:01,680 --> 00:52:09,760
C, B 108, E, F, and alpha. And they're

1091
00:52:06,800 --> 00:52:12,559
associated probabilities. Well, A stays

1092
00:52:09,760 --> 00:52:16,720
the same. We haven't touched it. Ste C

1093
00:52:12,559 --> 00:52:20,559
stays the same. E stays the same. F

1094
00:52:16,720 --> 00:52:22,400
stays the same. and alpha is now 0.12

1095
00:52:20,559 --> 00:52:24,400
because I added up the probabilities of

1096
00:52:22,400 --> 00:52:26,880
B and C.

1097
00:52:24,400 --> 00:52:31,119
What's my next step in this uh

1098
00:52:26,880 --> 00:52:33,440
procedure? Can anyone help me out?

1099
00:52:31,119 --> 00:52:35,119
What should I do?

1100
00:52:33,440 --> 00:52:37,040
I'm trying to reduce my, you know,

1101
00:52:35,119 --> 00:52:39,839
original problem down to smaller

1102
00:52:37,040 --> 00:52:44,079
problems in such a way that I can back

1103
00:52:39,839 --> 00:52:46,160
out what the optimal solution is.

1104
00:52:44,079 --> 00:52:50,839
What should I do now? I've got this new

1105
00:52:46,160 --> 00:52:50,839
problem here on this alphabet A prime.

1106
00:52:51,839 --> 00:52:54,319
>> Yeah.

1107
00:52:52,400 --> 00:52:56,640
>> Do a similar operation with F and alpha.

1108
00:52:54,319 --> 00:52:59,200
>> F and alpha. That's right. So these

1109
00:52:56,640 --> 00:53:01,839
become the two symbols with the smallest

1110
00:52:59,200 --> 00:53:04,000
and second smallest probability. And I

1111
00:53:01,839 --> 00:53:09,760
can replace them with a new symbol beta.

1112
00:53:04,000 --> 00:53:14,040
So I get a C, E, and beta. And now their

1113
00:53:09,760 --> 00:53:14,040
associated probabilities are

1114
00:53:15,200 --> 00:53:19,839
Still point4 for a I haven't touched it.

1115
00:53:17,920 --> 00:53:23,280
0.18

1116
00:53:19,839 --> 00:53:25,760
0.2 and 0.22

1117
00:53:23,280 --> 00:53:28,800
and after this my symbols with the

1118
00:53:25,760 --> 00:53:30,240
smallest probabilities are C and E. So

1119
00:53:28,800 --> 00:53:35,599
I'm going to replace them with a new

1120
00:53:30,240 --> 00:53:39,440
symbol gamma. So I have a gamma beta

1121
00:53:35,599 --> 00:53:41,599
and they have associated probability 0.4

1122
00:53:39,440 --> 00:53:45,599
0.38

1123
00:53:41,599 --> 00:53:47,040
0.22 22. And last but not least, I take

1124
00:53:45,599 --> 00:53:49,520
the two ones with the smallest

1125
00:53:47,040 --> 00:53:53,640
probabilities right here and I replace

1126
00:53:49,520 --> 00:53:53,640
them with the new symbol delta.

1127
00:53:58,240 --> 00:54:03,800
So what's my optimal prefix code for

1128
00:54:00,800 --> 00:54:03,800
this?

1129
00:54:04,480 --> 00:54:09,760
If I gave you a problem with just an

1130
00:54:06,559 --> 00:54:14,160
alphabet of size two and the two symbols

1131
00:54:09,760 --> 00:54:16,000
had probability 04 and 6,

1132
00:54:14,160 --> 00:54:17,520
you know, my goal is to try and take my

1133
00:54:16,000 --> 00:54:20,480
original problem, which I didn't know

1134
00:54:17,520 --> 00:54:23,280
the optimal solution for, and hopefully

1135
00:54:20,480 --> 00:54:25,920
reduce it to a problem that's so simple

1136
00:54:23,280 --> 00:54:28,640
that I can solve it. So, I'm done

1137
00:54:25,920 --> 00:54:30,880
reducing it. I ran out of board space.

1138
00:54:28,640 --> 00:54:32,480
Um, what's the optimal solution to this

1139
00:54:30,880 --> 00:54:34,640
last problem at the very end of the

1140
00:54:32,480 --> 00:54:37,640
chain? What's my optimal prefix free

1141
00:54:34,640 --> 00:54:37,640
code?

1142
00:54:38,160 --> 00:54:41,520
>> Yeah.

1143
00:54:39,040 --> 00:54:44,000
>> Can you say like just like gamma like

1144
00:54:41,520 --> 00:54:46,319
one and then a 01?

1145
00:54:44,000 --> 00:54:48,319
>> That's right. Perfect.

1146
00:54:46,319 --> 00:54:50,720
Because you know remember what's going

1147
00:54:48,319 --> 00:54:53,359
on these prefix free codes I can think

1148
00:54:50,720 --> 00:54:55,359
about them as binary trees. There's only

1149
00:54:53,359 --> 00:54:59,440
one binary tree I can do on these two

1150
00:54:55,359 --> 00:55:03,839
things. So my optimal code is just this

1151
00:54:59,440 --> 00:55:06,480
guy right here. I have the root and then

1152
00:55:03,839 --> 00:55:08,319
my two symbols get encoded with either a

1153
00:55:06,480 --> 00:55:11,520
zero or one. Doesn't matter which one is

1154
00:55:08,319 --> 00:55:13,760
which. Right? And now for you know the

1155
00:55:11,520 --> 00:55:15,920
question for the audience, right? Okay.

1156
00:55:13,760 --> 00:55:17,920
My goal wasn't to get down to a trivial

1157
00:55:15,920 --> 00:55:19,760
problem that I can solve. You know, if

1158
00:55:17,920 --> 00:55:21,760
we give you on your exam three a

1159
00:55:19,760 --> 00:55:23,119
question like this, you can't just

1160
00:55:21,760 --> 00:55:26,000
replace it with your own favorite

1161
00:55:23,119 --> 00:55:27,760
trivial question and solve it. Um I care

1162
00:55:26,000 --> 00:55:30,480
about the solution to my original

1163
00:55:27,760 --> 00:55:32,319
problem.

1164
00:55:30,480 --> 00:55:33,839
So, how can I try and get the solution

1165
00:55:32,319 --> 00:55:37,280
to my original problem? Maybe let's

1166
00:55:33,839 --> 00:55:40,240
start simple. Uh, what's the optimal

1167
00:55:37,280 --> 00:55:43,119
solution to this problem right here?

1168
00:55:40,240 --> 00:55:46,319
Slightly harder. Uh, there's an alphabet

1169
00:55:43,119 --> 00:55:48,319
of size three. We know what the optimal

1170
00:55:46,319 --> 00:55:50,880
solution is on the associated sub

1171
00:55:48,319 --> 00:55:53,040
problem. So, how can I get my next

1172
00:55:50,880 --> 00:55:55,440
optimal solution? Trying to go the other

1173
00:55:53,040 --> 00:55:59,839
direction

1174
00:55:55,440 --> 00:55:59,839
or what would the optimal solution be?

1175
00:56:02,880 --> 00:56:05,680
Yeah.

1176
00:56:03,280 --> 00:56:07,839
>> Adding a branch off of delta.

1177
00:56:05,680 --> 00:56:10,000
>> That's right. That's right. Because how

1178
00:56:07,839 --> 00:56:12,960
do we get delta? It was merging gamma

1179
00:56:10,000 --> 00:56:14,960
and beta. What we did was we invoked the

1180
00:56:12,960 --> 00:56:17,280
claim that says that the optimal tree

1181
00:56:14,960 --> 00:56:19,200
for this had better have the symbol with

1182
00:56:17,280 --> 00:56:22,880
the smallest and second smallest

1183
00:56:19,200 --> 00:56:24,880
probabilities be siblings. And now I can

1184
00:56:22,880 --> 00:56:27,200
undo my operation where I merge them

1185
00:56:24,880 --> 00:56:28,880
together into a new symbol delta. And

1186
00:56:27,200 --> 00:56:31,760
what I'll get is I'll get this new

1187
00:56:28,880 --> 00:56:34,559
binary tree. A stays where it is. It's

1188
00:56:31,760 --> 00:56:37,440
still encoded as zero. But now we get a

1189
00:56:34,559 --> 00:56:39,920
deeper binary tree where I replace delta

1190
00:56:37,440 --> 00:56:42,799
with beta

1191
00:56:39,920 --> 00:56:45,599
and gamma.

1192
00:56:42,799 --> 00:56:48,960
So beta gets mapped to zero z uh one

1193
00:56:45,599 --> 00:56:50,559
zero and gamma gets mapped to one one.

1194
00:56:48,960 --> 00:56:52,079
Right?

1195
00:56:50,559 --> 00:56:53,599
Okay. Just to make sure that we're

1196
00:56:52,079 --> 00:56:56,720
really on the same page. What should I

1197
00:56:53,599 --> 00:56:59,720
do next? What's my next uh optimal

1198
00:56:56,720 --> 00:56:59,720
solution?

1199
00:57:00,240 --> 00:57:04,319
What should I do?

1200
00:57:02,960 --> 00:57:06,799
>> Yeah, split up.

1201
00:57:04,319 --> 00:57:09,200
>> Split up gamma. Perfect. So now I think

1202
00:57:06,799 --> 00:57:12,319
you guys see how this works, right? So

1203
00:57:09,200 --> 00:57:14,160
my new solution right here would be a is

1204
00:57:12,319 --> 00:57:17,440
over here.

1205
00:57:14,160 --> 00:57:20,640
I still have beta where it was before. I

1206
00:57:17,440 --> 00:57:22,400
split up gamma into

1207
00:57:20,640 --> 00:57:25,040
c

1208
00:57:22,400 --> 00:57:28,000
and e, right?

1209
00:57:25,040 --> 00:57:29,599
And then I go backwards once more. Uh,

1210
00:57:28,000 --> 00:57:33,680
I'm going to run out of space soon. So,

1211
00:57:29,599 --> 00:57:35,359
this will be the last one that I'll do.

1212
00:57:33,680 --> 00:57:38,359
Actually, maybe I'll do one more. That's

1213
00:57:35,359 --> 00:57:38,359
fine.

1214
00:57:45,920 --> 00:57:51,920
And my last one, which I'll need a bit

1215
00:57:47,920 --> 00:57:54,240
of space to draw. Uh,

1216
00:57:51,920 --> 00:57:58,760
okay.

1217
00:57:54,240 --> 00:57:58,760
I guess I'll draw it over here.

1218
00:58:08,640 --> 00:58:14,359
So my last one is this binary tree.

1219
00:58:30,319 --> 00:58:36,319
So this is a valid prefix free encoding,

1220
00:58:32,960 --> 00:58:39,319
right? Um what can I say about this tree

1221
00:58:36,319 --> 00:58:39,319
T?

1222
00:58:39,520 --> 00:58:44,720
It's optimal, right? Why is it optimal?

1223
00:58:42,880 --> 00:58:46,559
I claim that this is an optimal solution

1224
00:58:44,720 --> 00:58:48,799
to the original running example I gave

1225
00:58:46,559 --> 00:58:52,359
you at the beginning of class. Why is

1226
00:58:48,799 --> 00:58:52,359
this tree optimal?

1227
00:58:55,680 --> 00:59:01,359
Because in each step, right, all we did

1228
00:58:58,640 --> 00:59:04,160
was we reasoned about any tree that's

1229
00:59:01,359 --> 00:59:07,200
optimal without loss generality had the

1230
00:59:04,160 --> 00:59:09,440
property that B and D were siblings. And

1231
00:59:07,200 --> 00:59:12,240
then for the new problem on my alphabet

1232
00:59:09,440 --> 00:59:14,799
A prime without loss generality, it had

1233
00:59:12,240 --> 00:59:17,359
the property that you know F and alpha

1234
00:59:14,799 --> 00:59:18,640
were siblings. And for my new sub

1235
00:59:17,359 --> 00:59:21,359
problem, it had the property that

1236
00:59:18,640 --> 00:59:23,760
without loss of generality and so on. So

1237
00:59:21,359 --> 00:59:26,799
in fact we argued in each step that

1238
00:59:23,760 --> 00:59:29,520
without loss generality our optimal tree

1239
00:59:26,799 --> 00:59:31,359
could take this form. Now there could be

1240
00:59:29,520 --> 00:59:34,240
other ways of doing it because I could

1241
00:59:31,359 --> 00:59:35,760
swap f and c together. But we argued

1242
00:59:34,240 --> 00:59:37,280
that whatever we get out of this

1243
00:59:35,760 --> 00:59:39,599
procedure had actually better be

1244
00:59:37,280 --> 00:59:42,799
optimal. So this was you know huffman

1245
00:59:39,599 --> 00:59:44,799
coding. Um in fact we're not done.

1246
00:59:42,799 --> 00:59:48,240
There's one more crucial question that

1247
00:59:44,799 --> 00:59:50,079
we want to ask and answer about it. But

1248
00:59:48,240 --> 00:59:52,400
right now what we did was we gave you a

1249
00:59:50,079 --> 00:59:55,599
simple greedy algorithm that finds the

1250
00:59:52,400 --> 00:59:57,520
optimal prefix free code. It's not like

1251
00:59:55,599 --> 00:59:59,520
Shannon where I say it's approximately

1252
00:59:57,520 --> 01:00:02,319
optimal up to some additive terms. It is

1253
00:59:59,520 --> 01:00:04,640
the optimal prefix free code. But

1254
01:00:02,319 --> 01:00:07,680
there's one more crucial question which

1255
01:00:04,640 --> 01:00:10,000
is you know how good is this code right?

1256
01:00:07,680 --> 01:00:12,559
So when we talked about Shannon you know

1257
01:00:10,000 --> 01:00:14,480
I have it conveniently up here. It's not

1258
01:00:12,559 --> 01:00:17,200
just that you know we argue that there's

1259
01:00:14,480 --> 01:00:19,440
a coding function and we constructed it.

1260
01:00:17,200 --> 01:00:22,160
it's that we actually argued about how

1261
01:00:19,440 --> 01:00:24,720
good it is. We bounded its performance

1262
01:00:22,160 --> 01:00:27,599
and we saw that the binary entropy fell

1263
01:00:24,720 --> 01:00:29,839
out from the end of that. Right? So our

1264
01:00:27,599 --> 01:00:33,280
last step is to bound the performance of

1265
01:00:29,839 --> 01:00:36,240
the Huffman code and show that it's very

1266
01:00:33,280 --> 01:00:38,799
good. In fact, it'll really beat what we

1267
01:00:36,240 --> 01:00:42,960
proved in Shannon last time. So that's

1268
01:00:38,799 --> 01:00:46,880
the last part of today's lecture.

1269
01:00:42,960 --> 01:00:48,880
So let me state one helper lema which um

1270
01:00:46,880 --> 01:00:50,720
you're going to

1271
01:00:48,880 --> 01:00:53,040
give an alternative proof for in

1272
01:00:50,720 --> 01:00:56,000
recitation and talk about you know what

1273
01:00:53,040 --> 01:00:57,440
are figures to illustrate this proof.

1274
01:00:56,000 --> 01:00:59,119
This proof is called the craft

1275
01:00:57,440 --> 01:01:02,000
inequality and once we have this craft

1276
01:00:59,119 --> 01:01:04,160
inequality we'll be able to get a very

1277
01:01:02,000 --> 01:01:07,160
nice bound on the performance of Huffman

1278
01:01:04,160 --> 01:01:07,160
codes.

1279
01:01:07,359 --> 01:01:12,440
So this is a purely cominatorial lama

1280
01:01:18,400 --> 01:01:27,200
and it's called the craft inequality.

1281
01:01:22,640 --> 01:01:31,359
So what I claim is that for any

1282
01:01:27,200 --> 01:01:33,680
natural numbers L1 L2

1283
01:01:31,359 --> 01:01:36,559
all the way up to LK. So of course

1284
01:01:33,680 --> 01:01:38,720
natural numbers just means uh non-

1285
01:01:36,559 --> 01:01:43,280
negative integers. So any non- negative

1286
01:01:38,720 --> 01:01:47,079
integers. I claim that there is

1287
01:01:43,280 --> 01:01:47,079
a binary tree

1288
01:01:49,520 --> 01:01:53,319
with leaves

1289
01:01:53,440 --> 01:02:02,160
at depths given by these values. So at

1290
01:01:57,599 --> 01:02:04,319
depths L1, L2 all the way up to LK.

1291
01:02:02,160 --> 01:02:10,640
If and only if the following condition

1292
01:02:04,319 --> 01:02:14,960
holds, the sum of i = 1 to k of 2 the

1293
01:02:10,640 --> 01:02:17,200
minus l i is at most one. Okay, so this

1294
01:02:14,960 --> 01:02:19,680
is a little bit of a mouthful. So what

1295
01:02:17,200 --> 01:02:22,240
I'm asking you is some sort of packing

1296
01:02:19,680 --> 01:02:25,040
constraint. Obviously, you can't have

1297
01:02:22,240 --> 01:02:27,599
three leaves at depth 2 because it's a

1298
01:02:25,040 --> 01:02:29,440
binary tree, right?

1299
01:02:27,599 --> 01:02:31,200
And what this craft inequality tells you

1300
01:02:29,440 --> 01:02:33,760
is it tells you a necessary and

1301
01:02:31,200 --> 01:02:35,760
sufficient condition if you give me the

1302
01:02:33,760 --> 01:02:38,720
sequence of depths whether or not there

1303
01:02:35,760 --> 01:02:40,960
is a tree you know with leaves at those

1304
01:02:38,720 --> 01:02:43,440
depths.

1305
01:02:40,960 --> 01:02:45,680
So you know let's do a simple example

1306
01:02:43,440 --> 01:02:48,920
just to make sure that uh we're on the

1307
01:02:45,680 --> 01:02:48,920
same page.

1308
01:02:55,359 --> 01:03:00,319
So let's start off with some depths of

1309
01:02:57,760 --> 01:03:03,359
the leaves

1310
01:03:00,319 --> 01:03:11,040
that satisfy the craft inequality.

1311
01:03:03,359 --> 01:03:12,799
Let's say L1= 2, L2= 3, L3= 3. You can

1312
01:03:11,040 --> 01:03:16,240
check when you add up the craft

1313
01:03:12,799 --> 01:03:18,880
inequality that uh you know you're good,

1314
01:03:16,240 --> 01:03:22,319
right?

1315
01:03:18,880 --> 01:03:25,920
Actually, sorry, this should be uh depth

1316
01:03:22,319 --> 01:03:30,000
one, two, two. Okay,

1317
01:03:25,920 --> 01:03:32,480
depth one, two, two. Okay.

1318
01:03:30,000 --> 01:03:36,400
And so what would be the associated tree

1319
01:03:32,480 --> 01:03:39,039
here? Well, you know, here's one example

1320
01:03:36,400 --> 01:03:41,039
of a binary tree that satisfies these

1321
01:03:39,039 --> 01:03:42,720
conditions as promised by craft

1322
01:03:41,039 --> 01:03:45,520
inequality.

1323
01:03:42,720 --> 01:03:48,079
So I take this associated binary tree.

1324
01:03:45,520 --> 01:03:49,920
It has one leaf of depth one because

1325
01:03:48,079 --> 01:03:54,640
we're going down distance one from the

1326
01:03:49,920 --> 01:03:58,000
root. It has uh one leaf of depth two

1327
01:03:54,640 --> 01:03:59,760
and its third leaf is also of depth two.

1328
01:03:58,000 --> 01:04:01,599
And you can check that you know a half

1329
01:03:59,760 --> 01:04:03,599
plus a quarter plus a quarter is less

1330
01:04:01,599 --> 01:04:05,839
than or equal to one. So this is an

1331
01:04:03,599 --> 01:04:08,720
example which both satisfies this craft

1332
01:04:05,839 --> 01:04:10,240
condition and has an associated binary

1333
01:04:08,720 --> 01:04:12,880
tree.

1334
01:04:10,240 --> 01:04:16,160
So this is just one illustration. But

1335
01:04:12,880 --> 01:04:21,039
what if instead I take you know L3 and

1336
01:04:16,160 --> 01:04:23,039
replace it by L3 is equal to

1337
01:04:21,039 --> 01:04:26,000
uh

1338
01:04:23,039 --> 01:04:29,839
let's see three

1339
01:04:26,000 --> 01:04:32,319
and L4 is equal to three. This still

1340
01:04:29,839 --> 01:04:34,960
satisfies the craft inequality. What

1341
01:04:32,319 --> 01:04:39,200
would I do is I would just replace this

1342
01:04:34,960 --> 01:04:42,079
part with a deeper binary tree with A3

1343
01:04:39,200 --> 01:04:44,000
here and A4 here.

1344
01:04:42,079 --> 01:04:45,520
So the proof for the craft inequality

1345
01:04:44,000 --> 01:04:48,400
essentially goes, you know, the way

1346
01:04:45,520 --> 01:04:52,119
you'd expect it to is you just build up

1347
01:04:48,400 --> 01:04:52,119
a binary tree.

1348
01:05:04,720 --> 01:05:09,039
The key point is that, you know, if I

1349
01:05:06,480 --> 01:05:12,400
had all of the same lengths, right? like

1350
01:05:09,039 --> 01:05:15,520
I had L1 equals 1 and L2 equals 1 then

1351
01:05:12,400 --> 01:05:17,440
it's just you know a regular binary tree

1352
01:05:15,520 --> 01:05:19,200
and every time what's going on is that

1353
01:05:17,440 --> 01:05:22,079
you know when I have larger depths it

1354
01:05:19,200 --> 01:05:24,640
really corresponds to replacing the leaf

1355
01:05:22,079 --> 01:05:27,119
with uh some deeper binary tree exactly

1356
01:05:24,640 --> 01:05:29,280
as I did in this example. So you're

1357
01:05:27,119 --> 01:05:30,960
going to prove this in recitation. So

1358
01:05:29,280 --> 01:05:33,039
I'll just leave the proof as to be

1359
01:05:30,960 --> 01:05:35,359
continued. You're going to work on both

1360
01:05:33,039 --> 01:05:37,359
understanding the proof of this and

1361
01:05:35,359 --> 01:05:39,200
drawing diagrams to illustrate the

1362
01:05:37,359 --> 01:05:41,280
proof. But for us, we're going to take

1363
01:05:39,200 --> 01:05:43,599
this for granted and we're going to

1364
01:05:41,280 --> 01:05:46,240
prove our main theorem about Huffman

1365
01:05:43,599 --> 01:05:47,760
codes, which is, you know, not just that

1366
01:05:46,240 --> 01:05:50,160
there's an algorithm for building

1367
01:05:47,760 --> 01:05:51,760
Huffman codes, but we're going to give a

1368
01:05:50,160 --> 01:05:53,440
bound on their performance, and we're

1369
01:05:51,760 --> 01:05:56,559
going to relate it back to what we

1370
01:05:53,440 --> 01:06:00,119
proved on Thursday,

1371
01:05:56,559 --> 01:06:00,119
uh, using Shannon.

1372
01:06:00,319 --> 01:06:03,839
So, here's our last statement for today

1373
01:06:02,319 --> 01:06:07,200
that we're going to prove, and we're

1374
01:06:03,839 --> 01:06:13,160
going to build on this craft inequality.

1375
01:06:07,200 --> 01:06:13,160
What I claim is that the Huffman code

1376
01:06:16,799 --> 01:06:21,400
has expected length

1377
01:06:24,720 --> 01:06:33,440
L

1378
01:06:27,200 --> 01:06:35,280
which is between H and H + one.

1379
01:06:33,440 --> 01:06:37,760
So this is an incredibly strong

1380
01:06:35,280 --> 01:06:40,319
statement because I'm saying that you

1381
01:06:37,760 --> 01:06:42,319
know the binary entropy really tightly

1382
01:06:40,319 --> 01:06:45,520
controls what the expected length of our

1383
01:06:42,319 --> 01:06:48,319
optimal prefix free code is. I'm not

1384
01:06:45,520 --> 01:06:50,720
going to prove this part. This part in

1385
01:06:48,319 --> 01:06:52,400
effect we already proved through Shannon

1386
01:06:50,720 --> 01:06:54,880
but I'll argue about why we already

1387
01:06:52,400 --> 01:06:57,839
proved that. Let's prove the other side

1388
01:06:54,880 --> 01:07:00,839
that the Huffman code is good.

1389
01:06:57,839 --> 01:07:00,839
Okay,

1390
01:07:03,039 --> 01:07:08,400
so here's our idea.

1391
01:07:06,400 --> 01:07:10,480
Let's let

1392
01:07:08,400 --> 01:07:13,599
LA a

1393
01:07:10,480 --> 01:07:16,559
be the length of the encoding for symbol

1394
01:07:13,599 --> 01:07:19,039
A. And we're going to, you know, uh,

1395
01:07:16,559 --> 01:07:23,760
very cleverly choose it to be the

1396
01:07:19,039 --> 01:07:25,760
ceiling of log of PA. Okay. So what's

1397
01:07:23,760 --> 01:07:28,079
going on here is that the depths of my

1398
01:07:25,760 --> 01:07:31,119
leaves had better be, you know, natural

1399
01:07:28,079 --> 01:07:33,440
numbers. They're non- negative integers.

1400
01:07:31,119 --> 01:07:36,559
And you know, PA is the associated

1401
01:07:33,440 --> 01:07:38,240
probability of the symbol A, right? So I

1402
01:07:36,559 --> 01:07:40,079
take log of PA, I'm going to get a

1403
01:07:38,240 --> 01:07:42,000
negative number. I multiply it by minus

1404
01:07:40,079 --> 01:07:43,440
one, I'm going to get a positive number.

1405
01:07:42,000 --> 01:07:45,359
And I'm just going to round up that

1406
01:07:43,440 --> 01:07:47,839
number.

1407
01:07:45,359 --> 01:07:50,559
And those are going to be my depths LA,

1408
01:07:47,839 --> 01:07:53,440
right? And so the first thing I have to

1409
01:07:50,559 --> 01:07:55,680
argue about is you know that these are

1410
01:07:53,440 --> 01:07:57,760
valid depths for the leaves because

1411
01:07:55,680 --> 01:08:00,559
that's where I want to put each of these

1412
01:07:57,760 --> 01:08:02,720
symbols. So how do I argue that these

1413
01:08:00,559 --> 01:08:05,359
are valid depths is I appeal to the

1414
01:08:02,720 --> 01:08:07,680
craft inequality. So the craft

1415
01:08:05,359 --> 01:08:10,880
inequality tells me I just have to check

1416
01:08:07,680 --> 01:08:13,880
a particular inequality. So let's verify

1417
01:08:10,880 --> 01:08:13,880
craft

1418
01:08:15,599 --> 01:08:20,960
that the conditions of craft inequality

1419
01:08:17,520 --> 01:08:24,480
hold. So I want that the sum over all

1420
01:08:20,960 --> 01:08:27,520
symbols in my alphabet of 2 the minus la

1421
01:08:24,480 --> 01:08:30,080
I want to show that this is at most one.

1422
01:08:27,520 --> 01:08:32,719
Right? So let's write out what this

1423
01:08:30,080 --> 01:08:35,040
thing is. Well, by definition, the way

1424
01:08:32,719 --> 01:08:38,000
we've constructed LA, this is still the

1425
01:08:35,040 --> 01:08:44,000
sum over all symbols in our alphabet of

1426
01:08:38,000 --> 01:08:46,719
2 to the minus ceiling of minus log PA.

1427
01:08:44,000 --> 01:08:49,120
And I claim that this is upper bounded

1428
01:08:46,719 --> 01:08:54,799
by the sum over all the symbols in our

1429
01:08:49,120 --> 01:08:57,279
alphabet of 2 to the log PA.

1430
01:08:54,799 --> 01:09:00,159
So what's going on here, right, is that

1431
01:08:57,279 --> 01:09:02,799
remember inside I have a positive number

1432
01:09:00,159 --> 01:09:06,159
because it's minus log PA. Log PA is

1433
01:09:02,799 --> 01:09:08,159
negative. So when I'm rounding it up and

1434
01:09:06,159 --> 01:09:11,040
then I'm multiplying by minus one, I'm

1435
01:09:08,159 --> 01:09:13,199
making this associated number smaller.

1436
01:09:11,040 --> 01:09:15,679
So I can make the number only bigger by

1437
01:09:13,199 --> 01:09:17,199
removing the ceiling function. When I

1438
01:09:15,679 --> 01:09:20,719
remove the ceiling function, the two

1439
01:09:17,199 --> 01:09:22,880
minuses cancel and I get log PA. And now

1440
01:09:20,719 --> 01:09:25,839
two to the log PA is very simple. It's

1441
01:09:22,880 --> 01:09:28,560
just PA. So I get sum over all of the

1442
01:09:25,839 --> 01:09:31,920
symbols in my alphabet of PA which is

1443
01:09:28,560 --> 01:09:35,120
one. So this verifies the craft

1444
01:09:31,920 --> 01:09:39,000
inequality because all of these lengths

1445
01:09:35,120 --> 01:09:39,000
LA that I've conveniently

1446
01:09:45,040 --> 01:09:50,960
part I have to do is I just have to

1447
01:09:46,560 --> 01:09:53,759
analyze how good this particular uh you

1448
01:09:50,960 --> 01:09:56,960
know construction is and then because

1449
01:09:53,759 --> 01:09:59,360
the Huffman code is optimal it'll only

1450
01:09:56,960 --> 01:10:02,800
ever be better than whatever I get for

1451
01:09:59,360 --> 01:10:06,520
this particular code that follows by

1452
01:10:02,800 --> 01:10:06,520
appealing to craft.

1453
01:10:09,679 --> 01:10:15,400
So now let's calculate the performance

1454
01:10:12,000 --> 01:10:15,400
of the code.

1455
01:10:15,520 --> 01:10:26,199
So we know you know by lema 4

1456
01:10:20,880 --> 01:10:26,199
we know that there is a binary tree

1457
01:10:27,040 --> 01:10:32,320
with these depths the depths that I've

1458
01:10:29,360 --> 01:10:34,960
guessed

1459
01:10:32,320 --> 01:10:37,520
and let's calculate its expected length.

1460
01:10:34,960 --> 01:10:40,560
Right? So, I know that L, the expected

1461
01:10:37,520 --> 01:10:42,719
length of my Huffman code, is only ever

1462
01:10:40,560 --> 01:10:44,239
better than whatever expected length I'm

1463
01:10:42,719 --> 01:10:46,400
going to get for this tree that I'm

1464
01:10:44,239 --> 01:10:48,880
guessing from Craft.

1465
01:10:46,400 --> 01:10:52,880
And this right here is the sum over all

1466
01:10:48,880 --> 01:10:55,600
symbols in my alphabet of PA time LA,

1467
01:10:52,880 --> 01:10:57,920
the length of the associated symbol.

1468
01:10:55,600 --> 01:11:00,480
Well, I can replace this again. This is

1469
01:10:57,920 --> 01:11:06,719
the sum over all symbols in my alphabet

1470
01:11:00,480 --> 01:11:08,480
of PA times the ceiling of minus log PA.

1471
01:11:06,719 --> 01:11:10,400
And now I claim that this is upper

1472
01:11:08,480 --> 01:11:12,400
bounded just by adding one instead of

1473
01:11:10,400 --> 01:11:15,120
taking the ceiling, right? Because at

1474
01:11:12,400 --> 01:11:17,600
most I bump it up by one. So this is the

1475
01:11:15,120 --> 01:11:24,080
sum over all symbols in my alphabet of

1476
01:11:17,600 --> 01:11:26,239
PA time minus log PA + 1. But now I'm in

1477
01:11:24,080 --> 01:11:28,080
good shape, right? Because this term

1478
01:11:26,239 --> 01:11:30,560
should look familiar. This is the binary

1479
01:11:28,080 --> 01:11:33,840
entropy and this term right here when

1480
01:11:30,560 --> 01:11:35,520
I'm summing up all the PAS I get one. So

1481
01:11:33,840 --> 01:11:37,920
in total the thing that I get as my

1482
01:11:35,520 --> 01:11:41,840
upper bound is the binary entropy plus

1483
01:11:37,920 --> 01:11:44,400
one. So that's the proof.

1484
01:11:41,840 --> 01:11:47,199
The Huffman code is very very good

1485
01:11:44,400 --> 01:11:49,760
because it's optimal and because there

1486
01:11:47,199 --> 01:11:55,760
exists a good code by the craft

1487
01:11:49,760 --> 01:11:57,920
inequality whose performance is H+ one.

1488
01:11:55,760 --> 01:11:59,600
Now in the last couple minutes I want to

1489
01:11:57,920 --> 01:12:02,400
take this way further and connect it

1490
01:11:59,600 --> 01:12:04,320
back to Shannon. So you know we proved a

1491
01:12:02,400 --> 01:12:06,640
bunch of things. We proved you know that

1492
01:12:04,320 --> 01:12:08,800
we found an algorithm Huffman's uh

1493
01:12:06,640 --> 01:12:11,440
coding algorithm for finding the optimal

1494
01:12:08,800 --> 01:12:13,120
prefix free code. We analyzed its

1495
01:12:11,440 --> 01:12:16,080
performance in terms of its expected

1496
01:12:13,120 --> 01:12:18,560
length. But now what I want to argue

1497
01:12:16,080 --> 01:12:21,920
about is you know how we can do much

1498
01:12:18,560 --> 01:12:25,040
better than Shannon. Right? So we talked

1499
01:12:21,920 --> 01:12:27,679
about you know how Shannon I think I

1500
01:12:25,040 --> 01:12:29,679
still have it here.

1501
01:12:27,679 --> 01:12:32,320
It gets a bound you know when you apply

1502
01:12:29,679 --> 01:12:35,120
it to length n sequences instead of a

1503
01:12:32,320 --> 01:12:38,560
single length you know single symbol it

1504
01:12:35,120 --> 01:12:41,920
gets n * entropy plus some other term.

1505
01:12:38,560 --> 01:12:44,320
So if I naively use my Huffman code,

1506
01:12:41,920 --> 01:12:47,120
it'll sound like I'll get, you know, n

1507
01:12:44,320 --> 01:12:50,880
times entropy plus n because I'm paying

1508
01:12:47,120 --> 01:12:52,560
that plus one every time, right? But

1509
01:12:50,880 --> 01:12:54,880
there's a trick where we can replace

1510
01:12:52,560 --> 01:12:58,040
that. So that's the last thing I want to

1511
01:12:54,880 --> 01:12:58,040
show you.

1512
01:13:03,040 --> 01:13:07,480
And this is one of the really cool

1513
01:13:04,480 --> 01:13:07,480
punchlines.

1514
01:13:07,760 --> 01:13:11,440
So let's imagine you know and then the

1515
01:13:09,679 --> 01:13:14,159
length end case will follow immediately

1516
01:13:11,440 --> 01:13:19,560
from this. What if we want to encode

1517
01:13:14,159 --> 01:13:19,560
outputs of length two okay?

1518
01:13:27,199 --> 01:13:34,280
So what if our source outputs two

1519
01:13:30,320 --> 01:13:34,280
symbols instead?

1520
01:13:34,480 --> 01:13:41,120
Well, we can still think about them

1521
01:13:38,239 --> 01:13:42,960
as a single symbol just on a larger

1522
01:13:41,120 --> 01:13:44,640
alphabet,

1523
01:13:42,960 --> 01:13:47,440
right?

1524
01:13:44,640 --> 01:13:50,960
Because originally we had, you know, six

1525
01:13:47,440 --> 01:13:53,040
symbols, but now we'll have 36 in our

1526
01:13:50,960 --> 01:13:55,360
alphabet. Each of these pairs of

1527
01:13:53,040 --> 01:14:00,400
characters is a new symbol in my

1528
01:13:55,360 --> 01:14:03,440
alphabet. A AB acce

1529
01:14:00,400 --> 01:14:05,280
has a larger value for K.

1530
01:14:03,440 --> 01:14:10,920
What I can do is I can compute the

1531
01:14:05,280 --> 01:14:10,920
entropy, right? So what's the entropy

1532
01:14:11,199 --> 01:14:17,920
of this source?

1533
01:14:14,400 --> 01:14:20,880
Well, you know, now it's minus the sum

1534
01:14:17,920 --> 01:14:23,760
over all I, the sum over all J because

1535
01:14:20,880 --> 01:14:25,679
I'm taking two symbols I and J. the

1536
01:14:23,760 --> 01:14:27,120
probability that our first symbol is I,

1537
01:14:25,679 --> 01:14:33,199
the probability that our second symbol

1538
01:14:27,120 --> 01:14:36,000
is J times log of PI PJ.

1539
01:14:33,199 --> 01:14:38,080
But now something amazing happens which

1540
01:14:36,000 --> 01:14:41,600
is that I can just algebraically

1541
01:14:38,080 --> 01:14:46,320
manipulate this statement. I'll get

1542
01:14:41,600 --> 01:14:51,280
minus the sum over i the sum over j of p

1543
01:14:46,320 --> 01:14:56,880
i pj log pi

1544
01:14:51,280 --> 01:14:59,520
plus p i pj log pj. This is just using

1545
01:14:56,880 --> 01:15:02,640
properties of the log.

1546
01:14:59,520 --> 01:15:04,719
And now look at this term right here.

1547
01:15:02,640 --> 01:15:07,679
I can sum up over j and then I can

1548
01:15:04,719 --> 01:15:10,400
replace the pj with one because the pj

1549
01:15:07,679 --> 01:15:13,600
sum to one. So I'll get the sum over i

1550
01:15:10,400 --> 01:15:15,840
of pi log pi. And the same way here I

1551
01:15:13,600 --> 01:15:18,239
can sum up over i because i doesn't

1552
01:15:15,840 --> 01:15:21,600
appear inside the log. So I can replace

1553
01:15:18,239 --> 01:15:24,000
this pi with one and get rid of the sum.

1554
01:15:21,600 --> 01:15:29,840
So this entire thing is then equal to

1555
01:15:24,000 --> 01:15:35,040
minus the sum over i of pi log pi minus

1556
01:15:29,840 --> 01:15:39,040
the sum over j pj log pj.

1557
01:15:35,040 --> 01:15:40,640
All this is is two times the entropy,

1558
01:15:39,040 --> 01:15:42,320
right?

1559
01:15:40,640 --> 01:15:44,880
It's two times the entropy because each

1560
01:15:42,320 --> 01:15:46,719
of these terms is computing the entropy.

1561
01:15:44,880 --> 01:15:49,840
So this is one of the amazing facts

1562
01:15:46,719 --> 01:15:52,159
about entropy is that you know when you

1563
01:15:49,840 --> 01:15:54,640
look at the entropy of the output at

1564
01:15:52,159 --> 01:15:56,800
length two, it's just twice the entropy

1565
01:15:54,640 --> 01:16:00,000
of the per symbol entropy that you

1566
01:15:56,800 --> 01:16:01,760
started with H. Right? And now something

1567
01:16:00,000 --> 01:16:04,400
amazing happens which is if I think

1568
01:16:01,760 --> 01:16:07,120
about this theorem, right? And instead

1569
01:16:04,400 --> 01:16:09,360
of encoding my output for my channel

1570
01:16:07,120 --> 01:16:11,280
symbol by symbol,

1571
01:16:09,360 --> 01:16:14,239
what if I encode it, you know, as a

1572
01:16:11,280 --> 01:16:16,800
pair. So instead when I look at, you

1573
01:16:14,239 --> 01:16:20,159
know, the output as being two symbols,

1574
01:16:16,800 --> 01:16:22,000
you know, my new entropy is 2 h, right?

1575
01:16:20,159 --> 01:16:26,560
So I'll have that my expected length is

1576
01:16:22,000 --> 01:16:28,640
at most 2 h but still plus one.

1577
01:16:26,560 --> 01:16:32,480
When I do it for an output that's size

1578
01:16:28,640 --> 01:16:34,320
n, it'll be n * h, but still + one. that

1579
01:16:32,480 --> 01:16:36,400
plus one is just a fixed thing that we

1580
01:16:34,320 --> 01:16:39,199
add independently of how large our

1581
01:16:36,400 --> 01:16:42,400
alphabet is. So this result that we had

1582
01:16:39,199 --> 01:16:44,880
from Shannon where there was a you know

1583
01:16:42,400 --> 01:16:47,120
bound and the suboptimality that's some

1584
01:16:44,880 --> 01:16:49,440
little o of n that's like n over log n

1585
01:16:47,120 --> 01:16:52,320
or root n it turns out that we can

1586
01:16:49,440 --> 01:16:54,239
replace this with plus one.

1587
01:16:52,320 --> 01:16:55,920
So this is an amazingly sharp thing that

1588
01:16:54,239 --> 01:16:58,719
follows immediately from our proof of

1589
01:16:55,920 --> 01:17:00,960
Huffman codes. So we improved upon two

1590
01:16:58,719 --> 01:17:02,960
things here. First of all, we have a

1591
01:17:00,960 --> 01:17:05,199
more explicit coding function because it

1592
01:17:02,960 --> 01:17:06,880
follows just from this greedy algorithm.

1593
01:17:05,199 --> 01:17:08,800
And second of all, we drastically

1594
01:17:06,880 --> 01:17:11,600
improve this additive loss in our

1595
01:17:08,800 --> 01:17:13,760
original bound. So, you know, Huffman is

1596
01:17:11,600 --> 01:17:16,880
really um one of the crown jewels in

1597
01:17:13,760 --> 01:17:18,480
coding theory. And it was proven really

1598
01:17:16,880 --> 01:17:20,000
uh by a grad student, which is pretty

1599
01:17:18,480 --> 01:17:22,960
amazing, who wanted to get out of taking

1600
01:17:20,000 --> 01:17:25,840
a final exam. So, with that, I'll leave

1601
01:17:22,960 --> 01:17:28,960
you as an invitation. If you also want

1602
01:17:25,840 --> 01:17:30,400
to get out of your exam three, just

1603
01:17:28,960 --> 01:17:32,400
prove something else that we're going to

1604
01:17:30,400 --> 01:17:33,920
teach in lecture next semester and I

1605
01:17:32,400 --> 01:17:36,560
will happily give you an A for the

1606
01:17:33,920 --> 01:17:39,600
class. If not, come to office hours and

1607
01:17:36,560 --> 01:17:41,840
we'll help you study. All right. Um, so

1608
01:17:39,600 --> 01:17:43,920
we'll continue next time with Shannon's

1609
01:17:41,840 --> 01:17:45,440
noisy coding theorem. That'll probably

1610
01:17:43,920 --> 01:17:48,000
be the hardest lecture in the coding

1611
01:17:45,440 --> 01:17:50,080
theory unit. Uh, but you know, come

1612
01:17:48,000 --> 01:17:53,880
prepared, be awake, and ready to answer

1613
01:17:50,080 --> 01:17:53,880
questions. See you then.

