#!/usr/bin/env node
/**
 * MIT Persons Enricher (for enrich.sh pipeline)
 * 
 * Enriches MIT person records with AI-generated content.
 * Similar to preEnrich.js for events, but for MIT persons.
 * 
 * Generates:
 * - expertise (detailed description from research areas)
 * - biography (if missing)
 * - industries (relevant industries)
 * - techThemes (technology themes)
 * - ilpAudiences (target corporate audiences)
 * 
 * Note: ilpSummary and ilpKeywords are still generated by enrichIlpFields.js
 * 
 * Environment Variables:
 *   MIT_BRAIN - Brain filename (without extension)
 *   OUTPUT_DIR - Output directory
 *   OPENAI_MODEL - Model to use (default: gpt-4o-mini)
 *   MAX_PERSONS - Optional limit (for testing)
 * 
 * Usage:
 *   node enrichers/enrichPersons.js
 *   MAX_PERSONS=10 OPENAI_MODEL=gpt-4o-mini node enrichers/enrichPersons.js
 */

import fs from 'fs/promises';
import path from 'path';
import OpenAI from 'openai';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const MIT_BRAIN = process.env.MIT_BRAIN || 'mit_brain_test17';
const OUTPUT_DIR = process.env.OUTPUT_DIR || 'output';
const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';
const MAX_PERSONS = process.env.MAX_PERSONS ? parseInt(process.env.MAX_PERSONS) : null;

class PersonsEnricher {
  constructor() {
    this.client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.stats = {
      total: 0,
      enriched: 0,
      skipped: 0,
      errors: 0
    };
  }

  /**
   * Main entry point
   */
  async run() {
    console.log('ü§ñ Starting MIT Persons Enricher\n');
    console.log(`Model: ${OPENAI_MODEL}`);
    if (MAX_PERSONS) {
      console.log(`Limit: ${MAX_PERSONS} persons`);
    }
    if (process.env.FORCE_REGENERATE_PERSONS === '1') {
      console.log('‚ö†Ô∏è  FORCE_REGENERATE_PERSONS enabled - will re-enrich all persons');
    }
    console.log('');

    try {
      // Check for API key
      if (!process.env.OPENAI_API_KEY) {
        throw new Error('OPENAI_API_KEY environment variable not set');
      }

      // Load brain
      const brain = await this.loadBrain();
      
      // Find MIT persons that need enrichment
      const persons = this.findPersonsToEnrich(brain);
      
      console.log(`Found ${persons.length} MIT persons to enrich\n`);
      
      if (persons.length === 0) {
        console.log('‚úÖ No persons need enrichment\n');
        return 0;
      }

      // Enrich persons
      await this.enrichPersons(persons);

      // Update brain with enriched persons
      this.updateBrain(brain, persons);

      // Save brain
      await this.saveBrain(brain);

      // Print summary
      this.printSummary();

      console.log('\n‚úÖ MIT Persons enrichment complete!\n');
      return 0;

    } catch (error) {
      console.error('\n‚ùå Fatal error:', error.message);
      console.error(error.stack);
      return 1;
    }
  }

  /**
   * Load brain from JSONL
   * (FATAL ERROR if file doesn't exist - enrich.sh requires existing data)
   */
  async loadBrain() {
    const jsonlPath = path.join(OUTPUT_DIR, 'jsonl', `${MIT_BRAIN}.jsonl`);
    
    console.log(`üìÇ Loading brain from ${jsonlPath}...`);
    
    try {
      const content = await fs.readFile(jsonlPath, 'utf8');
      
      // Handle empty file
      if (!content.trim()) {
        throw new Error(`Brain file is empty: ${jsonlPath}\n  Run scrape.sh first to collect data`);
      }
      
      const lines = content.split('\n').filter(line => line.trim());
      const brain = lines.map(line => JSON.parse(line));
      
      console.log(`‚úÖ Loaded ${brain.length} records\n`);
      return brain;
      
    } catch (error) {
      if (error.code === 'ENOENT') {
        // File doesn't exist - FATAL ERROR
        throw new Error(
          `Brain file not found: ${jsonlPath}\n` +
          `  enrich.sh requires existing data from scrape.sh\n` +
          `  Run: bash scrape.sh first`
        );
      } else {
        // Other error - rethrow
        throw error;
      }
    }
  }

  /**
   * Find MIT persons that need enrichment
   */
  findPersonsToEnrich(brain) {
    let persons = brain.filter(item => 
      item.kind === 'mit_person' && 
      this.needsEnrichment(item)
    );

    this.stats.total = persons.length;

    // Apply limit if set
    if (MAX_PERSONS && persons.length > MAX_PERSONS) {
      console.log(`‚ö†Ô∏è  Limiting to ${MAX_PERSONS} persons for testing\n`);
      persons = persons.slice(0, MAX_PERSONS);
    }

    return persons;
  }

  /**
   * Check if person needs enrichment
   */
  needsEnrichment(person) {
    // If force regenerate is enabled, always re-enrich
    if (process.env.FORCE_REGENERATE_PERSONS === '1') {
      return true;
    }
    
    // Otherwise, only enrich if any of these fields are missing
    return !person.expertise || 
           !person.industries || 
           !person.techThemes || 
           !person.ilpAudiences;
  }

  /**
   * Enrich all persons with AI
   */
  async enrichPersons(persons) {
    console.log('üß† Enriching persons with AI...\n');

    for (let i = 0; i < persons.length; i++) {
      const person = persons[i];
      console.log(`[${i + 1}/${persons.length}] ${person.title}`);

      try {
        const enriched = await this.enrichPerson(person);
        
        // Update person object
        Object.assign(person, enriched);
        
        console.log('  ‚úÖ Enriched');
        this.stats.enriched++;

      } catch (error) {
        console.log(`  ‚ùå Error: ${error.message}`);
        this.stats.errors++;
      }

      // Small delay to avoid rate limits
      await this.sleep(100);
    }

    console.log('');
  }

  /**
   * Enrich single person with AI
   */
  async enrichPerson(person) {
    const context = this.buildContext(person);
    
    const prompt = `You are helping MIT's Industrial Liaison Program (ILP) connect corporate members with MIT researchers.

Given this MIT person's information:

${context}

Generate the following in JSON format:

1. **expertise**: A 2-3 sentence description of their expertise and research focus that would be useful for corporate connections. Make it clear and accessible to industry people, not overly academic. (~100-150 words)

2. **industries**: Comma-separated list of industries where this person's research is most relevant (e.g., "Manufacturing, Healthcare, Energy, Automotive")

3. **techThemes**: Comma-separated list of 3-5 technology themes (e.g., "AI/ML, Robotics, Materials Science, Quantum Computing, Biotechnology")

4. **ilpAudiences**: Comma-separated list of corporate roles who would be interested in this person's work (e.g., "CTO, VP Engineering, R&D Leaders, Product Managers")

Notes:
- If they have publications/citations, mention their research impact
- Focus on practical applications and corporate value
- Be specific about industries and themes based on their research areas
- If information is limited, make reasonable inferences from their title and department

Respond ONLY with valid JSON:
{
  "expertise": "...",
  "industries": "...",
  "techThemes": "...",
  "ilpAudiences": "..."
}`;

    try {
      const response = await this.client.chat.completions.create({
        model: OPENAI_MODEL,
        messages: [
          {
            role: 'system',
            content: 'You are an expert at translating academic research into industry-relevant summaries. You respond ONLY with valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 500
      });

      const content = response.choices[0].message.content.trim();
      
      // Remove markdown code fences if present
      const cleanContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      
      // Parse JSON
      const enrichment = JSON.parse(cleanContent);
      
      return enrichment;

    } catch (error) {
      throw new Error(`AI enrichment failed: ${error.message}`);
    }
  }

  /**
   * Build context string for AI
   */
  buildContext(person) {
    const parts = [];

    parts.push(`Name: ${person.title}`);

    if (person.academicTitles && person.academicTitles.length > 0) {
      parts.push(`Titles: ${person.academicTitles.join(', ')}`);
    }

    if (person.personType) {
      parts.push(`Role: ${person.personType}`);
    }

    if (person.departments && person.departments.length > 0) {
      parts.push(`Departments: ${person.departments.join(', ')}`);
    }

    if (person.labs && person.labs.length > 0) {
      parts.push(`Labs: ${person.labs.join(', ')}`);
    }

    if (person.researchAreas && person.researchAreas.length > 0) {
      parts.push(`Research Areas: ${person.researchAreas.join(', ')}`);
    }

    if (person.publications && person.publications > 0) {
      parts.push(`Publications: ${person.publications} papers, ${person.citationCount || 0} citations`);
      if (person.hIndex > 0) {
        parts.push(`h-index: ${person.hIndex}`);
      }
    }

    if (person.biography && person.biography.length > 50) {
      parts.push(`Bio: ${person.biography.substring(0, 300)}...`);
    }

    if (person.expertise && person.expertise.length > 50) {
      parts.push(`Existing expertise: ${person.expertise.substring(0, 300)}...`);
    }

    return parts.join('\n');
  }

  /**
   * Update brain with enriched persons
   */
  updateBrain(brain, enrichedPersons) {
    // Create a map of enriched persons by URL
    const enrichedMap = new Map();
    for (const person of enrichedPersons) {
      enrichedMap.set(person.url, person);
    }

    // Update brain in place
    for (let i = 0; i < brain.length; i++) {
      if (brain[i].kind === 'mit_person' && enrichedMap.has(brain[i].url)) {
        brain[i] = enrichedMap.get(brain[i].url);
      }
    }
  }

  /**
   * Save brain to JSONL
   */
  async saveBrain(brain) {
    const jsonlPath = path.join(OUTPUT_DIR, 'jsonl', `${MIT_BRAIN}.jsonl`);
    
    console.log(`üíæ Saving brain to ${jsonlPath}...`);
    
    const lines = brain.map(item => JSON.stringify(item));
    await fs.writeFile(jsonlPath, lines.join('\n') + '\n');
    
    console.log(`‚úÖ Saved ${brain.length} records`);
  }

  /**
   * Print summary
   */
  printSummary() {
    console.log('\n' + '='.repeat(60));
    console.log('SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total MIT persons: ${this.stats.total}`);
    console.log(`Enriched: ${this.stats.enriched}`);
    if (this.stats.skipped > 0) {
      console.log(`Skipped (already enriched): ${this.stats.skipped}`);
    }
    if (this.stats.errors > 0) {
      console.log(`Errors: ${this.stats.errors}`);
    }
  }

  /**
   * Sleep helper
   */
  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Run enricher
const enricher = new PersonsEnricher();
enricher.run().then(code => process.exit(code));